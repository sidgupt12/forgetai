"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-reconciler";
exports.ids = ["vendor-chunks/react-reconciler"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar NoLane =\n/*                          */\n0;\nvar SyncLane =\n/*                        */\n2;\nvar InputContinuousLane =\n/*             */\n8;\nvar DefaultLane =\n/*                     */\n32;\nvar IdleLane =\n/*                        */\n268435456;\n\nvar NoEventPriority = NoLane;\nvar DiscreteEventPriority = SyncLane;\nvar ContinuousEventPriority = InputContinuousLane;\nvar DefaultEventPriority = DefaultLane;\nvar IdleEventPriority = IdleLane;\n\nvar LegacyRoot = 0;\nvar ConcurrentRoot = 1;\n\nexports.ConcurrentRoot = ConcurrentRoot;\nexports.ContinuousEventPriority = ContinuousEventPriority;\nexports.DefaultEventPriority = DefaultEventPriority;\nexports.DiscreteEventPriority = DiscreteEventPriority;\nexports.IdleEventPriority = IdleEventPriority;\nexports.LegacyRoot = LegacyRoot;\nexports.NoEventPriority = NoEventPriority;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QiwrQkFBK0I7QUFDL0IsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIi9Vc2Vycy9zaWRkaGFudGd1cHRhL0RvY3VtZW50cy9wcm9qZWN0cy9mb3JnZXRhaS9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBOb0xhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xudmFyIFN5bmNMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgSW5wdXRDb250aW51b3VzTGFuZSA9XG4vKiAgICAgICAgICAgICAqL1xuODtcbnZhciBEZWZhdWx0TGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG4zMjtcbnZhciBJZGxlTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4yNjg0MzU0NTY7XG5cbnZhciBOb0V2ZW50UHJpb3JpdHkgPSBOb0xhbmU7XG52YXIgRGlzY3JldGVFdmVudFByaW9yaXR5ID0gU3luY0xhbmU7XG52YXIgQ29udGludW91c0V2ZW50UHJpb3JpdHkgPSBJbnB1dENvbnRpbnVvdXNMYW5lO1xudmFyIERlZmF1bHRFdmVudFByaW9yaXR5ID0gRGVmYXVsdExhbmU7XG52YXIgSWRsZUV2ZW50UHJpb3JpdHkgPSBJZGxlTGFuZTtcblxudmFyIExlZ2FjeVJvb3QgPSAwO1xudmFyIENvbmN1cnJlbnRSb290ID0gMTtcblxuZXhwb3J0cy5Db25jdXJyZW50Um9vdCA9IENvbmN1cnJlbnRSb290O1xuZXhwb3J0cy5Db250aW51b3VzRXZlbnRQcmlvcml0eSA9IENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuZXhwb3J0cy5EZWZhdWx0RXZlbnRQcmlvcml0eSA9IERlZmF1bHRFdmVudFByaW9yaXR5O1xuZXhwb3J0cy5EaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG5leHBvcnRzLklkbGVFdmVudFByaW9yaXR5ID0gSWRsZUV2ZW50UHJpb3JpdHk7XG5leHBvcnRzLkxlZ2FjeVJvb3QgPSBMZWdhY3lSb290O1xuZXhwb3J0cy5Ob0V2ZW50UHJpb3JpdHkgPSBOb0V2ZW50UHJpb3JpdHk7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler.development.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    module.exports = function $$$reconciler($$$config) {\n        var exports = {};\n        'use strict';\n        var React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n        var Scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/react-reconciler/node_modules/scheduler/index.js\");\n        var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n        var suppressWarning = false;\n        function setSuppressWarning(newSuppressWarning) {\n            {\n                suppressWarning = newSuppressWarning;\n            }\n        } // In DEV, calls to console.warn and console.error get replaced\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                if (!suppressWarning) {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning('warn', format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                if (!suppressWarning) {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning('error', format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var isErrorLogger = format === '%s\\n\\n%s\\n' || format === '%o\\n\\n%s\\n\\n%s\\n';\n                if (ReactSharedInternals.getCurrentStack) {\n                    var stack = ReactSharedInternals.getCurrentStack();\n                    if (stack !== '') {\n                        format += '%s';\n                        args = args.concat([\n                            stack\n                        ]);\n                    }\n                }\n                if (isErrorLogger) {\n                    // Don't prefix our default logging formatting in ReactFiberErrorLoggger.\n                    // Don't toString the arguments.\n                    args.unshift(format);\n                } else {\n                    // TODO: Remove this prefix and stop toStringing in the wrapper and\n                    // instead do it at each callsite as needed.\n                    // Careful: RN currently depends on this prefix\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    args = args.map(function(item) {\n                        return String(item);\n                    });\n                    args.unshift('Warning: ' + format);\n                } // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, args);\n            }\n        }\n        var assign = Object.assign;\n        var LegacyRoot = 0;\n        var ConcurrentRoot = 1;\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        // -----------------------------------------------------------------------------\n        // Killswitch\n        //\n        // Flags that exist solely to turn off a change in case it causes a regression\n        // when it rolls out to prod. We should remove these as soon as possible.\n        // -----------------------------------------------------------------------------\n        // -----------------------------------------------------------------------------\n        // Land or remove (moderate effort)\n        //\n        // Flags that can be probably deleted or landed, but might require extra effort\n        // like migrating internal callers or performance testing.\n        // -----------------------------------------------------------------------------\n        // TODO: Finish rolling out in www\n        var favorSafetyOverHydrationPerf = true;\n        var enableAsyncActions = true; // Need to remove didTimeout argument from Scheduler before landing\n        var disableDefaultPropsExceptForClasses = true; // -----------------------------------------------------------------------------\n        // Slated for removal in the future (significant effort)\n        //\n        // These are experiments that didn't work out, and never shipped, but we can't\n        // delete from the codebase until we migrate internal callers.\n        // -----------------------------------------------------------------------------\n        // Add a callback property to suspense to notify which promises are currently\n        // in the update queue. This allows reporting and tracing of what is causing\n        // the user to see a loading state.\n        //\n        // Also allows hydration callbacks to fire when a dehydrated boundary gets\n        // hydrated or deleted.\n        //\n        // This will eventually be replaced by the Transition Tracing proposal.\n        var enableSuspenseCallback = false; // Experimental Scope support.\n        var enableAsyncIterableChildren = false;\n        var enableLazyContextPropagation = false; // FB-only usage. The new API has different semantics.\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        var alwaysThrottleRetries = true;\n        var passChildrenWhenCloningPersistedNodes = false;\n        var syncLaneExpirationMs = 250;\n        var transitionLaneExpirationMs = 5000; // -----------------------------------------------------------------------------\n        // This allows us to land breaking changes to remove legacy mode APIs in experimental builds\n        // before removing them in stable in the next Major\n        var disableLegacyMode = true;\n        // Debugging and DevTools\n        // -----------------------------------------------------------------------------\n        // Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n        // for an experimental timeline tool.\n        var enableSchedulingProfiler = true; // Helps identify side effects in render-phase lifecycle hooks and setState\n        var enableProfilerTimer = true; // Record durations for commit and passive effects phases.\n        var enableProfilerCommitHooks = true; // Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\n        var enableProfilerNestedUpdatePhase = true; // Adds verbose console logging for e.g. state updates, suspense, and work loop\n        var FunctionComponent = 0;\n        var ClassComponent = 1;\n        var HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n        var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n        var HostComponent = 5;\n        var HostText = 6;\n        var Fragment = 7;\n        var Mode = 8;\n        var ContextConsumer = 9;\n        var ContextProvider = 10;\n        var ForwardRef = 11;\n        var Profiler = 12;\n        var SuspenseComponent = 13;\n        var MemoComponent = 14;\n        var SimpleMemoComponent = 15;\n        var LazyComponent = 16;\n        var IncompleteClassComponent = 17;\n        var DehydratedFragment = 18;\n        var SuspenseListComponent = 19;\n        var ScopeComponent = 21;\n        var OffscreenComponent = 22;\n        var LegacyHiddenComponent = 23;\n        var CacheComponent = 24;\n        var TracingMarkerComponent = 25;\n        var HostHoistable = 26;\n        var HostSingleton = 27;\n        var IncompleteFunctionComponent = 28;\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element');\n        var REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element');\n        var REACT_PORTAL_TYPE = Symbol.for('react.portal');\n        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\n        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\n        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');\n        var REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n        var REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\n        var REACT_CONTEXT_TYPE = Symbol.for('react.context');\n        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\n        var REACT_MEMO_TYPE = Symbol.for('react.memo');\n        var REACT_LAZY_TYPE = Symbol.for('react.lazy');\n        var REACT_SCOPE_TYPE = Symbol.for('react.scope');\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');\n        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');\n        var REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');\n        var REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = '@@iterator';\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== 'object') {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === 'function') {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName$1(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || '';\n            return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName$1(type) {\n            return type.displayName || 'Context';\n        }\n        var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === 'function') {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === 'string') {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return 'Fragment';\n                case REACT_PORTAL_TYPE:\n                    return 'Portal';\n                case REACT_PROFILER_TYPE:\n                    return 'Profiler';\n                case REACT_STRICT_MODE_TYPE:\n                    return 'StrictMode';\n                case REACT_SUSPENSE_TYPE:\n                    return 'Suspense';\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return 'SuspenseList';\n            }\n            if (typeof type === 'object') {\n                {\n                    if (typeof type.tag === 'number') {\n                        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_PROVIDER_TYPE:\n                        {\n                            return null;\n                        }\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        {\n                            return getContextName$1(context) + '.Provider';\n                        }\n                    case REACT_CONSUMER_TYPE:\n                        {\n                            var consumer = type;\n                            return getContextName$1(consumer._context) + '.Consumer';\n                        }\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName$1(type, type.render, 'ForwardRef');\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || 'Memo';\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var functionName = innerType.displayName || innerType.name || '';\n            return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n        } // Keep in sync with shared/getComponentNameFromType\n        function getContextName(type) {\n            return type.displayName || 'Context';\n        }\n        function getComponentNameFromOwner(owner) {\n            if (typeof owner.tag === 'number') {\n                return getComponentNameFromFiber(owner);\n            }\n            if (typeof owner.name === 'string') {\n                return owner.name;\n            }\n            return null;\n        }\n        function getComponentNameFromFiber(fiber) {\n            var tag = fiber.tag, type = fiber.type;\n            switch(tag){\n                case CacheComponent:\n                    return 'Cache';\n                case ContextConsumer:\n                    {\n                        var consumer = type;\n                        return getContextName(consumer._context) + '.Consumer';\n                    }\n                case ContextProvider:\n                    {\n                        var _context = type;\n                        return getContextName(_context) + '.Provider';\n                    }\n                case DehydratedFragment:\n                    return 'DehydratedFragment';\n                case ForwardRef:\n                    return getWrappedName(type, type.render, 'ForwardRef');\n                case Fragment:\n                    return 'Fragment';\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    // Host component type is the display name (e.g. \"div\", \"View\")\n                    return type;\n                case HostPortal:\n                    return 'Portal';\n                case HostRoot:\n                    return 'Root';\n                case HostText:\n                    return 'Text';\n                case LazyComponent:\n                    // Name comes from the type in this case; we don't have a tag.\n                    return getComponentNameFromType(type);\n                case Mode:\n                    if (type === REACT_STRICT_MODE_TYPE) {\n                        // Don't be less specific than shared/getComponentNameFromType\n                        return 'StrictMode';\n                    }\n                    return 'Mode';\n                case OffscreenComponent:\n                    return 'Offscreen';\n                case Profiler:\n                    return 'Profiler';\n                case ScopeComponent:\n                    return 'Scope';\n                case SuspenseComponent:\n                    return 'Suspense';\n                case SuspenseListComponent:\n                    return 'SuspenseList';\n                case TracingMarkerComponent:\n                    return 'TracingMarker';\n                // The display name for these tags come from the user-provided type:\n                case IncompleteClassComponent:\n                case IncompleteFunctionComponent:\n                    {\n                        break;\n                    }\n                // Fallthrough\n                case ClassComponent:\n                case FunctionComponent:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    if (typeof type === 'function') {\n                        return type.displayName || type.name || null;\n                    }\n                    if (typeof type === 'string') {\n                        return type;\n                    }\n                    break;\n            }\n            return null;\n        }\n        var NoFlags$1 = /*                      */ 0;\n        var PerformedWork = /*                */ 1;\n        var Placement = /*                    */ 2;\n        var DidCapture = /*                   */ 128;\n        var Hydrating = /*                    */ 4096; // You can change the rest (and add more).\n        var Update = /*                       */ 4;\n        /* Skipped value:                                 0b0000000000000000000000001000; */ var ChildDeletion = /*                */ 16;\n        var ContentReset = /*                 */ 32;\n        var Callback = /*                     */ 64;\n        /* Used by DidCapture:                            0b0000000000000000000010000000; */ var ForceClientRender = /*            */ 256;\n        var Ref = /*                          */ 512;\n        var Snapshot = /*                     */ 1024;\n        var Passive$1 = /*                      */ 2048;\n        /* Used by Hydrating:                             0b0000000000000001000000000000; */ var Visibility = /*                   */ 8192;\n        var StoreConsistency = /*             */ 16384; // It's OK to reuse these bits because these flags are mutually exclusive for\n        // different fiber types. We should really be doing this for as many flags as\n        // possible, because we're about to run out of bits.\n        var ScheduleRetry = StoreConsistency;\n        var ShouldSuspendCommit = Visibility;\n        var DidDefer = ContentReset;\n        var FormReset = Snapshot;\n        var HostEffectMask = /*               */ 32767; // These are not really side effects, but we still reuse this field.\n        var Incomplete = /*                   */ 32768;\n        var ShouldCapture = /*                */ 65536;\n        var ForceUpdateForLegacySuspense = /* */ 131072;\n        var Forked = /*                       */ 1048576; // Static tags describe aspects of a fiber that are not specific to a render,\n        // e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n        // This enables us to defer more work in the unmount case,\n        // since we can defer traversing the tree during layout to look for Passive effects,\n        // and instead rely on the static flag as a signal that there may be cleanup work.\n        var RefStatic = /*                    */ 2097152;\n        var LayoutStatic = /*                 */ 4194304;\n        var PassiveStatic = /*                */ 8388608;\n        var MaySuspendCommit = /*             */ 16777216; // Flag used to identify newly inserted fibers. It isn't reset after commit unlike `Placement`.\n        var PlacementDEV = /*                 */ 33554432;\n        var MountLayoutDev = /*               */ 67108864;\n        var MountPassiveDev = /*              */ 134217728; // Groups of flags that are used in the commit phase to skip over trees that\n        // don't contain effects, by checking subtreeFlags.\n        var BeforeMutationMask = // flag logic (see #20043)\n        Update | Snapshot | 0;\n        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility | FormReset;\n        var LayoutMask = Update | Callback | Ref | Visibility; // TODO: Split into PassiveMountMask and PassiveUnmountMask\n        var PassiveMask = Passive$1 | Visibility | ChildDeletion; // Union of tags that don't get reset on clones.\n        // This allows certain concepts to persist without recalculating them,\n        // e.g. whether a subtree contains passive effects or portals.\n        var StaticMask = LayoutStatic | PassiveStatic | RefStatic | MaySuspendCommit;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n                }\n            }\n        }\n        var prefix;\n        function describeBuiltInComponentFrame(name) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || '';\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return '\\n' + prefix + name;\n            }\n        }\n        function describeDebugInfoFrame(name, env) {\n            return describeBuiltInComponentFrame(name + (env ? ' (' + env + ')' : ''));\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap$1();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return '';\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher = null;\n            {\n                previousDispatcher = ReactSharedInternals.H; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactSharedInternals.H = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, 'props', {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === 'object' && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === 'function') {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === 'string') {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                'name', {\n                    value: 'DetermineComponentFrameRoot'\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split('\\n');\n                    var controlLines = controlStack.split('\\n');\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes('<anonymous>')) {\n                                            _frame = _frame.replace('<anonymous>', fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === 'function') {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactSharedInternals.H = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : '';\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n            {\n                if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function describeFiber(fiber) {\n            switch(fiber.tag){\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    return describeBuiltInComponentFrame(fiber.type);\n                case LazyComponent:\n                    return describeBuiltInComponentFrame('Lazy');\n                case SuspenseComponent:\n                    return describeBuiltInComponentFrame('Suspense');\n                case SuspenseListComponent:\n                    return describeBuiltInComponentFrame('SuspenseList');\n                case FunctionComponent:\n                case SimpleMemoComponent:\n                    return describeFunctionComponentFrame(fiber.type);\n                case ForwardRef:\n                    return describeFunctionComponentFrame(fiber.type.render);\n                case ClassComponent:\n                    return describeClassComponentFrame(fiber.type);\n                default:\n                    return '';\n            }\n        }\n        function getStackByFiberInDevAndProd(workInProgress) {\n            try {\n                var info = '';\n                var node = workInProgress;\n                do {\n                    info += describeFiber(node);\n                    if (true) {\n                        // Add any Server Component stack frames in reverse order.\n                        var debugInfo = node._debugInfo;\n                        if (debugInfo) {\n                            for(var i = debugInfo.length - 1; i >= 0; i--){\n                                var entry = debugInfo[i];\n                                if (typeof entry.name === 'string') {\n                                    info += describeDebugInfoFrame(entry.name, entry.env);\n                                }\n                            }\n                        }\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    node = node.return;\n                }while (node);\n                return info;\n            } catch (x) {\n                return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n            }\n        }\n        var current = null;\n        var isRendering = false;\n        function getCurrentFiberStackInDev() {\n            {\n                if (current === null) {\n                    return '';\n                } // Safe because if current fiber exists, we are reconciling,\n                // and it is guaranteed to be the work-in-progress version.\n                return getStackByFiberInDevAndProd(current);\n            }\n        }\n        function resetCurrentDebugFiberInDEV() {\n            {\n                resetCurrentFiber();\n            }\n        }\n        function setCurrentDebugFiberInDEV(fiber) {\n            {\n                setCurrentFiber(fiber);\n            }\n        }\n        function resetCurrentFiber() {\n            {\n                ReactSharedInternals.getCurrentStack = null;\n                isRendering = false;\n            }\n            current = null;\n        }\n        function setCurrentFiber(fiber) {\n            {\n                ReactSharedInternals.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;\n                isRendering = false;\n            }\n            current = fiber;\n        }\n        function getCurrentFiber() {\n            {\n                return current;\n            }\n        }\n        function setIsRendering(rendering) {\n            {\n                isRendering = rendering;\n            }\n        }\n        function getNearestMountedFiber(fiber) {\n            var node = fiber;\n            var nearestMounted = fiber;\n            if (!fiber.alternate) {\n                // If there is no alternate, this might be a new tree that isn't inserted\n                // yet. If it is, then it will have a pending insertion effect on it.\n                var nextNode = node;\n                do {\n                    node = nextNode;\n                    if ((node.flags & (Placement | Hydrating)) !== NoFlags$1) {\n                        // This is an insertion or in-progress hydration. The nearest possible\n                        // mounted fiber is the parent but we need to continue to figure out\n                        // if that one is still mounted.\n                        nearestMounted = node.return;\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    nextNode = node.return;\n                }while (nextNode);\n            } else {\n                while(node.return){\n                    node = node.return;\n                }\n            }\n            if (node.tag === HostRoot) {\n                // TODO: Check if this was a nested HostRoot when used with\n                // renderContainerIntoSubtree.\n                return nearestMounted;\n            } // If we didn't hit the root, that means that we're in an disconnected tree\n            // that has been unmounted.\n            return null;\n        }\n        function isMounted(component) {\n            {\n                var owner = current;\n                if (owner !== null && isRendering && owner.tag === ClassComponent) {\n                    var ownerFiber = owner;\n                    var instance = ownerFiber.stateNode;\n                    if (!instance._warnedAboutRefsInRender) {\n                        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentNameFromFiber(ownerFiber) || 'A component');\n                    }\n                    instance._warnedAboutRefsInRender = true;\n                }\n            }\n            var fiber = get(component);\n            if (!fiber) {\n                return false;\n            }\n            return getNearestMountedFiber(fiber) === fiber;\n        }\n        function assertIsMounted(fiber) {\n            if (getNearestMountedFiber(fiber) !== fiber) {\n                throw new Error('Unable to find node on an unmounted component.');\n            }\n        }\n        function findCurrentFiberUsingSlowPath(fiber) {\n            var alternate = fiber.alternate;\n            if (!alternate) {\n                // If there is no alternate, then we only need to check if it is mounted.\n                var nearestMounted = getNearestMountedFiber(fiber);\n                if (nearestMounted === null) {\n                    throw new Error('Unable to find node on an unmounted component.');\n                }\n                if (nearestMounted !== fiber) {\n                    return null;\n                }\n                return fiber;\n            } // If we have two possible branches, we'll walk backwards up to the root\n            // to see what path the root points to. On the way we may hit one of the\n            // special cases and we'll deal with them.\n            var a = fiber;\n            var b = alternate;\n            while(true){\n                var parentA = a.return;\n                if (parentA === null) {\n                    break;\n                }\n                var parentB = parentA.alternate;\n                if (parentB === null) {\n                    // There is no alternate. This is an unusual case. Currently, it only\n                    // happens when a Suspense component is hidden. An extra fragment fiber\n                    // is inserted in between the Suspense fiber and its children. Skip\n                    // over this extra fragment fiber and proceed to the next parent.\n                    var nextParent = parentA.return;\n                    if (nextParent !== null) {\n                        a = b = nextParent;\n                        continue;\n                    } // If there's no parent, we're at the root.\n                    break;\n                } // If both copies of the parent fiber point to the same child, we can\n                // assume that the child is current. This happens when we bailout on low\n                // priority: the bailed out fiber's child reuses the current child.\n                if (parentA.child === parentB.child) {\n                    var child = parentA.child;\n                    while(child){\n                        if (child === a) {\n                            // We've determined that A is the current branch.\n                            assertIsMounted(parentA);\n                            return fiber;\n                        }\n                        if (child === b) {\n                            // We've determined that B is the current branch.\n                            assertIsMounted(parentA);\n                            return alternate;\n                        }\n                        child = child.sibling;\n                    } // We should never have an alternate for any mounting node. So the only\n                    // way this could possibly happen is if this was unmounted, if at all.\n                    throw new Error('Unable to find node on an unmounted component.');\n                }\n                if (a.return !== b.return) {\n                    // The return pointer of A and the return pointer of B point to different\n                    // fibers. We assume that return pointers never criss-cross, so A must\n                    // belong to the child set of A.return, and B must belong to the child\n                    // set of B.return.\n                    a = parentA;\n                    b = parentB;\n                } else {\n                    // The return pointers point to the same fiber. We'll have to use the\n                    // default, slow path: scan the child sets of each parent alternate to see\n                    // which child belongs to which set.\n                    //\n                    // Search parent A's child set\n                    var didFindChild = false;\n                    var _child = parentA.child;\n                    while(_child){\n                        if (_child === a) {\n                            didFindChild = true;\n                            a = parentA;\n                            b = parentB;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = true;\n                            b = parentA;\n                            a = parentB;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) {\n                        // Search parent B's child set\n                        _child = parentB.child;\n                        while(_child){\n                            if (_child === a) {\n                                didFindChild = true;\n                                a = parentB;\n                                b = parentA;\n                                break;\n                            }\n                            if (_child === b) {\n                                didFindChild = true;\n                                b = parentB;\n                                a = parentA;\n                                break;\n                            }\n                            _child = _child.sibling;\n                        }\n                        if (!didFindChild) {\n                            throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n                        }\n                    }\n                }\n                if (a.alternate !== b) {\n                    throw new Error(\"Return fibers should always be each others' alternates. \" + 'This error is likely caused by a bug in React. Please file an issue.');\n                }\n            } // If the root is not a host container, we're in a disconnected tree. I.e.\n            // unmounted.\n            if (a.tag !== HostRoot) {\n                throw new Error('Unable to find node on an unmounted component.');\n            }\n            if (a.stateNode.current === a) {\n                // We've determined that A is the current branch.\n                return fiber;\n            } // Otherwise B has to be current branch.\n            return alternate;\n        }\n        function findCurrentHostFiber(parent) {\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\n            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberImpl(node) {\n            // Next we'll drill down this component to find the first HostComponent/Text.\n            var tag = node.tag;\n            if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton || tag === HostText) {\n                return node;\n            }\n            var child = node.child;\n            while(child !== null){\n                var match = findCurrentHostFiberImpl(child);\n                if (match !== null) {\n                    return match;\n                }\n                child = child.sibling;\n            }\n            return null;\n        }\n        function findCurrentHostFiberWithNoPortals(parent) {\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\n            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberWithNoPortalsImpl(node) {\n            // Next we'll drill down this component to find the first HostComponent/Text.\n            var tag = node.tag;\n            if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton || tag === HostText) {\n                return node;\n            }\n            var child = node.child;\n            while(child !== null){\n                if (child.tag !== HostPortal) {\n                    var match = findCurrentHostFiberWithNoPortalsImpl(child);\n                    if (match !== null) {\n                        return match;\n                    }\n                }\n                child = child.sibling;\n            }\n            return null;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        // This is a host config that's used for the `react-reconciler` package on npm.\n        // It is only used by third-party renderers.\n        //\n        // Its API lets you pass the host config as an argument.\n        // However, inside the `react-reconciler` we treat host config as a module.\n        // This file is a shim between two worlds.\n        //\n        // It works because the `react-reconciler` bundle is wrapped in something like:\n        //\n        // module.exports = function ($$$config) {\n        //   /* reconciler code */\n        // }\n        //\n        // So `$$$config` looks like a global variable, but it's\n        // really an argument to a top-level wrapping function.\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        var getPublicInstance = $$$config.getPublicInstance;\n        var getRootHostContext = $$$config.getRootHostContext;\n        var getChildHostContext = $$$config.getChildHostContext;\n        var prepareForCommit = $$$config.prepareForCommit;\n        var resetAfterCommit = $$$config.resetAfterCommit;\n        var createInstance = $$$config.createInstance;\n        var appendInitialChild = $$$config.appendInitialChild;\n        var finalizeInitialChildren = $$$config.finalizeInitialChildren;\n        var shouldSetTextContent = $$$config.shouldSetTextContent;\n        var createTextInstance = $$$config.createTextInstance;\n        var scheduleTimeout = $$$config.scheduleTimeout;\n        var cancelTimeout = $$$config.cancelTimeout;\n        var noTimeout = $$$config.noTimeout;\n        var isPrimaryRenderer = $$$config.isPrimaryRenderer;\n        $$$config.warnsIfNotActing;\n        var supportsMutation = $$$config.supportsMutation;\n        var supportsPersistence = $$$config.supportsPersistence;\n        var supportsHydration = $$$config.supportsHydration;\n        var getInstanceFromNode = $$$config.getInstanceFromNode;\n        $$$config.beforeActiveInstanceBlur;\n        $$$config.afterActiveInstanceBlur;\n        var preparePortalMount = $$$config.preparePortalMount;\n        $$$config.prepareScopeUpdate;\n        $$$config.getInstanceFromScope;\n        var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority;\n        var getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority;\n        var resolveUpdatePriority = $$$config.resolveUpdatePriority;\n        var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition;\n        var detachDeletedInstance = $$$config.detachDeletedInstance;\n        $$$config.requestPostPaintCallback;\n        var maySuspendCommit = $$$config.maySuspendCommit;\n        var preloadInstance = $$$config.preloadInstance;\n        var startSuspendingCommit = $$$config.startSuspendingCommit;\n        var suspendInstance = $$$config.suspendInstance;\n        var waitForCommitToBeReady = $$$config.waitForCommitToBeReady;\n        var NotPendingTransition = $$$config.NotPendingTransition;\n        var resetFormInstance = $$$config.resetFormInstance; // -------------------\n        //      Microtasks\n        //     (optional)\n        // -------------------\n        var supportsMicrotasks = $$$config.supportsMicrotasks;\n        var scheduleMicrotask = $$$config.scheduleMicrotask; // -------------------\n        //      Test selectors\n        //     (optional)\n        // -------------------\n        var supportsTestSelectors = $$$config.supportsTestSelectors;\n        var findFiberRoot = $$$config.findFiberRoot;\n        var getBoundingRect = $$$config.getBoundingRect;\n        var getTextContent = $$$config.getTextContent;\n        var isHiddenSubtree = $$$config.isHiddenSubtree;\n        var matchAccessibilityRole = $$$config.matchAccessibilityRole;\n        var setFocusIfFocusable = $$$config.setFocusIfFocusable;\n        var setupIntersectionObserver = $$$config.setupIntersectionObserver; // -------------------\n        //      Mutation\n        //     (optional)\n        // -------------------\n        var appendChild = $$$config.appendChild;\n        var appendChildToContainer = $$$config.appendChildToContainer;\n        var commitTextUpdate = $$$config.commitTextUpdate;\n        var commitMount = $$$config.commitMount;\n        var commitUpdate = $$$config.commitUpdate;\n        var insertBefore = $$$config.insertBefore;\n        var insertInContainerBefore = $$$config.insertInContainerBefore;\n        var removeChild = $$$config.removeChild;\n        var removeChildFromContainer = $$$config.removeChildFromContainer;\n        var resetTextContent = $$$config.resetTextContent;\n        var hideInstance = $$$config.hideInstance;\n        var hideTextInstance = $$$config.hideTextInstance;\n        var unhideInstance = $$$config.unhideInstance;\n        var unhideTextInstance = $$$config.unhideTextInstance;\n        var clearContainer = $$$config.clearContainer; // -------------------\n        //     Persistence\n        //     (optional)\n        // -------------------\n        var cloneInstance = $$$config.cloneInstance;\n        var createContainerChildSet = $$$config.createContainerChildSet;\n        var appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet;\n        var finalizeContainerChildren = $$$config.finalizeContainerChildren;\n        var replaceContainerChildren = $$$config.replaceContainerChildren;\n        var cloneHiddenInstance = $$$config.cloneHiddenInstance;\n        var cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance; // -------------------\n        //     Hydration\n        //     (optional)\n        // -------------------\n        var isSuspenseInstancePending = $$$config.isSuspenseInstancePending;\n        var isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback;\n        var getSuspenseInstanceFallbackErrorDetails = $$$config.getSuspenseInstanceFallbackErrorDetails;\n        var registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry;\n        var canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker;\n        var isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching;\n        var getNextHydratableSibling = $$$config.getNextHydratableSibling;\n        var getFirstHydratableChild = $$$config.getFirstHydratableChild;\n        var getFirstHydratableChildWithinContainer = $$$config.getFirstHydratableChildWithinContainer;\n        var getFirstHydratableChildWithinSuspenseInstance = $$$config.getFirstHydratableChildWithinSuspenseInstance;\n        var canHydrateInstance = $$$config.canHydrateInstance;\n        var canHydrateTextInstance = $$$config.canHydrateTextInstance;\n        var canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance;\n        var hydrateInstance = $$$config.hydrateInstance;\n        var hydrateTextInstance = $$$config.hydrateTextInstance;\n        var hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance;\n        var getNextHydratableInstanceAfterSuspenseInstance = $$$config.getNextHydratableInstanceAfterSuspenseInstance;\n        var commitHydratedContainer = $$$config.commitHydratedContainer;\n        var commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance;\n        var clearSuspenseBoundary = $$$config.clearSuspenseBoundary;\n        var clearSuspenseBoundaryFromContainer = $$$config.clearSuspenseBoundaryFromContainer;\n        var shouldDeleteUnhydratedTailInstances = $$$config.shouldDeleteUnhydratedTailInstances;\n        var diffHydratedPropsForDevWarnings = $$$config.diffHydratedPropsForDevWarnings;\n        var diffHydratedTextForDevWarnings = $$$config.diffHydratedTextForDevWarnings;\n        var describeHydratableInstanceForDevWarnings = $$$config.describeHydratableInstanceForDevWarnings;\n        var validateHydratableInstance = $$$config.validateHydratableInstance;\n        var validateHydratableTextInstance = $$$config.validateHydratableTextInstance; // -------------------\n        //     Resources\n        //     (optional)\n        // -------------------\n        // eslint-disable-line no-undef\n        var supportsResources = $$$config.supportsResources;\n        var isHostHoistableType = $$$config.isHostHoistableType;\n        var getHoistableRoot = $$$config.getHoistableRoot;\n        var getResource = $$$config.getResource;\n        var acquireResource = $$$config.acquireResource;\n        var releaseResource = $$$config.releaseResource;\n        var hydrateHoistable = $$$config.hydrateHoistable;\n        var mountHoistable = $$$config.mountHoistable;\n        var unmountHoistable = $$$config.unmountHoistable;\n        var createHoistableInstance = $$$config.createHoistableInstance;\n        var prepareToCommitHoistables = $$$config.prepareToCommitHoistables;\n        var mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit;\n        var preloadResource = $$$config.preloadResource;\n        var suspendResource = $$$config.suspendResource; // -------------------\n        //     Singletons\n        //     (optional)\n        // -------------------\n        var supportsSingletons = $$$config.supportsSingletons;\n        var resolveSingletonInstance = $$$config.resolveSingletonInstance;\n        var clearSingleton = $$$config.clearSingleton;\n        var acquireSingletonInstance = $$$config.acquireSingletonInstance;\n        var releaseSingletonInstance = $$$config.releaseSingletonInstance;\n        var isHostSingletonType = $$$config.isHostSingletonType;\n        var valueStack = [];\n        var fiberStack;\n        {\n            fiberStack = [];\n        }\n        var index = -1;\n        function createCursor(defaultValue) {\n            return {\n                current: defaultValue\n            };\n        }\n        function pop(cursor, fiber) {\n            if (index < 0) {\n                {\n                    error('Unexpected pop.');\n                }\n                return;\n            }\n            {\n                if (fiber !== fiberStack[index]) {\n                    error('Unexpected Fiber popped.');\n                }\n            }\n            cursor.current = valueStack[index];\n            valueStack[index] = null;\n            {\n                fiberStack[index] = null;\n            }\n            index--;\n        }\n        function push(cursor, value, fiber) {\n            index++;\n            valueStack[index] = cursor.current;\n            {\n                fiberStack[index] = fiber;\n            }\n            cursor.current = value;\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        function hasContextChanged() {\n            {\n                return false;\n            }\n        }\n        function isContextProvider(type) {\n            {\n                return false;\n            }\n        }\n        function processChildContext(fiber, type, parentContext) {\n            {\n                return parentContext;\n            }\n        }\n        function findCurrentUnmaskedContext(fiber) {\n            {\n                return emptyContextObject;\n            }\n        }\n        // We use the existence of the state object as an indicator that the component\n        // is hidden.\n        var OffscreenVisible = /*                     */ 1;\n        var OffscreenDetached = /*                    */ 2;\n        var OffscreenPassiveEffectsConnected = /*     */ 4;\n        function isOffscreenManual(offscreenFiber) {\n            return offscreenFiber.memoizedProps !== null && offscreenFiber.memoizedProps.mode === 'manual';\n        }\n        var NoMode = /*                         */ 0; // TODO: Remove ConcurrentMode by reading from the root tag instead\n        var ConcurrentMode = /*                 */ 1;\n        var ProfileMode = /*                    */ 2;\n        var StrictLegacyMode = /*               */ 8;\n        var StrictEffectsMode = /*              */ 16;\n        var NoStrictPassiveEffectsMode = /*     */ 64;\n        // TODO: This is pretty well supported by browsers. Maybe we can drop it.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log$1 = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log$1(asUint) / LN2 | 0) | 0;\n        }\n        // If those values are changed that package should be rebuilt and redeployed.\n        var TotalLanes = 31;\n        var NoLanes = /*                        */ 0;\n        var NoLane = /*                          */ 0;\n        var SyncHydrationLane = /*               */ 1;\n        var SyncLane = /*                        */ 2;\n        var SyncLaneIndex = 1;\n        var InputContinuousHydrationLane = /*    */ 4;\n        var InputContinuousLane = /*             */ 8;\n        var DefaultHydrationLane = /*            */ 16;\n        var DefaultLane = /*                     */ 32;\n        var SyncUpdateLanes = SyncLane | InputContinuousLane | DefaultLane;\n        var TransitionHydrationLane = /*                */ 64;\n        var TransitionLanes = /*                       */ 4194176;\n        var TransitionLane1 = /*                        */ 128;\n        var TransitionLane2 = /*                        */ 256;\n        var TransitionLane3 = /*                        */ 512;\n        var TransitionLane4 = /*                        */ 1024;\n        var TransitionLane5 = /*                        */ 2048;\n        var TransitionLane6 = /*                        */ 4096;\n        var TransitionLane7 = /*                        */ 8192;\n        var TransitionLane8 = /*                        */ 16384;\n        var TransitionLane9 = /*                        */ 32768;\n        var TransitionLane10 = /*                       */ 65536;\n        var TransitionLane11 = /*                       */ 131072;\n        var TransitionLane12 = /*                       */ 262144;\n        var TransitionLane13 = /*                       */ 524288;\n        var TransitionLane14 = /*                       */ 1048576;\n        var TransitionLane15 = /*                       */ 2097152;\n        var RetryLanes = /*                            */ 62914560;\n        var RetryLane1 = /*                             */ 4194304;\n        var RetryLane2 = /*                             */ 8388608;\n        var RetryLane3 = /*                             */ 16777216;\n        var RetryLane4 = /*                             */ 33554432;\n        var SomeRetryLane = RetryLane1;\n        var SelectiveHydrationLane = /*          */ 67108864;\n        var NonIdleLanes = /*                          */ 134217727;\n        var IdleHydrationLane = /*               */ 134217728;\n        var IdleLane = /*                        */ 268435456;\n        var OffscreenLane = /*                   */ 536870912;\n        var DeferredLane = /*                    */ 1073741824; // Any lane that might schedule an update. This is used to detect infinite\n        // update loops, so it doesn't include hydration lanes or retries.\n        var UpdateLanes = SyncLane | InputContinuousLane | DefaultLane | TransitionLanes; // This function is used for the experimental timeline (react-devtools-timeline)\n        // It should be kept in sync with the Lanes values above.\n        function getLabelForLane(lane) {\n            {\n                if (lane & SyncHydrationLane) {\n                    return 'SyncHydrationLane';\n                }\n                if (lane & SyncLane) {\n                    return 'Sync';\n                }\n                if (lane & InputContinuousHydrationLane) {\n                    return 'InputContinuousHydration';\n                }\n                if (lane & InputContinuousLane) {\n                    return 'InputContinuous';\n                }\n                if (lane & DefaultHydrationLane) {\n                    return 'DefaultHydration';\n                }\n                if (lane & DefaultLane) {\n                    return 'Default';\n                }\n                if (lane & TransitionHydrationLane) {\n                    return 'TransitionHydration';\n                }\n                if (lane & TransitionLanes) {\n                    return 'Transition';\n                }\n                if (lane & RetryLanes) {\n                    return 'Retry';\n                }\n                if (lane & SelectiveHydrationLane) {\n                    return 'SelectiveHydration';\n                }\n                if (lane & IdleHydrationLane) {\n                    return 'IdleHydration';\n                }\n                if (lane & IdleLane) {\n                    return 'Idle';\n                }\n                if (lane & OffscreenLane) {\n                    return 'Offscreen';\n                }\n                if (lane & DeferredLane) {\n                    return 'Deferred';\n                }\n            }\n        }\n        var NoTimestamp = -1;\n        var nextTransitionLane = TransitionLane1;\n        var nextRetryLane = RetryLane1;\n        function getHighestPriorityLanes(lanes) {\n            {\n                var pendingSyncLanes = lanes & SyncUpdateLanes;\n                if (pendingSyncLanes !== 0) {\n                    return pendingSyncLanes;\n                }\n            }\n            switch(getHighestPriorityLane(lanes)){\n                case SyncHydrationLane:\n                    return SyncHydrationLane;\n                case SyncLane:\n                    return SyncLane;\n                case InputContinuousHydrationLane:\n                    return InputContinuousHydrationLane;\n                case InputContinuousLane:\n                    return InputContinuousLane;\n                case DefaultHydrationLane:\n                    return DefaultHydrationLane;\n                case DefaultLane:\n                    return DefaultLane;\n                case TransitionHydrationLane:\n                    return TransitionHydrationLane;\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                    return lanes & TransitionLanes;\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                    return lanes & RetryLanes;\n                case SelectiveHydrationLane:\n                    return SelectiveHydrationLane;\n                case IdleHydrationLane:\n                    return IdleHydrationLane;\n                case IdleLane:\n                    return IdleLane;\n                case OffscreenLane:\n                    return OffscreenLane;\n                case DeferredLane:\n                    // This shouldn't be reachable because deferred work is always entangled\n                    // with something else.\n                    return NoLanes;\n                default:\n                    {\n                        error('Should have found matching lanes. This is a bug in React.');\n                    }\n                    return lanes;\n            }\n        }\n        function getNextLanes(root, wipLanes) {\n            // Early bailout if there's no pending work left.\n            var pendingLanes = root.pendingLanes;\n            if (pendingLanes === NoLanes) {\n                return NoLanes;\n            }\n            var nextLanes = NoLanes;\n            var suspendedLanes = root.suspendedLanes;\n            var pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,\n            // even if the work is suspended.\n            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n            if (nonIdlePendingLanes !== NoLanes) {\n                var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n                if (nonIdleUnblockedLanes !== NoLanes) {\n                    nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n                } else {\n                    var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n                    if (nonIdlePingedLanes !== NoLanes) {\n                        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n                    }\n                }\n            } else {\n                // The only remaining work is Idle.\n                var unblockedLanes = pendingLanes & ~suspendedLanes;\n                if (unblockedLanes !== NoLanes) {\n                    nextLanes = getHighestPriorityLanes(unblockedLanes);\n                } else {\n                    if (pingedLanes !== NoLanes) {\n                        nextLanes = getHighestPriorityLanes(pingedLanes);\n                    }\n                }\n            }\n            if (nextLanes === NoLanes) {\n                // This should only be reachable if we're suspended\n                // TODO: Consider warning in this path if a fallback timer is not scheduled.\n                return NoLanes;\n            } // If we're already in the middle of a render, switching lanes will interrupt\n            // it and we'll lose our progress. We should only do this if the new lanes are\n            // higher priority.\n            if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n            // bother waiting until the root is complete.\n            (wipLanes & suspendedLanes) === NoLanes) {\n                var nextLane = getHighestPriorityLane(nextLanes);\n                var wipLane = getHighestPriorityLane(wipLanes);\n                if (// one. This works because the bits decrease in priority as you go left.\n                nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n                // only difference between default updates and transition updates is that\n                // default updates do not support refresh transitions.\n                nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n                    // Keep working on the existing in-progress tree. Do not interrupt.\n                    return wipLanes;\n                }\n            }\n            return nextLanes;\n        }\n        function getEntangledLanes(root, renderLanes) {\n            var entangledLanes = renderLanes;\n            if ((entangledLanes & InputContinuousLane) !== NoLanes) {\n                // When updates are sync by default, we entangle continuous priority updates\n                // and default updates, so they render in the same batch. The only reason\n                // they use separate lanes is because continuous updates should interrupt\n                // transitions, but default updates should not.\n                entangledLanes |= entangledLanes & DefaultLane;\n            } // Check for entangled lanes and add them to the batch.\n            //\n            // A lane is said to be entangled with another when it's not allowed to render\n            // in a batch that does not also include the other lane. Typically we do this\n            // when multiple updates have the same source, and we only want to respond to\n            // the most recent event from that source.\n            //\n            // Note that we apply entanglements *after* checking for partial work above.\n            // This means that if a lane is entangled during an interleaved event while\n            // it's already rendering, we won't interrupt it. This is intentional, since\n            // entanglement is usually \"best effort\": we'll try our best to render the\n            // lanes in the same batch, but it's not worth throwing out partially\n            // completed work in order to do it.\n            // TODO: Reconsider this. The counter-argument is that the partial work\n            // represents an intermediate state, which we don't want to show to the user.\n            // And by spending extra time finishing it, we're increasing the amount of\n            // time it takes to show the final state, which is what they are actually\n            // waiting for.\n            //\n            // For those exceptions where entanglement is semantically important,\n            // we should ensure that there is no partial work at the\n            // time we apply the entanglement.\n            var allEntangledLanes = root.entangledLanes;\n            if (allEntangledLanes !== NoLanes) {\n                var entanglements = root.entanglements;\n                var lanes = entangledLanes & allEntangledLanes;\n                while(lanes > 0){\n                    var index = pickArbitraryLaneIndex(lanes);\n                    var lane = 1 << index;\n                    entangledLanes |= entanglements[index];\n                    lanes &= ~lane;\n                }\n            }\n            return entangledLanes;\n        }\n        function computeExpirationTime(lane, currentTime) {\n            switch(lane){\n                case SyncHydrationLane:\n                case SyncLane:\n                case InputContinuousHydrationLane:\n                case InputContinuousLane:\n                    // User interactions should expire slightly more quickly.\n                    //\n                    // NOTE: This is set to the corresponding constant as in Scheduler.js.\n                    // When we made it larger, a product metric in www regressed, suggesting\n                    // there's a user interaction that's being starved by a series of\n                    // synchronous updates. If that theory is correct, the proper solution is\n                    // to fix the starvation. However, this scenario supports the idea that\n                    // expiration times are an important safeguard when starvation\n                    // does happen.\n                    return currentTime + syncLaneExpirationMs;\n                case DefaultHydrationLane:\n                case DefaultLane:\n                case TransitionHydrationLane:\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                    return currentTime + transitionLaneExpirationMs;\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                    // TODO: Retries should be allowed to expire if they are CPU bound for\n                    // too long, but when I made this change it caused a spike in browser\n                    // crashes. There must be some other underlying bug; not super urgent but\n                    // ideally should figure out why and fix it. Unfortunately we don't have\n                    // a repro for the crashes, only detected via production metrics.\n                    return NoTimestamp;\n                case SelectiveHydrationLane:\n                case IdleHydrationLane:\n                case IdleLane:\n                case OffscreenLane:\n                case DeferredLane:\n                    // Anything idle priority or lower should never expire.\n                    return NoTimestamp;\n                default:\n                    {\n                        error('Should have found matching lanes. This is a bug in React.');\n                    }\n                    return NoTimestamp;\n            }\n        }\n        function markStarvedLanesAsExpired(root, currentTime) {\n            // TODO: This gets called every time we yield. We can optimize by storing\n            // the earliest expiration time on the root. Then use that to quickly bail out\n            // of this function.\n            var pendingLanes = root.pendingLanes;\n            var suspendedLanes = root.suspendedLanes;\n            var pingedLanes = root.pingedLanes;\n            var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\n            // expiration time. If so, we'll assume the update is being starved and mark\n            // it as expired to force it to finish.\n            // TODO: We should be able to replace this with upgradePendingLanesToSync\n            //\n            // We exclude retry lanes because those must always be time sliced, in order\n            // to unwrap uncached promises.\n            // TODO: Write a test for this\n            var lanes = pendingLanes & ~RetryLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                var expirationTime = expirationTimes[index];\n                if (expirationTime === NoTimestamp) {\n                    // Found a pending lane with no expiration time. If it's not suspended, or\n                    // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n                    // using the current time.\n                    if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n                        // Assumes timestamps are monotonically increasing.\n                        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n                    }\n                } else if (expirationTime <= currentTime) {\n                    // This lane expired\n                    root.expiredLanes |= lane;\n                }\n                lanes &= ~lane;\n            }\n        } // This returns the highest priority pending lanes regardless of whether they\n        // are suspended.\n        function getHighestPriorityPendingLanes(root) {\n            return getHighestPriorityLanes(root.pendingLanes);\n        }\n        function getLanesToRetrySynchronouslyOnError(root, originallyAttemptedLanes) {\n            if (root.errorRecoveryDisabledLanes & originallyAttemptedLanes) {\n                // The error recovery mechanism is disabled until these lanes are cleared.\n                return NoLanes;\n            }\n            var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n            if (everythingButOffscreen !== NoLanes) {\n                return everythingButOffscreen;\n            }\n            if (everythingButOffscreen & OffscreenLane) {\n                return OffscreenLane;\n            }\n            return NoLanes;\n        }\n        function includesSyncLane(lanes) {\n            return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;\n        }\n        function includesNonIdleWork(lanes) {\n            return (lanes & NonIdleLanes) !== NoLanes;\n        }\n        function includesOnlyRetries(lanes) {\n            return (lanes & RetryLanes) === lanes;\n        }\n        function includesOnlyNonUrgentLanes(lanes) {\n            // TODO: Should hydration lanes be included here? This function is only\n            // used in `updateDeferredValueImpl`.\n            var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\n            return (lanes & UrgentLanes) === NoLanes;\n        }\n        function includesOnlyTransitions(lanes) {\n            return (lanes & TransitionLanes) === lanes;\n        }\n        function includesBlockingLane(root, lanes) {\n            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n            return (lanes & SyncDefaultLanes) !== NoLanes;\n        }\n        function includesExpiredLane(root, lanes) {\n            // This is a separate check from includesBlockingLane because a lane can\n            // expire after a render has already started.\n            return (lanes & root.expiredLanes) !== NoLanes;\n        }\n        function isTransitionLane(lane) {\n            return (lane & TransitionLanes) !== NoLanes;\n        }\n        function claimNextTransitionLane() {\n            // Cycle through the lanes, assigning each new transition to the next lane.\n            // In most cases, this means every transition gets its own lane, until we\n            // run out of lanes and cycle back to the beginning.\n            var lane = nextTransitionLane;\n            nextTransitionLane <<= 1;\n            if ((nextTransitionLane & TransitionLanes) === NoLanes) {\n                nextTransitionLane = TransitionLane1;\n            }\n            return lane;\n        }\n        function claimNextRetryLane() {\n            var lane = nextRetryLane;\n            nextRetryLane <<= 1;\n            if ((nextRetryLane & RetryLanes) === NoLanes) {\n                nextRetryLane = RetryLane1;\n            }\n            return lane;\n        }\n        function getHighestPriorityLane(lanes) {\n            return lanes & -lanes;\n        }\n        function pickArbitraryLane(lanes) {\n            // This wrapper function gets inlined. Only exists so to communicate that it\n            // doesn't matter which bit is selected; you can pick any bit without\n            // affecting the algorithms where its used. Here I'm using\n            // getHighestPriorityLane because it requires the fewest operations.\n            return getHighestPriorityLane(lanes);\n        }\n        function pickArbitraryLaneIndex(lanes) {\n            return 31 - clz32(lanes);\n        }\n        function laneToIndex(lane) {\n            return pickArbitraryLaneIndex(lane);\n        }\n        function includesSomeLane(a, b) {\n            return (a & b) !== NoLanes;\n        }\n        function isSubsetOfLanes(set, subset) {\n            return (set & subset) === subset;\n        }\n        function mergeLanes(a, b) {\n            return a | b;\n        }\n        function removeLanes(set, subset) {\n            return set & ~subset;\n        }\n        function intersectLanes(a, b) {\n            return a & b;\n        } // Seems redundant, but it changes the type from a single lane (used for\n        // updates) to a group of lanes (used for flushing work).\n        function laneToLanes(lane) {\n            return lane;\n        }\n        function higherPriorityLane(a, b) {\n            // This works because the bit ranges decrease in priority as you go left.\n            return a !== NoLane && a < b ? a : b;\n        }\n        function createLaneMap(initial) {\n            // Intentionally pushing one by one.\n            // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n            var laneMap = [];\n            for(var i = 0; i < TotalLanes; i++){\n                laneMap.push(initial);\n            }\n            return laneMap;\n        }\n        function markRootUpdated$1(root, updateLane) {\n            root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update\n            // could unblock them. Clear the suspended lanes so that we can try rendering\n            // them again.\n            //\n            // TODO: We really only need to unsuspend only lanes that are in the\n            // `subtreeLanes` of the updated fiber, or the update lanes of the return\n            // path. This would exclude suspended updates in an unrelated sibling tree,\n            // since there's no way for this update to unblock it.\n            //\n            // We don't do this if the incoming update is idle, because we never process\n            // idle updates until after all the regular updates have finished; there's no\n            // way it could unblock a transition.\n            if (updateLane !== IdleLane) {\n                root.suspendedLanes = NoLanes;\n                root.pingedLanes = NoLanes;\n            }\n        }\n        function markRootSuspended$1(root, suspendedLanes, spawnedLane) {\n            root.suspendedLanes |= suspendedLanes;\n            root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n            var expirationTimes = root.expirationTimes;\n            var lanes = suspendedLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                expirationTimes[index] = NoTimestamp;\n                lanes &= ~lane;\n            }\n            if (spawnedLane !== NoLane) {\n                markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n            }\n        }\n        function markRootPinged$1(root, pingedLanes) {\n            root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        }\n        function markRootFinished(root, remainingLanes, spawnedLane) {\n            var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n            root.pendingLanes = remainingLanes; // Let's try everything again\n            root.suspendedLanes = NoLanes;\n            root.pingedLanes = NoLanes;\n            root.expiredLanes &= remainingLanes;\n            root.entangledLanes &= remainingLanes;\n            root.errorRecoveryDisabledLanes &= remainingLanes;\n            root.shellSuspendCounter = 0;\n            var entanglements = root.entanglements;\n            var expirationTimes = root.expirationTimes;\n            var hiddenUpdates = root.hiddenUpdates; // Clear the lanes that no longer have pending work\n            var lanes = noLongerPendingLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                entanglements[index] = NoLanes;\n                expirationTimes[index] = NoTimestamp;\n                var hiddenUpdatesForLane = hiddenUpdates[index];\n                if (hiddenUpdatesForLane !== null) {\n                    hiddenUpdates[index] = null; // \"Hidden\" updates are updates that were made to a hidden component. They\n                    // have special logic associated with them because they may be entangled\n                    // with updates that occur outside that tree. But once the outer tree\n                    // commits, they behave like regular updates.\n                    for(var i = 0; i < hiddenUpdatesForLane.length; i++){\n                        var update = hiddenUpdatesForLane[i];\n                        if (update !== null) {\n                            update.lane &= ~OffscreenLane;\n                        }\n                    }\n                }\n                lanes &= ~lane;\n            }\n            if (spawnedLane !== NoLane) {\n                markSpawnedDeferredLane(root, spawnedLane, // to entangle the spawned task with the parent task.\n                NoLanes);\n            }\n        }\n        function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n            // This render spawned a deferred task. Mark it as pending.\n            root.pendingLanes |= spawnedLane;\n            root.suspendedLanes &= ~spawnedLane; // Entangle the spawned lane with the DeferredLane bit so that we know it\n            // was the result of another render. This lets us avoid a useDeferredValue\n            // waterfall — only the first level will defer.\n            var spawnedLaneIndex = laneToIndex(spawnedLane);\n            root.entangledLanes |= spawnedLane;\n            root.entanglements[spawnedLaneIndex] |= DeferredLane | // If the parent render task suspended, we must also entangle those lanes\n            // with the spawned task, so that the deferred task includes all the same\n            // updates that the parent task did. We can exclude any lane that is not\n            // used for updates (e.g. Offscreen).\n            entangledLanes & UpdateLanes;\n        }\n        function markRootEntangled(root, entangledLanes) {\n            // In addition to entangling each of the given lanes with each other, we also\n            // have to consider _transitive_ entanglements. For each lane that is already\n            // entangled with *any* of the given lanes, that lane is now transitively\n            // entangled with *all* the given lanes.\n            //\n            // Translated: If C is entangled with A, then entangling A with B also\n            // entangles C with B.\n            //\n            // If this is hard to grasp, it might help to intentionally break this\n            // function and look at the tests that fail in ReactTransition-test.js. Try\n            // commenting out one of the conditions below.\n            var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n            var entanglements = root.entanglements;\n            var lanes = rootEntangledLanes;\n            while(lanes){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                if (lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n                entanglements[index] & entangledLanes) {\n                    entanglements[index] |= entangledLanes;\n                }\n                lanes &= ~lane;\n            }\n        }\n        function upgradePendingLaneToSync(root, lane) {\n            // Since we're upgrading the priority of the given lane, there is now pending\n            // sync work.\n            root.pendingLanes |= SyncLane; // Entangle the sync lane with the lane we're upgrading. This means SyncLane\n            // will not be allowed to finish without also finishing the given lane.\n            root.entangledLanes |= SyncLane;\n            root.entanglements[SyncLaneIndex] |= lane;\n        }\n        function upgradePendingLanesToSync(root, lanesToUpgrade) {\n            // Same as upgradePendingLaneToSync but accepts multiple lanes, so it's a\n            // bit slower.\n            root.pendingLanes |= SyncLane;\n            root.entangledLanes |= SyncLane;\n            var lanes = lanesToUpgrade;\n            while(lanes){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                root.entanglements[SyncLaneIndex] |= lane;\n                lanes &= ~lane;\n            }\n        }\n        function markHiddenUpdate(root, update, lane) {\n            var index = laneToIndex(lane);\n            var hiddenUpdates = root.hiddenUpdates;\n            var hiddenUpdatesForLane = hiddenUpdates[index];\n            if (hiddenUpdatesForLane === null) {\n                hiddenUpdates[index] = [\n                    update\n                ];\n            } else {\n                hiddenUpdatesForLane.push(update);\n            }\n            update.lane = lane | OffscreenLane;\n        }\n        function getBumpedLaneForHydration(root, renderLanes) {\n            var renderLane = getHighestPriorityLane(renderLanes);\n            var lane;\n            if ((renderLane & SyncUpdateLanes) !== NoLane) {\n                lane = SyncHydrationLane;\n            } else {\n                switch(renderLane){\n                    case SyncLane:\n                        lane = SyncHydrationLane;\n                        break;\n                    case InputContinuousLane:\n                        lane = InputContinuousHydrationLane;\n                        break;\n                    case DefaultLane:\n                        lane = DefaultHydrationLane;\n                        break;\n                    case TransitionLane1:\n                    case TransitionLane2:\n                    case TransitionLane3:\n                    case TransitionLane4:\n                    case TransitionLane5:\n                    case TransitionLane6:\n                    case TransitionLane7:\n                    case TransitionLane8:\n                    case TransitionLane9:\n                    case TransitionLane10:\n                    case TransitionLane11:\n                    case TransitionLane12:\n                    case TransitionLane13:\n                    case TransitionLane14:\n                    case TransitionLane15:\n                    case RetryLane1:\n                    case RetryLane2:\n                    case RetryLane3:\n                    case RetryLane4:\n                        lane = TransitionHydrationLane;\n                        break;\n                    case IdleLane:\n                        lane = IdleHydrationLane;\n                        break;\n                    default:\n                        // Everything else is already either a hydration lane, or shouldn't\n                        // be retried at a hydration lane.\n                        lane = NoLane;\n                        break;\n                }\n            } // Check if the lane we chose is suspended. If so, that indicates that we\n            // already attempted and failed to hydrate at that level. Also check if we're\n            // already rendering that lane, which is rare but could happen.\n            if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n                // Give up trying to hydrate and fall back to client render.\n                return NoLane;\n            }\n            return lane;\n        }\n        function addFiberToLanesMap(root, fiber, lanes) {\n            if (!isDevToolsPresent) {\n                return;\n            }\n            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n            while(lanes > 0){\n                var index = laneToIndex(lanes);\n                var lane = 1 << index;\n                var updaters = pendingUpdatersLaneMap[index];\n                updaters.add(fiber);\n                lanes &= ~lane;\n            }\n        }\n        function movePendingFibersToMemoized(root, lanes) {\n            if (!isDevToolsPresent) {\n                return;\n            }\n            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n            var memoizedUpdaters = root.memoizedUpdaters;\n            while(lanes > 0){\n                var index = laneToIndex(lanes);\n                var lane = 1 << index;\n                var updaters = pendingUpdatersLaneMap[index];\n                if (updaters.size > 0) {\n                    updaters.forEach(function(fiber) {\n                        var alternate = fiber.alternate;\n                        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n                            memoizedUpdaters.add(fiber);\n                        }\n                    });\n                    updaters.clear();\n                }\n                lanes &= ~lane;\n            }\n        }\n        function getTransitionsForLanes(root, lanes) {\n            {\n                return null;\n            }\n        }\n        var DiscreteEventPriority = SyncLane;\n        var ContinuousEventPriority = InputContinuousLane;\n        var DefaultEventPriority = DefaultLane;\n        var IdleEventPriority = IdleLane;\n        function higherEventPriority(a, b) {\n            return a !== 0 && a < b ? a : b;\n        }\n        function lowerEventPriority(a, b) {\n            return a === 0 || a > b ? a : b;\n        }\n        function isHigherEventPriority(a, b) {\n            return a !== 0 && a < b;\n        }\n        function eventPriorityToLane(updatePriority) {\n            return updatePriority;\n        }\n        function lanesToEventPriority(lanes) {\n            var lane = getHighestPriorityLane(lanes);\n            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n                return DiscreteEventPriority;\n            }\n            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n                return ContinuousEventPriority;\n            }\n            if (includesNonIdleWork(lane)) {\n                return DefaultEventPriority;\n            }\n            return IdleEventPriority;\n        }\n        // This module only exists as an ESM wrapper around the external CommonJS\n        var scheduleCallback$3 = Scheduler.unstable_scheduleCallback;\n        var cancelCallback$1 = Scheduler.unstable_cancelCallback;\n        var shouldYield = Scheduler.unstable_shouldYield;\n        var requestPaint = Scheduler.unstable_requestPaint;\n        var now$1 = Scheduler.unstable_now;\n        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;\n        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\n        var NormalPriority$1 = Scheduler.unstable_NormalPriority;\n        var IdlePriority = Scheduler.unstable_IdlePriority; // this doesn't actually exist on the scheduler, but it *does*\n        // on scheduler/unstable_mock, which we'll need for internal testing\n        var log = Scheduler.log;\n        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;\n        var rendererID = null;\n        var injectedHook = null;\n        var injectedProfilingHooks = null;\n        var hasLoggedError = false;\n        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';\n        function injectInternals(internals) {\n            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n                // No DevTools\n                return false;\n            }\n            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n            if (hook.isDisabled) {\n                // This isn't a real property on the hook, but it can be set to opt out\n                // of DevTools integration and associated warnings and logs.\n                // https://github.com/facebook/react/issues/3877\n                return true;\n            }\n            if (!hook.supportsFiber) {\n                {\n                    error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://react.dev/link/react-devtools');\n                }\n                return true;\n            }\n            try {\n                if (enableSchedulingProfiler) {\n                    // Conditionally inject these hooks only if Timeline profiler is supported by this build.\n                    // This gives DevTools a way to feature detect that isn't tied to version number\n                    // (since profiling and timeline are controlled by different feature flags).\n                    internals = assign({}, internals, {\n                        getLaneLabelMap: getLaneLabelMap,\n                        injectProfilingHooks: injectProfilingHooks\n                    });\n                }\n                rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\n                injectedHook = hook;\n            } catch (err) {\n                // Catch all errors because it is unsafe to throw during initialization.\n                {\n                    error('React instrumentation encountered an error: %s.', err);\n                }\n            }\n            if (hook.checkDCE) {\n                // This is the real DevTools.\n                return true;\n            } else {\n                // This is likely a hook installed by Fast Refresh runtime.\n                return false;\n            }\n        }\n        function onScheduleRoot(root, children) {\n            {\n                if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {\n                    try {\n                        injectedHook.onScheduleFiberRoot(rendererID, root, children);\n                    } catch (err) {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function onCommitRoot$1(root, eventPriority) {\n            if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {\n                try {\n                    var didError = (root.current.flags & DidCapture) === DidCapture;\n                    if (enableProfilerTimer) {\n                        var schedulerPriority;\n                        switch(eventPriority){\n                            case DiscreteEventPriority:\n                                schedulerPriority = ImmediatePriority;\n                                break;\n                            case ContinuousEventPriority:\n                                schedulerPriority = UserBlockingPriority;\n                                break;\n                            case DefaultEventPriority:\n                                schedulerPriority = NormalPriority$1;\n                                break;\n                            case IdleEventPriority:\n                                schedulerPriority = IdlePriority;\n                                break;\n                            default:\n                                schedulerPriority = NormalPriority$1;\n                                break;\n                        }\n                        injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n                    }\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function onPostCommitRoot(root) {\n            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === 'function') {\n                try {\n                    injectedHook.onPostCommitFiberRoot(rendererID, root);\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function onCommitUnmount(fiber) {\n            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {\n                try {\n                    injectedHook.onCommitFiberUnmount(rendererID, fiber);\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function setIsStrictModeForDevtools(newIsStrictMode) {\n            {\n                if (typeof log === 'function') {\n                    // We're in a test because Scheduler.log only exists\n                    // in SchedulerMock. To reduce the noise in strict mode tests,\n                    // suppress warnings and disable scheduler yielding during the double render\n                    unstable_setDisableYieldValue(newIsStrictMode);\n                    setSuppressWarning(newIsStrictMode);\n                }\n                if (injectedHook && typeof injectedHook.setStrictMode === 'function') {\n                    try {\n                        injectedHook.setStrictMode(rendererID, newIsStrictMode);\n                    } catch (err) {\n                        {\n                            if (!hasLoggedError) {\n                                hasLoggedError = true;\n                                error('React instrumentation encountered an error: %s', err);\n                            }\n                        }\n                    }\n                }\n            }\n        } // Profiler API hooks\n        function injectProfilingHooks(profilingHooks) {\n            injectedProfilingHooks = profilingHooks;\n        }\n        function getLaneLabelMap() {\n            {\n                var map = new Map();\n                var lane = 1;\n                for(var index = 0; index < TotalLanes; index++){\n                    var label = getLabelForLane(lane);\n                    map.set(lane, label);\n                    lane *= 2;\n                }\n                return map;\n            }\n        }\n        function markCommitStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === 'function') {\n                    injectedProfilingHooks.markCommitStarted(lanes);\n                }\n            }\n        }\n        function markCommitStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === 'function') {\n                    injectedProfilingHooks.markCommitStopped();\n                }\n            }\n        }\n        function markComponentRenderStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === 'function') {\n                    injectedProfilingHooks.markComponentRenderStarted(fiber);\n                }\n            }\n        }\n        function markComponentRenderStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === 'function') {\n                    injectedProfilingHooks.markComponentRenderStopped();\n                }\n            }\n        }\n        function markComponentPassiveEffectMountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\n                }\n            }\n        }\n        function markComponentPassiveEffectMountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectMountStopped();\n                }\n            }\n        }\n        function markComponentPassiveEffectUnmountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\n                }\n            }\n        }\n        function markComponentPassiveEffectUnmountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\n                }\n            }\n        }\n        function markComponentLayoutEffectMountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\n                }\n            }\n        }\n        function markComponentLayoutEffectMountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectMountStopped();\n                }\n            }\n        }\n        function markComponentLayoutEffectUnmountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\n                }\n            }\n        }\n        function markComponentLayoutEffectUnmountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\n                }\n            }\n        }\n        function markComponentErrored(fiber, thrownValue, lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === 'function') {\n                    injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\n                }\n            }\n        }\n        function markComponentSuspended(fiber, wakeable, lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === 'function') {\n                    injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\n                }\n            }\n        }\n        function markLayoutEffectsStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === 'function') {\n                    injectedProfilingHooks.markLayoutEffectsStarted(lanes);\n                }\n            }\n        }\n        function markLayoutEffectsStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === 'function') {\n                    injectedProfilingHooks.markLayoutEffectsStopped();\n                }\n            }\n        }\n        function markPassiveEffectsStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === 'function') {\n                    injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n                }\n            }\n        }\n        function markPassiveEffectsStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === 'function') {\n                    injectedProfilingHooks.markPassiveEffectsStopped();\n                }\n            }\n        }\n        function markRenderStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === 'function') {\n                    injectedProfilingHooks.markRenderStarted(lanes);\n                }\n            }\n        }\n        function markRenderYielded() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === 'function') {\n                    injectedProfilingHooks.markRenderYielded();\n                }\n            }\n        }\n        function markRenderStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === 'function') {\n                    injectedProfilingHooks.markRenderStopped();\n                }\n            }\n        }\n        function markRenderScheduled(lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === 'function') {\n                    injectedProfilingHooks.markRenderScheduled(lane);\n                }\n            }\n        }\n        function markForceUpdateScheduled(fiber, lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === 'function') {\n                    injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\n                }\n            }\n        }\n        function markStateUpdateScheduled(fiber, lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === 'function') {\n                    injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n                }\n            }\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === 'function' ? Object.is : is;\n        // This is imported by the event replaying implementation in React DOM. It's\n        // in a separate file to break a circular dependency between the renderer and\n        // the reconciler.\n        function isRootDehydrated(root) {\n            var currentState = root.current.memoizedState;\n            return currentState.isDehydrated;\n        }\n        var CapturedStacks = new WeakMap();\n        function createCapturedValueAtFiber(value, source) {\n            // If the value is an error, call this function immediately after it is thrown\n            // so the stack is accurate.\n            var stack;\n            if (typeof value === 'object' && value !== null) {\n                var capturedStack = CapturedStacks.get(value);\n                if (typeof capturedStack === 'string') {\n                    stack = capturedStack;\n                } else {\n                    stack = getStackByFiberInDevAndProd(source);\n                    CapturedStacks.set(value, stack);\n                }\n            } else {\n                stack = getStackByFiberInDevAndProd(source);\n            }\n            return {\n                value: value,\n                source: source,\n                stack: stack\n            };\n        }\n        function createCapturedValueFromError(value, stack) {\n            if (typeof stack === 'string') {\n                CapturedStacks.set(value, stack);\n            }\n            return {\n                value: value,\n                source: null,\n                stack: stack\n            };\n        }\n        // Intentionally not using it yet to derisk the initial implementation, because\n        // the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n        // rather the ids be wrong than crash the whole reconciler.\n        var forkStack = [];\n        var forkStackIndex = 0;\n        var treeForkProvider = null;\n        var treeForkCount = 0;\n        var idStack = [];\n        var idStackIndex = 0;\n        var treeContextProvider = null;\n        var treeContextId = 1;\n        var treeContextOverflow = '';\n        function isForkedChild(workInProgress) {\n            warnIfNotHydrating();\n            return (workInProgress.flags & Forked) !== NoFlags$1;\n        }\n        function getForksAtLevel(workInProgress) {\n            warnIfNotHydrating();\n            return treeForkCount;\n        }\n        function getTreeId() {\n            var overflow = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeFork(workInProgress, totalChildren) {\n            // This is called right after we reconcile an array (or iterator) of child\n            // fibers, because that's the only place where we know how many children in\n            // the whole set without doing extra work later, or storing addtional\n            // information on the fiber.\n            //\n            // That's why this function is separate from pushTreeId — it's called during\n            // the render phase of the fork parent, not the child, which is where we push\n            // the other context values.\n            //\n            // In the Fizz implementation this is much simpler because the child is\n            // rendered in the same callstack as the parent.\n            //\n            // It might be better to just add a `forks` field to the Fiber type. It would\n            // make this module simpler.\n            warnIfNotHydrating();\n            forkStack[forkStackIndex++] = treeForkCount;\n            forkStack[forkStackIndex++] = treeForkProvider;\n            treeForkProvider = workInProgress;\n            treeForkCount = totalChildren;\n        }\n        function pushTreeId(workInProgress, totalChildren, index) {\n            warnIfNotHydrating();\n            idStack[idStackIndex++] = treeContextId;\n            idStack[idStackIndex++] = treeContextOverflow;\n            idStack[idStackIndex++] = treeContextProvider;\n            treeContextProvider = workInProgress;\n            var baseIdWithLeadingBit = treeContextId;\n            var baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                treeContextId = 1 << restOfLength | id;\n                treeContextOverflow = overflow;\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                treeContextId = 1 << length | _id;\n                treeContextOverflow = _overflow;\n            }\n        }\n        function pushMaterializedTreeId(workInProgress) {\n            warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear\n            // in its children.\n            var returnFiber = workInProgress.return;\n            if (returnFiber !== null) {\n                var numberOfForks = 1;\n                var slotIndex = 0;\n                pushTreeFork(workInProgress, numberOfForks);\n                pushTreeId(workInProgress, numberOfForks, slotIndex);\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        }\n        function popTreeContext(workInProgress) {\n            // Restore the previous values.\n            // This is a bit more complicated than other context-like modules in Fiber\n            // because the same Fiber may appear on the stack multiple times and for\n            // different reasons. We have to keep popping until the work-in-progress is\n            // no longer at the top of the stack.\n            while(workInProgress === treeForkProvider){\n                treeForkProvider = forkStack[--forkStackIndex];\n                forkStack[forkStackIndex] = null;\n                treeForkCount = forkStack[--forkStackIndex];\n                forkStack[forkStackIndex] = null;\n            }\n            while(workInProgress === treeContextProvider){\n                treeContextProvider = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n                treeContextOverflow = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n                treeContextId = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n            }\n        }\n        function getSuspendedTreeContext() {\n            warnIfNotHydrating();\n            if (treeContextProvider !== null) {\n                return {\n                    id: treeContextId,\n                    overflow: treeContextOverflow\n                };\n            } else {\n                return null;\n            }\n        }\n        function restoreSuspendedTreeContext(workInProgress, suspendedContext) {\n            warnIfNotHydrating();\n            idStack[idStackIndex++] = treeContextId;\n            idStack[idStackIndex++] = treeContextOverflow;\n            idStack[idStackIndex++] = treeContextProvider;\n            treeContextId = suspendedContext.id;\n            treeContextOverflow = suspendedContext.overflow;\n            treeContextProvider = workInProgress;\n        }\n        function warnIfNotHydrating() {\n            {\n                if (!getIsHydrating()) {\n                    error('Expected to be hydrating. This is a bug in React. Please file ' + 'an issue.');\n                }\n            }\n        }\n        var contextStackCursor = createCursor(null);\n        var contextFiberStackCursor = createCursor(null);\n        var rootInstanceStackCursor = createCursor(null); // Represents the nearest host transition provider (in React DOM, a <form />)\n        // NOTE: Since forms cannot be nested, and this feature is only implemented by\n        // React DOM, we don't technically need this to be a stack. It could be a single\n        // module variable instead.\n        var hostTransitionProviderCursor = createCursor(null); // TODO: This should initialize to NotPendingTransition, a constant\n        // imported from the fiber config. However, because of a cycle in the module\n        // graph, that value isn't defined during this module's initialization. I can't\n        // think of a way to work around this without moving that value out of the\n        // fiber config. For now, the \"no provider\" case is handled when reading,\n        // inside useHostTransitionStatus.\n        var HostTransitionContext = {\n            $$typeof: REACT_CONTEXT_TYPE,\n            Provider: null,\n            Consumer: null,\n            _currentValue: null,\n            _currentValue2: null,\n            _threadCount: 0\n        };\n        function requiredContext(c) {\n            {\n                if (c === null) {\n                    error('Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n                }\n            }\n            return c;\n        }\n        function getRootHostContainer() {\n            var rootInstance = requiredContext(rootInstanceStackCursor.current);\n            return rootInstance;\n        }\n        function pushHostContainer(fiber, nextRootInstance) {\n            // Push current root instance onto the stack;\n            // This allows us to reset root when portals are popped.\n            push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n            // This enables us to pop only Fibers that provide unique contexts.\n            push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n            // However, we can't just call getRootHostContext() and push it because\n            // we'd have a different number of entries on the stack depending on\n            // whether getRootHostContext() throws somewhere in renderer code or not.\n            // So we push an empty value first. This lets us safely unwind on errors.\n            push(contextStackCursor, null, fiber);\n            var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n            pop(contextStackCursor, fiber);\n            push(contextStackCursor, nextRootContext, fiber);\n        }\n        function popHostContainer(fiber) {\n            pop(contextStackCursor, fiber);\n            pop(contextFiberStackCursor, fiber);\n            pop(rootInstanceStackCursor, fiber);\n        }\n        function getHostContext() {\n            var context = requiredContext(contextStackCursor.current);\n            return context;\n        }\n        function pushHostContext(fiber) {\n            {\n                var stateHook = fiber.memoizedState;\n                if (stateHook !== null) {\n                    // Only provide context if this fiber has been upgraded by a host\n                    // transition. We use the same optimization for regular host context below.\n                    push(hostTransitionProviderCursor, fiber, fiber);\n                }\n            }\n            var context = requiredContext(contextStackCursor.current);\n            var nextContext = getChildHostContext(context, fiber.type); // Don't push this Fiber's context unless it's unique.\n            if (context !== nextContext) {\n                // Track the context and the Fiber that provided it.\n                // This enables us to pop only Fibers that provide unique contexts.\n                push(contextFiberStackCursor, fiber, fiber);\n                push(contextStackCursor, nextContext, fiber);\n            }\n        }\n        function popHostContext(fiber) {\n            if (contextFiberStackCursor.current === fiber) {\n                // Do not pop unless this Fiber provided the current context.\n                // pushHostContext() only pushes Fibers that provide unique contexts.\n                pop(contextStackCursor, fiber);\n                pop(contextFiberStackCursor, fiber);\n            }\n            {\n                if (hostTransitionProviderCursor.current === fiber) {\n                    // Do not pop unless this Fiber provided the current context. This is mostly\n                    // a performance optimization, but conveniently it also prevents a potential\n                    // data race where a host provider is upgraded (i.e. memoizedState becomes\n                    // non-null) during a concurrent event. This is a bit of a flaw in the way\n                    // we upgrade host components, but because we're accounting for it here, it\n                    // should be fine.\n                    pop(hostTransitionProviderCursor, fiber); // When popping the transition provider, we reset the context value back\n                    // to `null`. We can do this because you're not allowd to nest forms. If\n                    // we allowed for multiple nested host transition providers, then we'd\n                    // need to reset this to the parent provider's status.\n                    if (isPrimaryRenderer) {\n                        HostTransitionContext._currentValue = null;\n                    } else {\n                        HostTransitionContext._currentValue2 = null;\n                    }\n                }\n            }\n        }\n        var maxRowLength = 120;\n        var idealDepth = 15;\n        function findNotableNode(node, indent) {\n            if (node.serverProps === undefined && node.serverTail.length === 0 && node.children.length === 1 && node.distanceFromLeaf > 3 && node.distanceFromLeaf > idealDepth - indent) {\n                // This is not an interesting node for contextual purposes so we can skip it.\n                var child = node.children[0];\n                return findNotableNode(child, indent);\n            }\n            return node;\n        }\n        function indentation(indent) {\n            return '  ' + '  '.repeat(indent);\n        }\n        function added(indent) {\n            return '+ ' + '  '.repeat(indent);\n        }\n        function removed(indent) {\n            return '- ' + '  '.repeat(indent);\n        }\n        function describeFiberType(fiber) {\n            switch(fiber.tag){\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    return fiber.type;\n                case LazyComponent:\n                    return 'Lazy';\n                case SuspenseComponent:\n                    return 'Suspense';\n                case SuspenseListComponent:\n                    return 'SuspenseList';\n                case FunctionComponent:\n                case SimpleMemoComponent:\n                    var fn = fiber.type;\n                    return fn.displayName || fn.name || null;\n                case ForwardRef:\n                    var render = fiber.type.render;\n                    return render.displayName || render.name || null;\n                case ClassComponent:\n                    var ctr = fiber.type;\n                    return ctr.displayName || ctr.name || null;\n                default:\n                    // Skip\n                    return null;\n            }\n        }\n        var needsEscaping = /[\"'&<>\\n\\t]/;\n        function describeTextNode(content, maxLength) {\n            if (needsEscaping.test(content)) {\n                var encoded = JSON.stringify(content);\n                if (encoded.length > maxLength - 2) {\n                    if (maxLength < 8) {\n                        return '{\"...\"}';\n                    }\n                    return '{' + encoded.slice(0, maxLength - 7) + '...\"}';\n                }\n                return '{' + encoded + '}';\n            } else {\n                if (content.length > maxLength) {\n                    if (maxLength < 5) {\n                        return '{\"...\"}';\n                    }\n                    return content.slice(0, maxLength - 3) + '...';\n                }\n                return content;\n            }\n        }\n        function describeTextDiff(clientText, serverProps, indent) {\n            var maxLength = maxRowLength - indent * 2;\n            if (serverProps === null) {\n                return added(indent) + describeTextNode(clientText, maxLength) + '\\n';\n            } else if (typeof serverProps === 'string') {\n                var serverText = serverProps;\n                var firstDiff = 0;\n                for(; firstDiff < serverText.length && firstDiff < clientText.length; firstDiff++){\n                    if (serverText.charCodeAt(firstDiff) !== clientText.charCodeAt(firstDiff)) {\n                        break;\n                    }\n                }\n                if (firstDiff > maxLength - 8 && firstDiff > 10) {\n                    // The first difference between the two strings would be cut off, so cut off in\n                    // the beginning instead.\n                    clientText = '...' + clientText.slice(firstDiff - 8);\n                    serverText = '...' + serverText.slice(firstDiff - 8);\n                }\n                return added(indent) + describeTextNode(clientText, maxLength) + '\\n' + removed(indent) + describeTextNode(serverText, maxLength) + '\\n';\n            } else {\n                return indentation(indent) + describeTextNode(clientText, maxLength) + '\\n';\n            }\n        }\n        function objectName(object) {\n            // $FlowFixMe[method-unbinding]\n            var name = Object.prototype.toString.call(object);\n            return name.replace(/^\\[object (.*)\\]$/, function(m, p0) {\n                return p0;\n            });\n        }\n        function describeValue(value, maxLength) {\n            switch(typeof value){\n                case 'string':\n                    {\n                        var encoded = JSON.stringify(value);\n                        if (encoded.length > maxLength) {\n                            if (maxLength < 5) {\n                                return '\"...\"';\n                            }\n                            return encoded.slice(0, maxLength - 4) + '...\"';\n                        }\n                        return encoded;\n                    }\n                case 'object':\n                    {\n                        if (value === null) {\n                            return 'null';\n                        }\n                        if (isArray(value)) {\n                            return '[...]';\n                        }\n                        if (value.$$typeof === REACT_ELEMENT_TYPE) {\n                            var type = getComponentNameFromType(value.type);\n                            return type ? '<' + type + '>' : '<...>';\n                        }\n                        var name = objectName(value);\n                        if (name === 'Object') {\n                            var properties = '';\n                            maxLength -= 2;\n                            for(var propName in value){\n                                if (!value.hasOwnProperty(propName)) {\n                                    continue;\n                                }\n                                var jsonPropName = JSON.stringify(propName);\n                                if (jsonPropName !== '\"' + propName + '\"') {\n                                    propName = jsonPropName;\n                                }\n                                maxLength -= propName.length - 2;\n                                var propValue = describeValue(value[propName], maxLength < 15 ? maxLength : 15);\n                                maxLength -= propValue.length;\n                                if (maxLength < 0) {\n                                    properties += properties === '' ? '...' : ', ...';\n                                    break;\n                                }\n                                properties += (properties === '' ? '' : ',') + propName + ':' + propValue;\n                            }\n                            return '{' + properties + '}';\n                        }\n                        return name;\n                    }\n                case 'function':\n                    {\n                        var _name = value.displayName || value.name;\n                        return _name ? 'function ' + _name : 'function';\n                    }\n                default:\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    return String(value);\n            }\n        }\n        function describePropValue(value, maxLength) {\n            if (typeof value === 'string' && !needsEscaping.test(value)) {\n                if (value.length > maxLength - 2) {\n                    if (maxLength < 5) {\n                        return '\"...\"';\n                    }\n                    return '\"' + value.slice(0, maxLength - 5) + '...\"';\n                }\n                return '\"' + value + '\"';\n            }\n            return '{' + describeValue(value, maxLength - 2) + '}';\n        }\n        function describeCollapsedElement(type, props, indent) {\n            // This function tries to fit the props into a single line for non-essential elements.\n            // We also ignore children because we're not going deeper.\n            var maxLength = maxRowLength - indent * 2 - type.length - 2;\n            var content = '';\n            for(var propName in props){\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n                if (propName === 'children') {\n                    continue;\n                }\n                var propValue = describePropValue(props[propName], 15);\n                maxLength -= propName.length + propValue.length + 2;\n                if (maxLength < 0) {\n                    content += ' ...';\n                    break;\n                }\n                content += ' ' + propName + '=' + propValue;\n            }\n            return indentation(indent) + '<' + type + content + '>\\n';\n        }\n        function describeExpandedElement(type, props, rowPrefix) {\n            // This function tries to fit the props into a single line for non-essential elements.\n            // We also ignore children because we're not going deeper.\n            var remainingRowLength = maxRowLength - rowPrefix.length - type.length; // We add the properties to a set so we can choose later whether we'll put it on one\n            // line or multiple lines.\n            var properties = [];\n            for(var propName in props){\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n                if (propName === 'children') {\n                    continue;\n                }\n                var maxLength = maxRowLength - rowPrefix.length - propName.length - 1;\n                var propValue = describePropValue(props[propName], maxLength);\n                remainingRowLength -= propName.length + propValue.length + 2;\n                properties.push(propName + '=' + propValue);\n            }\n            if (properties.length === 0) {\n                return rowPrefix + '<' + type + '>\\n';\n            } else if (remainingRowLength > 0) {\n                // We can fit all on one row.\n                return rowPrefix + '<' + type + ' ' + properties.join(' ') + '>\\n';\n            } else {\n                // Split into one row per property:\n                return rowPrefix + '<' + type + '\\n' + rowPrefix + '  ' + properties.join('\\n' + rowPrefix + '  ') + '\\n' + rowPrefix + '>\\n';\n            }\n        }\n        function describePropertiesDiff(clientObject, serverObject, indent) {\n            var properties = '';\n            var remainingServerProperties = assign({}, serverObject);\n            for(var propName in clientObject){\n                if (!clientObject.hasOwnProperty(propName)) {\n                    continue;\n                }\n                delete remainingServerProperties[propName];\n                var maxLength = maxRowLength - indent * 2 - propName.length - 2;\n                var clientValue = clientObject[propName];\n                var clientPropValue = describeValue(clientValue, maxLength);\n                if (serverObject.hasOwnProperty(propName)) {\n                    var serverValue = serverObject[propName];\n                    var serverPropValue = describeValue(serverValue, maxLength);\n                    properties += added(indent) + propName + ': ' + clientPropValue + '\\n';\n                    properties += removed(indent) + propName + ': ' + serverPropValue + '\\n';\n                } else {\n                    properties += added(indent) + propName + ': ' + clientPropValue + '\\n';\n                }\n            }\n            for(var _propName in remainingServerProperties){\n                if (!remainingServerProperties.hasOwnProperty(_propName)) {\n                    continue;\n                }\n                var _maxLength = maxRowLength - indent * 2 - _propName.length - 2;\n                var _serverValue = remainingServerProperties[_propName];\n                var _serverPropValue = describeValue(_serverValue, _maxLength);\n                properties += removed(indent) + _propName + ': ' + _serverPropValue + '\\n';\n            }\n            return properties;\n        }\n        function describeElementDiff(type, clientProps, serverProps, indent) {\n            var content = ''; // Maps any previously unmatched lower case server prop name to its full prop name\n            var serverPropNames = new Map();\n            for(var propName in serverProps){\n                if (!serverProps.hasOwnProperty(propName)) {\n                    continue;\n                }\n                serverPropNames.set(propName.toLowerCase(), propName);\n            }\n            if (serverPropNames.size === 1 && serverPropNames.has('children')) {\n                content += describeExpandedElement(type, clientProps, indentation(indent));\n            } else {\n                for(var _propName2 in clientProps){\n                    if (!clientProps.hasOwnProperty(_propName2)) {\n                        continue;\n                    }\n                    if (_propName2 === 'children') {\n                        continue;\n                    }\n                    var maxLength = maxRowLength - (indent + 1) * 2 - _propName2.length - 1;\n                    var serverPropName = serverPropNames.get(_propName2.toLowerCase());\n                    if (serverPropName !== undefined) {\n                        serverPropNames.delete(_propName2.toLowerCase()); // There's a diff here.\n                        var clientValue = clientProps[_propName2];\n                        var serverValue = serverProps[serverPropName];\n                        var clientPropValue = describePropValue(clientValue, maxLength);\n                        var serverPropValue = describePropValue(serverValue, maxLength);\n                        if (typeof clientValue === 'object' && clientValue !== null && typeof serverValue === 'object' && serverValue !== null && objectName(clientValue) === 'Object' && objectName(serverValue) === 'Object' && (Object.keys(clientValue).length > 2 || Object.keys(serverValue).length > 2 || clientPropValue.indexOf('...') > -1 || serverPropValue.indexOf('...') > -1)) {\n                            // We're comparing two plain objects. We can diff the nested objects instead.\n                            content += indentation(indent + 1) + _propName2 + '={{\\n' + describePropertiesDiff(clientValue, serverValue, indent + 2) + indentation(indent + 1) + '}}\\n';\n                        } else {\n                            content += added(indent + 1) + _propName2 + '=' + clientPropValue + '\\n';\n                            content += removed(indent + 1) + _propName2 + '=' + serverPropValue + '\\n';\n                        }\n                    } else {\n                        // Considered equal.\n                        content += indentation(indent + 1) + _propName2 + '=' + describePropValue(clientProps[_propName2], maxLength) + '\\n';\n                    }\n                }\n                serverPropNames.forEach(function(propName) {\n                    if (propName === 'children') {\n                        // Handled below.\n                        return;\n                    }\n                    var maxLength = maxRowLength - (indent + 1) * 2 - propName.length - 1;\n                    content += removed(indent + 1) + propName + '=' + describePropValue(serverProps[propName], maxLength) + '\\n';\n                });\n                if (content === '') {\n                    // No properties\n                    content = indentation(indent) + '<' + type + '>\\n';\n                } else {\n                    // Had properties\n                    content = indentation(indent) + '<' + type + '\\n' + content + indentation(indent) + '>\\n';\n                }\n            }\n            var serverChildren = serverProps.children;\n            var clientChildren = clientProps.children;\n            if (typeof serverChildren === 'string' || typeof serverChildren === 'number' || typeof serverChildren === 'bigint') {\n                // There's a diff of the children.\n                // $FlowFixMe[unsafe-addition]\n                var serverText = '' + serverChildren;\n                var clientText = '';\n                if (typeof clientChildren === 'string' || typeof clientChildren === 'number' || typeof clientChildren === 'bigint') {\n                    // $FlowFixMe[unsafe-addition]\n                    clientText = '' + clientChildren;\n                }\n                content += describeTextDiff(clientText, serverText, indent + 1);\n            } else if (typeof clientChildren === 'string' || typeof clientChildren === 'number' || typeof clientChildren === 'bigint') {\n                // The client has children but it's not considered a difference from the server.\n                // $FlowFixMe[unsafe-addition]\n                content += describeTextDiff('' + clientChildren, undefined, indent + 1);\n            }\n            return content;\n        }\n        function describeSiblingFiber(fiber, indent) {\n            var type = describeFiberType(fiber);\n            if (type === null) {\n                // Skip this type of fiber. We currently treat this as a fragment\n                // so it's just part of the parent's children.\n                var flatContent = '';\n                var childFiber = fiber.child;\n                while(childFiber){\n                    flatContent += describeSiblingFiber(childFiber, indent);\n                    childFiber = childFiber.sibling;\n                }\n                return flatContent;\n            }\n            return indentation(indent) + '<' + type + '>' + '\\n';\n        }\n        function describeNode(node, indent) {\n            var skipToNode = findNotableNode(node, indent);\n            if (skipToNode !== node && (node.children.length !== 1 || node.children[0] !== skipToNode)) {\n                return indentation(indent) + '...\\n' + describeNode(skipToNode, indent + 1);\n            } // Prefix with any server components for context\n            var parentContent = '';\n            var debugInfo = node.fiber._debugInfo;\n            if (debugInfo) {\n                for(var i = 0; i < debugInfo.length; i++){\n                    var serverComponentName = debugInfo[i].name;\n                    if (typeof serverComponentName === 'string') {\n                        parentContent += indentation(indent) + '<' + serverComponentName + '>' + '\\n';\n                        indent++;\n                    }\n                }\n            } // Self\n            var selfContent = ''; // We use the pending props since we might be generating a diff before the complete phase\n            // when something throws.\n            var clientProps = node.fiber.pendingProps;\n            if (node.fiber.tag === HostText) {\n                // Text Node\n                selfContent = describeTextDiff(clientProps, node.serverProps, indent);\n            } else {\n                var type = describeFiberType(node.fiber);\n                if (type !== null) {\n                    // Element Node\n                    if (node.serverProps === undefined) {\n                        // Just a reference node for context.\n                        selfContent = describeCollapsedElement(type, clientProps, indent);\n                        indent++;\n                    } else if (node.serverProps === null) {\n                        selfContent = describeExpandedElement(type, clientProps, added(indent)); // If this was an insertion we won't step down further. Any tail\n                    // are considered siblings so we don't indent.\n                    // TODO: Model this a little better.\n                    } else if (typeof node.serverProps === 'string') {\n                        {\n                            error('Should not have matched a non HostText fiber to a Text node. This is a bug in React.');\n                        }\n                    } else {\n                        selfContent = describeElementDiff(type, clientProps, node.serverProps, indent);\n                        indent++;\n                    }\n                }\n            } // Compute children\n            var childContent = '';\n            var childFiber = node.fiber.child;\n            var diffIdx = 0;\n            while(childFiber && diffIdx < node.children.length){\n                var childNode = node.children[diffIdx];\n                if (childNode.fiber === childFiber) {\n                    // This was a match in the diff.\n                    childContent += describeNode(childNode, indent);\n                    diffIdx++;\n                } else {\n                    // This is an unrelated previous sibling.\n                    childContent += describeSiblingFiber(childFiber, indent);\n                }\n                childFiber = childFiber.sibling;\n            }\n            if (childFiber && node.children.length > 0) {\n                // If we had any further siblings after the last mismatch, we can't be sure if it's\n                // actually a valid match since it might not have found a match. So we exclude next\n                // siblings to avoid confusion.\n                childContent += indentation(indent) + '...' + '\\n';\n            } // Deleted tail nodes\n            var serverTail = node.serverTail;\n            for(var _i = 0; _i < serverTail.length; _i++){\n                var tailNode = serverTail[_i];\n                if (typeof tailNode === 'string') {\n                    // Removed text node\n                    childContent += removed(indent) + describeTextNode(tailNode, maxRowLength - indent * 2) + '\\n';\n                } else {\n                    // Removed element\n                    childContent += describeExpandedElement(tailNode.type, tailNode.props, removed(indent));\n                }\n            }\n            return parentContent + selfContent + childContent;\n        }\n        function describeDiff(rootNode) {\n            try {\n                return '\\n\\n' + describeNode(rootNode, 0);\n            } catch (x) {\n                return '';\n            }\n        }\n        // This may have been an insertion or a hydration.\n        var hydrationParentFiber = null;\n        var nextHydratableInstance = null;\n        var isHydrating = false; // This flag allows for warning supression when we expect there to be mismatches\n        // due to earlier mismatches or a suspended fiber.\n        var didSuspendOrErrorDEV = false; // Hydration differences found that haven't yet been logged.\n        var hydrationDiffRootDEV = null; // Hydration errors that were thrown inside this boundary\n        var hydrationErrors = null;\n        var rootOrSingletonContext = false; // Builds a common ancestor tree from the root down for collecting diffs.\n        function buildHydrationDiffNode(fiber, distanceFromLeaf) {\n            if (fiber.return === null) {\n                // We're at the root.\n                if (hydrationDiffRootDEV === null) {\n                    hydrationDiffRootDEV = {\n                        fiber: fiber,\n                        children: [],\n                        serverProps: undefined,\n                        serverTail: [],\n                        distanceFromLeaf: distanceFromLeaf\n                    };\n                } else if (hydrationDiffRootDEV.fiber !== fiber) {\n                    throw new Error('Saw multiple hydration diff roots in a pass. This is a bug in React.');\n                } else if (hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf) {\n                    hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf;\n                }\n                return hydrationDiffRootDEV;\n            }\n            var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children; // The same node may already exist in the parent. Since we currently always render depth first\n            // and rerender if we suspend or terminate early, if a shared ancestor was added we should still\n            // be inside of that shared ancestor which means it was the last one to be added. If this changes\n            // we may have to scan the whole set.\n            if (siblings.length > 0 && siblings[siblings.length - 1].fiber === fiber) {\n                var existing = siblings[siblings.length - 1];\n                if (existing.distanceFromLeaf > distanceFromLeaf) {\n                    existing.distanceFromLeaf = distanceFromLeaf;\n                }\n                return existing;\n            }\n            var newNode = {\n                fiber: fiber,\n                children: [],\n                serverProps: undefined,\n                serverTail: [],\n                distanceFromLeaf: distanceFromLeaf\n            };\n            siblings.push(newNode);\n            return newNode;\n        }\n        function warnIfHydrating() {\n            {\n                if (isHydrating) {\n                    error('We should not be hydrating here. This is a bug in React. Please file a bug.');\n                }\n            }\n        }\n        function markDidThrowWhileHydratingDEV() {\n            {\n                didSuspendOrErrorDEV = true;\n            }\n        }\n        function enterHydrationState(fiber) {\n            if (!supportsHydration) {\n                return false;\n            }\n            var parentInstance = fiber.stateNode.containerInfo;\n            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n            hydrationParentFiber = fiber;\n            isHydrating = true;\n            hydrationErrors = null;\n            didSuspendOrErrorDEV = false;\n            hydrationDiffRootDEV = null;\n            rootOrSingletonContext = true;\n            return true;\n        }\n        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n            if (!supportsHydration) {\n                return false;\n            }\n            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n            hydrationParentFiber = fiber;\n            isHydrating = true;\n            hydrationErrors = null;\n            didSuspendOrErrorDEV = false;\n            hydrationDiffRootDEV = null;\n            rootOrSingletonContext = false;\n            if (treeContext !== null) {\n                restoreSuspendedTreeContext(fiber, treeContext);\n            }\n            return true;\n        }\n        function warnNonHydratedInstance(fiber, rejectedCandidate) {\n            {\n                if (didSuspendOrErrorDEV) {\n                    // Inside a boundary that already suspended. We're currently rendering the\n                    // siblings of a suspended node. The mismatch may be due to the missing\n                    // data, so it's probably a false positive.\n                    return;\n                } // Add this fiber to the diff tree.\n                var diffNode = buildHydrationDiffNode(fiber, 0); // We use null as a signal that there was no node to match.\n                diffNode.serverProps = null;\n                if (rejectedCandidate !== null) {\n                    var description = describeHydratableInstanceForDevWarnings(rejectedCandidate);\n                    diffNode.serverTail.push(description);\n                }\n            }\n        }\n        function tryHydrateInstance(fiber, nextInstance, hostContext) {\n            // fiber is a HostComponent Fiber\n            var instance = canHydrateInstance(nextInstance, fiber.type, fiber.pendingProps, rootOrSingletonContext);\n            if (instance !== null) {\n                fiber.stateNode = instance;\n                {\n                    if (!didSuspendOrErrorDEV) {\n                        var differences = diffHydratedPropsForDevWarnings(instance, fiber.type, fiber.pendingProps, hostContext);\n                        if (differences !== null) {\n                            var diffNode = buildHydrationDiffNode(fiber, 0);\n                            diffNode.serverProps = differences;\n                        }\n                    }\n                }\n                hydrationParentFiber = fiber;\n                nextHydratableInstance = getFirstHydratableChild(instance);\n                rootOrSingletonContext = false;\n                return true;\n            }\n            return false;\n        }\n        function tryHydrateText(fiber, nextInstance) {\n            // fiber is a HostText Fiber\n            var text = fiber.pendingProps;\n            var textInstance = canHydrateTextInstance(nextInstance, text, rootOrSingletonContext);\n            if (textInstance !== null) {\n                fiber.stateNode = textInstance;\n                hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.\n                nextHydratableInstance = null;\n                return true;\n            }\n            return false;\n        }\n        function tryHydrateSuspense(fiber, nextInstance) {\n            // fiber is a SuspenseComponent Fiber\n            var suspenseInstance = canHydrateSuspenseInstance(nextInstance, rootOrSingletonContext);\n            if (suspenseInstance !== null) {\n                var suspenseState = {\n                    dehydrated: suspenseInstance,\n                    treeContext: getSuspendedTreeContext(),\n                    retryLane: OffscreenLane\n                };\n                fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n                // This simplifies the code for getHostSibling and deleting nodes,\n                // since it doesn't have to consider all Suspense boundaries and\n                // check if they're dehydrated ones or not.\n                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n                dehydratedFragment.return = fiber;\n                fiber.child = dehydratedFragment;\n                hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into\n                // it during the first pass. Instead, we'll reenter it later.\n                nextHydratableInstance = null;\n                return true;\n            }\n            return false;\n        }\n        var HydrationMismatchException = new Error('Hydration Mismatch Exception: This is not a real error, and should not leak into ' + \"userspace. If you're seeing this, it's likely a bug in React.\");\n        function throwOnHydrationMismatch(fiber) {\n            var diff = '';\n            {\n                // Consume the diff root for this mismatch.\n                // Any other errors will get their own diffs.\n                var diffRoot = hydrationDiffRootDEV;\n                if (diffRoot !== null) {\n                    hydrationDiffRootDEV = null;\n                    diff = describeDiff(diffRoot);\n                }\n            }\n            var error = new Error(\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\\n\" + '\\n' + \"- A server/client branch `if (typeof window !== 'undefined')`.\\n\" + \"- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n\" + \"- Date formatting in a user's locale which doesn't match the server.\\n\" + '- External changing data without sending a snapshot of it along with the HTML.\\n' + '- Invalid HTML tag nesting.\\n' + '\\n' + 'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n' + '\\n' + 'https://react.dev/link/hydration-mismatch' + diff);\n            queueHydrationError(createCapturedValueAtFiber(error, fiber));\n            throw HydrationMismatchException;\n        }\n        function claimHydratableSingleton(fiber) {\n            if (supportsSingletons) {\n                if (!isHydrating) {\n                    return;\n                }\n                var currentRootContainer = getRootHostContainer();\n                var currentHostContext = getHostContext();\n                var instance = fiber.stateNode = resolveSingletonInstance(fiber.type, fiber.pendingProps, currentRootContainer, currentHostContext, false);\n                {\n                    if (!didSuspendOrErrorDEV) {\n                        var differences = diffHydratedPropsForDevWarnings(instance, fiber.type, fiber.pendingProps, currentHostContext);\n                        if (differences !== null) {\n                            var diffNode = buildHydrationDiffNode(fiber, 0);\n                            diffNode.serverProps = differences;\n                        }\n                    }\n                }\n                hydrationParentFiber = fiber;\n                rootOrSingletonContext = true;\n                nextHydratableInstance = getFirstHydratableChild(instance);\n            }\n        }\n        function tryToClaimNextHydratableInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            } // Validate that this is ok to render here before any mismatches.\n            var currentHostContext = getHostContext();\n            var shouldKeepWarning = validateHydratableInstance(fiber.type, fiber.pendingProps, currentHostContext);\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance || !tryHydrateInstance(fiber, nextInstance, currentHostContext)) {\n                if (shouldKeepWarning) {\n                    warnNonHydratedInstance(fiber, nextInstance);\n                }\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function tryToClaimNextHydratableTextInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            }\n            var text = fiber.pendingProps;\n            var shouldKeepWarning = true; // Validate that this is ok to render here before any mismatches.\n            var currentHostContext = getHostContext();\n            shouldKeepWarning = validateHydratableTextInstance(text, currentHostContext);\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance || !tryHydrateText(fiber, nextInstance)) {\n                if (shouldKeepWarning) {\n                    warnNonHydratedInstance(fiber, nextInstance);\n                }\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function tryToClaimNextHydratableSuspenseInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            }\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance || !tryHydrateSuspense(fiber, nextInstance)) {\n                warnNonHydratedInstance(fiber, nextInstance);\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function tryToClaimNextHydratableFormMarkerInstance(fiber) {\n            if (!isHydrating) {\n                return false;\n            }\n            if (nextHydratableInstance) {\n                var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);\n                if (markerInstance) {\n                    // Found the marker instance.\n                    nextHydratableInstance = getNextHydratableSibling(markerInstance); // Return true if this marker instance should use the state passed\n                    // to hydrateRoot.\n                    // TODO: As an optimization, Fizz should only emit these markers if form\n                    // state is passed at the root.\n                    return isFormStateMarkerMatching(markerInstance);\n                }\n            } // Should have found a marker instance. Throw an error to trigger client\n            // rendering. We don't bother to check if we're in a concurrent root because\n            // useActionState is a new API, so backwards compat is not an issue.\n            throwOnHydrationMismatch(fiber);\n            return false;\n        }\n        function prepareToHydrateHostInstance(fiber, hostContext) {\n            if (!supportsHydration) {\n                throw new Error('Expected prepareToHydrateHostInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var instance = fiber.stateNode;\n            var didHydrate = hydrateInstance(instance, fiber.type, fiber.memoizedProps, hostContext, fiber);\n            if (!didHydrate && favorSafetyOverHydrationPerf) {\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function prepareToHydrateHostTextInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error('Expected prepareToHydrateHostTextInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var textInstance = fiber.stateNode;\n            var textContent = fiber.memoizedProps;\n            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n            var parentProps = null; // We assume that prepareToHydrateHostTextInstance is called in a context where the\n            // hydration parent is the parent host component of this host text.\n            var returnFiber = hydrationParentFiber;\n            if (returnFiber !== null) {\n                switch(returnFiber.tag){\n                    case HostRoot:\n                        {\n                            {\n                                if (shouldWarnIfMismatchDev) {\n                                    var difference = diffHydratedTextForDevWarnings(textInstance, textContent, parentProps);\n                                    if (difference !== null) {\n                                        var diffNode = buildHydrationDiffNode(fiber, 0);\n                                        diffNode.serverProps = difference;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                    case HostSingleton:\n                    case HostComponent:\n                        {\n                            parentProps = returnFiber.memoizedProps;\n                            {\n                                if (shouldWarnIfMismatchDev) {\n                                    var _difference = diffHydratedTextForDevWarnings(textInstance, textContent, parentProps);\n                                    if (_difference !== null) {\n                                        var _diffNode = buildHydrationDiffNode(fiber, 0);\n                                        _diffNode.serverProps = _difference;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                } // TODO: What if it's a SuspenseInstance?\n            }\n            var didHydrate = hydrateTextInstance(textInstance, textContent, fiber, parentProps);\n            if (!didHydrate && favorSafetyOverHydrationPerf) {\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function prepareToHydrateHostSuspenseInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error('Expected prepareToHydrateHostSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var suspenseState = fiber.memoizedState;\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n            if (!suspenseInstance) {\n                throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            hydrateSuspenseInstance(suspenseInstance, fiber);\n        }\n        function skipPastDehydratedSuspenseInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error('Expected skipPastDehydratedSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var suspenseState = fiber.memoizedState;\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n            if (!suspenseInstance) {\n                throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n        }\n        function popToNextHostParent(fiber) {\n            hydrationParentFiber = fiber.return;\n            while(hydrationParentFiber){\n                switch(hydrationParentFiber.tag){\n                    case HostRoot:\n                    case HostSingleton:\n                        rootOrSingletonContext = true;\n                        return;\n                    case HostComponent:\n                    case SuspenseComponent:\n                        rootOrSingletonContext = false;\n                        return;\n                    default:\n                        hydrationParentFiber = hydrationParentFiber.return;\n                }\n            }\n        }\n        function popHydrationState(fiber) {\n            if (!supportsHydration) {\n                return false;\n            }\n            if (fiber !== hydrationParentFiber) {\n                // We're deeper than the current hydration context, inside an inserted\n                // tree.\n                return false;\n            }\n            if (!isHydrating) {\n                // If we're not currently hydrating but we're in a hydration context, then\n                // we were an insertion and now need to pop up reenter hydration of our\n                // siblings.\n                popToNextHostParent(fiber);\n                isHydrating = true;\n                return false;\n            }\n            var shouldClear = false;\n            if (supportsSingletons) {\n                // With float we never clear the Root, or Singleton instances. We also do not clear Instances\n                // that have singleton text content\n                if (fiber.tag !== HostRoot && fiber.tag !== HostSingleton && !(fiber.tag === HostComponent && (!shouldDeleteUnhydratedTailInstances(fiber.type) || shouldSetTextContent(fiber.type, fiber.memoizedProps)))) {\n                    shouldClear = true;\n                }\n            } else {\n                // If we have any remaining hydratable nodes, we need to delete them now.\n                // We only do this deeper than head and body since they tend to have random\n                // other nodes in them. We also ignore components with pure text content in\n                // side of them. We also don't delete anything inside the root container.\n                if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n                    shouldClear = true;\n                }\n            }\n            if (shouldClear) {\n                var nextInstance = nextHydratableInstance;\n                if (nextInstance) {\n                    warnIfUnhydratedTailNodes(fiber);\n                    throwOnHydrationMismatch(fiber);\n                }\n            }\n            popToNextHostParent(fiber);\n            if (fiber.tag === SuspenseComponent) {\n                nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n            } else {\n                nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n            }\n            return true;\n        }\n        function warnIfUnhydratedTailNodes(fiber) {\n            {\n                var nextInstance = nextHydratableInstance;\n                while(nextInstance){\n                    var diffNode = buildHydrationDiffNode(fiber, 0);\n                    var description = describeHydratableInstanceForDevWarnings(nextInstance);\n                    diffNode.serverTail.push(description);\n                    if (description.type === 'Suspense') {\n                        var suspenseInstance = nextInstance;\n                        nextInstance = getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n                    } else {\n                        nextInstance = getNextHydratableSibling(nextInstance);\n                    }\n                }\n            }\n        }\n        function resetHydrationState() {\n            if (!supportsHydration) {\n                return;\n            }\n            hydrationParentFiber = null;\n            nextHydratableInstance = null;\n            isHydrating = false;\n            didSuspendOrErrorDEV = false;\n        }\n        function upgradeHydrationErrorsToRecoverable() {\n            if (hydrationErrors !== null) {\n                // Successfully completed a forced client render. The errors that occurred\n                // during the hydration attempt are now recovered. We will log them in\n                // commit phase, once the entire tree has finished.\n                queueRecoverableErrors(hydrationErrors);\n                hydrationErrors = null;\n            }\n        }\n        function getIsHydrating() {\n            return isHydrating;\n        }\n        function queueHydrationError(error) {\n            if (hydrationErrors === null) {\n                hydrationErrors = [\n                    error\n                ];\n            } else {\n                hydrationErrors.push(error);\n            }\n        }\n        function emitPendingHydrationWarnings() {\n            {\n                // If we haven't yet thrown any hydration errors by the time we reach the end we've successfully\n                // hydrated, however, we might still have DEV-only mismatches that we log now.\n                var diffRoot = hydrationDiffRootDEV;\n                if (diffRoot !== null) {\n                    hydrationDiffRootDEV = null;\n                    var diff = describeDiff(diffRoot);\n                    error(\"A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. \" + 'This can happen if a SSR-ed Client Component used:\\n' + '\\n' + \"- A server/client branch `if (typeof window !== 'undefined')`.\\n\" + \"- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n\" + \"- Date formatting in a user's locale which doesn't match the server.\\n\" + '- External changing data without sending a snapshot of it along with the HTML.\\n' + '- Invalid HTML tag nesting.\\n' + '\\n' + 'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n' + '\\n' + '%s%s', 'https://react.dev/link/hydration-mismatch', diff);\n                }\n            }\n        }\n        // we wait until the current render is over (either finished or interrupted)\n        // before adding it to the fiber/hook queue. Push to this array so we can\n        // access the queue, fiber, update, et al later.\n        var concurrentQueues = [];\n        var concurrentQueuesIndex = 0;\n        var concurrentlyUpdatedLanes = NoLanes;\n        function finishQueueingConcurrentUpdates() {\n            var endIndex = concurrentQueuesIndex;\n            concurrentQueuesIndex = 0;\n            concurrentlyUpdatedLanes = NoLanes;\n            var i = 0;\n            while(i < endIndex){\n                var fiber = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                var queue = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                var update = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                var lane = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                if (queue !== null && update !== null) {\n                    var pending = queue.pending;\n                    if (pending === null) {\n                        // This is the first update. Create a circular list.\n                        update.next = update;\n                    } else {\n                        update.next = pending.next;\n                        pending.next = update;\n                    }\n                    queue.pending = update;\n                }\n                if (lane !== NoLane) {\n                    markUpdateLaneFromFiberToRoot(fiber, update, lane);\n                }\n            }\n        }\n        function getConcurrentlyUpdatedLanes() {\n            return concurrentlyUpdatedLanes;\n        }\n        function enqueueUpdate$1(fiber, queue, update, lane) {\n            // Don't update the `childLanes` on the return path yet. If we already in\n            // the middle of rendering, wait until after it has completed.\n            concurrentQueues[concurrentQueuesIndex++] = fiber;\n            concurrentQueues[concurrentQueuesIndex++] = queue;\n            concurrentQueues[concurrentQueuesIndex++] = update;\n            concurrentQueues[concurrentQueuesIndex++] = lane;\n            concurrentlyUpdatedLanes = mergeLanes(concurrentlyUpdatedLanes, lane); // The fiber's `lane` field is used in some places to check if any work is\n            // scheduled, to perform an eager bailout, so we need to update it immediately.\n            // TODO: We should probably move this to the \"shared\" queue instead.\n            fiber.lanes = mergeLanes(fiber.lanes, lane);\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, lane);\n            }\n        }\n        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n            var concurrentQueue = queue;\n            var concurrentUpdate = update;\n            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane);\n            return getRootForUpdatedFiber(fiber);\n        }\n        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update) {\n            // This function is used to queue an update that doesn't need a rerender. The\n            // only reason we queue it is in case there's a subsequent higher priority\n            // update that causes it to be rebased.\n            var lane = NoLane;\n            var concurrentQueue = queue;\n            var concurrentUpdate = update;\n            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane); // Usually we can rely on the upcoming render phase to process the concurrent\n            // queue. However, since this is a bail out, we're not scheduling any work\n            // here. So the update we just queued will leak until something else happens\n            // to schedule work (if ever).\n            //\n            // Check if we're currently in the middle of rendering a tree, and if not,\n            // process the queue immediately to prevent a leak.\n            var isConcurrentlyRendering = getWorkInProgressRoot() !== null;\n            if (!isConcurrentlyRendering) {\n                finishQueueingConcurrentUpdates();\n            }\n        }\n        function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {\n            var concurrentQueue = queue;\n            var concurrentUpdate = update;\n            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane);\n            return getRootForUpdatedFiber(fiber);\n        }\n        function enqueueConcurrentRenderForLane(fiber, lane) {\n            enqueueUpdate$1(fiber, null, null, lane);\n            return getRootForUpdatedFiber(fiber);\n        } // Calling this function outside this module should only be done for backwards\n        // compatibility and should always be accompanied by a warning.\n        function unsafe_markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n            // NOTE: For Hyrum's Law reasons, if an infinite update loop is detected, it\n            // should throw before `markUpdateLaneFromFiberToRoot` is called. But this is\n            // undefined behavior and we can change it if we need to; it just so happens\n            // that, at the time of this writing, there's an internal product test that\n            // happens to rely on this.\n            var root = getRootForUpdatedFiber(sourceFiber);\n            markUpdateLaneFromFiberToRoot(sourceFiber, null, lane);\n            return root;\n        }\n        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n            // Update the source fiber's lanes\n            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n            var alternate = sourceFiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, lane);\n            } // Walk the parent path to the root and update the child lanes.\n            var isHidden = false;\n            var parent = sourceFiber.return;\n            var node = sourceFiber;\n            while(parent !== null){\n                parent.childLanes = mergeLanes(parent.childLanes, lane);\n                alternate = parent.alternate;\n                if (alternate !== null) {\n                    alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n                }\n                if (parent.tag === OffscreenComponent) {\n                    // Check if this offscreen boundary is currently hidden.\n                    //\n                    // The instance may be null if the Offscreen parent was unmounted. Usually\n                    // the parent wouldn't be reachable in that case because we disconnect\n                    // fibers from the tree when they are deleted. However, there's a weird\n                    // edge case where setState is called on a fiber that was interrupted\n                    // before it ever mounted. Because it never mounts, it also never gets\n                    // deleted. Because it never gets deleted, its return pointer never gets\n                    // disconnected. Which means it may be attached to a deleted Offscreen\n                    // parent node. (This discovery suggests it may be better for memory usage\n                    // if we don't attach the `return` pointer until the commit phase, though\n                    // in order to do that we'd need some other way to track the return\n                    // pointer during the initial render, like on the stack.)\n                    //\n                    // This case is always accompanied by a warning, but we still need to\n                    // account for it. (There may be other cases that we haven't discovered,\n                    // too.)\n                    var offscreenInstance = parent.stateNode;\n                    if (offscreenInstance !== null && !(offscreenInstance._visibility & OffscreenVisible)) {\n                        isHidden = true;\n                    }\n                }\n                node = parent;\n                parent = parent.return;\n            }\n            if (isHidden && update !== null && node.tag === HostRoot) {\n                var root = node.stateNode;\n                markHiddenUpdate(root, update, lane);\n            }\n        }\n        function getRootForUpdatedFiber(sourceFiber) {\n            // TODO: We will detect and infinite update loop and throw even if this fiber\n            // has already unmounted. This isn't really necessary but it happens to be the\n            // current behavior we've used for several release cycles. Consider not\n            // performing this check if the updated fiber already unmounted, since it's\n            // not possible for that to cause an infinite update loop.\n            throwIfInfiniteUpdateLoopDetected(); // When a setState happens, we must ensure the root is scheduled. Because\n            // update queues do not have a backpointer to the root, the only way to do\n            // this currently is to walk up the return path. This used to not be a big\n            // deal because we would have to walk up the return path to set\n            // the `childLanes`, anyway, but now those two traversals happen at\n            // different times.\n            // TODO: Consider adding a `root` backpointer on the update queue.\n            detectUpdateOnUnmountedFiber(sourceFiber, sourceFiber);\n            var node = sourceFiber;\n            var parent = node.return;\n            while(parent !== null){\n                detectUpdateOnUnmountedFiber(sourceFiber, node);\n                node = parent;\n                parent = node.return;\n            }\n            return node.tag === HostRoot ? node.stateNode : null;\n        }\n        function detectUpdateOnUnmountedFiber(sourceFiber, parent) {\n            {\n                var alternate = parent.alternate;\n                if (alternate === null && (parent.flags & (Placement | Hydrating)) !== NoFlags$1) {\n                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n                }\n            }\n        }\n        // there's only a single root, but we do support multi root apps, hence this\n        // extra complexity. But this module is optimized for the single root case.\n        var firstScheduledRoot = null;\n        var lastScheduledRoot = null; // Used to prevent redundant mircotasks from being scheduled.\n        var didScheduleMicrotask = false; // `act` \"microtasks\" are scheduled on the `act` queue instead of an actual\n        // microtask, so we have to dedupe those separately. This wouldn't be an issue\n        // if we required all `act` calls to be awaited, which we might in the future.\n        var didScheduleMicrotask_act = false; // Used to quickly bail out of flushSync if there's no sync work to do.\n        var mightHavePendingSyncWork = false;\n        var isFlushingWork = false;\n        var currentEventTransitionLane = NoLane;\n        function ensureRootIsScheduled(root) {\n            // This function is called whenever a root receives an update. It does two\n            // things 1) it ensures the root is in the root schedule, and 2) it ensures\n            // there's a pending microtask to process the root schedule.\n            //\n            // Most of the actual scheduling logic does not happen until\n            // `scheduleTaskForRootDuringMicrotask` runs.\n            // Add the root to the schedule\n            if (root === lastScheduledRoot || root.next !== null) ;\n            else {\n                if (lastScheduledRoot === null) {\n                    firstScheduledRoot = lastScheduledRoot = root;\n                } else {\n                    lastScheduledRoot.next = root;\n                    lastScheduledRoot = root;\n                }\n            } // Any time a root received an update, we set this to true until the next time\n            // we process the schedule. If it's false, then we can quickly exit flushSync\n            // without consulting the schedule.\n            mightHavePendingSyncWork = true; // At the end of the current event, go through each of the roots and ensure\n            // there's a task scheduled for each one at the correct priority.\n            if (ReactSharedInternals.actQueue !== null) {\n                // We're inside an `act` scope.\n                if (!didScheduleMicrotask_act) {\n                    didScheduleMicrotask_act = true;\n                    scheduleImmediateTask(processRootScheduleInMicrotask);\n                }\n            } else {\n                if (!didScheduleMicrotask) {\n                    didScheduleMicrotask = true;\n                    scheduleImmediateTask(processRootScheduleInMicrotask);\n                }\n            }\n        }\n        function flushSyncWorkOnAllRoots() {\n            // This is allowed to be called synchronously, but the caller should check\n            // the execution context first.\n            flushSyncWorkAcrossRoots_impl(false);\n        }\n        function flushSyncWorkAcrossRoots_impl(onlyLegacy) {\n            if (isFlushingWork) {\n                // Prevent reentrancy.\n                // TODO: Is this overly defensive? The callers must check the execution\n                // context first regardless.\n                return;\n            }\n            if (!mightHavePendingSyncWork) {\n                // Fast path. There's no sync work to do.\n                return;\n            } // There may or may not be synchronous work scheduled. Let's check.\n            var didPerformSomeWork;\n            isFlushingWork = true;\n            do {\n                didPerformSomeWork = false;\n                var root = firstScheduledRoot;\n                while(root !== null){\n                    if (onlyLegacy && disableLegacyMode) ;\n                    else {\n                        var workInProgressRoot = getWorkInProgressRoot();\n                        var workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();\n                        var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n                        if (includesSyncLane(nextLanes)) {\n                            // This root has pending sync work. Flush it now.\n                            didPerformSomeWork = true;\n                            performSyncWorkOnRoot(root, nextLanes);\n                        }\n                    }\n                    root = root.next;\n                }\n            }while (didPerformSomeWork);\n            isFlushingWork = false;\n        }\n        function processRootScheduleInMicrotask() {\n            // This function is always called inside a microtask. It should never be\n            // called synchronously.\n            didScheduleMicrotask = false;\n            {\n                didScheduleMicrotask_act = false;\n            }\n            mightHavePendingSyncWork = false;\n            var currentTime = now$1();\n            var prev = null;\n            var root = firstScheduledRoot;\n            while(root !== null){\n                var next = root.next;\n                if (currentEventTransitionLane !== NoLane && shouldAttemptEagerTransition()) {\n                    // A transition was scheduled during an event, but we're going to try to\n                    // render it synchronously anyway. We do this during a popstate event to\n                    // preserve the scroll position of the previous page.\n                    upgradePendingLaneToSync(root, currentEventTransitionLane);\n                }\n                var nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n                if (nextLanes === NoLane) {\n                    // This root has no more pending work. Remove it from the schedule. To\n                    // guard against subtle reentrancy bugs, this microtask is the only place\n                    // we do this — you can add roots to the schedule whenever, but you can\n                    // only remove them here.\n                    // Null this out so we know it's been removed from the schedule.\n                    root.next = null;\n                    if (prev === null) {\n                        // This is the new head of the list\n                        firstScheduledRoot = next;\n                    } else {\n                        prev.next = next;\n                    }\n                    if (next === null) {\n                        // This is the new tail of the list\n                        lastScheduledRoot = prev;\n                    }\n                } else {\n                    // This root still has work. Keep it in the list.\n                    prev = root;\n                    if (includesSyncLane(nextLanes)) {\n                        mightHavePendingSyncWork = true;\n                    }\n                }\n                root = next;\n            }\n            currentEventTransitionLane = NoLane; // At the end of the microtask, flush any pending synchronous work. This has\n            // to come at the end, because it does actual rendering work that might throw.\n            flushSyncWorkOnAllRoots();\n        }\n        function scheduleTaskForRootDuringMicrotask(root, currentTime) {\n            // This function is always called inside a microtask, or at the very end of a\n            // rendering task right before we yield to the main thread. It should never be\n            // called synchronously.\n            //\n            // TODO: Unless enableDeferRootSchedulingToMicrotask is off. We need to land\n            // that ASAP to unblock additional features we have planned.\n            //\n            // This function also never performs React work synchronously; it should\n            // only schedule work to be performed later, in a separate task or microtask.\n            // Check if any lanes are being starved by other work. If so, mark them as\n            // expired so we know to work on those next.\n            markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\n            var workInProgressRoot = getWorkInProgressRoot();\n            var workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();\n            var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n            var existingCallbackNode = root.callbackNode;\n            if (nextLanes === NoLanes || // If this root is currently suspended and waiting for data to resolve, don't\n            // schedule a task to render it. We'll either wait for a ping, or wait to\n            // receive an update.\n            //\n            // Suspended render phase\n            root === workInProgressRoot && isWorkLoopSuspendedOnData() || // Suspended commit phase\n            root.cancelPendingCommit !== null) {\n                // Fast path: There's nothing to work on.\n                if (existingCallbackNode !== null) {\n                    cancelCallback(existingCallbackNode);\n                }\n                root.callbackNode = null;\n                root.callbackPriority = NoLane;\n                return NoLane;\n            } // Schedule a new callback in the host environment.\n            if (includesSyncLane(nextLanes)) {\n                // Synchronous work is always flushed at the end of the microtask, so we\n                // don't need to schedule an additional task.\n                if (existingCallbackNode !== null) {\n                    cancelCallback(existingCallbackNode);\n                }\n                root.callbackPriority = SyncLane;\n                root.callbackNode = null;\n                return SyncLane;\n            } else {\n                // We use the highest priority lane to represent the priority of the callback.\n                var existingCallbackPriority = root.callbackPriority;\n                var newCallbackPriority = getHighestPriorityLane(nextLanes);\n                if (newCallbackPriority === existingCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n                // Scheduler task, rather than an `act` task, cancel it and re-schedule\n                // on the `act` queue.\n                !(ReactSharedInternals.actQueue !== null && existingCallbackNode !== fakeActCallbackNode$1)) {\n                    // The priority hasn't changed. We can reuse the existing task.\n                    return newCallbackPriority;\n                } else {\n                    // Cancel the existing callback. We'll schedule a new one below.\n                    cancelCallback(existingCallbackNode);\n                }\n                var schedulerPriorityLevel;\n                switch(lanesToEventPriority(nextLanes)){\n                    case DiscreteEventPriority:\n                        schedulerPriorityLevel = ImmediatePriority;\n                        break;\n                    case ContinuousEventPriority:\n                        schedulerPriorityLevel = UserBlockingPriority;\n                        break;\n                    case DefaultEventPriority:\n                        schedulerPriorityLevel = NormalPriority$1;\n                        break;\n                    case IdleEventPriority:\n                        schedulerPriorityLevel = IdlePriority;\n                        break;\n                    default:\n                        schedulerPriorityLevel = NormalPriority$1;\n                        break;\n                }\n                var newCallbackNode = scheduleCallback$2(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n                root.callbackPriority = newCallbackPriority;\n                root.callbackNode = newCallbackNode;\n                return newCallbackPriority;\n            }\n        }\n        function getContinuationForRoot(root, originalCallbackNode) {\n            // This is called at the end of `performConcurrentWorkOnRoot` to determine\n            // if we need to schedule a continuation task.\n            //\n            // Usually `scheduleTaskForRootDuringMicrotask` only runs inside a microtask;\n            // however, since most of the logic for determining if we need a continuation\n            // versus a new task is the same, we cheat a bit and call it here. This is\n            // only safe to do because we know we're at the end of the browser task.\n            // So although it's not an actual microtask, it might as well be.\n            scheduleTaskForRootDuringMicrotask(root, now$1());\n            if (root.callbackNode === originalCallbackNode) {\n                // The task node scheduled for this root is the same one that's\n                // currently executed. Need to return a continuation.\n                return performConcurrentWorkOnRoot.bind(null, root);\n            }\n            return null;\n        }\n        var fakeActCallbackNode$1 = {};\n        function scheduleCallback$2(priorityLevel, callback) {\n            if (ReactSharedInternals.actQueue !== null) {\n                // Special case: We're inside an `act` scope (a testing utility).\n                // Instead of scheduling work in the host environment, add it to a\n                // fake internal queue that's managed by the `act` implementation.\n                ReactSharedInternals.actQueue.push(callback);\n                return fakeActCallbackNode$1;\n            } else {\n                return scheduleCallback$3(priorityLevel, callback);\n            }\n        }\n        function cancelCallback(callbackNode) {\n            if (callbackNode === fakeActCallbackNode$1) ;\n            else if (callbackNode !== null) {\n                cancelCallback$1(callbackNode);\n            }\n        }\n        function scheduleImmediateTask(cb) {\n            if (ReactSharedInternals.actQueue !== null) {\n                // Special case: Inside an `act` scope, we push microtasks to the fake `act`\n                // callback queue. This is because we currently support calling `act`\n                // without awaiting the result. The plan is to deprecate that, and require\n                // that you always await the result so that the microtasks have a chance to\n                // run. But it hasn't happened yet.\n                ReactSharedInternals.actQueue.push(function() {\n                    cb();\n                    return null;\n                });\n            } // TODO: Can we land supportsMicrotasks? Which environments don't support it?\n            // Alternatively, can we move this check to the host config?\n            if (supportsMicrotasks) {\n                scheduleMicrotask(function() {\n                    // In Safari, appending an iframe forces microtasks to run.\n                    // https://github.com/facebook/react/issues/22459\n                    // We don't support running callbacks in the middle of render\n                    // or commit so we need to check against that.\n                    var executionContext = getExecutionContext();\n                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                        // Note that this would still prematurely flush the callbacks\n                        // if this happens outside render or commit phase (e.g. in an event).\n                        // Intentionally using a macrotask instead of a microtask here. This is\n                        // wrong semantically but it prevents an infinite loop. The bug is\n                        // Safari's, not ours, so we just do our best to not crash even though\n                        // the behavior isn't completely correct.\n                        scheduleCallback$3(ImmediatePriority, cb);\n                        return;\n                    }\n                    cb();\n                });\n            } else {\n                // If microtasks are not supported, use Scheduler.\n                scheduleCallback$3(ImmediatePriority, cb);\n            }\n        }\n        function requestTransitionLane(// check that it's inside a transition before calling this function.\n        // TODO: Make this non-nullable. Requires a tweak to useOptimistic.\n        transition) {\n            // The algorithm for assigning an update to a lane should be stable for all\n            // updates at the same priority within the same event. To do this, the\n            // inputs to the algorithm must be the same.\n            //\n            // The trick we use is to cache the first of each of these inputs within an\n            // event. Then reset the cached values once we can be sure the event is\n            // over. Our heuristic for that is whenever we enter a concurrent work loop.\n            if (currentEventTransitionLane === NoLane) {\n                // All transitions within the same event are assigned the same lane.\n                currentEventTransitionLane = claimNextTransitionLane();\n            }\n            return currentEventTransitionLane;\n        }\n        // transition updates that occur while the async action is still in progress\n        // are treated as part of the action.\n        //\n        // The ideal behavior would be to treat each async function as an independent\n        // action. However, without a mechanism like AsyncContext, we can't tell which\n        // action an update corresponds to. So instead, we entangle them all into one.\n        // The listeners to notify once the entangled scope completes.\n        var currentEntangledListeners = null; // The number of pending async actions in the entangled scope.\n        var currentEntangledPendingCount = 0; // The transition lane shared by all updates in the entangled scope.\n        var currentEntangledLane = NoLane; // A thenable that resolves when the entangled scope completes. It does not\n        // resolve to a particular value because it's only used for suspending the UI\n        // until the async action scope has completed.\n        var currentEntangledActionThenable = null;\n        function entangleAsyncAction(transition, thenable) {\n            // `thenable` is the return value of the async action scope function. Create\n            // a combined thenable that resolves once every entangled scope function\n            // has finished.\n            if (currentEntangledListeners === null) {\n                // There's no outer async action scope. Create a new one.\n                var entangledListeners = currentEntangledListeners = [];\n                currentEntangledPendingCount = 0;\n                currentEntangledLane = requestTransitionLane();\n                var entangledThenable = {\n                    status: 'pending',\n                    value: undefined,\n                    then: function(resolve) {\n                        entangledListeners.push(resolve);\n                    }\n                };\n                currentEntangledActionThenable = entangledThenable;\n            }\n            currentEntangledPendingCount++;\n            thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n            return thenable;\n        }\n        function pingEngtangledActionScope() {\n            if (currentEntangledListeners !== null && --currentEntangledPendingCount === 0) {\n                // All the actions have finished. Close the entangled async action scope\n                // and notify all the listeners.\n                if (currentEntangledActionThenable !== null) {\n                    var fulfilledThenable = currentEntangledActionThenable;\n                    fulfilledThenable.status = 'fulfilled';\n                }\n                var listeners = currentEntangledListeners;\n                currentEntangledListeners = null;\n                currentEntangledLane = NoLane;\n                currentEntangledActionThenable = null;\n                for(var i = 0; i < listeners.length; i++){\n                    var listener = listeners[i];\n                    listener();\n                }\n            }\n        }\n        function chainThenableValue(thenable, result) {\n            // Equivalent to: Promise.resolve(thenable).then(() => result), except we can\n            // cheat a bit since we know that that this thenable is only ever consumed\n            // by React.\n            //\n            // We don't technically require promise support on the client yet, hence this\n            // extra code.\n            var listeners = [];\n            var thenableWithOverride = {\n                status: 'pending',\n                value: null,\n                reason: null,\n                then: function(resolve) {\n                    listeners.push(resolve);\n                }\n            };\n            thenable.then(function(value) {\n                var fulfilledThenable = thenableWithOverride;\n                fulfilledThenable.status = 'fulfilled';\n                fulfilledThenable.value = result;\n                for(var i = 0; i < listeners.length; i++){\n                    var listener = listeners[i];\n                    listener(result);\n                }\n            }, function(error) {\n                var rejectedThenable = thenableWithOverride;\n                rejectedThenable.status = 'rejected';\n                rejectedThenable.reason = error;\n                for(var i = 0; i < listeners.length; i++){\n                    var listener = listeners[i]; // This is a perf hack where we call the `onFulfill` ping function\n                    // instead of `onReject`, because we know that React is the only\n                    // consumer of these promises, and it passes the same listener to both.\n                    // We also know that it will read the error directly off the\n                    // `.reason` field.\n                    listener(undefined);\n                }\n            });\n            return thenableWithOverride;\n        }\n        function peekEntangledActionLane() {\n            return currentEntangledLane;\n        }\n        function peekEntangledActionThenable() {\n            return currentEntangledActionThenable;\n        }\n        var UpdateState = 0;\n        var ReplaceState = 1;\n        var ForceUpdate = 2;\n        var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n        // It should only be read right after calling `processUpdateQueue`, via\n        // `checkHasForceUpdateAfterProcessing`.\n        var hasForceUpdate = false;\n        var didWarnUpdateInsideUpdate;\n        var currentlyProcessingQueue;\n        {\n            didWarnUpdateInsideUpdate = false;\n            currentlyProcessingQueue = null;\n        }\n        function initializeUpdateQueue(fiber) {\n            var queue = {\n                baseState: fiber.memoizedState,\n                firstBaseUpdate: null,\n                lastBaseUpdate: null,\n                shared: {\n                    pending: null,\n                    lanes: NoLanes,\n                    hiddenCallbacks: null\n                },\n                callbacks: null\n            };\n            fiber.updateQueue = queue;\n        }\n        function cloneUpdateQueue(current, workInProgress) {\n            // Clone the update queue from current. Unless it's already a clone.\n            var queue = workInProgress.updateQueue;\n            var currentQueue = current.updateQueue;\n            if (queue === currentQueue) {\n                var clone = {\n                    baseState: currentQueue.baseState,\n                    firstBaseUpdate: currentQueue.firstBaseUpdate,\n                    lastBaseUpdate: currentQueue.lastBaseUpdate,\n                    shared: currentQueue.shared,\n                    callbacks: null\n                };\n                workInProgress.updateQueue = clone;\n            }\n        }\n        function createUpdate(lane) {\n            var update = {\n                lane: lane,\n                tag: UpdateState,\n                payload: null,\n                callback: null,\n                next: null\n            };\n            return update;\n        }\n        function enqueueUpdate(fiber, update, lane) {\n            var updateQueue = fiber.updateQueue;\n            if (updateQueue === null) {\n                // Only occurs if the fiber has been unmounted.\n                return null;\n            }\n            var sharedQueue = updateQueue.shared;\n            {\n                if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n                    var componentName = getComponentNameFromFiber(fiber);\n                    error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.\\n\\nPlease update the following component: %s', componentName);\n                    didWarnUpdateInsideUpdate = true;\n                }\n            }\n            if (isUnsafeClassRenderPhaseUpdate()) {\n                // This is an unsafe render phase update. Add directly to the update\n                // queue so we can process it immediately during the current render.\n                var pending = sharedQueue.pending;\n                if (pending === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update;\n                } else {\n                    update.next = pending.next;\n                    pending.next = update;\n                }\n                sharedQueue.pending = update; // Update the childLanes even though we're most likely already rendering\n                // this fiber. This is for backwards compatibility in the case where you\n                // update a different component during render phase than the one that is\n                // currently renderings (a pattern that is accompanied by a warning).\n                return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);\n            } else {\n                return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);\n            }\n        }\n        function entangleTransitions(root, fiber, lane) {\n            var updateQueue = fiber.updateQueue;\n            if (updateQueue === null) {\n                // Only occurs if the fiber has been unmounted.\n                return;\n            }\n            var sharedQueue = updateQueue.shared;\n            if (isTransitionLane(lane)) {\n                var queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must\n                // have finished. We can remove them from the shared queue, which represents\n                // a superset of the actually pending lanes. In some cases we may entangle\n                // more than we need to, but that's OK. In fact it's worse if we *don't*\n                // entangle when we should.\n                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n                var newQueueLanes = mergeLanes(queueLanes, lane);\n                sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n                // the lane finished since the last time we entangled it. So we need to\n                // entangle it again, just to be sure.\n                markRootEntangled(root, newQueueLanes);\n            }\n        }\n        function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n            // Captured updates are updates that are thrown by a child during the render\n            // phase. They should be discarded if the render is aborted. Therefore,\n            // we should only put them on the work-in-progress queue, not the current one.\n            var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\n            var current = workInProgress.alternate;\n            if (current !== null) {\n                var currentQueue = current.updateQueue;\n                if (queue === currentQueue) {\n                    // The work-in-progress queue is the same as current. This happens when\n                    // we bail out on a parent fiber that then captures an error thrown by\n                    // a child. Since we want to append the update only to the work-in\n                    // -progress queue, we need to clone the updates. We usually clone during\n                    // processUpdateQueue, but that didn't happen in this case because we\n                    // skipped over the parent when we bailed out.\n                    var newFirst = null;\n                    var newLast = null;\n                    var firstBaseUpdate = queue.firstBaseUpdate;\n                    if (firstBaseUpdate !== null) {\n                        // Loop through the updates and clone them.\n                        var update = firstBaseUpdate;\n                        do {\n                            var clone = {\n                                lane: update.lane,\n                                tag: update.tag,\n                                payload: update.payload,\n                                // When this update is rebased, we should not fire its\n                                // callback again.\n                                callback: null,\n                                next: null\n                            };\n                            if (newLast === null) {\n                                newFirst = newLast = clone;\n                            } else {\n                                newLast.next = clone;\n                                newLast = clone;\n                            } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                            update = update.next;\n                        }while (update !== null); // Append the captured update the end of the cloned list.\n                        if (newLast === null) {\n                            newFirst = newLast = capturedUpdate;\n                        } else {\n                            newLast.next = capturedUpdate;\n                            newLast = capturedUpdate;\n                        }\n                    } else {\n                        // There are no base updates.\n                        newFirst = newLast = capturedUpdate;\n                    }\n                    queue = {\n                        baseState: currentQueue.baseState,\n                        firstBaseUpdate: newFirst,\n                        lastBaseUpdate: newLast,\n                        shared: currentQueue.shared,\n                        callbacks: currentQueue.callbacks\n                    };\n                    workInProgress.updateQueue = queue;\n                    return;\n                }\n            } // Append the update to the end of the list.\n            var lastBaseUpdate = queue.lastBaseUpdate;\n            if (lastBaseUpdate === null) {\n                queue.firstBaseUpdate = capturedUpdate;\n            } else {\n                lastBaseUpdate.next = capturedUpdate;\n            }\n            queue.lastBaseUpdate = capturedUpdate;\n        }\n        function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n            switch(update.tag){\n                case ReplaceState:\n                    {\n                        var payload = update.payload;\n                        if (typeof payload === 'function') {\n                            // Updater function\n                            {\n                                enterDisallowedContextReadInDEV();\n                            }\n                            var nextState = payload.call(instance, prevState, nextProps);\n                            {\n                                if (workInProgress.mode & StrictLegacyMode) {\n                                    setIsStrictModeForDevtools(true);\n                                    try {\n                                        payload.call(instance, prevState, nextProps);\n                                    } finally{\n                                        setIsStrictModeForDevtools(false);\n                                    }\n                                }\n                                exitDisallowedContextReadInDEV();\n                            }\n                            return nextState;\n                        } // State object\n                        return payload;\n                    }\n                case CaptureUpdate:\n                    {\n                        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\n                    }\n                // Intentional fallthrough\n                case UpdateState:\n                    {\n                        var _payload = update.payload;\n                        var partialState;\n                        if (typeof _payload === 'function') {\n                            // Updater function\n                            {\n                                enterDisallowedContextReadInDEV();\n                            }\n                            partialState = _payload.call(instance, prevState, nextProps);\n                            {\n                                if (workInProgress.mode & StrictLegacyMode) {\n                                    setIsStrictModeForDevtools(true);\n                                    try {\n                                        _payload.call(instance, prevState, nextProps);\n                                    } finally{\n                                        setIsStrictModeForDevtools(false);\n                                    }\n                                }\n                                exitDisallowedContextReadInDEV();\n                            }\n                        } else {\n                            // Partial state object\n                            partialState = _payload;\n                        }\n                        if (partialState === null || partialState === undefined) {\n                            // Null and undefined are treated as no-ops.\n                            return prevState;\n                        } // Merge the partial state and the previous state.\n                        return assign({}, prevState, partialState);\n                    }\n                case ForceUpdate:\n                    {\n                        hasForceUpdate = true;\n                        return prevState;\n                    }\n            }\n            return prevState;\n        }\n        var didReadFromEntangledAsyncAction = false; // Each call to processUpdateQueue should be accompanied by a call to this. It's\n        // only in a separate function because in updateHostRoot, it must happen after\n        // all the context stacks have been pushed to, to prevent a stack mismatch. A\n        // bit unfortunate.\n        function suspendIfUpdateReadFromEntangledAsyncAction() {\n            // Check if this update is part of a pending async action. If so, we'll\n            // need to suspend until the action has finished, so that it's batched\n            // together with future updates in the same action.\n            // TODO: Once we support hooks inside useMemo (or an equivalent\n            // memoization boundary like Forget), hoist this logic so that it only\n            // suspends if the memo boundary produces a new value.\n            if (didReadFromEntangledAsyncAction) {\n                var entangledActionThenable = peekEntangledActionThenable();\n                if (entangledActionThenable !== null) {\n                    // TODO: Instead of the throwing the thenable directly, throw a\n                    // special object like `use` does so we can detect if it's captured\n                    // by userspace.\n                    throw entangledActionThenable;\n                }\n            }\n        }\n        function processUpdateQueue(workInProgress, props, instance, renderLanes) {\n            didReadFromEntangledAsyncAction = false; // This is always non-null on a ClassComponent or HostRoot\n            var queue = workInProgress.updateQueue;\n            hasForceUpdate = false;\n            {\n                currentlyProcessingQueue = queue.shared;\n            }\n            var firstBaseUpdate = queue.firstBaseUpdate;\n            var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\n            var pendingQueue = queue.shared.pending;\n            if (pendingQueue !== null) {\n                queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\n                // and last so that it's non-circular.\n                var lastPendingUpdate = pendingQueue;\n                var firstPendingUpdate = lastPendingUpdate.next;\n                lastPendingUpdate.next = null; // Append pending updates to base queue\n                if (lastBaseUpdate === null) {\n                    firstBaseUpdate = firstPendingUpdate;\n                } else {\n                    lastBaseUpdate.next = firstPendingUpdate;\n                }\n                lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\n                // we need to transfer the updates to that queue, too. Because the base\n                // queue is a singly-linked list with no cycles, we can append to both\n                // lists and take advantage of structural sharing.\n                // TODO: Pass `current` as argument\n                var current = workInProgress.alternate;\n                if (current !== null) {\n                    // This is always non-null on a ClassComponent or HostRoot\n                    var currentQueue = current.updateQueue;\n                    var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n                    if (currentLastBaseUpdate !== lastBaseUpdate) {\n                        if (currentLastBaseUpdate === null) {\n                            currentQueue.firstBaseUpdate = firstPendingUpdate;\n                        } else {\n                            currentLastBaseUpdate.next = firstPendingUpdate;\n                        }\n                        currentQueue.lastBaseUpdate = lastPendingUpdate;\n                    }\n                }\n            } // These values may change as we process the queue.\n            if (firstBaseUpdate !== null) {\n                // Iterate through the list of updates to compute the result.\n                var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n                // from the original lanes.\n                var newLanes = NoLanes;\n                var newBaseState = null;\n                var newFirstBaseUpdate = null;\n                var newLastBaseUpdate = null;\n                var update = firstBaseUpdate;\n                do {\n                    // An extra OffscreenLane bit is added to updates that were made to\n                    // a hidden tree, so that we can distinguish them from updates that were\n                    // already there when the tree was hidden.\n                    var updateLane = removeLanes(update.lane, OffscreenLane);\n                    var isHiddenUpdate = updateLane !== update.lane; // Check if this update was made while the tree was hidden. If so, then\n                    // it's not a \"base\" update and we should disregard the extra base lanes\n                    // that were added to renderLanes when we entered the Offscreen tree.\n                    var shouldSkipUpdate = isHiddenUpdate ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane) : !isSubsetOfLanes(renderLanes, updateLane);\n                    if (shouldSkipUpdate) {\n                        // Priority is insufficient. Skip this update. If this is the first\n                        // skipped update, the previous update/state is the new base\n                        // update/state.\n                        var clone = {\n                            lane: updateLane,\n                            tag: update.tag,\n                            payload: update.payload,\n                            callback: update.callback,\n                            next: null\n                        };\n                        if (newLastBaseUpdate === null) {\n                            newFirstBaseUpdate = newLastBaseUpdate = clone;\n                            newBaseState = newState;\n                        } else {\n                            newLastBaseUpdate = newLastBaseUpdate.next = clone;\n                        } // Update the remaining priority in the queue.\n                        newLanes = mergeLanes(newLanes, updateLane);\n                    } else {\n                        // This update does have sufficient priority.\n                        // Check if this update is part of a pending async action. If so,\n                        // we'll need to suspend until the action has finished, so that it's\n                        // batched together with future updates in the same action.\n                        if (updateLane !== NoLane && updateLane === peekEntangledActionLane()) {\n                            didReadFromEntangledAsyncAction = true;\n                        }\n                        if (newLastBaseUpdate !== null) {\n                            var _clone = {\n                                // This update is going to be committed so we never want uncommit\n                                // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                                // this will never be skipped by the check above.\n                                lane: NoLane,\n                                tag: update.tag,\n                                payload: update.payload,\n                                // When this update is rebased, we should not fire its\n                                // callback again.\n                                callback: null,\n                                next: null\n                            };\n                            newLastBaseUpdate = newLastBaseUpdate.next = _clone;\n                        } // Process this update.\n                        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n                        var callback = update.callback;\n                        if (callback !== null) {\n                            workInProgress.flags |= Callback;\n                            if (isHiddenUpdate) {\n                                workInProgress.flags |= Visibility;\n                            }\n                            var callbacks = queue.callbacks;\n                            if (callbacks === null) {\n                                queue.callbacks = [\n                                    callback\n                                ];\n                            } else {\n                                callbacks.push(callback);\n                            }\n                        }\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    update = update.next;\n                    if (update === null) {\n                        pendingQueue = queue.shared.pending;\n                        if (pendingQueue === null) {\n                            break;\n                        } else {\n                            // An update was scheduled from inside a reducer. Add the new\n                            // pending updates to the end of the list and keep processing.\n                            var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\n                            // unravel them when transferring them to the base queue.\n                            var _firstPendingUpdate = _lastPendingUpdate.next;\n                            _lastPendingUpdate.next = null;\n                            update = _firstPendingUpdate;\n                            queue.lastBaseUpdate = _lastPendingUpdate;\n                            queue.shared.pending = null;\n                        }\n                    }\n                }while (true);\n                if (newLastBaseUpdate === null) {\n                    newBaseState = newState;\n                }\n                queue.baseState = newBaseState;\n                queue.firstBaseUpdate = newFirstBaseUpdate;\n                queue.lastBaseUpdate = newLastBaseUpdate;\n                if (firstBaseUpdate === null) {\n                    // `queue.lanes` is used for entangling transitions. We can set it back to\n                    // zero once the queue is empty.\n                    queue.shared.lanes = NoLanes;\n                } // Set the remaining expiration time to be whatever is remaining in the queue.\n                // This should be fine because the only two other things that contribute to\n                // expiration time are props and context. We're already in the middle of the\n                // begin phase by the time we start processing the queue, so we've already\n                // dealt with the props. Context in components that specify\n                // shouldComponentUpdate is tricky; but we'll have to account for\n                // that regardless.\n                markSkippedUpdateLanes(newLanes);\n                workInProgress.lanes = newLanes;\n                workInProgress.memoizedState = newState;\n            }\n            {\n                currentlyProcessingQueue = null;\n            }\n        }\n        function callCallback(callback, context) {\n            if (typeof callback !== 'function') {\n                throw new Error('Invalid argument passed as callback. Expected a function. Instead ' + (\"received: \" + callback));\n            }\n            callback.call(context);\n        }\n        function resetHasForceUpdateBeforeProcessing() {\n            hasForceUpdate = false;\n        }\n        function checkHasForceUpdateAfterProcessing() {\n            return hasForceUpdate;\n        }\n        function deferHiddenCallbacks(updateQueue) {\n            // When an update finishes on a hidden component, its callback should not\n            // be fired until/unless the component is made visible again. Stash the\n            // callback on the shared queue object so it can be fired later.\n            var newHiddenCallbacks = updateQueue.callbacks;\n            if (newHiddenCallbacks !== null) {\n                var existingHiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n                if (existingHiddenCallbacks === null) {\n                    updateQueue.shared.hiddenCallbacks = newHiddenCallbacks;\n                } else {\n                    updateQueue.shared.hiddenCallbacks = existingHiddenCallbacks.concat(newHiddenCallbacks);\n                }\n            }\n        }\n        function commitHiddenCallbacks(updateQueue, context) {\n            // This component is switching from hidden -> visible. Commit any callbacks\n            // that were previously deferred.\n            var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n            if (hiddenCallbacks !== null) {\n                updateQueue.shared.hiddenCallbacks = null;\n                for(var i = 0; i < hiddenCallbacks.length; i++){\n                    var callback = hiddenCallbacks[i];\n                    callCallback(callback, context);\n                }\n            }\n        }\n        function commitCallbacks(updateQueue, context) {\n            var callbacks = updateQueue.callbacks;\n            if (callbacks !== null) {\n                updateQueue.callbacks = null;\n                for(var i = 0; i < callbacks.length; i++){\n                    var callback = callbacks[i];\n                    callCallback(callback, context);\n                }\n            }\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        /**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */ function shallowEqual(objA, objB) {\n            if (objectIs(objA, objB)) {\n                return true;\n            }\n            if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n                return false;\n            }\n            var keysA = Object.keys(objA);\n            var keysB = Object.keys(objB);\n            if (keysA.length !== keysB.length) {\n                return false;\n            } // Test for A's keys different from B.\n            for(var i = 0; i < keysA.length; i++){\n                var currentKey = keysA[i];\n                if (!hasOwnProperty.call(objB, currentKey) || // $FlowFixMe[incompatible-use] lost refinement of `objB`\n                !objectIs(objA[currentKey], objB[currentKey])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        var ReactStrictModeWarnings = {\n            recordUnsafeLifecycleWarnings: function(fiber, instance) {},\n            flushPendingUnsafeLifecycleWarnings: function() {},\n            recordLegacyContextWarning: function(fiber, instance) {},\n            flushLegacyContextWarning: function() {},\n            discardPendingWarnings: function() {}\n        };\n        {\n            var findStrictRoot = function(fiber) {\n                var maybeStrictRoot = null;\n                var node = fiber;\n                while(node !== null){\n                    if (node.mode & StrictLegacyMode) {\n                        maybeStrictRoot = node;\n                    }\n                    node = node.return;\n                }\n                return maybeStrictRoot;\n            };\n            var setToSortedString = function(set) {\n                var array = [];\n                set.forEach(function(value) {\n                    array.push(value);\n                });\n                return array.sort().join(', ');\n            };\n            var pendingComponentWillMountWarnings = [];\n            var pendingUNSAFE_ComponentWillMountWarnings = [];\n            var pendingComponentWillReceivePropsWarnings = [];\n            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n            var pendingComponentWillUpdateWarnings = [];\n            var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.\n            var didWarnAboutUnsafeLifecycles = new Set();\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n                // Dedupe strategy: Warn once per component.\n                if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n                    return;\n                }\n                if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.\n                instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillMountWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === 'function') {\n                    pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\n                }\n                if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillReceivePropsWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\n                }\n                if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillUpdateWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {\n                    pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\n                }\n            };\n            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n                // We do an initial pass to gather component names\n                var componentWillMountUniqueNames = new Set();\n                if (pendingComponentWillMountWarnings.length > 0) {\n                    pendingComponentWillMountWarnings.forEach(function(fiber) {\n                        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillMountWarnings = [];\n                }\n                var UNSAFE_componentWillMountUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillMountWarnings = [];\n                }\n                var componentWillReceivePropsUniqueNames = new Set();\n                if (pendingComponentWillReceivePropsWarnings.length > 0) {\n                    pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillReceivePropsWarnings = [];\n                }\n                var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n                }\n                var componentWillUpdateUniqueNames = new Set();\n                if (pendingComponentWillUpdateWarnings.length > 0) {\n                    pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n                        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillUpdateWarnings = [];\n                }\n                var UNSAFE_componentWillUpdateUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillUpdateWarnings = [];\n                } // Finally, we flush all the warnings\n                // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\n                if (UNSAFE_componentWillMountUniqueNames.size > 0) {\n                    var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n                    error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '\\nPlease update the following components: %s', sortedNames);\n                }\n                if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\n                    var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\n                    error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, \" + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n' + '\\nPlease update the following components: %s', _sortedNames);\n                }\n                if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\n                    var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\n                    error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '\\nPlease update the following components: %s', _sortedNames2);\n                }\n                if (componentWillMountUniqueNames.size > 0) {\n                    var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\n                    warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames3);\n                }\n                if (componentWillReceivePropsUniqueNames.size > 0) {\n                    var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\n                    warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, refactor your \" + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames4);\n                }\n                if (componentWillUpdateUniqueNames.size > 0) {\n                    var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\n                    warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames5);\n                }\n            };\n            var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.\n            var didWarnAboutLegacyContext = new Set();\n            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n                var strictRoot = findStrictRoot(fiber);\n                if (strictRoot === null) {\n                    error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n                    return;\n                } // Dedup strategy: Warn once per component.\n                if (didWarnAboutLegacyContext.has(fiber.type)) {\n                    return;\n                }\n                var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n                if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {\n                    if (warningsForRoot === undefined) {\n                        warningsForRoot = [];\n                        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n                    }\n                    warningsForRoot.push(fiber);\n                }\n            };\n            ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n                pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {\n                    if (fiberArray.length === 0) {\n                        return;\n                    }\n                    var firstFiber = fiberArray[0];\n                    var uniqueNames = new Set();\n                    fiberArray.forEach(function(fiber) {\n                        uniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutLegacyContext.add(fiber.type);\n                    });\n                    var sortedNames = setToSortedString(uniqueNames);\n                    try {\n                        setCurrentDebugFiberInDEV(firstFiber);\n                        error('Legacy context API has been detected within a strict-mode tree.' + '\\n\\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here: https://react.dev/link/legacy-context', sortedNames);\n                    } finally{\n                        resetCurrentDebugFiberInDEV();\n                    }\n                });\n            };\n            ReactStrictModeWarnings.discardPendingWarnings = function() {\n                pendingComponentWillMountWarnings = [];\n                pendingUNSAFE_ComponentWillMountWarnings = [];\n                pendingComponentWillReceivePropsWarnings = [];\n                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n                pendingComponentWillUpdateWarnings = [];\n                pendingUNSAFE_ComponentWillUpdateWarnings = [];\n                pendingLegacyContextWarning = new Map();\n            };\n        }\n        function getThenablesFromState(state) {\n            {\n                var devState = state;\n                return devState.thenables;\n            }\n        } // An error that is thrown (e.g. by `use`) to trigger Suspense. If we\n        // detect this is caught by userspace, we'll log a warning in development.\n        var SuspenseException = new Error(\"Suspense Exception: This is not a real error! It's an implementation \" + 'detail of `use` to interrupt the current render. You must either ' + 'rethrow it immediately, or move the `use` call outside of the ' + '`try/catch` block. Capturing without rethrowing will lead to ' + 'unexpected behavior.\\n\\n' + 'To handle async errors, wrap your component in an error boundary, or ' + \"call the promise's `.catch` method and pass the result to `use`\");\n        var SuspenseyCommitException = new Error('Suspense Exception: This is not a real error, and should not leak into ' + \"userspace. If you're seeing this, it's likely a bug in React.\"); // This is a noop thenable that we use to trigger a fallback in throwException.\n        // TODO: It would be better to refactor throwException into multiple functions\n        // so we can trigger a fallback directly without having to check the type. But\n        // for now this will do.\n        var noopSuspenseyCommitThenable = {\n            then: function() {\n                {\n                    error('Internal React error: A listener was unexpectedly attached to a ' + '\"noop\" thenable. This is a bug in React. Please file an issue.');\n                }\n            }\n        };\n        function createThenableState() {\n            // The ThenableState is created the first time a component suspends. If it\n            // suspends again, we'll reuse the same state.\n            {\n                return {\n                    didWarnAboutUncachedPromise: false,\n                    thenables: []\n                };\n            }\n        }\n        function isThenableResolved(thenable) {\n            var status = thenable.status;\n            return status === 'fulfilled' || status === 'rejected';\n        }\n        function noop$1() {}\n        function trackUsedThenable(thenableState, thenable, index) {\n            if (ReactSharedInternals.actQueue !== null) {\n                ReactSharedInternals.didUsePromise = true;\n            }\n            var trackedThenables = getThenablesFromState(thenableState);\n            var previous = trackedThenables[index];\n            if (previous === undefined) {\n                trackedThenables.push(thenable);\n            } else {\n                if (previous !== thenable) {\n                    // Reuse the previous thenable, and drop the new one. We can assume\n                    // they represent the same value, because components are idempotent.\n                    {\n                        var thenableStateDev = thenableState;\n                        if (!thenableStateDev.didWarnAboutUncachedPromise) {\n                            // We should only warn the first time an uncached thenable is\n                            // discovered per component, because if there are multiple, the\n                            // subsequent ones are likely derived from the first.\n                            //\n                            // We track this on the thenableState instead of deduping using the\n                            // component name like we usually do, because in the case of a\n                            // promise-as-React-node, the owner component is likely different from\n                            // the parent that's currently being reconciled. We'd have to track\n                            // the owner using state, which we're trying to move away from. Though\n                            // since this is dev-only, maybe that'd be OK.\n                            //\n                            // However, another benefit of doing it this way is we might\n                            // eventually have a thenableState per memo/Forget boundary instead\n                            // of per component, so this would allow us to have more\n                            // granular warnings.\n                            thenableStateDev.didWarnAboutUncachedPromise = true; // TODO: This warning should link to a corresponding docs page.\n                            error('A component was suspended by an uncached promise. Creating ' + 'promises inside a Client Component or hook is not yet ' + 'supported, except via a Suspense-compatible library or framework.');\n                        }\n                    }\n                    // intentionally ignore.\n                    thenable.then(noop$1, noop$1);\n                    thenable = previous;\n                }\n            } // We use an expando to track the status and result of a thenable so that we\n            // can synchronously unwrap the value. Think of this as an extension of the\n            // Promise API, or a custom interface that is a superset of Thenable.\n            //\n            // If the thenable doesn't have a status, set it to \"pending\" and attach\n            // a listener that will update its status and result when it resolves.\n            switch(thenable.status){\n                case 'fulfilled':\n                    {\n                        var fulfilledValue = thenable.value;\n                        return fulfilledValue;\n                    }\n                case 'rejected':\n                    {\n                        var rejectedError = thenable.reason;\n                        checkIfUseWrappedInAsyncCatch(rejectedError);\n                        throw rejectedError;\n                    }\n                default:\n                    {\n                        if (typeof thenable.status === 'string') {\n                            // Only instrument the thenable if the status if not defined. If\n                            // it's defined, but an unknown value, assume it's been instrumented by\n                            // some custom userspace implementation. We treat it as \"pending\".\n                            // Attach a dummy listener, to ensure that any lazy initialization can\n                            // happen. Flight lazily parses JSON when the value is actually awaited.\n                            thenable.then(noop$1, noop$1);\n                        } else {\n                            // This is an uncached thenable that we haven't seen before.\n                            // Detect infinite ping loops caused by uncached promises.\n                            var root = getWorkInProgressRoot();\n                            if (root !== null && root.shellSuspendCounter > 100) {\n                                // This root has suspended repeatedly in the shell without making any\n                                // progress (i.e. committing something). This is highly suggestive of\n                                // an infinite ping loop, often caused by an accidental Async Client\n                                // Component.\n                                //\n                                // During a transition, we can suspend the work loop until the promise\n                                // to resolve, but this is a sync render, so that's not an option. We\n                                // also can't show a fallback, because none was provided. So our last\n                                // resort is to throw an error.\n                                //\n                                // TODO: Remove this error in a future release. Other ways of handling\n                                // this case include forcing a concurrent render, or putting the whole\n                                // root into offscreen mode.\n                                throw new Error('async/await is not yet supported in Client Components, only ' + 'Server Components. This error is often caused by accidentally ' + \"adding `'use client'` to a module that was originally written \" + 'for the server.');\n                            }\n                            var pendingThenable = thenable;\n                            pendingThenable.status = 'pending';\n                            pendingThenable.then(function(fulfilledValue) {\n                                if (thenable.status === 'pending') {\n                                    var fulfilledThenable = thenable;\n                                    fulfilledThenable.status = 'fulfilled';\n                                    fulfilledThenable.value = fulfilledValue;\n                                }\n                            }, function(error) {\n                                if (thenable.status === 'pending') {\n                                    var rejectedThenable = thenable;\n                                    rejectedThenable.status = 'rejected';\n                                    rejectedThenable.reason = error;\n                                }\n                            });\n                        } // Check one more time in case the thenable resolved synchronously.\n                        switch(thenable.status){\n                            case 'fulfilled':\n                                {\n                                    var fulfilledThenable = thenable;\n                                    return fulfilledThenable.value;\n                                }\n                            case 'rejected':\n                                {\n                                    var rejectedThenable = thenable;\n                                    var _rejectedError = rejectedThenable.reason;\n                                    checkIfUseWrappedInAsyncCatch(_rejectedError);\n                                    throw _rejectedError;\n                                }\n                        } // Suspend.\n                        //\n                        // Throwing here is an implementation detail that allows us to unwind the\n                        // call stack. But we shouldn't allow it to leak into userspace. Throw an\n                        // opaque placeholder value instead of the actual thenable. If it doesn't\n                        // get captured by the work loop, log a warning, because that means\n                        // something in userspace must have caught it.\n                        suspendedThenable = thenable;\n                        {\n                            needsToResetSuspendedThenableDEV = true;\n                        }\n                        throw SuspenseException;\n                    }\n            }\n        }\n        function suspendCommit() {\n            // This extra indirection only exists so it can handle passing\n            // noopSuspenseyCommitThenable through to throwException.\n            // TODO: Factor the thenable check out of throwException\n            suspendedThenable = noopSuspenseyCommitThenable;\n            throw SuspenseyCommitException;\n        } // This is used to track the actual thenable that suspended so it can be\n        // passed to the rest of the Suspense implementation — which, for historical\n        // reasons, expects to receive a thenable.\n        var suspendedThenable = null;\n        var needsToResetSuspendedThenableDEV = false;\n        function getSuspendedThenable() {\n            // This is called right after `use` suspends by throwing an exception. `use`\n            // throws an opaque value instead of the thenable itself so that it can't be\n            // caught in userspace. Then the work loop accesses the actual thenable using\n            // this function.\n            if (suspendedThenable === null) {\n                throw new Error('Expected a suspended thenable. This is a bug in React. Please file ' + 'an issue.');\n            }\n            var thenable = suspendedThenable;\n            suspendedThenable = null;\n            {\n                needsToResetSuspendedThenableDEV = false;\n            }\n            return thenable;\n        }\n        function checkIfUseWrappedInTryCatch() {\n            {\n                // This was set right before SuspenseException was thrown, and it should\n                // have been cleared when the exception was handled. If it wasn't,\n                // it must have been caught by userspace.\n                if (needsToResetSuspendedThenableDEV) {\n                    needsToResetSuspendedThenableDEV = false;\n                    return true;\n                }\n            }\n            return false;\n        }\n        function checkIfUseWrappedInAsyncCatch(rejectedReason) {\n            // This check runs in prod, too, because it prevents a more confusing\n            // downstream error, where SuspenseException is caught by a promise and\n            // thrown asynchronously.\n            // TODO: Another way to prevent SuspenseException from leaking into an async\n            // execution context is to check the dispatcher every time `use` is called,\n            // or some equivalent. That might be preferable for other reasons, too, since\n            // it matches how we prevent similar mistakes for other hooks.\n            if (rejectedReason === SuspenseException) {\n                throw new Error('Hooks are not supported inside an async component. This ' + \"error is often caused by accidentally adding `'use client'` \" + 'to a module that was originally written for the server.');\n            }\n        }\n        var thenableState$1 = null;\n        var thenableIndexCounter$1 = 0;\n        function mergeDebugInfo(outer, inner) {\n            if (inner == null) {\n                return outer;\n            } else if (outer === null) {\n                return inner;\n            } else {\n                // If we have two debugInfo, we need to create a new one. This makes the array no longer\n                // live so we'll miss any future updates if we received more so ideally we should always\n                // do this after both have fully resolved/unsuspended.\n                return outer.concat(inner);\n            }\n        }\n        var didWarnAboutMaps;\n        var didWarnAboutGenerators;\n        var ownerHasKeyUseWarning;\n        var ownerHasFunctionTypeWarning;\n        var ownerHasSymbolTypeWarning;\n        var warnForMissingKey = function(child, returnFiber) {};\n        {\n            didWarnAboutMaps = false;\n            didWarnAboutGenerators = false;\n            /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ ownerHasKeyUseWarning = {};\n            ownerHasFunctionTypeWarning = {};\n            ownerHasSymbolTypeWarning = {};\n            warnForMissingKey = function(child, returnFiber) {\n                if (child === null || typeof child !== 'object') {\n                    return;\n                }\n                if (!child._store || (child._store.validated || child.key != null) && child._store.validated !== 2) {\n                    return;\n                }\n                if (typeof child._store !== 'object') {\n                    throw new Error('React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n                } // $FlowFixMe[cannot-write] unable to narrow type from mixed to writable object\n                child._store.validated = 1;\n                var componentName = getComponentNameFromFiber(returnFiber);\n                var componentKey = componentName || 'null';\n                if (ownerHasKeyUseWarning[componentKey]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[componentKey] = true;\n                var childOwner = child._owner;\n                var parentOwner = returnFiber._debugOwner;\n                var currentComponentErrorInfo = '';\n                if (parentOwner && typeof parentOwner.tag === 'number') {\n                    var name = getComponentNameFromFiber(parentOwner);\n                    if (name) {\n                        currentComponentErrorInfo = '\\n\\nCheck the render method of `' + name + '`.';\n                    }\n                }\n                if (!currentComponentErrorInfo) {\n                    if (componentName) {\n                        currentComponentErrorInfo = \"\\n\\nCheck the top-level render call using <\" + componentName + \">.\";\n                    }\n                } // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwnerAppendix = '';\n                if (childOwner != null && parentOwner !== childOwner) {\n                    var ownerName = null;\n                    if (typeof childOwner.tag === 'number') {\n                        ownerName = getComponentNameFromFiber(childOwner);\n                    } else if (typeof childOwner.name === 'string') {\n                        ownerName = childOwner.name;\n                    }\n                    if (ownerName) {\n                        // Give the component that originally created this child.\n                        childOwnerAppendix = \" It was passed a child from \" + ownerName + \".\";\n                    }\n                } // We create a fake Fiber for the child to log the stack trace from.\n                // TODO: Refactor the warnForMissingKey calls to happen after fiber creation\n                // so that we can get access to the fiber that will eventually be created.\n                // That way the log can show up associated with the right instance in DevTools.\n                var fiber = createFiberFromElement(child, returnFiber.mode, 0);\n                fiber.return = returnFiber;\n                var prevDebugFiber = getCurrentFiber();\n                setCurrentFiber(fiber);\n                error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);\n                setCurrentFiber(prevDebugFiber);\n            };\n        }\n        // We do this here instead of BeginWork because the Fragment fiber doesn't have\n        // the whole props object, only the children and is shared with arrays.\n        function validateFragmentProps(element, fiber, returnFiber) {\n            {\n                var keys = Object.keys(element.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== 'children' && key !== 'key') {\n                        if (fiber === null) {\n                            // For unkeyed root fragments there's no Fiber. We create a fake one just for\n                            // error stack handling.\n                            fiber = createFiberFromElement(element, returnFiber.mode, 0);\n                            fiber.return = returnFiber;\n                        }\n                        var prevDebugFiber = getCurrentFiber();\n                        setCurrentFiber(fiber);\n                        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n                        setCurrentFiber(prevDebugFiber);\n                        break;\n                    }\n                }\n            }\n        }\n        function unwrapThenable(thenable) {\n            var index = thenableIndexCounter$1;\n            thenableIndexCounter$1 += 1;\n            if (thenableState$1 === null) {\n                thenableState$1 = createThenableState();\n            }\n            return trackUsedThenable(thenableState$1, thenable, index);\n        }\n        function coerceRef(returnFiber, current, workInProgress, element) {\n            var ref;\n            {\n                // TODO: This is a temporary, intermediate step. When enableRefAsProp is on,\n                // we should resolve the `ref` prop during the begin phase of the component\n                // it's attached to (HostComponent, ClassComponent, etc).\n                var refProp = element.props.ref;\n                ref = refProp !== undefined ? refProp : null;\n            }\n            // should always read the ref from the prop.\n            workInProgress.ref = ref;\n        }\n        function throwOnInvalidObjectType(returnFiber, newChild) {\n            if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) {\n                throw new Error('A React Element from an older version of React was rendered. ' + 'This is not supported. It can happen if:\\n' + '- Multiple copies of the \"react\" package is used.\\n' + '- A library pre-bundled an old copy of \"react\" or \"react/jsx-runtime\".\\n' + '- A compiler tries to \"inline\" JSX instead of using the runtime.');\n            } // $FlowFixMe[method-unbinding]\n            var childString = Object.prototype.toString.call(newChild);\n            throw new Error(\"Objects are not valid as a React child (found: \" + (childString === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : childString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n        }\n        function warnOnFunctionType(returnFiber, invalidChild) {\n            {\n                var parentName = getComponentNameFromFiber(returnFiber) || 'Component';\n                if (ownerHasFunctionTypeWarning[parentName]) {\n                    return;\n                }\n                ownerHasFunctionTypeWarning[parentName] = true;\n                var name = invalidChild.displayName || invalidChild.name || 'Component';\n                if (returnFiber.tag === HostRoot) {\n                    error('Functions are not valid as a React child. This may happen if ' + 'you return %s instead of <%s /> from render. ' + 'Or maybe you meant to call this function rather than return it.\\n' + '  root.render(%s)', name, name, name);\n                } else {\n                    error('Functions are not valid as a React child. This may happen if ' + 'you return %s instead of <%s /> from render. ' + 'Or maybe you meant to call this function rather than return it.\\n' + '  <%s>{%s}</%s>', name, name, parentName, name, parentName);\n                }\n            }\n        }\n        function warnOnSymbolType(returnFiber, invalidChild) {\n            {\n                var parentName = getComponentNameFromFiber(returnFiber) || 'Component';\n                if (ownerHasSymbolTypeWarning[parentName]) {\n                    return;\n                }\n                ownerHasSymbolTypeWarning[parentName] = true; // eslint-disable-next-line react-internal/safe-string-coercion\n                var name = String(invalidChild);\n                if (returnFiber.tag === HostRoot) {\n                    error('Symbols are not valid as a React child.\\n' + '  root.render(%s)', name);\n                } else {\n                    error('Symbols are not valid as a React child.\\n' + '  <%s>%s</%s>', parentName, name, parentName);\n                }\n            }\n        }\n        function resolveLazy(lazyType) {\n            var payload = lazyType._payload;\n            var init = lazyType._init;\n            return init(payload);\n        } // This wrapper function exists because I expect to clone the code in each path\n        // to be able to optimize each path individually by branching early. This needs\n        // a compiler or we can do it manually. Helpers that don't need this branching\n        // live outside of this function.\n        function createChildReconciler(shouldTrackSideEffects) {\n            function deleteChild(returnFiber, childToDelete) {\n                if (!shouldTrackSideEffects) {\n                    // Noop.\n                    return;\n                }\n                var deletions = returnFiber.deletions;\n                if (deletions === null) {\n                    returnFiber.deletions = [\n                        childToDelete\n                    ];\n                    returnFiber.flags |= ChildDeletion;\n                } else {\n                    deletions.push(childToDelete);\n                }\n            }\n            function deleteRemainingChildren(returnFiber, currentFirstChild) {\n                if (!shouldTrackSideEffects) {\n                    // Noop.\n                    return null;\n                } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n                // assuming that after the first child we've already added everything.\n                var childToDelete = currentFirstChild;\n                while(childToDelete !== null){\n                    deleteChild(returnFiber, childToDelete);\n                    childToDelete = childToDelete.sibling;\n                }\n                return null;\n            }\n            function mapRemainingChildren(currentFirstChild) {\n                // Add the remaining children to a temporary map so that we can find them by\n                // keys quickly. Implicit (null) keys get added to this set with their index\n                // instead.\n                var existingChildren = new Map();\n                var existingChild = currentFirstChild;\n                while(existingChild !== null){\n                    if (existingChild.key !== null) {\n                        existingChildren.set(existingChild.key, existingChild);\n                    } else {\n                        existingChildren.set(existingChild.index, existingChild);\n                    }\n                    existingChild = existingChild.sibling;\n                }\n                return existingChildren;\n            }\n            function useFiber(fiber, pendingProps) {\n                // We currently set sibling to null and index to 0 here because it is easy\n                // to forget to do before returning it. E.g. for the single child case.\n                var clone = createWorkInProgress(fiber, pendingProps);\n                clone.index = 0;\n                clone.sibling = null;\n                return clone;\n            }\n            function placeChild(newFiber, lastPlacedIndex, newIndex) {\n                newFiber.index = newIndex;\n                if (!shouldTrackSideEffects) {\n                    // During hydration, the useId algorithm needs to know which fibers are\n                    // part of a list of children (arrays, iterators).\n                    newFiber.flags |= Forked;\n                    return lastPlacedIndex;\n                }\n                var current = newFiber.alternate;\n                if (current !== null) {\n                    var oldIndex = current.index;\n                    if (oldIndex < lastPlacedIndex) {\n                        // This is a move.\n                        newFiber.flags |= Placement | PlacementDEV;\n                        return lastPlacedIndex;\n                    } else {\n                        // This item can stay in place.\n                        return oldIndex;\n                    }\n                } else {\n                    // This is an insertion.\n                    newFiber.flags |= Placement | PlacementDEV;\n                    return lastPlacedIndex;\n                }\n            }\n            function placeSingleChild(newFiber) {\n                // This is simpler for the single child case. We only need to do a\n                // placement for inserting new children.\n                if (shouldTrackSideEffects && newFiber.alternate === null) {\n                    newFiber.flags |= Placement | PlacementDEV;\n                }\n                return newFiber;\n            }\n            function updateTextNode(returnFiber, current, textContent, lanes, debugInfo) {\n                if (current === null || current.tag !== HostText) {\n                    // Insert\n                    var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, textContent);\n                    existing.return = returnFiber;\n                    {\n                        existing._debugInfo = debugInfo;\n                    }\n                    return existing;\n                }\n            }\n            function updateElement(returnFiber, current, element, lanes, debugInfo) {\n                var elementType = element.type;\n                if (elementType === REACT_FRAGMENT_TYPE) {\n                    var updated = updateFragment(returnFiber, current, element.props.children, lanes, element.key, debugInfo);\n                    validateFragmentProps(element, updated, returnFiber);\n                    return updated;\n                }\n                if (current !== null) {\n                    if (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || // Lazy types should reconcile their resolved type.\n                    // We need to do this after the Hot Reloading check above,\n                    // because hot reloading has different semantics than prod because\n                    // it doesn't resuspend. So we can't let the call below suspend.\n                    typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {\n                        // Move based on index\n                        var existing = useFiber(current, element.props);\n                        coerceRef(returnFiber, current, existing, element);\n                        existing.return = returnFiber;\n                        {\n                            existing._debugOwner = element._owner;\n                            existing._debugInfo = debugInfo;\n                        }\n                        return existing;\n                    }\n                } // Insert\n                var created = createFiberFromElement(element, returnFiber.mode, lanes);\n                coerceRef(returnFiber, current, created, element);\n                created.return = returnFiber;\n                {\n                    created._debugInfo = debugInfo;\n                }\n                return created;\n            }\n            function updatePortal(returnFiber, current, portal, lanes, debugInfo) {\n                if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n                    // Insert\n                    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, portal.children || []);\n                    existing.return = returnFiber;\n                    {\n                        existing._debugInfo = debugInfo;\n                    }\n                    return existing;\n                }\n            }\n            function updateFragment(returnFiber, current, fragment, lanes, key, debugInfo) {\n                if (current === null || current.tag !== Fragment) {\n                    // Insert\n                    var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, fragment);\n                    existing.return = returnFiber;\n                    {\n                        existing._debugInfo = debugInfo;\n                    }\n                    return existing;\n                }\n            }\n            function createChild(returnFiber, newChild, lanes, debugInfo) {\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\n                    // we can continue to replace it without aborting even if it is not a text\n                    // node.\n                    var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                }\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n                                coerceRef(returnFiber, null, _created, newChild);\n                                _created.return = returnFiber;\n                                {\n                                    _created._debugInfo = mergeDebugInfo(debugInfo, newChild._debugInfo);\n                                }\n                                return _created;\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n                                _created2.return = returnFiber;\n                                {\n                                    _created2._debugInfo = debugInfo;\n                                }\n                                return _created2;\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = newChild._payload;\n                                var init = newChild._init;\n                                return createChild(returnFiber, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo) // call merge after init\n                                );\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren) {\n                        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n                        _created3.return = returnFiber;\n                        {\n                            _created3._debugInfo = mergeDebugInfo(debugInfo, newChild._debugInfo);\n                        }\n                        return _created3;\n                    } // Usable node types\n                    //\n                    // Unwrap the inner value and recursively call this function again.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return createChild(returnFiber, unwrapThenable(thenable), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return createChild(returnFiber, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return null;\n            }\n            function updateSlot(returnFiber, oldFiber, newChild, lanes, debugInfo) {\n                // Update the fiber if the keys match, otherwise return null.\n                var key = oldFiber !== null ? oldFiber.key : null;\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\n                    // we can continue to replace it without aborting even if it is not a text\n                    // node.\n                    if (key !== null) {\n                        return null;\n                    }\n                    return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes, debugInfo);\n                }\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                if (newChild.key === key) {\n                                    return updateElement(returnFiber, oldFiber, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                                } else {\n                                    return null;\n                                }\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                if (newChild.key === key) {\n                                    return updatePortal(returnFiber, oldFiber, newChild, lanes, debugInfo);\n                                } else {\n                                    return null;\n                                }\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = newChild._payload;\n                                var init = newChild._init;\n                                return updateSlot(returnFiber, oldFiber, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren) {\n                        if (key !== null) {\n                            return null;\n                        }\n                        return updateFragment(returnFiber, oldFiber, newChild, lanes, null, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    } // Usable node types\n                    //\n                    // Unwrap the inner value and recursively call this function again.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return updateSlot(returnFiber, oldFiber, unwrapThenable(thenable), lanes, debugInfo);\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return null;\n            }\n            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes, debugInfo) {\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    // Text nodes don't have keys, so we neither have to check the old nor\n                    // new node for the key. If both are text nodes, they match.\n                    var matchedFiber = existingChildren.get(newIdx) || null;\n                    return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes, debugInfo);\n                }\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                                return updateElement(returnFiber, _matchedFiber, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes, debugInfo);\n                            }\n                        case REACT_LAZY_TYPE:\n                            var payload = newChild._payload;\n                            var init = newChild._init;\n                            return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren) {\n                        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n                        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    } // Usable node types\n                    //\n                    // Unwrap the inner value and recursively call this function again.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(thenable), lanes, debugInfo);\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return null;\n            }\n            /**\n   * Warns if there is a duplicate or missing key\n   */ function warnOnInvalidKey(child, knownKeys, returnFiber) {\n                {\n                    if (typeof child !== 'object' || child === null) {\n                        return knownKeys;\n                    }\n                    switch(child.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                        case REACT_PORTAL_TYPE:\n                            warnForMissingKey(child, returnFiber);\n                            var key = child.key;\n                            if (typeof key !== 'string') {\n                                break;\n                            }\n                            if (knownKeys === null) {\n                                knownKeys = new Set();\n                                knownKeys.add(key);\n                                break;\n                            }\n                            if (!knownKeys.has(key)) {\n                                knownKeys.add(key);\n                                break;\n                            }\n                            error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);\n                            break;\n                        case REACT_LAZY_TYPE:\n                            var payload = child._payload;\n                            var init = child._init;\n                            warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n                            break;\n                    }\n                }\n                return knownKeys;\n            }\n            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes, debugInfo) {\n                // This algorithm can't optimize by searching from both ends since we\n                // don't have backpointers on fibers. I'm trying to see how far we can get\n                // with that model. If it ends up not being worth the tradeoffs, we can\n                // add it later.\n                // Even with a two ended optimization, we'd want to optimize for the case\n                // where there are few changes and brute force the comparison instead of\n                // going for the Map. It'd like to explore hitting that path first in\n                // forward-only mode and only go for the Map once we notice that we need\n                // lots of look ahead. This doesn't handle reversal as well as two ended\n                // search but that's unusual. Besides, for the two ended optimization to\n                // work on Iterables, we'd need to copy the whole set.\n                // In this first iteration, we'll just live with hitting the bad case\n                // (adding everything to a Map) in for every insert/move.\n                // If you change this code, also update reconcileChildrenIterator() which\n                // uses the same algorithm.\n                {\n                    // First, validate keys.\n                    var knownKeys = null;\n                    for(var i = 0; i < newChildren.length; i++){\n                        var child = newChildren[i];\n                        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n                    }\n                }\n                var resultingFirstChild = null;\n                var previousNewFiber = null;\n                var oldFiber = currentFirstChild;\n                var lastPlacedIndex = 0;\n                var newIdx = 0;\n                var nextOldFiber = null;\n                for(; oldFiber !== null && newIdx < newChildren.length; newIdx++){\n                    if (oldFiber.index > newIdx) {\n                        nextOldFiber = oldFiber;\n                        oldFiber = null;\n                    } else {\n                        nextOldFiber = oldFiber.sibling;\n                    }\n                    var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes, debugInfo);\n                    if (newFiber === null) {\n                        // TODO: This breaks on empty slots like null children. That's\n                        // unfortunate because it triggers the slow path all the time. We need\n                        // a better way to communicate whether this was a miss or null,\n                        // boolean, undefined, etc.\n                        if (oldFiber === null) {\n                            oldFiber = nextOldFiber;\n                        }\n                        break;\n                    }\n                    if (shouldTrackSideEffects) {\n                        if (oldFiber && newFiber.alternate === null) {\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\n                            // need to delete the existing child.\n                            deleteChild(returnFiber, oldFiber);\n                        }\n                    }\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n                    if (previousNewFiber === null) {\n                        // TODO: Move out of the loop. This only happens for the first run.\n                        resultingFirstChild = newFiber;\n                    } else {\n                        // TODO: Defer siblings if we're not at the right index for this slot.\n                        // I.e. if we had null values before, then we want to defer this\n                        // for each null value. However, we also don't want to call updateSlot\n                        // with the previous one.\n                        previousNewFiber.sibling = newFiber;\n                    }\n                    previousNewFiber = newFiber;\n                    oldFiber = nextOldFiber;\n                }\n                if (newIdx === newChildren.length) {\n                    // We've reached the end of the new children. We can delete the rest.\n                    deleteRemainingChildren(returnFiber, oldFiber);\n                    if (getIsHydrating()) {\n                        var numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, numberOfForks);\n                    }\n                    return resultingFirstChild;\n                }\n                if (oldFiber === null) {\n                    // If we don't have any more existing children we can choose a fast path\n                    // since the rest will all be insertions.\n                    for(; newIdx < newChildren.length; newIdx++){\n                        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes, debugInfo);\n                        if (_newFiber === null) {\n                            continue;\n                        }\n                        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            // TODO: Move out of the loop. This only happens for the first run.\n                            resultingFirstChild = _newFiber;\n                        } else {\n                            previousNewFiber.sibling = _newFiber;\n                        }\n                        previousNewFiber = _newFiber;\n                    }\n                    if (getIsHydrating()) {\n                        var _numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, _numberOfForks);\n                    }\n                    return resultingFirstChild;\n                } // Add all children to a key map for quick lookups.\n                var existingChildren = mapRemainingChildren(oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n                for(; newIdx < newChildren.length; newIdx++){\n                    var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes, debugInfo);\n                    if (_newFiber2 !== null) {\n                        if (shouldTrackSideEffects) {\n                            if (_newFiber2.alternate !== null) {\n                                // The new fiber is a work in progress, but if there exists a\n                                // current, that means that we reused the fiber. We need to delete\n                                // it from the child list so that we don't add it to the deletion\n                                // list.\n                                existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n                            }\n                        }\n                        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            resultingFirstChild = _newFiber2;\n                        } else {\n                            previousNewFiber.sibling = _newFiber2;\n                        }\n                        previousNewFiber = _newFiber2;\n                    }\n                }\n                if (shouldTrackSideEffects) {\n                    // Any existing children that weren't consumed above were deleted. We need\n                    // to add them to the deletion list.\n                    existingChildren.forEach(function(child) {\n                        return deleteChild(returnFiber, child);\n                    });\n                }\n                if (getIsHydrating()) {\n                    var _numberOfForks2 = newIdx;\n                    pushTreeFork(returnFiber, _numberOfForks2);\n                }\n                return resultingFirstChild;\n            }\n            function reconcileChildrenIteratable(returnFiber, currentFirstChild, newChildrenIterable, lanes, debugInfo) {\n                // This is the same implementation as reconcileChildrenArray(),\n                // but using the iterator instead.\n                var iteratorFn = getIteratorFn(newChildrenIterable);\n                if (typeof iteratorFn !== 'function') {\n                    throw new Error('An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');\n                }\n                var newChildren = iteratorFn.call(newChildrenIterable);\n                {\n                    if (newChildren === newChildrenIterable) {\n                        // We don't support rendering Generators as props because it's a mutation.\n                        // See https://github.com/facebook/react/issues/12995\n                        // We do support generators if they were created by a GeneratorFunction component\n                        // as its direct child since we can recreate those by rerendering the component\n                        // as needed.\n                        var isGeneratorComponent = returnFiber.tag === FunctionComponent && // $FlowFixMe[method-unbinding]\n                        Object.prototype.toString.call(returnFiber.type) === '[object GeneratorFunction]' && // $FlowFixMe[method-unbinding]\n                        Object.prototype.toString.call(newChildren) === '[object Generator]';\n                        if (!isGeneratorComponent) {\n                            if (!didWarnAboutGenerators) {\n                                error('Using Iterators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. You can also use an ' + 'Iterable that can iterate multiple times over the same items.');\n                            }\n                            didWarnAboutGenerators = true;\n                        }\n                    } else if (newChildrenIterable.entries === iteratorFn) {\n                        // Warn about using Maps as children\n                        if (!didWarnAboutMaps) {\n                            error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n                            didWarnAboutMaps = true;\n                        }\n                    }\n                }\n                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes, debugInfo);\n            }\n            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes, debugInfo) {\n                if (newChildren == null) {\n                    throw new Error('An iterable object provided no iterator.');\n                }\n                var resultingFirstChild = null;\n                var previousNewFiber = null;\n                var oldFiber = currentFirstChild;\n                var lastPlacedIndex = 0;\n                var newIdx = 0;\n                var nextOldFiber = null;\n                var knownKeys = null;\n                var step = newChildren.next();\n                {\n                    knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber);\n                }\n                for(; oldFiber !== null && !step.done; newIdx++, step = newChildren.next(), knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber)){\n                    if (oldFiber.index > newIdx) {\n                        nextOldFiber = oldFiber;\n                        oldFiber = null;\n                    } else {\n                        nextOldFiber = oldFiber.sibling;\n                    }\n                    var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes, debugInfo);\n                    if (newFiber === null) {\n                        // TODO: This breaks on empty slots like null children. That's\n                        // unfortunate because it triggers the slow path all the time. We need\n                        // a better way to communicate whether this was a miss or null,\n                        // boolean, undefined, etc.\n                        if (oldFiber === null) {\n                            oldFiber = nextOldFiber;\n                        }\n                        break;\n                    }\n                    if (shouldTrackSideEffects) {\n                        if (oldFiber && newFiber.alternate === null) {\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\n                            // need to delete the existing child.\n                            deleteChild(returnFiber, oldFiber);\n                        }\n                    }\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n                    if (previousNewFiber === null) {\n                        // TODO: Move out of the loop. This only happens for the first run.\n                        resultingFirstChild = newFiber;\n                    } else {\n                        // TODO: Defer siblings if we're not at the right index for this slot.\n                        // I.e. if we had null values before, then we want to defer this\n                        // for each null value. However, we also don't want to call updateSlot\n                        // with the previous one.\n                        previousNewFiber.sibling = newFiber;\n                    }\n                    previousNewFiber = newFiber;\n                    oldFiber = nextOldFiber;\n                }\n                if (step.done) {\n                    // We've reached the end of the new children. We can delete the rest.\n                    deleteRemainingChildren(returnFiber, oldFiber);\n                    if (getIsHydrating()) {\n                        var numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, numberOfForks);\n                    }\n                    return resultingFirstChild;\n                }\n                if (oldFiber === null) {\n                    // If we don't have any more existing children we can choose a fast path\n                    // since the rest will all be insertions.\n                    for(; !step.done; newIdx++, step = newChildren.next(), knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber)){\n                        var _newFiber3 = createChild(returnFiber, step.value, lanes, debugInfo);\n                        if (_newFiber3 === null) {\n                            continue;\n                        }\n                        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            // TODO: Move out of the loop. This only happens for the first run.\n                            resultingFirstChild = _newFiber3;\n                        } else {\n                            previousNewFiber.sibling = _newFiber3;\n                        }\n                        previousNewFiber = _newFiber3;\n                    }\n                    if (getIsHydrating()) {\n                        var _numberOfForks3 = newIdx;\n                        pushTreeFork(returnFiber, _numberOfForks3);\n                    }\n                    return resultingFirstChild;\n                } // Add all children to a key map for quick lookups.\n                var existingChildren = mapRemainingChildren(oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n                for(; !step.done; newIdx++, step = newChildren.next(), knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber)){\n                    var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes, debugInfo);\n                    if (_newFiber4 !== null) {\n                        if (shouldTrackSideEffects) {\n                            if (_newFiber4.alternate !== null) {\n                                // The new fiber is a work in progress, but if there exists a\n                                // current, that means that we reused the fiber. We need to delete\n                                // it from the child list so that we don't add it to the deletion\n                                // list.\n                                existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n                            }\n                        }\n                        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            resultingFirstChild = _newFiber4;\n                        } else {\n                            previousNewFiber.sibling = _newFiber4;\n                        }\n                        previousNewFiber = _newFiber4;\n                    }\n                }\n                if (shouldTrackSideEffects) {\n                    // Any existing children that weren't consumed above were deleted. We need\n                    // to add them to the deletion list.\n                    existingChildren.forEach(function(child) {\n                        return deleteChild(returnFiber, child);\n                    });\n                }\n                if (getIsHydrating()) {\n                    var _numberOfForks4 = newIdx;\n                    pushTreeFork(returnFiber, _numberOfForks4);\n                }\n                return resultingFirstChild;\n            }\n            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n                // There's no need to check for keys on text nodes since we don't have a\n                // way to define them.\n                if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n                    // We already have an existing node so let's just update it and delete\n                    // the rest.\n                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                    var existing = useFiber(currentFirstChild, textContent);\n                    existing.return = returnFiber;\n                    return existing;\n                } // The existing first child is not a text node so we need to create one\n                // and delete the existing ones.\n                deleteRemainingChildren(returnFiber, currentFirstChild);\n                var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n                created.return = returnFiber;\n                return created;\n            }\n            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes, debugInfo) {\n                var key = element.key;\n                var child = currentFirstChild;\n                while(child !== null){\n                    // TODO: If key === null and child.key === null, then this only applies to\n                    // the first item in the list.\n                    if (child.key === key) {\n                        var elementType = element.type;\n                        if (elementType === REACT_FRAGMENT_TYPE) {\n                            if (child.tag === Fragment) {\n                                deleteRemainingChildren(returnFiber, child.sibling);\n                                var existing = useFiber(child, element.props.children);\n                                existing.return = returnFiber;\n                                {\n                                    existing._debugOwner = element._owner;\n                                    existing._debugInfo = debugInfo;\n                                }\n                                validateFragmentProps(element, existing, returnFiber);\n                                return existing;\n                            }\n                        } else {\n                            if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.\n                            // We need to do this after the Hot Reloading check above,\n                            // because hot reloading has different semantics than prod because\n                            // it doesn't resuspend. So we can't let the call below suspend.\n                            typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n                                deleteRemainingChildren(returnFiber, child.sibling);\n                                var _existing = useFiber(child, element.props);\n                                coerceRef(returnFiber, child, _existing, element);\n                                _existing.return = returnFiber;\n                                {\n                                    _existing._debugOwner = element._owner;\n                                    _existing._debugInfo = debugInfo;\n                                }\n                                return _existing;\n                            }\n                        } // Didn't match.\n                        deleteRemainingChildren(returnFiber, child);\n                        break;\n                    } else {\n                        deleteChild(returnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n                if (element.type === REACT_FRAGMENT_TYPE) {\n                    var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    validateFragmentProps(element, created, returnFiber);\n                    return created;\n                } else {\n                    var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n                    coerceRef(returnFiber, currentFirstChild, _created4, element);\n                    _created4.return = returnFiber;\n                    {\n                        _created4._debugInfo = debugInfo;\n                    }\n                    return _created4;\n                }\n            }\n            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes, debugInfo) {\n                var key = portal.key;\n                var child = currentFirstChild;\n                while(child !== null){\n                    // TODO: If key === null and child.key === null, then this only applies to\n                    // the first item in the list.\n                    if (child.key === key) {\n                        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n                            deleteRemainingChildren(returnFiber, child.sibling);\n                            var existing = useFiber(child, portal.children || []);\n                            existing.return = returnFiber;\n                            return existing;\n                        } else {\n                            deleteRemainingChildren(returnFiber, child);\n                            break;\n                        }\n                    } else {\n                        deleteChild(returnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n                created.return = returnFiber;\n                return created;\n            } // This API will tag the children with the side-effect of the reconciliation\n            // itself. They will be added to the side-effect list as we pass through the\n            // children and the parent.\n            function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes, debugInfo) {\n                // This function is only recursive for Usables/Lazy and not nested arrays.\n                // That's so that using a Lazy wrapper is unobservable to the Fragment\n                // convention.\n                // If the top level item is an array, we treat it as a set of children,\n                // not as a fragment. Nested arrays on the other hand will be treated as\n                // fragment nodes. Recursion happens at the normal flow.\n                // Handle top level unkeyed fragments as if they were arrays.\n                // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n                // We treat the ambiguous cases above the same.\n                // We don't use recursion here because a fragment inside a fragment\n                // is no longer considered \"top level\" for these purposes.\n                var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n                if (isUnkeyedTopLevelFragment) {\n                    validateFragmentProps(newChild, null, returnFiber);\n                    newChild = newChild.props.children;\n                } // Handle object types\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo)));\n                        case REACT_PORTAL_TYPE:\n                            return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n                        case REACT_LAZY_TYPE:\n                            var payload = newChild._payload;\n                            var init = newChild._init;\n                            return reconcileChildFibersImpl(returnFiber, currentFirstChild, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (isArray(newChild)) {\n                        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (getIteratorFn(newChild)) {\n                        return reconcileChildrenIteratable(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    // a child position, it unwraps it using the same algorithm as `use`. For\n                    // example, for promises, React will throw an exception to unwind the\n                    // stack, then replay the component once the promise resolves.\n                    //\n                    // A difference from `use` is that React will keep unwrapping the value\n                    // until it reaches a non-Usable type.\n                    //\n                    // e.g. Usable<Usable<Usable<T>>> should resolve to T\n                    //\n                    // The structure is a bit unfortunate. Ideally, we shouldn't need to\n                    // replay the entire begin phase of the parent fiber in order to reconcile\n                    // the children again. This would require a somewhat significant refactor,\n                    // because reconcilation happens deep within the begin phase, and\n                    // depending on the type of work, not always at the end. We should\n                    // consider as an future improvement.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(thenable), lanes, mergeDebugInfo(debugInfo, thenable._debugInfo));\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return deleteRemainingChildren(returnFiber, currentFirstChild);\n            }\n            function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n                // This indirection only exists so we can reset `thenableState` at the end.\n                // It should get inlined by Closure.\n                thenableIndexCounter$1 = 0;\n                var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes, null // debugInfo\n                );\n                thenableState$1 = null; // Don't bother to reset `thenableIndexCounter` to 0 because it always gets\n                // set at the beginning.\n                return firstChildFiber;\n            }\n            return reconcileChildFibers;\n        }\n        var reconcileChildFibers = createChildReconciler(true);\n        var mountChildFibers = createChildReconciler(false);\n        function resetChildReconcilerOnUnwind() {\n            // On unwind, clear any pending thenables that were used.\n            thenableState$1 = null;\n            thenableIndexCounter$1 = 0;\n        }\n        function cloneChildFibers(current, workInProgress) {\n            if (current !== null && workInProgress.child !== current.child) {\n                throw new Error('Resuming work not yet implemented.');\n            }\n            if (workInProgress.child === null) {\n                return;\n            }\n            var currentChild = workInProgress.child;\n            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n            workInProgress.child = newChild;\n            newChild.return = workInProgress;\n            while(currentChild.sibling !== null){\n                currentChild = currentChild.sibling;\n                newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n                newChild.return = workInProgress;\n            }\n            newChild.sibling = null;\n        } // Reset a workInProgress child set to prepare it for a second pass.\n        function resetChildFibers(workInProgress, lanes) {\n            var child = workInProgress.child;\n            while(child !== null){\n                resetWorkInProgress(child, lanes);\n                child = child.sibling;\n            }\n        }\n        // TODO: This isn't being used yet, but it's intended to replace the\n        // InvisibleParentContext that is currently managed by SuspenseContext.\n        var currentTreeHiddenStackCursor = createCursor(null);\n        var prevEntangledRenderLanesCursor = createCursor(NoLanes);\n        function pushHiddenContext(fiber, context) {\n            var prevEntangledRenderLanes = getEntangledRenderLanes();\n            push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);\n            push(currentTreeHiddenStackCursor, context, fiber); // When rendering a subtree that's currently hidden, we must include all\n            // lanes that would have rendered if the hidden subtree hadn't been deferred.\n            // That is, in order to reveal content from hidden -> visible, we must commit\n            // all the updates that we skipped when we originally hid the tree.\n            setEntangledRenderLanes(mergeLanes(prevEntangledRenderLanes, context.baseLanes));\n        }\n        function reuseHiddenContextOnStack(fiber) {\n            // This subtree is not currently hidden, so we don't need to add any lanes\n            // to the render lanes. But we still need to push something to avoid a\n            // context mismatch. Reuse the existing context on the stack.\n            push(prevEntangledRenderLanesCursor, getEntangledRenderLanes(), fiber);\n            push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);\n        }\n        function popHiddenContext(fiber) {\n            // Restore the previous render lanes from the stack\n            setEntangledRenderLanes(prevEntangledRenderLanesCursor.current);\n            pop(currentTreeHiddenStackCursor, fiber);\n            pop(prevEntangledRenderLanesCursor, fiber);\n        }\n        function isCurrentTreeHidden() {\n            return currentTreeHiddenStackCursor.current !== null;\n        }\n        // suspends, i.e. it's the nearest `catch` block on the stack.\n        var suspenseHandlerStackCursor = createCursor(null); // Represents the outermost boundary that is not visible in the current tree.\n        // Everything above this is the \"shell\". When this is null, it means we're\n        // rendering in the shell of the app. If it's non-null, it means we're rendering\n        // deeper than the shell, inside a new tree that wasn't already visible.\n        //\n        // The main way we use this concept is to determine whether showing a fallback\n        // would result in a desirable or undesirable loading state. Activing a fallback\n        // in the shell is considered an undersirable loading state, because it would\n        // mean hiding visible (albeit stale) content in the current tree — we prefer to\n        // show the stale content, rather than switch to a fallback. But showing a\n        // fallback in a new tree is fine, because there's no stale content to\n        // prefer instead.\n        var shellBoundary = null;\n        function getShellBoundary() {\n            return shellBoundary;\n        }\n        function pushPrimaryTreeSuspenseHandler(handler) {\n            // TODO: Pass as argument\n            var current = handler.alternate;\n            // propagated a single level. For example, when ForceSuspenseFallback is set,\n            // it should only force the nearest Suspense boundary into fallback mode.\n            pushSuspenseListContext(handler, setDefaultShallowSuspenseListContext(suspenseStackCursor.current)); // Experimental feature: Some Suspense boundaries are marked as having an\n            // to push a nested Suspense handler, because it will get replaced by the\n            // outer fallback, anyway. Consider this as a future optimization.\n            push(suspenseHandlerStackCursor, handler, handler);\n            if (shellBoundary === null) {\n                if (current === null || isCurrentTreeHidden()) {\n                    // This boundary is not visible in the current UI.\n                    shellBoundary = handler;\n                } else {\n                    var prevState = current.memoizedState;\n                    if (prevState !== null) {\n                        // This boundary is showing a fallback in the current UI.\n                        shellBoundary = handler;\n                    }\n                }\n            }\n        }\n        function pushFallbackTreeSuspenseHandler(fiber) {\n            // We're about to render the fallback. If something in the fallback suspends,\n            // it's akin to throwing inside of a `catch` block. This boundary should not\n            // capture. Reuse the existing handler on the stack.\n            reuseSuspenseHandlerOnStack(fiber);\n        }\n        function pushOffscreenSuspenseHandler(fiber) {\n            if (fiber.tag === OffscreenComponent) {\n                // A SuspenseList context is only pushed here to avoid a push/pop mismatch.\n                // Reuse the current value on the stack.\n                // TODO: We can avoid needing to push here by by forking popSuspenseHandler\n                // into separate functions for Suspense and Offscreen.\n                pushSuspenseListContext(fiber, suspenseStackCursor.current);\n                push(suspenseHandlerStackCursor, fiber, fiber);\n                if (shellBoundary !== null) ;\n                else {\n                    var current = fiber.alternate;\n                    if (current !== null) {\n                        var prevState = current.memoizedState;\n                        if (prevState !== null) {\n                            // This is the first boundary in the stack that's already showing\n                            // a fallback. So everything outside is considered the shell.\n                            shellBoundary = fiber;\n                        }\n                    }\n                }\n            } else {\n                // This is a LegacyHidden component.\n                reuseSuspenseHandlerOnStack(fiber);\n            }\n        }\n        function reuseSuspenseHandlerOnStack(fiber) {\n            pushSuspenseListContext(fiber, suspenseStackCursor.current);\n            push(suspenseHandlerStackCursor, getSuspenseHandler(), fiber);\n        }\n        function getSuspenseHandler() {\n            return suspenseHandlerStackCursor.current;\n        }\n        function popSuspenseHandler(fiber) {\n            pop(suspenseHandlerStackCursor, fiber);\n            if (shellBoundary === fiber) {\n                // Popping back into the shell.\n                shellBoundary = null;\n            }\n            popSuspenseListContext(fiber);\n        } // SuspenseList context\n        // TODO: Move to a separate module? We may change the SuspenseList\n        // implementation to hide/show in the commit phase, anyway.\n        var DefaultSuspenseContext = 0;\n        var SubtreeSuspenseContextMask = 1; // ForceSuspenseFallback can be used by SuspenseList to force newly added\n        // items into their fallback state during one of the render passes.\n        var ForceSuspenseFallback = 2;\n        var suspenseStackCursor = createCursor(DefaultSuspenseContext);\n        function hasSuspenseListContext(parentContext, flag) {\n            return (parentContext & flag) !== 0;\n        }\n        function setDefaultShallowSuspenseListContext(parentContext) {\n            return parentContext & SubtreeSuspenseContextMask;\n        }\n        function setShallowSuspenseListContext(parentContext, shallowContext) {\n            return parentContext & SubtreeSuspenseContextMask | shallowContext;\n        }\n        function pushSuspenseListContext(fiber, newContext) {\n            push(suspenseStackCursor, newContext, fiber);\n        }\n        function popSuspenseListContext(fiber) {\n            pop(suspenseStackCursor, fiber);\n        }\n        // A non-null SuspenseState means that it is blocked for one reason or another.\n        // - A non-null dehydrated field means it's blocked pending hydration.\n        //   - A non-null dehydrated field can use isSuspenseInstancePending or\n        //     isSuspenseInstanceFallback to query the reason for being dehydrated.\n        // - A null dehydrated field means it's blocked by something suspending and\n        //   we're currently showing a fallback instead.\n        function findFirstSuspended(row) {\n            var node = row;\n            while(node !== null){\n                if (node.tag === SuspenseComponent) {\n                    var state = node.memoizedState;\n                    if (state !== null) {\n                        var dehydrated = state.dehydrated;\n                        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n                            return node;\n                        }\n                    }\n                } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n                // keep track of whether it suspended or not.\n                node.memoizedProps.revealOrder !== undefined) {\n                    var didSuspend = (node.flags & DidCapture) !== NoFlags$1;\n                    if (didSuspend) {\n                        return node;\n                    }\n                } else if (node.child !== null) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === row) {\n                    return null;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === row) {\n                        return null;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n            return null;\n        }\n        var NoFlags = /*   */ 0; // Represents whether effect should fire.\n        var HasEffect = /* */ 1; // Represents the phase in which the effect (not the clean-up) fires.\n        var Insertion = /* */ 2;\n        var Layout = /*    */ 4;\n        var Passive = /*   */ 8;\n        var didWarnAboutMismatchedHooksForComponent;\n        var didWarnUncachedGetSnapshot;\n        var didWarnAboutUseWrappedInTryCatch;\n        var didWarnAboutAsyncClientComponent;\n        var didWarnAboutUseFormState;\n        {\n            didWarnAboutMismatchedHooksForComponent = new Set();\n            didWarnAboutUseWrappedInTryCatch = new Set();\n            didWarnAboutAsyncClientComponent = new Set();\n            didWarnAboutUseFormState = new Set();\n        }\n        // lifetime of an effect. In Rust terms, a RefCell. We use it to store the\n        // \"destroy\" function that is returned from an effect, because that is stateful.\n        // The field is `undefined` if the effect is unmounted, or if the effect ran\n        // but is not stateful. We don't explicitly track whether the effect is mounted\n        // or unmounted because that can be inferred by the hiddenness of the fiber in\n        // the tree, i.e. whether there is a hidden Offscreen fiber above it.\n        //\n        // It's unfortunate that this is stored on a separate object, because it adds\n        // more memory per effect instance, but it's conceptually sound. I think there's\n        // likely a better data structure we could use for effects; perhaps just one\n        // array of effect instances per fiber. But I think this is OK for now despite\n        // the additional memory and we can follow up with performance\n        // optimizations later.\n        // These are set right before calling the component.\n        var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\n        // the work-in-progress hook.\n        var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n        // current hook list is the list that belongs to the current fiber. The\n        // work-in-progress hook list is a new list that will be added to the\n        // work-in-progress fiber.\n        var currentHook = null;\n        var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n        // does not get reset if we do another render pass; only when we're completely\n        // finished evaluating this component. This is an optimization so we know\n        // whether we need to clear render phase updates after a throw.\n        var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\n        // gets reset after each attempt.\n        // TODO: Maybe there's some way to consolidate this with\n        // `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n        var didScheduleRenderPhaseUpdateDuringThisPass = false;\n        var shouldDoubleInvokeUserFnsInHooksDEV = false; // Counts the number of useId hooks in this component.\n        var localIdCounter = 0; // Counts number of `use`-d thenables\n        var thenableIndexCounter = 0;\n        var thenableState = null; // Used for ids that are generated completely client-side (i.e. not during\n        // hydration). This counter is global, so client ids are not stable across\n        // render attempts.\n        var globalClientIdCounter = 0;\n        var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n        // The list stores the order of hooks used during the initial render (mount).\n        // Subsequent renders (updates) reference this list.\n        var hookTypesDev = null;\n        var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n        // the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n        // When true, such Hooks will always be \"remounted\". Only used during hot reload.\n        var ignorePreviousDependencies = false;\n        function mountHookTypesDev() {\n            {\n                var hookName = currentHookNameInDev;\n                if (hookTypesDev === null) {\n                    hookTypesDev = [\n                        hookName\n                    ];\n                } else {\n                    hookTypesDev.push(hookName);\n                }\n            }\n        }\n        function updateHookTypesDev() {\n            {\n                var hookName = currentHookNameInDev;\n                if (hookTypesDev !== null) {\n                    hookTypesUpdateIndexDev++;\n                    if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n                        warnOnHookMismatchInDev(hookName);\n                    }\n                }\n            }\n        }\n        function checkDepsAreArrayDev(deps) {\n            {\n                if (deps !== undefined && deps !== null && !isArray(deps)) {\n                    // Verify deps, but only on mount to avoid extra checks.\n                    // It's unlikely their type would change as usually you define them inline.\n                    error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);\n                }\n            }\n        }\n        function warnOnHookMismatchInDev(currentHookName) {\n            {\n                var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n                    didWarnAboutMismatchedHooksForComponent.add(componentName);\n                    if (hookTypesDev !== null) {\n                        var table = '';\n                        var secondColumnStart = 30;\n                        for(var i = 0; i <= hookTypesUpdateIndexDev; i++){\n                            var oldHookName = hookTypesDev[i];\n                            var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n                            var row = i + 1 + \". \" + oldHookName; // Extra space so second column lines up\n                            // lol @ IE not supporting String#repeat\n                            while(row.length < secondColumnStart){\n                                row += ' ';\n                            }\n                            row += newHookName + '\\n';\n                            table += row;\n                        }\n                        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\\n\\n' + '   Previous render            Next render\\n' + '   ------------------------------------------------------\\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n', componentName, table);\n                    }\n                }\n            }\n        }\n        function warnOnUseFormStateInDev() {\n            {\n                var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                if (!didWarnAboutUseFormState.has(componentName)) {\n                    didWarnAboutUseFormState.add(componentName);\n                    error('ReactDOM.useFormState has been renamed to React.useActionState. ' + 'Please update %s to use React.useActionState.', componentName);\n                }\n            }\n        }\n        function warnIfAsyncClientComponent(Component) {\n            {\n                // This dev-only check only works for detecting native async functions,\n                // not transpiled ones. There's also a prod check that we use to prevent\n                // async client components from crashing the app; the prod one works even\n                // for transpiled async functions. Neither mechanism is completely\n                // bulletproof but together they cover the most common cases.\n                var isAsyncFunction = Object.prototype.toString.call(Component) === '[object AsyncFunction]' || // $FlowIgnore[method-unbinding]\n                Object.prototype.toString.call(Component) === '[object AsyncGeneratorFunction]';\n                if (isAsyncFunction) {\n                    // Encountered an async Client Component. This is not yet supported.\n                    var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                    if (!didWarnAboutAsyncClientComponent.has(componentName)) {\n                        didWarnAboutAsyncClientComponent.add(componentName);\n                        error('async/await is not yet supported in Client Components, only ' + 'Server Components. This error is often caused by accidentally ' + \"adding `'use client'` to a module that was originally written \" + 'for the server.');\n                    }\n                }\n            }\n        }\n        function throwInvalidHookError() {\n            throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.');\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            {\n                if (ignorePreviousDependencies) {\n                    // Only true when this component is being hot reloaded.\n                    return false;\n                }\n            }\n            if (prevDeps === null) {\n                {\n                    error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\\n\\n' + 'Previous: %s\\n' + 'Incoming: %s', currentHookNameInDev, \"[\" + prevDeps.join(', ') + \"]\", \"[\" + nextDeps.join(', ') + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                // $FlowFixMe[incompatible-use] found when upgrading Flow\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n            renderLanes = nextRenderLanes;\n            currentlyRenderingFiber$1 = workInProgress;\n            {\n                hookTypesDev = current !== null ? current._debugHookTypes : null;\n                hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n                warnIfAsyncClientComponent(Component);\n            }\n            workInProgress.memoizedState = null;\n            workInProgress.updateQueue = null;\n            workInProgress.lanes = NoLanes; // The following should have already been reset\n            // currentHook = null;\n            // workInProgressHook = null;\n            // didScheduleRenderPhaseUpdate = false;\n            // localIdCounter = 0;\n            // thenableIndexCounter = 0;\n            // thenableState = null;\n            // TODO Warn if no hooks are used at all during mount, then some are used during update.\n            // Currently we will identify the update render as a mount because memoizedState === null.\n            // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n            // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n            // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n            // so memoizedState would be null during updates and mounts.\n            {\n                if (current !== null && current.memoizedState !== null) {\n                    ReactSharedInternals.H = HooksDispatcherOnUpdateInDEV;\n                } else if (hookTypesDev !== null) {\n                    // This dispatcher handles an edge case where a component is updating,\n                    // but no stateful hooks have been used.\n                    // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n                    // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n                    // This dispatcher does that.\n                    ReactSharedInternals.H = HooksDispatcherOnMountWithHookTypesInDEV;\n                } else {\n                    ReactSharedInternals.H = HooksDispatcherOnMountInDEV;\n                }\n            }\n            // help detect side effects. The logic for how this is implemented for in\n            // hook components is a bit complex so let's break it down.\n            //\n            // We will invoke the entire component function twice. However, during the\n            // second invocation of the component, the hook state from the first\n            // invocation will be reused. That means things like `useMemo` functions won't\n            // run again, because the deps will match and the memoized result will\n            // be reused.\n            //\n            // We want memoized functions to run twice, too, so account for this, user\n            // functions are double invoked during the *first* invocation of the component\n            // function, and are *not* double invoked during the second incovation:\n            //\n            // - First execution of component function: user functions are double invoked\n            // - Second execution of component function (in Strict Mode, during\n            //   development): user functions are not double invoked.\n            //\n            // This is intentional for a few reasons; most importantly, it's because of\n            // how `use` works when something suspends: it reuses the promise that was\n            // passed during the first attempt. This is itself a form of memoization.\n            // We need to be able to memoize the reactive inputs to the `use` call using\n            // a hook (i.e. `useMemo`), which means, the reactive inputs to `use` must\n            // come from the same component invocation as the output.\n            //\n            // There are plenty of tests to ensure this behavior is correct.\n            var shouldDoubleRenderDEV = (workInProgress.mode & StrictLegacyMode) !== NoMode;\n            shouldDoubleInvokeUserFnsInHooksDEV = shouldDoubleRenderDEV;\n            var children = Component(props, secondArg);\n            shouldDoubleInvokeUserFnsInHooksDEV = false; // Check if there was a render phase update\n            if (didScheduleRenderPhaseUpdateDuringThisPass) {\n                // Keep rendering until the component stabilizes (there are no more render\n                // phase updates).\n                children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            }\n            if (shouldDoubleRenderDEV) {\n                // In development, components are invoked twice to help detect side effects.\n                setIsStrictModeForDevtools(true);\n                try {\n                    children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n                } finally{\n                    setIsStrictModeForDevtools(false);\n                }\n            }\n            finishRenderingHooks(current, workInProgress);\n            return children;\n        }\n        function finishRenderingHooks(current, workInProgress, Component) {\n            {\n                workInProgress._debugHookTypes = hookTypesDev;\n            }\n            // at the beginning of the render phase and there's no re-entrance.\n            ReactSharedInternals.H = ContextOnlyDispatcher; // This check uses currentHook so that it works the same in DEV and prod bundles.\n            // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n            renderLanes = NoLanes;\n            currentlyRenderingFiber$1 = null;\n            currentHook = null;\n            workInProgressHook = null;\n            {\n                currentHookNameInDev = null;\n                hookTypesDev = null;\n                hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last\n                // render. If this fires, it suggests that we incorrectly reset the static\n                // flags in some other part of the codebase. This has happened before, for\n                // example, in the SuspenseList implementation.\n                if (current !== null && (current.flags & StaticMask) !== (workInProgress.flags & StaticMask) && // and creates false positives. To make this work in legacy mode, we'd\n                // need to mark fibers that commit in an incomplete state, somehow. For\n                // now I'll disable the warning that most of the bugs that would trigger\n                // it are either exclusive to concurrent mode or exist in both.\n                disableLegacyMode) {\n                    error('Internal React error: Expected static flag was missing. Please ' + 'notify the React team.');\n                }\n            }\n            didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook\n            // localIdCounter = 0;\n            thenableIndexCounter = 0;\n            thenableState = null;\n            if (didRenderTooFewHooks) {\n                throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');\n            }\n            {\n                if (checkIfUseWrappedInTryCatch()) {\n                    var componentName = getComponentNameFromFiber(workInProgress) || 'Unknown';\n                    if (!didWarnAboutUseWrappedInTryCatch.has(componentName) && // This warning also fires if you suspend with `use` inside an\n                    // async component. Since we warn for that above, we'll silence this\n                    // second warning by checking here.\n                    !didWarnAboutAsyncClientComponent.has(componentName)) {\n                        didWarnAboutUseWrappedInTryCatch.add(componentName);\n                        error('`use` was called from inside a try/catch block. This is not allowed ' + 'and can lead to unexpected behavior. To handle errors triggered ' + 'by `use`, wrap your component in a error boundary.');\n                    }\n                }\n            }\n        }\n        function replaySuspendedComponentWithHooks(current, workInProgress, Component, props, secondArg) {\n            // This function is used to replay a component that previously suspended,\n            // after its data resolves.\n            //\n            // It's a simplified version of renderWithHooks, but it doesn't need to do\n            // most of the set up work because they weren't reset when we suspended; they\n            // only get reset when the component either completes (finishRenderingHooks)\n            // or unwinds (resetHooksOnUnwind).\n            {\n                hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n            }\n            var children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            finishRenderingHooks(current, workInProgress);\n            return children;\n        }\n        function renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n            // This is used to perform another render pass. It's used when setState is\n            // called during render, and for double invoking components in Strict Mode\n            // during development.\n            //\n            // The state from the previous pass is reused whenever possible. So, state\n            // updates that were already processed are not processed again, and memoized\n            // functions (`useMemo`) are not invoked again.\n            //\n            // Keep rendering in a loop for as long as render phase updates continue to\n            // be scheduled. Use a counter to prevent infinite loops.\n            currentlyRenderingFiber$1 = workInProgress;\n            var numberOfReRenders = 0;\n            var children;\n            do {\n                if (didScheduleRenderPhaseUpdateDuringThisPass) {\n                    // It's possible that a use() value depended on a state that was updated in\n                    // this rerender, so we need to watch for different thenables this time.\n                    thenableState = null;\n                }\n                thenableIndexCounter = 0;\n                didScheduleRenderPhaseUpdateDuringThisPass = false;\n                if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                    throw new Error('Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');\n                }\n                numberOfReRenders += 1;\n                {\n                    // Even when hot reloading, allow dependencies to stabilize\n                    // after first render to prevent infinite render phase updates.\n                    ignorePreviousDependencies = false;\n                }\n                currentHook = null;\n                workInProgressHook = null;\n                workInProgress.updateQueue = null;\n                {\n                    // Also validate hook order for cascading updates.\n                    hookTypesUpdateIndexDev = -1;\n                }\n                ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;\n                children = Component(props, secondArg);\n            }while (didScheduleRenderPhaseUpdateDuringThisPass);\n            return children;\n        }\n        function renderTransitionAwareHostComponentWithHooks(current, workInProgress, lanes) {\n            return renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, lanes);\n        }\n        function TransitionAwareHostComponent() {\n            var dispatcher = ReactSharedInternals.H;\n            var _dispatcher$useState = dispatcher.useState(), maybeThenable = _dispatcher$useState[0];\n            var nextState;\n            if (typeof maybeThenable.then === 'function') {\n                var thenable = maybeThenable;\n                nextState = useThenable(thenable);\n            } else {\n                var status = maybeThenable;\n                nextState = status;\n            } // The \"reset state\" is an object. If it changes, that means something\n            // requested that we reset the form.\n            var _dispatcher$useState2 = dispatcher.useState(), nextResetState = _dispatcher$useState2[0];\n            var prevResetState = currentHook !== null ? currentHook.memoizedState : null;\n            if (prevResetState !== nextResetState) {\n                // Schedule a form reset\n                currentlyRenderingFiber$1.flags |= FormReset;\n            }\n            return nextState;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every renderWithHooks call.\n            // Conceptually, it's part of the return value of renderWithHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            localIdCounter = 0;\n            return didRenderIdHook;\n        }\n        function bailoutHooks(current, workInProgress, lanes) {\n            workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the\n            // complete phase (bubbleProperties).\n            if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                workInProgress.flags &= ~(MountPassiveDev | MountLayoutDev | Passive$1 | Update);\n            } else {\n                workInProgress.flags &= ~(Passive$1 | Update);\n            }\n            current.lanes = removeLanes(current.lanes, lanes);\n        }\n        function resetHooksAfterThrow() {\n            // This is called immediaetly after a throw. It shouldn't reset the entire\n            // module state, because the work loop might decide to replay the component\n            // again without rewinding.\n            //\n            // It should only reset things like the current dispatcher, to prevent hooks\n            // from being called outside of a component.\n            currentlyRenderingFiber$1 = null; // We can assume the previous dispatcher is always this one, since we set it\n            // at the beginning of the render phase and there's no re-entrance.\n            ReactSharedInternals.H = ContextOnlyDispatcher;\n        }\n        function resetHooksOnUnwind(workInProgress) {\n            if (didScheduleRenderPhaseUpdate) {\n                // There were render phase updates. These are only valid for this render\n                // phase, which we are now aborting. Remove the updates from the queues so\n                // they do not persist to the next render. Do not remove updates from hooks\n                // that weren't processed.\n                //\n                // Only reset the updates from the queue if it has a clone. If it does\n                // not have a clone, that means it wasn't processed, and the updates were\n                // scheduled before we entered the render phase.\n                var hook = workInProgress.memoizedState;\n                while(hook !== null){\n                    var queue = hook.queue;\n                    if (queue !== null) {\n                        queue.pending = null;\n                    }\n                    hook = hook.next;\n                }\n                didScheduleRenderPhaseUpdate = false;\n            }\n            renderLanes = NoLanes;\n            currentlyRenderingFiber$1 = null;\n            currentHook = null;\n            workInProgressHook = null;\n            {\n                hookTypesDev = null;\n                hookTypesUpdateIndexDev = -1;\n                currentHookNameInDev = null;\n            }\n            didScheduleRenderPhaseUpdateDuringThisPass = false;\n            localIdCounter = 0;\n            thenableIndexCounter = 0;\n            thenableState = null;\n        }\n        function mountWorkInProgressHook() {\n            var hook = {\n                memoizedState: null,\n                baseState: null,\n                baseQueue: null,\n                queue: null,\n                next: null\n            };\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\n            } else {\n                // Append to the end of the list\n                workInProgressHook = workInProgressHook.next = hook;\n            }\n            return workInProgressHook;\n        }\n        function updateWorkInProgressHook() {\n            // This function is used both for updates and for re-renders triggered by a\n            // render phase update. It assumes there is either a current hook we can\n            // clone, or a work-in-progress hook from a previous render pass that we can\n            // use as a base.\n            var nextCurrentHook;\n            if (currentHook === null) {\n                var current = currentlyRenderingFiber$1.alternate;\n                if (current !== null) {\n                    nextCurrentHook = current.memoizedState;\n                } else {\n                    nextCurrentHook = null;\n                }\n            } else {\n                nextCurrentHook = currentHook.next;\n            }\n            var nextWorkInProgressHook;\n            if (workInProgressHook === null) {\n                nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\n            } else {\n                nextWorkInProgressHook = workInProgressHook.next;\n            }\n            if (nextWorkInProgressHook !== null) {\n                // There's already a work-in-progress. Reuse it.\n                workInProgressHook = nextWorkInProgressHook;\n                nextWorkInProgressHook = workInProgressHook.next;\n                currentHook = nextCurrentHook;\n            } else {\n                // Clone from the current hook.\n                if (nextCurrentHook === null) {\n                    var currentFiber = currentlyRenderingFiber$1.alternate;\n                    if (currentFiber === null) {\n                        // This is the initial render. This branch is reached when the component\n                        // suspends, resumes, then renders an additional hook.\n                        // Should never be reached because we should switch to the mount dispatcher first.\n                        throw new Error('Update hook called on initial render. This is likely a bug in React. Please file an issue.');\n                    } else {\n                        // This is an update. We should always have a current hook.\n                        throw new Error('Rendered more hooks than during the previous render.');\n                    }\n                }\n                currentHook = nextCurrentHook;\n                var newHook = {\n                    memoizedState: currentHook.memoizedState,\n                    baseState: currentHook.baseState,\n                    baseQueue: currentHook.baseQueue,\n                    queue: currentHook.queue,\n                    next: null\n                };\n                if (workInProgressHook === null) {\n                    // This is the first hook in the list.\n                    currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\n                } else {\n                    // Append to the end of the list.\n                    workInProgressHook = workInProgressHook.next = newHook;\n                }\n            }\n            return workInProgressHook;\n        } // NOTE: defining two versions of this function to avoid size impact when this feature is disabled.\n        // Previously this function was inlined, the additional `memoCache` property makes it not inlined.\n        var createFunctionComponentUpdateQueue;\n        {\n            createFunctionComponentUpdateQueue = function() {\n                return {\n                    lastEffect: null,\n                    events: null,\n                    stores: null,\n                    memoCache: null\n                };\n            };\n        }\n        function useThenable(thenable) {\n            // Track the position of the thenable within this fiber.\n            var index = thenableIndexCounter;\n            thenableIndexCounter += 1;\n            if (thenableState === null) {\n                thenableState = createThenableState();\n            }\n            var result = trackUsedThenable(thenableState, thenable, index);\n            if (currentlyRenderingFiber$1.alternate === null && (workInProgressHook === null ? currentlyRenderingFiber$1.memoizedState === null : workInProgressHook.next === null)) {\n                // Initial render, and either this is the first time the component is\n                // called, or there were no Hooks called after this use() the previous\n                // time (perhaps because it threw). Subsequent Hook calls should use the\n                // mount dispatcher.\n                {\n                    ReactSharedInternals.H = HooksDispatcherOnMountInDEV;\n                }\n            }\n            return result;\n        }\n        function use(usable) {\n            if (usable !== null && typeof usable === 'object') {\n                // $FlowFixMe[method-unbinding]\n                if (typeof usable.then === 'function') {\n                    // This is a thenable.\n                    var thenable = usable;\n                    return useThenable(thenable);\n                } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {\n                    var context = usable;\n                    return readContext(context);\n                }\n            } // eslint-disable-next-line react-internal/safe-string-coercion\n            throw new Error('An unsupported type was passed to use(): ' + String(usable));\n        }\n        function useMemoCache(size) {\n            var memoCache = null; // Fast-path, load memo cache from wip fiber if already prepared\n            var updateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (updateQueue !== null) {\n                memoCache = updateQueue.memoCache;\n            } // Otherwise clone from the current fiber\n            if (memoCache == null) {\n                var current = currentlyRenderingFiber$1.alternate;\n                if (current !== null) {\n                    var currentUpdateQueue = current.updateQueue;\n                    if (currentUpdateQueue !== null) {\n                        var currentMemoCache = currentUpdateQueue.memoCache;\n                        if (currentMemoCache != null) {\n                            memoCache = {\n                                // When enableNoCloningMemoCache is enabled, instead of treating the\n                                // cache as copy-on-write, like we do with fibers, we share the same\n                                // cache instance across all render attempts, even if the component\n                                // is interrupted before it commits.\n                                //\n                                // If an update is interrupted, either because it suspended or\n                                // because of another update, we can reuse the memoized computations\n                                // from the previous attempt. We can do this because the React\n                                // Compiler performs atomic writes to the memo cache, i.e. it will\n                                // not record the inputs to a memoization without also recording its\n                                // output.\n                                //\n                                // This gives us a form of \"resuming\" within components and hooks.\n                                //\n                                // This only works when updating a component that already mounted.\n                                // It has no impact during initial render, because the memo cache is\n                                // stored on the fiber, and since we have not implemented resuming\n                                // for fibers, it's always a fresh memo cache, anyway.\n                                //\n                                // However, this alone is pretty useful — it happens whenever you\n                                // update the UI with fresh data after a mutation/action, which is\n                                // extremely common in a Suspense-driven (e.g. RSC or Relay) app.\n                                data: currentMemoCache.data.map(function(array) {\n                                    return array.slice();\n                                }),\n                                index: 0\n                            };\n                        }\n                    }\n                }\n            } // Finally fall back to allocating a fresh instance of the cache\n            if (memoCache == null) {\n                memoCache = {\n                    data: [],\n                    index: 0\n                };\n            }\n            if (updateQueue === null) {\n                updateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = updateQueue;\n            }\n            updateQueue.memoCache = memoCache;\n            var data = memoCache.data[memoCache.index];\n            if (data === undefined) {\n                data = memoCache.data[memoCache.index] = new Array(size);\n                for(var i = 0; i < size; i++){\n                    data[i] = REACT_MEMO_CACHE_SENTINEL;\n                }\n            } else if (data.length !== size) {\n                // TODO: consider warning or throwing here\n                {\n                    error('Expected a constant size argument for each invocation of useMemoCache. ' + 'The previous cache was allocated with size %s but size %s was requested.', data.length, size);\n                }\n            }\n            memoCache.index++;\n            return data;\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n            return typeof action === 'function' ? action(state) : action;\n        }\n        function mountReducer(reducer, initialArg, init) {\n            var hook = mountWorkInProgressHook();\n            var initialState;\n            if (init !== undefined) {\n                initialState = init(initialArg);\n                if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                    setIsStrictModeForDevtools(true);\n                    init(initialArg);\n                    setIsStrictModeForDevtools(false);\n                }\n            } else {\n                initialState = initialArg;\n            }\n            hook.memoizedState = hook.baseState = initialState;\n            var queue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: reducer,\n                lastRenderedState: initialState\n            };\n            hook.queue = queue;\n            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function updateReducer(reducer, initialArg, init) {\n            var hook = updateWorkInProgressHook();\n            return updateReducerImpl(hook, currentHook, reducer);\n        }\n        function updateReducerImpl(hook, current, reducer) {\n            var queue = hook.queue;\n            if (queue === null) {\n                throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n            }\n            queue.lastRenderedReducer = reducer; // The last rebase update that is NOT part of the base state.\n            var baseQueue = hook.baseQueue; // The last pending update that hasn't been processed yet.\n            var pendingQueue = queue.pending;\n            if (pendingQueue !== null) {\n                // We have new updates that haven't been processed yet.\n                // We'll add them to the base queue.\n                if (baseQueue !== null) {\n                    // Merge the pending queue and the base queue.\n                    var baseFirst = baseQueue.next;\n                    var pendingFirst = pendingQueue.next;\n                    baseQueue.next = pendingFirst;\n                    pendingQueue.next = baseFirst;\n                }\n                {\n                    if (current.baseQueue !== baseQueue) {\n                        // Internal invariant that should never happen, but feasibly could in\n                        // the future if we implement resuming, or some form of that.\n                        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');\n                    }\n                }\n                current.baseQueue = baseQueue = pendingQueue;\n                queue.pending = null;\n            }\n            var baseState = hook.baseState;\n            if (baseQueue === null) {\n                // If there are no pending updates, then the memoized state should be the\n                // same as the base state. Currently these only diverge in the case of\n                // useOptimistic, because useOptimistic accepts a new baseState on\n                // every render.\n                hook.memoizedState = baseState; // We don't need to call markWorkInProgressReceivedUpdate because\n            // baseState is derived from other reactive values.\n            } else {\n                // We have a queue to process.\n                var first = baseQueue.next;\n                var newState = baseState;\n                var newBaseState = null;\n                var newBaseQueueFirst = null;\n                var newBaseQueueLast = null;\n                var update = first;\n                var didReadFromEntangledAsyncAction = false;\n                do {\n                    // An extra OffscreenLane bit is added to updates that were made to\n                    // a hidden tree, so that we can distinguish them from updates that were\n                    // already there when the tree was hidden.\n                    var updateLane = removeLanes(update.lane, OffscreenLane);\n                    var isHiddenUpdate = updateLane !== update.lane; // Check if this update was made while the tree was hidden. If so, then\n                    // it's not a \"base\" update and we should disregard the extra base lanes\n                    // that were added to renderLanes when we entered the Offscreen tree.\n                    var shouldSkipUpdate = isHiddenUpdate ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane) : !isSubsetOfLanes(renderLanes, updateLane);\n                    if (shouldSkipUpdate) {\n                        // Priority is insufficient. Skip this update. If this is the first\n                        // skipped update, the previous update/state is the new base\n                        // update/state.\n                        var clone = {\n                            lane: updateLane,\n                            revertLane: update.revertLane,\n                            action: update.action,\n                            hasEagerState: update.hasEagerState,\n                            eagerState: update.eagerState,\n                            next: null\n                        };\n                        if (newBaseQueueLast === null) {\n                            newBaseQueueFirst = newBaseQueueLast = clone;\n                            newBaseState = newState;\n                        } else {\n                            newBaseQueueLast = newBaseQueueLast.next = clone;\n                        } // Update the remaining priority in the queue.\n                        // TODO: Don't need to accumulate this. Instead, we can remove\n                        // renderLanes from the original lanes.\n                        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\n                        markSkippedUpdateLanes(updateLane);\n                    } else {\n                        // This update does have sufficient priority.\n                        // Check if this is an optimistic update.\n                        var revertLane = update.revertLane;\n                        if (revertLane === NoLane) {\n                            // This is not an optimistic update, and we're going to apply it now.\n                            // But, if there were earlier updates that were skipped, we need to\n                            // leave this update in the queue so it can be rebased later.\n                            if (newBaseQueueLast !== null) {\n                                var _clone = {\n                                    // This update is going to be committed so we never want uncommit\n                                    // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                                    // this will never be skipped by the check above.\n                                    lane: NoLane,\n                                    revertLane: NoLane,\n                                    action: update.action,\n                                    hasEagerState: update.hasEagerState,\n                                    eagerState: update.eagerState,\n                                    next: null\n                                };\n                                newBaseQueueLast = newBaseQueueLast.next = _clone;\n                            } // Check if this update is part of a pending async action. If so,\n                            // we'll need to suspend until the action has finished, so that it's\n                            // batched together with future updates in the same action.\n                            if (updateLane === peekEntangledActionLane()) {\n                                didReadFromEntangledAsyncAction = true;\n                            }\n                        } else {\n                            // This is an optimistic update. If the \"revert\" priority is\n                            // sufficient, don't apply the update. Otherwise, apply the update,\n                            // but leave it in the queue so it can be either reverted or\n                            // rebased in a subsequent render.\n                            if (isSubsetOfLanes(renderLanes, revertLane)) {\n                                // The transition that this optimistic update is associated with\n                                // has finished. Pretend the update doesn't exist by skipping\n                                // over it.\n                                update = update.next; // Check if this update is part of a pending async action. If so,\n                                // we'll need to suspend until the action has finished, so that it's\n                                // batched together with future updates in the same action.\n                                if (revertLane === peekEntangledActionLane()) {\n                                    didReadFromEntangledAsyncAction = true;\n                                }\n                                continue;\n                            } else {\n                                var _clone2 = {\n                                    // Once we commit an optimistic update, we shouldn't uncommit it\n                                    // until the transition it is associated with has finished\n                                    // (represented by revertLane). Using NoLane here works because 0\n                                    // is a subset of all bitmasks, so this will never be skipped by\n                                    // the check above.\n                                    lane: NoLane,\n                                    // Reuse the same revertLane so we know when the transition\n                                    // has finished.\n                                    revertLane: update.revertLane,\n                                    action: update.action,\n                                    hasEagerState: update.hasEagerState,\n                                    eagerState: update.eagerState,\n                                    next: null\n                                };\n                                if (newBaseQueueLast === null) {\n                                    newBaseQueueFirst = newBaseQueueLast = _clone2;\n                                    newBaseState = newState;\n                                } else {\n                                    newBaseQueueLast = newBaseQueueLast.next = _clone2;\n                                } // Update the remaining priority in the queue.\n                                // TODO: Don't need to accumulate this. Instead, we can remove\n                                // renderLanes from the original lanes.\n                                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, revertLane);\n                                markSkippedUpdateLanes(revertLane);\n                            }\n                        } // Process this update.\n                        var action = update.action;\n                        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                            reducer(newState, action);\n                        }\n                        if (update.hasEagerState) {\n                            // If this update is a state update (not a reducer) and was processed eagerly,\n                            // we can use the eagerly computed state\n                            newState = update.eagerState;\n                        } else {\n                            newState = reducer(newState, action);\n                        }\n                    }\n                    update = update.next;\n                }while (update !== null && update !== first);\n                if (newBaseQueueLast === null) {\n                    newBaseState = newState;\n                } else {\n                    newBaseQueueLast.next = newBaseQueueFirst;\n                } // Mark that the fiber performed work, but only if the new state is\n                // different from the current state.\n                if (!objectIs(newState, hook.memoizedState)) {\n                    markWorkInProgressReceivedUpdate(); // Check if this update is part of a pending async action. If so, we'll\n                    // need to suspend until the action has finished, so that it's batched\n                    // together with future updates in the same action.\n                    // TODO: Once we support hooks inside useMemo (or an equivalent\n                    // memoization boundary like Forget), hoist this logic so that it only\n                    // suspends if the memo boundary produces a new value.\n                    if (didReadFromEntangledAsyncAction) {\n                        var entangledActionThenable = peekEntangledActionThenable();\n                        if (entangledActionThenable !== null) {\n                            // TODO: Instead of the throwing the thenable directly, throw a\n                            // special object like `use` does so we can detect if it's captured\n                            // by userspace.\n                            throw entangledActionThenable;\n                        }\n                    }\n                }\n                hook.memoizedState = newState;\n                hook.baseState = newBaseState;\n                hook.baseQueue = newBaseQueueLast;\n                queue.lastRenderedState = newState;\n            }\n            if (baseQueue === null) {\n                // `queue.lanes` is used for entangling transitions. We can set it back to\n                // zero once the queue is empty.\n                queue.lanes = NoLanes;\n            }\n            var dispatch = queue.dispatch;\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function rerenderReducer(reducer, initialArg, init) {\n            var hook = updateWorkInProgressHook();\n            var queue = hook.queue;\n            if (queue === null) {\n                throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n            }\n            queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n            // work-in-progress hook.\n            var dispatch = queue.dispatch;\n            var lastRenderPhaseUpdate = queue.pending;\n            var newState = hook.memoizedState;\n            if (lastRenderPhaseUpdate !== null) {\n                // The queue doesn't persist past this render pass.\n                queue.pending = null;\n                var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                var update = firstRenderPhaseUpdate;\n                do {\n                    // Process this render phase update. We don't have to check the\n                    // priority because it will always be the same as the current\n                    // render's.\n                    var action = update.action;\n                    newState = reducer(newState, action);\n                    update = update.next;\n                }while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n                // different from the current state.\n                if (!objectIs(newState, hook.memoizedState)) {\n                    markWorkInProgressReceivedUpdate();\n                }\n                hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n                // the base state unless the queue is empty.\n                // TODO: Not sure if this is the desired semantics, but it's what we\n                // do for gDSFP. I can't remember why.\n                if (hook.baseQueue === null) {\n                    hook.baseState = newState;\n                }\n                queue.lastRenderedState = newState;\n            }\n            return [\n                newState,\n                dispatch\n            ];\n        }\n        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var fiber = currentlyRenderingFiber$1;\n            var hook = mountWorkInProgressHook();\n            var nextSnapshot;\n            var isHydrating = getIsHydrating();\n            if (isHydrating) {\n                if (getServerSnapshot === undefined) {\n                    throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n                }\n                nextSnapshot = getServerSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        if (nextSnapshot !== getServerSnapshot()) {\n                            error('The result of getServerSnapshot should be cached to avoid an infinite loop');\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n            } else {\n                nextSnapshot = getSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        var cachedSnapshot = getSnapshot();\n                        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                            error('The result of getSnapshot should be cached to avoid an infinite loop');\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n                // Right before committing, we will walk the tree and check if any of the\n                // stores were mutated.\n                //\n                // We won't do this if we're hydrating server-rendered content, because if\n                // the content is stale, it's already visible anyway. Instead we'll patch\n                // it up in a passive effect.\n                var root = getWorkInProgressRoot();\n                if (root === null) {\n                    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n                }\n                var rootRenderLanes = getWorkInProgressRootRenderLanes();\n                if (!includesBlockingLane(root, rootRenderLanes)) {\n                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n                }\n            } // Read the current snapshot from the store on every render. This breaks the\n            // normal rules of React, and only works because store updates are\n            // always synchronous.\n            hook.memoizedState = nextSnapshot;\n            var inst = {\n                value: nextSnapshot,\n                getSnapshot: getSnapshot\n            };\n            hook.queue = inst; // Schedule an effect to subscribe to the store.\n            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n                subscribe\n            ]); // Schedule an effect to update the mutable instance fields. We will update\n            // this whenever subscribe, getSnapshot, or value changes. Because there's no\n            // clean-up function, and we track the deps correctly, we can call pushEffect\n            // directly, without storing any additional state. For the same reason, we\n            // don't need to set a static flag, either.\n            fiber.flags |= Passive$1;\n            pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), createEffectInstance(), null);\n            return nextSnapshot;\n        }\n        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var fiber = currentlyRenderingFiber$1;\n            var hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the\n            // normal rules of React, and only works because store updates are\n            // always synchronous.\n            var nextSnapshot;\n            var isHydrating = getIsHydrating();\n            if (isHydrating) {\n                // Needed for strict mode double render\n                if (getServerSnapshot === undefined) {\n                    throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n                }\n                nextSnapshot = getServerSnapshot();\n            } else {\n                nextSnapshot = getSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        var cachedSnapshot = getSnapshot();\n                        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                            error('The result of getSnapshot should be cached to avoid an infinite loop');\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n            }\n            var prevSnapshot = (currentHook || hook).memoizedState;\n            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);\n            if (snapshotChanged) {\n                hook.memoizedState = nextSnapshot;\n                markWorkInProgressReceivedUpdate();\n            }\n            var inst = hook.queue;\n            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n                subscribe\n            ]); // Whenever getSnapshot or subscribe changes, we need to check in the\n            // commit phase if there was an interleaved mutation. In concurrent mode\n            // this can happen all the time, but even in synchronous mode, an earlier\n            // effect may have mutated the store.\n            if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the subscribe function changed. We can save some memory by\n            // checking whether we scheduled a subscription effect above.\n            workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {\n                fiber.flags |= Passive$1;\n                pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), createEffectInstance(), null); // Unless we're rendering a blocking lane, schedule a consistency check.\n                // Right before committing, we will walk the tree and check if any of the\n                // stores were mutated.\n                var root = getWorkInProgressRoot();\n                if (root === null) {\n                    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n                }\n                if (!isHydrating && !includesBlockingLane(root, renderLanes)) {\n                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n                }\n            }\n            return nextSnapshot;\n        }\n        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n            fiber.flags |= StoreConsistency;\n            var check = {\n                getSnapshot: getSnapshot,\n                value: renderedSnapshot\n            };\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (componentUpdateQueue === null) {\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n                componentUpdateQueue.stores = [\n                    check\n                ];\n            } else {\n                var stores = componentUpdateQueue.stores;\n                if (stores === null) {\n                    componentUpdateQueue.stores = [\n                        check\n                    ];\n                } else {\n                    stores.push(check);\n                }\n            }\n        }\n        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n            // These are updated in the passive phase\n            inst.value = nextSnapshot;\n            inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could\n            // have been in an event that fired before the passive effects, or it could\n            // have been in a layout effect. In that case, we would have used the old\n            // snapsho and getSnapshot values to bail out. We need to check one more time.\n            if (checkIfSnapshotChanged(inst)) {\n                // Force a re-render.\n                forceStoreRerender(fiber);\n            }\n        }\n        function subscribeToStore(fiber, inst, subscribe) {\n            var handleStoreChange = function() {\n                // The store changed. Check if the snapshot changed since the last time we\n                // read from the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceStoreRerender(fiber);\n                }\n            }; // Subscribe to the store and return a clean-up function.\n            return subscribe(handleStoreChange);\n        }\n        function checkIfSnapshotChanged(inst) {\n            var latestGetSnapshot = inst.getSnapshot;\n            var prevValue = inst.value;\n            try {\n                var nextValue = latestGetSnapshot();\n                return !objectIs(prevValue, nextValue);\n            } catch (error) {\n                return true;\n            }\n        }\n        function forceStoreRerender(fiber) {\n            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, fiber, SyncLane);\n            }\n        }\n        function mountStateImpl(initialState) {\n            var hook = mountWorkInProgressHook();\n            if (typeof initialState === 'function') {\n                var initialStateInitializer = initialState; // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n                initialState = initialStateInitializer();\n                if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                    setIsStrictModeForDevtools(true); // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n                    initialStateInitializer();\n                    setIsStrictModeForDevtools(false);\n                }\n            }\n            hook.memoizedState = hook.baseState = initialState;\n            var queue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialState\n            };\n            hook.queue = queue;\n            return hook;\n        }\n        function mountState(initialState) {\n            var hook = mountStateImpl(initialState);\n            var queue = hook.queue;\n            var dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n            queue.dispatch = dispatch;\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function updateState(initialState) {\n            return updateReducer(basicStateReducer);\n        }\n        function rerenderState(initialState) {\n            return rerenderReducer(basicStateReducer);\n        }\n        function mountOptimistic(passthrough, reducer) {\n            var hook = mountWorkInProgressHook();\n            hook.memoizedState = hook.baseState = passthrough;\n            var queue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                // Optimistic state does not use the eager update optimization.\n                lastRenderedReducer: null,\n                lastRenderedState: null\n            };\n            hook.queue = queue; // This is different than the normal setState function.\n            var dispatch = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, true, queue);\n            queue.dispatch = dispatch;\n            return [\n                passthrough,\n                dispatch\n            ];\n        }\n        function updateOptimistic(passthrough, reducer) {\n            var hook = updateWorkInProgressHook();\n            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n        }\n        function updateOptimisticImpl(hook, current, passthrough, reducer) {\n            // Optimistic updates are always rebased on top of the latest value passed in\n            // as an argument. It's called a passthrough because if there are no pending\n            // updates, it will be returned as-is.\n            //\n            // Reset the base state to the passthrough. Future updates will be applied\n            // on top of this.\n            hook.baseState = passthrough; // If a reducer is not provided, default to the same one used by useState.\n            var resolvedReducer = typeof reducer === 'function' ? reducer : basicStateReducer;\n            return updateReducerImpl(hook, currentHook, resolvedReducer);\n        }\n        function rerenderOptimistic(passthrough, reducer) {\n            // Unlike useState, useOptimistic doesn't support render phase updates.\n            // Also unlike useState, we need to replay all pending updates again in case\n            // the passthrough value changed.\n            //\n            // So instead of a forked re-render implementation that knows how to handle\n            // render phase udpates, we can use the same implementation as during a\n            // regular mount or update.\n            var hook = updateWorkInProgressHook();\n            if (currentHook !== null) {\n                // This is an update. Process the update queue.\n                return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n            } // This is a mount. No updates to process.\n            // Reset the base state to the passthrough. Future updates will be applied\n            // on top of this.\n            hook.baseState = passthrough;\n            var dispatch = hook.queue.dispatch;\n            return [\n                passthrough,\n                dispatch\n            ];\n        } // useActionState actions run sequentially, because each action receives the\n        // previous state as an argument. We store pending actions on a queue.\n        function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {\n            if (isRenderPhaseUpdate(fiber)) {\n                throw new Error('Cannot update form state while rendering.');\n            }\n            var last = actionQueue.pending;\n            if (last === null) {\n                // There are no pending actions; this is the first one. We can run\n                // it immediately.\n                var newLast = {\n                    payload: payload,\n                    next: null // circular\n                };\n                newLast.next = actionQueue.pending = newLast;\n                runActionStateAction(actionQueue, setPendingState, setState, payload);\n            } else {\n                // There's already an action running. Add to the queue.\n                var first = last.next;\n                var _newLast = {\n                    payload: payload,\n                    next: first\n                };\n                actionQueue.pending = last.next = _newLast;\n            }\n        }\n        function runActionStateAction(actionQueue, setPendingState, setState, payload) {\n            var action = actionQueue.action;\n            var prevState = actionQueue.state; // This is a fork of startTransition\n            var prevTransition = ReactSharedInternals.T;\n            var currentTransition = {};\n            ReactSharedInternals.T = currentTransition;\n            {\n                ReactSharedInternals.T._updatedFibers = new Set();\n            }\n            // This will be reverted automatically when all actions are finished.\n            setPendingState(true);\n            try {\n                var returnValue = action(prevState, payload);\n                var onStartTransitionFinish = ReactSharedInternals.S;\n                if (onStartTransitionFinish !== null) {\n                    onStartTransitionFinish(currentTransition, returnValue);\n                }\n                if (returnValue !== null && typeof returnValue === 'object' && // $FlowFixMe[method-unbinding]\n                typeof returnValue.then === 'function') {\n                    var thenable = returnValue; // Attach a listener to read the return state of the action. As soon as\n                    // this resolves, we can run the next action in the sequence.\n                    thenable.then(function(nextState) {\n                        actionQueue.state = nextState;\n                        finishRunningActionStateAction(actionQueue, setPendingState, setState);\n                    }, function() {\n                        return finishRunningActionStateAction(actionQueue, setPendingState, setState);\n                    });\n                    setState(thenable);\n                } else {\n                    setState(returnValue);\n                    var nextState = returnValue;\n                    actionQueue.state = nextState;\n                    finishRunningActionStateAction(actionQueue, setPendingState, setState);\n                }\n            } catch (error) {\n                // This is a trick to get the `useActionState` hook to rethrow the error.\n                // When it unwraps the thenable with the `use` algorithm, the error\n                // will be thrown.\n                var rejectedThenable = {\n                    then: function() {},\n                    status: 'rejected',\n                    reason: error // $FlowFixMe: Not sure why this doesn't work\n                };\n                setState(rejectedThenable);\n                finishRunningActionStateAction(actionQueue, setPendingState, setState);\n            } finally{\n                ReactSharedInternals.T = prevTransition;\n                {\n                    if (prevTransition === null && currentTransition._updatedFibers) {\n                        var updatedFibersCount = currentTransition._updatedFibers.size;\n                        currentTransition._updatedFibers.clear();\n                        if (updatedFibersCount > 10) {\n                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n                        }\n                    }\n                }\n            }\n        }\n        function finishRunningActionStateAction(actionQueue, setPendingState, setState) {\n            // The action finished running. Pop it from the queue and run the next pending\n            // action, if there are any.\n            var last = actionQueue.pending;\n            if (last !== null) {\n                var first = last.next;\n                if (first === last) {\n                    // This was the last action in the queue.\n                    actionQueue.pending = null;\n                } else {\n                    // Remove the first node from the circular queue.\n                    var next = first.next;\n                    last.next = next; // Run the next action.\n                    runActionStateAction(actionQueue, setPendingState, setState, next.payload);\n                }\n            }\n        }\n        function actionStateReducer(oldState, newState) {\n            return newState;\n        }\n        function mountActionState(action, initialStateProp, permalink) {\n            var initialState = initialStateProp;\n            if (getIsHydrating()) {\n                var root = getWorkInProgressRoot();\n                var ssrFormState = root.formState; // If a formState option was passed to the root, there are form state\n                // markers that we need to hydrate. These indicate whether the form state\n                // matches this hook instance.\n                if (ssrFormState !== null) {\n                    var isMatching = tryToClaimNextHydratableFormMarkerInstance(currentlyRenderingFiber$1);\n                    if (isMatching) {\n                        initialState = ssrFormState[0];\n                    }\n                }\n            } // State hook. The state is stored in a thenable which is then unwrapped by\n            // the `use` algorithm during render.\n            var stateHook = mountWorkInProgressHook();\n            stateHook.memoizedState = stateHook.baseState = initialState; // TODO: Typing this \"correctly\" results in recursion limit errors\n            // const stateQueue: UpdateQueue<S | Awaited<S>, S | Awaited<S>> = {\n            var stateQueue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: actionStateReducer,\n                lastRenderedState: initialState\n            };\n            stateHook.queue = stateQueue;\n            var setState = dispatchSetState.bind(null, currentlyRenderingFiber$1, stateQueue);\n            stateQueue.dispatch = setState; // Pending state. This is used to store the pending state of the action.\n            // Tracked optimistically, like a transition pending state.\n            var pendingStateHook = mountStateImpl(false);\n            var setPendingState = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, false, pendingStateHook.queue); // Action queue hook. This is used to queue pending actions. The queue is\n            // shared between all instances of the hook. Similar to a regular state queue,\n            // but different because the actions are run sequentially, and they run in\n            // an event instead of during render.\n            var actionQueueHook = mountWorkInProgressHook();\n            var actionQueue = {\n                state: initialState,\n                dispatch: null,\n                // circular\n                action: action,\n                pending: null\n            };\n            actionQueueHook.queue = actionQueue;\n            var dispatch = dispatchActionState.bind(null, currentlyRenderingFiber$1, actionQueue, setPendingState, setState);\n            actionQueue.dispatch = dispatch; // Stash the action function on the memoized state of the hook. We'll use this\n            // to detect when the action function changes so we can update it in\n            // an effect.\n            actionQueueHook.memoizedState = action;\n            return [\n                initialState,\n                dispatch,\n                false\n            ];\n        }\n        function updateActionState(action, initialState, permalink) {\n            var stateHook = updateWorkInProgressHook();\n            var currentStateHook = currentHook;\n            return updateActionStateImpl(stateHook, currentStateHook, action);\n        }\n        function updateActionStateImpl(stateHook, currentStateHook, action, initialState, permalink) {\n            var _updateReducerImpl = updateReducerImpl(stateHook, currentStateHook, actionStateReducer), actionResult = _updateReducerImpl[0];\n            var _updateState = updateState(), isPending = _updateState[0]; // This will suspend until the action finishes.\n            var state = typeof actionResult === 'object' && actionResult !== null && // $FlowFixMe[method-unbinding]\n            typeof actionResult.then === 'function' ? useThenable(actionResult) : actionResult;\n            var actionQueueHook = updateWorkInProgressHook();\n            var actionQueue = actionQueueHook.queue;\n            var dispatch = actionQueue.dispatch; // Check if a new action was passed. If so, update it in an effect.\n            var prevAction = actionQueueHook.memoizedState;\n            if (action !== prevAction) {\n                currentlyRenderingFiber$1.flags |= Passive$1;\n                pushEffect(HasEffect | Passive, actionStateActionEffect.bind(null, actionQueue, action), createEffectInstance(), null);\n            }\n            return [\n                state,\n                dispatch,\n                isPending\n            ];\n        }\n        function actionStateActionEffect(actionQueue, action) {\n            actionQueue.action = action;\n        }\n        function rerenderActionState(action, initialState, permalink) {\n            // Unlike useState, useActionState doesn't support render phase updates.\n            // Also unlike useState, we need to replay all pending updates again in case\n            // the passthrough value changed.\n            //\n            // So instead of a forked re-render implementation that knows how to handle\n            // render phase udpates, we can use the same implementation as during a\n            // regular mount or update.\n            var stateHook = updateWorkInProgressHook();\n            var currentStateHook = currentHook;\n            if (currentStateHook !== null) {\n                // This is an update. Process the update queue.\n                return updateActionStateImpl(stateHook, currentStateHook, action);\n            }\n            updateWorkInProgressHook(); // State\n            // This is a mount. No updates to process.\n            var state = stateHook.memoizedState;\n            var actionQueueHook = updateWorkInProgressHook();\n            var actionQueue = actionQueueHook.queue;\n            var dispatch = actionQueue.dispatch; // This may have changed during the rerender.\n            actionQueueHook.memoizedState = action; // For mount, pending is always false.\n            return [\n                state,\n                dispatch,\n                false\n            ];\n        }\n        function pushEffect(tag, create, inst, deps) {\n            var effect = {\n                tag: tag,\n                create: create,\n                inst: inst,\n                deps: deps,\n                // Circular\n                next: null\n            };\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (componentUpdateQueue === null) {\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n                componentUpdateQueue.lastEffect = effect.next = effect;\n            } else {\n                var lastEffect = componentUpdateQueue.lastEffect;\n                if (lastEffect === null) {\n                    componentUpdateQueue.lastEffect = effect.next = effect;\n                } else {\n                    var firstEffect = lastEffect.next;\n                    lastEffect.next = effect;\n                    effect.next = firstEffect;\n                    componentUpdateQueue.lastEffect = effect;\n                }\n            }\n            return effect;\n        }\n        function createEffectInstance() {\n            return {\n                destroy: undefined\n            };\n        }\n        function mountRef(initialValue) {\n            var hook = mountWorkInProgressHook();\n            var ref = {\n                current: initialValue\n            };\n            hook.memoizedState = ref;\n            return ref;\n        }\n        function updateRef(initialValue) {\n            var hook = updateWorkInProgressHook();\n            return hook.memoizedState;\n        }\n        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            currentlyRenderingFiber$1.flags |= fiberFlags;\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, createEffectInstance(), nextDeps);\n        }\n        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var effect = hook.memoizedState;\n            var inst = effect.inst; // currentHook is null on initial mount when rerendering after a render phase\n            // state update or for strict mode.\n            if (currentHook !== null) {\n                if (nextDeps !== null) {\n                    var prevEffect = currentHook.memoizedState;\n                    var prevDeps = prevEffect.deps;\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\n                        hook.memoizedState = pushEffect(hookFlags, create, inst, nextDeps);\n                        return;\n                    }\n                }\n            }\n            currentlyRenderingFiber$1.flags |= fiberFlags;\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, inst, nextDeps);\n        }\n        function mountEffect(create, deps) {\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber$1.mode & NoStrictPassiveEffectsMode) === NoMode) {\n                mountEffectImpl(MountPassiveDev | Passive$1 | PassiveStatic, Passive, create, deps);\n            } else {\n                mountEffectImpl(Passive$1 | PassiveStatic, Passive, create, deps);\n            }\n        }\n        function updateEffect(create, deps) {\n            updateEffectImpl(Passive$1, Passive, create, deps);\n        }\n        function mountInsertionEffect(create, deps) {\n            mountEffectImpl(Update, Insertion, create, deps);\n        }\n        function updateInsertionEffect(create, deps) {\n            return updateEffectImpl(Update, Insertion, create, deps);\n        }\n        function mountLayoutEffect(create, deps) {\n            var fiberFlags = Update | LayoutStatic;\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n            }\n            return mountEffectImpl(fiberFlags, Layout, create, deps);\n        }\n        function updateLayoutEffect(create, deps) {\n            return updateEffectImpl(Update, Layout, create, deps);\n        }\n        function imperativeHandleEffect(create, ref) {\n            if (typeof ref === 'function') {\n                var refCallback = ref;\n                var inst = create();\n                var refCleanup = refCallback(inst);\n                return function() {\n                    if (typeof refCleanup === 'function') {\n                        // $FlowFixMe[incompatible-use] we need to assume no parameters\n                        refCleanup();\n                    } else {\n                        refCallback(null);\n                    }\n                };\n            } else if (ref !== null && ref !== undefined) {\n                var refObject = ref;\n                {\n                    if (!refObject.hasOwnProperty('current')) {\n                        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');\n                    }\n                }\n                var _inst = create();\n                refObject.current = _inst;\n                return function() {\n                    refObject.current = null;\n                };\n            }\n        }\n        function mountImperativeHandle(ref, create, deps) {\n            {\n                if (typeof create !== 'function') {\n                    error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n                }\n            }\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([\n                ref\n            ]) : null;\n            var fiberFlags = Update | LayoutStatic;\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n            }\n            mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function updateImperativeHandle(ref, create, deps) {\n            {\n                if (typeof create !== 'function') {\n                    error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n                }\n            }\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([\n                ref\n            ]) : null;\n            updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function mountDebugValue(value, formatterFn) {\n        // The react-debug-hooks package injects its own implementation\n        // so that e.g. DevTools can display custom hook values.\n        }\n        var updateDebugValue = mountDebugValue;\n        function mountCallback(callback, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            hook.memoizedState = [\n                callback,\n                nextDeps\n            ];\n            return callback;\n        }\n        function updateCallback(callback, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var prevState = hook.memoizedState;\n            if (nextDeps !== null) {\n                var prevDeps = prevState[1];\n                if (areHookInputsEqual(nextDeps, prevDeps)) {\n                    return prevState[0];\n                }\n            }\n            hook.memoizedState = [\n                callback,\n                nextDeps\n            ];\n            return callback;\n        }\n        function mountMemo(nextCreate, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var nextValue = nextCreate();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(true);\n                nextCreate();\n                setIsStrictModeForDevtools(false);\n            }\n            hook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function updateMemo(nextCreate, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var prevState = hook.memoizedState; // Assume these are defined. If they're not, areHookInputsEqual will warn.\n            if (nextDeps !== null) {\n                var prevDeps = prevState[1];\n                if (areHookInputsEqual(nextDeps, prevDeps)) {\n                    return prevState[0];\n                }\n            }\n            var nextValue = nextCreate();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(true);\n                nextCreate();\n                setIsStrictModeForDevtools(false);\n            }\n            hook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function mountDeferredValue(value, initialValue) {\n            var hook = mountWorkInProgressHook();\n            return mountDeferredValueImpl(hook, value, initialValue);\n        }\n        function updateDeferredValue(value, initialValue) {\n            var hook = updateWorkInProgressHook();\n            var resolvedCurrentHook = currentHook;\n            var prevValue = resolvedCurrentHook.memoizedState;\n            return updateDeferredValueImpl(hook, prevValue, value, initialValue);\n        }\n        function rerenderDeferredValue(value, initialValue) {\n            var hook = updateWorkInProgressHook();\n            if (currentHook === null) {\n                // This is a rerender during a mount.\n                return mountDeferredValueImpl(hook, value, initialValue);\n            } else {\n                // This is a rerender during an update.\n                var prevValue = currentHook.memoizedState;\n                return updateDeferredValueImpl(hook, prevValue, value, initialValue);\n            }\n        }\n        function mountDeferredValueImpl(hook, value, initialValue) {\n            if (// current render is not synchronous.\n            initialValue !== undefined && // However, to avoid waterfalls, we do not defer if this render\n            // was itself spawned by an earlier useDeferredValue. Check if DeferredLane\n            // is part of the render lanes.\n            !includesSomeLane(renderLanes, DeferredLane)) {\n                // Render with the initial value\n                hook.memoizedState = initialValue; // Schedule a deferred render to switch to the final value.\n                var deferredLane = requestDeferredLane();\n                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);\n                markSkippedUpdateLanes(deferredLane);\n                return initialValue;\n            } else {\n                hook.memoizedState = value;\n                return value;\n            }\n        }\n        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n            if (objectIs(value, prevValue)) {\n                // The incoming value is referentially identical to the currently rendered\n                // value, so we can bail out quickly.\n                return value;\n            } else {\n                // Received a new value that's different from the current value.\n                // Check if we're inside a hidden tree\n                if (isCurrentTreeHidden()) {\n                    // Revealing a prerendered tree is considered the same as mounting new\n                    // one, so we reuse the \"mount\" path in this case.\n                    var resultValue = mountDeferredValueImpl(hook, value, initialValue); // Unlike during an actual mount, we need to mark this as an update if\n                    // the value changed.\n                    if (!objectIs(resultValue, prevValue)) {\n                        markWorkInProgressReceivedUpdate();\n                    }\n                    return resultValue;\n                }\n                var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);\n                if (shouldDeferValue) {\n                    // This is an urgent update. Since the value has changed, keep using the\n                    // previous value and spawn a deferred render to update it later.\n                    // Schedule a deferred render\n                    var deferredLane = requestDeferredLane();\n                    currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);\n                    markSkippedUpdateLanes(deferredLane); // Reuse the previous value. We do not need to mark this as an update,\n                    // because we did not render a new value.\n                    return prevValue;\n                } else {\n                    // This is not an urgent update, so we can use the latest value regardless\n                    // of what it is. No need to defer it.\n                    // Mark this as an update to prevent the fiber from bailing out.\n                    markWorkInProgressReceivedUpdate();\n                    hook.memoizedState = value;\n                    return value;\n                }\n            }\n        }\n        function startTransition(fiber, queue, pendingState, finishedState, callback, options) {\n            var previousPriority = getCurrentUpdatePriority();\n            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n            var prevTransition = ReactSharedInternals.T;\n            var currentTransition = {};\n            {\n                // We don't really need to use an optimistic update here, because we\n                // schedule a second \"revert\" update below (which we use to suspend the\n                // transition until the async action scope has finished). But we'll use an\n                // optimistic update anyway to make it less likely the behavior accidentally\n                // diverges; for example, both an optimistic update and this one should\n                // share the same lane.\n                ReactSharedInternals.T = currentTransition;\n                dispatchOptimisticSetState(fiber, false, queue, pendingState);\n            }\n            {\n                currentTransition._updatedFibers = new Set();\n            }\n            try {\n                if (enableAsyncActions) {\n                    var returnValue = callback();\n                    var onStartTransitionFinish = ReactSharedInternals.S;\n                    if (onStartTransitionFinish !== null) {\n                        onStartTransitionFinish(currentTransition, returnValue);\n                    } // Check if we're inside an async action scope. If so, we'll entangle\n                    // this new action with the existing scope.\n                    //\n                    // If we're not already inside an async action scope, and this action is\n                    // async, then we'll create a new async scope.\n                    //\n                    // In the async case, the resulting render will suspend until the async\n                    // action scope has finished.\n                    if (returnValue !== null && typeof returnValue === 'object' && typeof returnValue.then === 'function') {\n                        var thenable = returnValue; // Create a thenable that resolves to `finishedState` once the async\n                        // action has completed.\n                        var thenableForFinishedState = chainThenableValue(thenable, finishedState);\n                        dispatchSetState(fiber, queue, thenableForFinishedState);\n                    } else {\n                        dispatchSetState(fiber, queue, finishedState);\n                    }\n                }\n            } catch (error) {\n                {\n                    // This is a trick to get the `useTransition` hook to rethrow the error.\n                    // When it unwraps the thenable with the `use` algorithm, the error\n                    // will be thrown.\n                    var rejectedThenable = {\n                        then: function() {},\n                        status: 'rejected',\n                        reason: error\n                    };\n                    dispatchSetState(fiber, queue, rejectedThenable);\n                }\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n                {\n                    if (prevTransition === null && currentTransition._updatedFibers) {\n                        var updatedFibersCount = currentTransition._updatedFibers.size;\n                        currentTransition._updatedFibers.clear();\n                        if (updatedFibersCount > 10) {\n                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n                        }\n                    }\n                }\n            }\n        }\n        var noop = function() {};\n        function startHostTransition(formFiber, pendingState, action, formData) {\n            if (formFiber.tag !== HostComponent) {\n                throw new Error('Expected the form instance to be a HostComponent. This ' + 'is a bug in React.');\n            }\n            var stateHook = ensureFormComponentIsStateful(formFiber);\n            var queue = stateHook.queue;\n            startTransition(formFiber, queue, pendingState, NotPendingTransition, // the action, if one is provided. Consider refactoring these two\n            // concerns to avoid the extra lambda.\n            action === null ? // set the pending form status.\n            noop : function() {\n                // Automatically reset the form when the action completes.\n                requestFormReset(formFiber);\n                return action(formData);\n            });\n        }\n        function ensureFormComponentIsStateful(formFiber) {\n            var existingStateHook = formFiber.memoizedState;\n            if (existingStateHook !== null) {\n                // This fiber was already upgraded to be stateful.\n                return existingStateHook;\n            } // Upgrade this host component fiber to be stateful. We're going to pretend\n            // it was stateful all along so we can reuse most of the implementation\n            // for function components and useTransition.\n            //\n            // Create the state hook used by TransitionAwareHostComponent. This is\n            // essentially an inlined version of mountState.\n            var newQueue = {\n                pending: null,\n                lanes: NoLanes,\n                // We're going to cheat and intentionally not create a bound dispatch\n                // method, because we can call it directly in startTransition.\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: NotPendingTransition\n            };\n            var stateHook = {\n                memoizedState: NotPendingTransition,\n                baseState: NotPendingTransition,\n                baseQueue: null,\n                queue: newQueue,\n                next: null\n            }; // We use another state hook to track whether the form needs to be reset.\n            // The state is an empty object. To trigger a reset, we update the state\n            // to a new object. Then during rendering, we detect that the state has\n            // changed and schedule a commit effect.\n            var initialResetState = {};\n            var newResetStateQueue = {\n                pending: null,\n                lanes: NoLanes,\n                // We're going to cheat and intentionally not create a bound dispatch\n                // method, because we can call it directly in startTransition.\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialResetState\n            };\n            var resetStateHook = {\n                memoizedState: initialResetState,\n                baseState: initialResetState,\n                baseQueue: null,\n                queue: newResetStateQueue,\n                next: null\n            };\n            stateHook.next = resetStateHook; // Add the hook list to both fiber alternates. The idea is that the fiber\n            // had this hook all along.\n            formFiber.memoizedState = stateHook;\n            var alternate = formFiber.alternate;\n            if (alternate !== null) {\n                alternate.memoizedState = stateHook;\n            }\n            return stateHook;\n        }\n        function requestFormReset(formFiber) {\n            var transition = requestCurrentTransition();\n            {\n                if (transition === null) {\n                    // An optimistic update occurred, but startTransition is not on the stack.\n                    // The form reset will be scheduled at default (sync) priority, which\n                    // is probably not what the user intended. Most likely because the\n                    // requestFormReset call happened after an `await`.\n                    // TODO: Theoretically, requestFormReset is still useful even for\n                    // non-transition updates because it allows you to update defaultValue\n                    // synchronously and then wait to reset until after the update commits.\n                    // I've chosen to warn anyway because it's more likely the `await` mistake\n                    // described above. But arguably we shouldn't.\n                    error('requestFormReset was called outside a transition or action. To ' + 'fix, move to an action, or wrap with startTransition.');\n                }\n            }\n            var stateHook = ensureFormComponentIsStateful(formFiber);\n            var newResetState = {};\n            var resetStateHook = stateHook.next;\n            var resetStateQueue = resetStateHook.queue;\n            dispatchSetState(formFiber, resetStateQueue, newResetState);\n        }\n        function mountTransition() {\n            var stateHook = mountStateImpl(false); // The `start` method never changes.\n            var start = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, true, false);\n            var hook = mountWorkInProgressHook();\n            hook.memoizedState = start;\n            return [\n                false,\n                start\n            ];\n        }\n        function updateTransition() {\n            var _updateState2 = updateState(), booleanOrThenable = _updateState2[0];\n            var hook = updateWorkInProgressHook();\n            var start = hook.memoizedState;\n            var isPending = typeof booleanOrThenable === 'boolean' ? booleanOrThenable : useThenable(booleanOrThenable);\n            return [\n                isPending,\n                start\n            ];\n        }\n        function rerenderTransition() {\n            var _rerenderState = rerenderState(), booleanOrThenable = _rerenderState[0];\n            var hook = updateWorkInProgressHook();\n            var start = hook.memoizedState;\n            var isPending = typeof booleanOrThenable === 'boolean' ? booleanOrThenable : useThenable(booleanOrThenable);\n            return [\n                isPending,\n                start\n            ];\n        }\n        function useHostTransitionStatus() {\n            var status = readContext(HostTransitionContext);\n            return status !== null ? status : NotPendingTransition;\n        }\n        function mountId() {\n            var hook = mountWorkInProgressHook();\n            var root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we\n            // should do this in Fiber, too? Deferring this decision for now because\n            // there's no other place to store the prefix except for an internal field on\n            // the public createRoot object, which the fiber tree does not currently have\n            // a reference to.\n            var identifierPrefix = root.identifierPrefix;\n            var id;\n            if (getIsHydrating()) {\n                var treeId = getTreeId(); // Use a captial R prefix for server-generated ids.\n                id = ':' + identifierPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end\n                // that represents the position of this useId hook among all the useId\n                // hooks for this fiber.\n                var localId = localIdCounter++;\n                if (localId > 0) {\n                    id += 'H' + localId.toString(32);\n                }\n                id += ':';\n            } else {\n                // Use a lowercase r prefix for client-generated ids.\n                var globalClientId = globalClientIdCounter++;\n                id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';\n            }\n            hook.memoizedState = id;\n            return id;\n        }\n        function updateId() {\n            var hook = updateWorkInProgressHook();\n            var id = hook.memoizedState;\n            return id;\n        }\n        function mountRefresh() {\n            var hook = mountWorkInProgressHook();\n            var refresh = hook.memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);\n            return refresh;\n        }\n        function updateRefresh() {\n            var hook = updateWorkInProgressHook();\n            return hook.memoizedState;\n        }\n        function refreshCache(fiber, seedKey, seedValue) {\n            // TODO: Consider warning if the refresh is at discrete priority, or if we\n            // otherwise suspect that it wasn't batched properly.\n            var provider = fiber.return;\n            while(provider !== null){\n                switch(provider.tag){\n                    case CacheComponent:\n                    case HostRoot:\n                        {\n                            // Schedule an update on the cache boundary to trigger a refresh.\n                            var lane = requestUpdateLane(provider);\n                            var refreshUpdate = createUpdate(lane);\n                            var root = enqueueUpdate(provider, refreshUpdate, lane);\n                            if (root !== null) {\n                                scheduleUpdateOnFiber(root, provider, lane);\n                                entangleTransitions(root, provider, lane);\n                            } // TODO: If a refresh never commits, the new cache created here must be\n                            // released. A simple case is start refreshing a cache boundary, but then\n                            // unmount that boundary before the refresh completes.\n                            var seededCache = createCache();\n                            if (seedKey !== null && seedKey !== undefined && root !== null) {\n                                {\n                                    {\n                                        error('The seed argument is not enabled outside experimental channels.');\n                                    }\n                                }\n                            }\n                            var payload = {\n                                cache: seededCache\n                            };\n                            refreshUpdate.payload = payload;\n                            return;\n                        }\n                }\n                provider = provider.return;\n            } // TODO: Warn if unmounted?\n        }\n        function dispatchReducerAction(fiber, queue, action) {\n            {\n                if (typeof arguments[3] === 'function') {\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n                }\n            }\n            var lane = requestUpdateLane(fiber);\n            var update = {\n                lane: lane,\n                revertLane: NoLane,\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                enqueueRenderPhaseUpdate(queue, update);\n            } else {\n                var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitionUpdate(root, queue, lane);\n                }\n            }\n            markUpdateInDevTools(fiber, lane);\n        }\n        function dispatchSetState(fiber, queue, action) {\n            {\n                if (typeof arguments[3] === 'function') {\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n                }\n            }\n            var lane = requestUpdateLane(fiber);\n            var update = {\n                lane: lane,\n                revertLane: NoLane,\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                enqueueRenderPhaseUpdate(queue, update);\n            } else {\n                var alternate = fiber.alternate;\n                if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n                    // The queue is currently empty, which means we can eagerly compute the\n                    // next state before entering the render phase. If the new state is the\n                    // same as the current state, we may be able to bail out entirely.\n                    var lastRenderedReducer = queue.lastRenderedReducer;\n                    if (lastRenderedReducer !== null) {\n                        var prevDispatcher = null;\n                        {\n                            prevDispatcher = ReactSharedInternals.H;\n                            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                        }\n                        try {\n                            var currentState = queue.lastRenderedState;\n                            var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n                            // it, on the update object. If the reducer hasn't changed by the\n                            // time we enter the render phase, then the eager state can be used\n                            // without calling the reducer again.\n                            update.hasEagerState = true;\n                            update.eagerState = eagerState;\n                            if (objectIs(eagerState, currentState)) {\n                                // Fast path. We can bail out without scheduling React to re-render.\n                                // It's still possible that we'll need to rebase this update later,\n                                // if the component re-renders for a different reason and by that\n                                // time the reducer has changed.\n                                // TODO: Do we still need to entangle transitions in this case?\n                                enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);\n                                return;\n                            }\n                        } catch (error) {} finally{\n                            {\n                                ReactSharedInternals.H = prevDispatcher;\n                            }\n                        }\n                    }\n                }\n                var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitionUpdate(root, queue, lane);\n                }\n            }\n            markUpdateInDevTools(fiber, lane);\n        }\n        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n            var transition = requestCurrentTransition();\n            {\n                if (transition === null) {\n                    // An optimistic update occurred, but startTransition is not on the stack.\n                    // There are two likely scenarios.\n                    // One possibility is that the optimistic update is triggered by a regular\n                    // event handler (e.g. `onSubmit`) instead of an action. This is a mistake\n                    // and we will warn.\n                    // The other possibility is the optimistic update is inside an async\n                    // action, but after an `await`. In this case, we can make it \"just work\"\n                    // by associating the optimistic update with the pending async action.\n                    // Technically it's possible that the optimistic update is unrelated to\n                    // the pending action, but we don't have a way of knowing this for sure\n                    // because browsers currently do not provide a way to track async scope.\n                    // (The AsyncContext proposal, if it lands, will solve this in the\n                    // future.) However, this is no different than the problem of unrelated\n                    // transitions being grouped together — it's not wrong per se, but it's\n                    // not ideal.\n                    // Once AsyncContext starts landing in browsers, we will provide better\n                    // warnings in development for these cases.\n                    if (peekEntangledActionLane() !== NoLane) ;\n                    else {\n                        // There's no pending async action. The most likely cause is that we're\n                        // inside a regular event handler (e.g. onSubmit) instead of an action.\n                        error('An optimistic state update occurred outside a transition or ' + 'action. To fix, move the update to an action, or wrap ' + 'with startTransition.');\n                    }\n                }\n            }\n            var update = {\n                // An optimistic update commits synchronously.\n                lane: SyncLane,\n                // After committing, the optimistic update is \"reverted\" using the same\n                // lane as the transition it's associated with.\n                revertLane: requestTransitionLane(),\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                // When calling startTransition during render, this warns instead of\n                // throwing because throwing would be a breaking change. setOptimisticState\n                // is a new API so it's OK to throw.\n                if (throwIfDuringRender) {\n                    throw new Error('Cannot update optimistic state while rendering.');\n                } else {\n                    // startTransition was called during render. We don't need to do anything\n                    // besides warn here because the render phase update would be overidden by\n                    // the second update, anyway. We can remove this branch and make it throw\n                    // in a future release.\n                    {\n                        error('Cannot call startTransition while rendering.');\n                    }\n                }\n            } else {\n                var root = enqueueConcurrentHookUpdate(fiber, queue, update, SyncLane);\n                if (root !== null) {\n                    // NOTE: The optimistic update implementation assumes that the transition\n                    // will never be attempted before the optimistic update. This currently\n                    // holds because the optimistic update is always synchronous. If we ever\n                    // change that, we'll need to account for this.\n                    scheduleUpdateOnFiber(root, fiber, SyncLane); // Optimistic updates are always synchronous, so we don't need to call\n                // entangleTransitionUpdate here.\n                }\n            }\n            markUpdateInDevTools(fiber, SyncLane);\n        }\n        function isRenderPhaseUpdate(fiber) {\n            var alternate = fiber.alternate;\n            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;\n        }\n        function enqueueRenderPhaseUpdate(queue, update) {\n            // This is a render phase update. Stash it in a lazily-created map of\n            // queue -> linked list of updates. After this render pass, we'll restart\n            // and apply the stashed updates on top of the work-in-progress hook.\n            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n            var pending = queue.pending;\n            if (pending === null) {\n                // This is the first update. Create a circular list.\n                update.next = update;\n            } else {\n                update.next = pending.next;\n                pending.next = update;\n            }\n            queue.pending = update;\n        } // TODO: Move to ReactFiberConcurrentUpdates?\n        function entangleTransitionUpdate(root, queue, lane) {\n            if (isTransitionLane(lane)) {\n                var queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they\n                // must have finished. We can remove them from the shared queue, which\n                // represents a superset of the actually pending lanes. In some cases we\n                // may entangle more than we need to, but that's OK. In fact it's worse if\n                // we *don't* entangle when we should.\n                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n                var newQueueLanes = mergeLanes(queueLanes, lane);\n                queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n                // the lane finished since the last time we entangled it. So we need to\n                // entangle it again, just to be sure.\n                markRootEntangled(root, newQueueLanes);\n            }\n        }\n        function markUpdateInDevTools(fiber, lane, action) {\n            {\n                markStateUpdateScheduled(fiber, lane);\n            }\n        }\n        var ContextOnlyDispatcher = {\n            readContext: readContext,\n            use: use,\n            useCallback: throwInvalidHookError,\n            useContext: throwInvalidHookError,\n            useEffect: throwInvalidHookError,\n            useImperativeHandle: throwInvalidHookError,\n            useLayoutEffect: throwInvalidHookError,\n            useInsertionEffect: throwInvalidHookError,\n            useMemo: throwInvalidHookError,\n            useReducer: throwInvalidHookError,\n            useRef: throwInvalidHookError,\n            useState: throwInvalidHookError,\n            useDebugValue: throwInvalidHookError,\n            useDeferredValue: throwInvalidHookError,\n            useTransition: throwInvalidHookError,\n            useSyncExternalStore: throwInvalidHookError,\n            useId: throwInvalidHookError\n        };\n        {\n            ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\n        }\n        {\n            ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;\n        }\n        {\n            ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;\n            ContextOnlyDispatcher.useFormState = throwInvalidHookError;\n            ContextOnlyDispatcher.useActionState = throwInvalidHookError;\n        }\n        {\n            ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;\n        }\n        var HooksDispatcherOnMountInDEV = null;\n        var HooksDispatcherOnMountWithHookTypesInDEV = null;\n        var HooksDispatcherOnUpdateInDEV = null;\n        var HooksDispatcherOnRerenderInDEV = null;\n        var InvalidNestedHooksDispatcherOnMountInDEV = null;\n        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;\n        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n        {\n            var warnInvalidContextAccess = function() {\n                error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n            };\n            var warnInvalidHookAccess = function() {\n                error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://react.dev/link/rules-of-hooks');\n            };\n            HooksDispatcherOnMountInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    mountHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    mountHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    mountHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    mountHookTypesDev();\n                    return mountDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    mountHookTypesDev();\n                    return mountTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    mountHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    mountHookTypesDev();\n                    return mountId();\n                }\n            };\n            {\n                HooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    mountHookTypesDev();\n                    return mountRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnMountInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n                HooksDispatcherOnMountInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n            }\n            {\n                HooksDispatcherOnMountInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    mountHookTypesDev();\n                    return mountOptimistic(passthrough);\n                };\n            }\n            HooksDispatcherOnMountWithHookTypesInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    updateHookTypesDev();\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    updateHookTypesDev();\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    updateHookTypesDev();\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    updateHookTypesDev();\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    updateHookTypesDev();\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    updateHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    updateHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    updateHookTypesDev();\n                    return mountDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    updateHookTypesDev();\n                    return mountTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    updateHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    updateHookTypesDev();\n                    return mountId();\n                }\n            };\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return mountRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    updateHookTypesDev();\n                    warnOnUseFormStateInDev();\n                    return mountActionState(action, initialState);\n                };\n                HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    updateHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n            }\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    updateHookTypesDev();\n                    return mountOptimistic(passthrough);\n                };\n            }\n            HooksDispatcherOnUpdateInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    updateHookTypesDev();\n                    return updateDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    updateHookTypesDev();\n                    return updateTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                HooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnUpdateInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    updateHookTypesDev();\n                    warnOnUseFormStateInDev();\n                    return updateActionState(action);\n                };\n                HooksDispatcherOnUpdateInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    updateHookTypesDev();\n                    return updateActionState(action);\n                };\n            }\n            {\n                HooksDispatcherOnUpdateInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    updateHookTypesDev();\n                    return updateOptimistic(passthrough, reducer);\n                };\n            }\n            HooksDispatcherOnRerenderInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return rerenderReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return rerenderState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    updateHookTypesDev();\n                    return rerenderDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    updateHookTypesDev();\n                    return rerenderTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                HooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnRerenderInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    updateHookTypesDev();\n                    warnOnUseFormStateInDev();\n                    return rerenderActionState(action);\n                };\n                HooksDispatcherOnRerenderInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    updateHookTypesDev();\n                    return rerenderActionState(action);\n                };\n            }\n            {\n                HooksDispatcherOnRerenderInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    updateHookTypesDev();\n                    return rerenderOptimistic(passthrough, reducer);\n                };\n            }\n            InvalidNestedHooksDispatcherOnMountInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                use: function(usable) {\n                    warnInvalidHookAccess();\n                    return use(usable);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountId();\n                }\n            };\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    mountHookTypesDev();\n                    return mountRefresh();\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useMemoCache = function(size) {\n                    warnInvalidHookAccess();\n                    return useMemoCache(size);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n                InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountOptimistic(passthrough);\n                };\n            }\n            InvalidNestedHooksDispatcherOnUpdateInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                use: function(usable) {\n                    warnInvalidHookAccess();\n                    return use(usable);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useMemoCache = function(size) {\n                    warnInvalidHookAccess();\n                    return useMemoCache(size);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateActionState(action);\n                };\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateActionState(action);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateOptimistic(passthrough, reducer);\n                };\n            }\n            InvalidNestedHooksDispatcherOnRerenderInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                use: function(usable) {\n                    warnInvalidHookAccess();\n                    return use(usable);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return rerenderReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return rerenderState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useMemoCache = function(size) {\n                    warnInvalidHookAccess();\n                    return useMemoCache(size);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderActionState(action);\n                };\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderActionState(action);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderOptimistic(passthrough, reducer);\n                };\n            }\n        }\n        var now = Scheduler.unstable_now;\n        var commitTime = 0;\n        var layoutEffectStartTime = -1;\n        var profilerStartTime = -1;\n        var passiveEffectStartTime = -1;\n        /**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */ var currentUpdateIsNested = false;\n        var nestedUpdateScheduled = false;\n        function isCurrentUpdateNested() {\n            return currentUpdateIsNested;\n        }\n        function markNestedUpdateScheduled() {\n            {\n                nestedUpdateScheduled = true;\n            }\n        }\n        function resetNestedUpdateFlag() {\n            {\n                currentUpdateIsNested = false;\n                nestedUpdateScheduled = false;\n            }\n        }\n        function syncNestedUpdateFlag() {\n            {\n                currentUpdateIsNested = nestedUpdateScheduled;\n                nestedUpdateScheduled = false;\n            }\n        }\n        function getCommitTime() {\n            return commitTime;\n        }\n        function recordCommitTime() {\n            commitTime = now();\n        }\n        function startProfilerTimer(fiber) {\n            profilerStartTime = now();\n            if (fiber.actualStartTime < 0) {\n                fiber.actualStartTime = now();\n            }\n        }\n        function stopProfilerTimerIfRunning(fiber) {\n            profilerStartTime = -1;\n        }\n        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n            if (profilerStartTime >= 0) {\n                var elapsedTime = now() - profilerStartTime;\n                fiber.actualDuration += elapsedTime;\n                if (overrideBaseTime) {\n                    fiber.selfBaseDuration = elapsedTime;\n                }\n                profilerStartTime = -1;\n            }\n        }\n        function recordLayoutEffectDuration(fiber) {\n            if (layoutEffectStartTime >= 0) {\n                var elapsedTime = now() - layoutEffectStartTime;\n                layoutEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n                // Or the root (for the DevTools Profiler to read)\n                var parentFiber = fiber.return;\n                while(parentFiber !== null){\n                    switch(parentFiber.tag){\n                        case HostRoot:\n                            var root = parentFiber.stateNode;\n                            root.effectDuration += elapsedTime;\n                            return;\n                        case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            parentStateNode.effectDuration += elapsedTime;\n                            return;\n                    }\n                    parentFiber = parentFiber.return;\n                }\n            }\n        }\n        function recordPassiveEffectDuration(fiber) {\n            if (passiveEffectStartTime >= 0) {\n                var elapsedTime = now() - passiveEffectStartTime;\n                passiveEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n                // Or the root (for the DevTools Profiler to read)\n                var parentFiber = fiber.return;\n                while(parentFiber !== null){\n                    switch(parentFiber.tag){\n                        case HostRoot:\n                            var root = parentFiber.stateNode;\n                            if (root !== null) {\n                                root.passiveEffectDuration += elapsedTime;\n                            }\n                            return;\n                        case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            if (parentStateNode !== null) {\n                                // Detached fibers have their state node cleared out.\n                                // In this case, the return pointer is also cleared out,\n                                // so we won't be able to report the time spent in this Profiler's subtree.\n                                parentStateNode.passiveEffectDuration += elapsedTime;\n                            }\n                            return;\n                    }\n                    parentFiber = parentFiber.return;\n                }\n            }\n        }\n        function startLayoutEffectTimer() {\n            layoutEffectStartTime = now();\n        }\n        function startPassiveEffectTimer() {\n            passiveEffectStartTime = now();\n        }\n        function transferActualDuration(fiber) {\n            // Transfer time spent rendering these children so we don't lose it\n            // after we rerender. This is used as a helper in special cases\n            // where we should count the work of multiple passes.\n            var child = fiber.child;\n            while(child){\n                // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                fiber.actualDuration += child.actualDuration;\n                child = child.sibling;\n            }\n        }\n        var fakeInternalInstance = {};\n        var didWarnAboutStateAssignmentForComponent;\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutInvalidateContextType;\n        var didWarnOnInvalidCallback;\n        {\n            didWarnAboutStateAssignmentForComponent = new Set();\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            didWarnOnInvalidCallback = new Set(); // This is so gross but it's at least non-critical and can be removed if\n            // it causes problems. This is meant to give a nicer error message for\n            // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n            // ...)) which otherwise throws a \"_processChildContext is not a function\"\n            // exception.\n            Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n                enumerable: false,\n                value: function() {\n                    throw new Error('_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');\n                }\n            });\n            Object.freeze(fakeInternalInstance);\n        }\n        function warnOnInvalidCallback(callback) {\n            {\n                if (callback === null || typeof callback === 'function') {\n                    return;\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var key = String(callback);\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error('Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n                }\n            }\n        }\n        function warnOnUndefinedDerivedState(type, partialState) {\n            {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || 'Component';\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n                    }\n                }\n            }\n        }\n        function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n            var prevState = workInProgress.memoizedState;\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        // Invoke the function an extra time to help detect side-effects.\n                        partialState = getDerivedStateFromProps(nextProps, prevState);\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n            // base state.\n            if (workInProgress.lanes === NoLanes) {\n                // Queue is always non-null for classes\n                var updateQueue = workInProgress.updateQueue;\n                updateQueue.baseState = memoizedState;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: isMounted,\n            // $FlowFixMe[missing-local-annot]\n            enqueueSetState: function(inst, payload, callback) {\n                var fiber = get(inst);\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(lane);\n                update.payload = payload;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback);\n                    }\n                    update.callback = callback;\n                }\n                var root = enqueueUpdate(fiber, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markStateUpdateScheduled(fiber, lane);\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var fiber = get(inst);\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(lane);\n                update.tag = ReplaceState;\n                update.payload = payload;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback);\n                    }\n                    update.callback = callback;\n                }\n                var root = enqueueUpdate(fiber, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markStateUpdateScheduled(fiber, lane);\n                }\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueForceUpdate: function(inst, callback) {\n                var fiber = get(inst);\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(lane);\n                update.tag = ForceUpdate;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback);\n                    }\n                    update.callback = callback;\n                }\n                var root = enqueueUpdate(fiber, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markForceUpdateScheduled(fiber, lane);\n                }\n            }\n        };\n        function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n            var instance = workInProgress.stateNode;\n            if (typeof instance.shouldComponentUpdate === 'function') {\n                var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                {\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            // Invoke the function an extra time to help detect side-effects.\n                            shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                    if (shouldUpdate === undefined) {\n                        error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentNameFromType(ctor) || 'Component');\n                    }\n                }\n                return shouldUpdate;\n            }\n            if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n                return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n            }\n            return true;\n        }\n        function checkClassInstance(workInProgress, ctor, newProps) {\n            var instance = workInProgress.stateNode;\n            {\n                var name = getComponentNameFromType(ctor) || 'Component';\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n                        error('No `render` method found on the %s ' + 'instance: did you accidentally return an object from the constructor?', name);\n                    } else {\n                        error('No `render` method found on the %s ' + 'instance: you may have forgotten to define `render`.', name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n                }\n                if (instance.propTypes) {\n                    error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n                }\n                if (instance.contextType) {\n                    error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);\n                }\n                {\n                    if (ctor.childContextTypes) {\n                        error('%s uses the legacy childContextTypes API which was removed in React 19. ' + 'Use React.createContext() instead.', name);\n                    }\n                    if (ctor.contextTypes) {\n                        error('%s uses the legacy contextTypes API which was removed in React 19. ' + 'Use React.createContext() with static contextType instead.', name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === 'function') {\n                    error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n                    error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentNameFromType(ctor) || 'A pure component');\n                }\n                if (typeof instance.componentDidUnmount === 'function') {\n                    error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n                }\n                if (typeof instance.componentDidReceiveProps === 'function') {\n                    error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n                }\n                if (typeof instance.componentWillRecieveProps === 'function') {\n                    error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\n                    error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error('When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name);\n                }\n                if (instance.defaultProps) {\n                    error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === 'function') {\n                    error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n                }\n                if (typeof instance.getDerivedStateFromError === 'function') {\n                    error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\n                    error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);\n                }\n                var state = instance.state;\n                if (state && (typeof state !== 'object' || isArray(state))) {\n                    error('%s.state: must be set to an object or null', name);\n                }\n                if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {\n                    error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);\n                }\n            }\n        }\n        function constructClassInstance(workInProgress, ctor, props) {\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if ('contextType' in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE;\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = '';\n                        if (contextType === undefined) {\n                            addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';\n                        } else if (typeof contextType !== 'object') {\n                            addendum = ' However, it is set to a ' + typeof contextType + '.';\n                        } else if (contextType.$$typeof === REACT_CONSUMER_TYPE) {\n                            addendum = ' Did you accidentally pass the Context.Consumer instead?';\n                        } else {\n                            addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';\n                        }\n                        error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentNameFromType(ctor) || 'Component', addendum);\n                    }\n                }\n            }\n            if (typeof contextType === 'object' && contextType !== null) {\n                context = readContext(contextType);\n            }\n            var instance = new ctor(props, context); // Instantiate twice to help detect side-effects.\n            {\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        instance = new ctor(props, context); // eslint-disable-line no-new\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n            }\n            var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n            instance.updater = classComponentUpdater;\n            workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n            set(instance, workInProgress);\n            {\n                instance._reactInternalInstance = fakeInternalInstance;\n            }\n            {\n                if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n                    var componentName = getComponentNameFromType(ctor) || 'Component';\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = 'componentWillMount';\n                    } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n                        foundWillMountName = 'UNSAFE_componentWillMount';\n                    }\n                    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = 'componentWillReceiveProps';\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n                        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n                    }\n                    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = 'componentWillUpdate';\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n                        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || 'Component';\n                        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://react.dev/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : '', foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : '', foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : '');\n                        }\n                    }\n                }\n            }\n            return instance;\n        }\n        function callComponentWillMount(workInProgress, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === 'function') {\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === 'function') {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error('%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentNameFromFiber(workInProgress) || 'Component');\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillReceiveProps === 'function') {\n                instance.componentWillReceiveProps(newProps, nextContext);\n            }\n            if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n                instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n            }\n            if (instance.state !== oldState) {\n                {\n                    var componentName = getComponentNameFromFiber(workInProgress) || 'Component';\n                    if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n                        didWarnAboutStateAssignmentForComponent.add(componentName);\n                        error('%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n                    }\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n            {\n                checkClassInstance(workInProgress, ctor, newProps);\n            }\n            var instance = workInProgress.stateNode;\n            instance.props = newProps;\n            instance.state = workInProgress.memoizedState;\n            instance.refs = {};\n            initializeUpdateQueue(workInProgress);\n            var contextType = ctor.contextType;\n            if (typeof contextType === 'object' && contextType !== null) {\n                instance.context = readContext(contextType);\n            } else {\n                instance.context = emptyContextObject;\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || 'Component';\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error('%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\n                    }\n                }\n                if (workInProgress.mode & StrictLegacyMode) {\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n                }\n                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n            }\n            instance.state = workInProgress.memoizedState;\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === 'function') {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                instance.state = workInProgress.memoizedState;\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n                callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n                suspendIfUpdateReadFromEntangledAsyncAction();\n                instance.state = workInProgress.memoizedState;\n            }\n            if (typeof instance.componentDidMount === 'function') {\n                workInProgress.flags |= Update | LayoutStatic;\n            }\n            if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                workInProgress.flags |= MountLayoutDev;\n            }\n        }\n        function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n            var instance = workInProgress.stateNode;\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            var oldProps = resolveClassComponentProps(ctor, unresolvedOldProps);\n            instance.props = oldProps;\n            var oldContext = instance.context;\n            var contextType = ctor.contextType;\n            var nextContext = emptyContextObject;\n            if (typeof contextType === 'object' && contextType !== null) {\n                nextContext = readContext(contextType);\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // When comparing whether props changed, we should compare using the\n            // unresolved props object that is stored on the fiber, rather than the\n            // one that gets assigned to the instance, because that object may have been\n            // cloned to resolve default props and/or remove `ref`.\n            var unresolvedNewProps = workInProgress.pendingProps;\n            var didReceiveNewProps = unresolvedNewProps !== unresolvedOldProps; // Note: During these life-cycles, instance.props/instance.state are what\n            // ever the previously attempted to render - not the \"current\". However,\n            // during componentDidUpdate we pass the \"current\" props.\n            // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n                if (didReceiveNewProps || oldContext !== nextContext) {\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n                }\n            }\n            resetHasForceUpdateBeforeProcessing();\n            var oldState = workInProgress.memoizedState;\n            var newState = instance.state = oldState;\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            newState = workInProgress.memoizedState;\n            if (!didReceiveNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidMount === 'function') {\n                    workInProgress.flags |= Update | LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    workInProgress.flags |= MountLayoutDev;\n                }\n                return false;\n            }\n            if (typeof getDerivedStateFromProps === 'function') {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                newState = workInProgress.memoizedState;\n            }\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n            if (shouldUpdate) {\n                // In order to support react-lifecycles-compat polyfilled components,\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n                    if (typeof instance.componentWillMount === 'function') {\n                        instance.componentWillMount();\n                    }\n                    if (typeof instance.UNSAFE_componentWillMount === 'function') {\n                        instance.UNSAFE_componentWillMount();\n                    }\n                }\n                if (typeof instance.componentDidMount === 'function') {\n                    workInProgress.flags |= Update | LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    workInProgress.flags |= MountLayoutDev;\n                }\n            } else {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidMount === 'function') {\n                    workInProgress.flags |= Update | LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    workInProgress.flags |= MountLayoutDev;\n                } // If shouldComponentUpdate returned false, we should still update the\n                // memoized state to indicate that this work can be reused.\n                workInProgress.memoizedProps = newProps;\n                workInProgress.memoizedState = newState;\n            } // Update the existing instance's state, props, and context pointers even\n            // if shouldComponentUpdate returns false.\n            instance.props = newProps;\n            instance.state = newState;\n            instance.context = nextContext;\n            return shouldUpdate;\n        } // Invokes the update life-cycles and returns false if it shouldn't rerender.\n        function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {\n            var instance = workInProgress.stateNode;\n            cloneUpdateQueue(current, workInProgress);\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            var oldProps = resolveClassComponentProps(ctor, unresolvedOldProps);\n            instance.props = oldProps;\n            var unresolvedNewProps = workInProgress.pendingProps;\n            var oldContext = instance.context;\n            var contextType = ctor.contextType;\n            var nextContext = emptyContextObject;\n            if (typeof contextType === 'object' && contextType !== null) {\n                nextContext = readContext(contextType);\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n            // ever the previously attempted to render - not the \"current\". However,\n            // during componentDidUpdate we pass the \"current\" props.\n            // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n                if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n                }\n            }\n            resetHasForceUpdateBeforeProcessing();\n            var oldState = workInProgress.memoizedState;\n            var newState = instance.state = oldState;\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            newState = workInProgress.memoizedState;\n            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Update;\n                    }\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Snapshot;\n                    }\n                }\n                return false;\n            }\n            if (typeof getDerivedStateFromProps === 'function') {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                newState = workInProgress.memoizedState;\n            }\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n            // both before and after `shouldComponentUpdate` has been called. Not ideal,\n            // but I'm loath to refactor this function. This only happens for memoized\n            // components so it's not that common.\n            enableLazyContextPropagation;\n            if (shouldUpdate) {\n                // In order to support react-lifecycles-compat polyfilled components,\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n                    if (typeof instance.componentWillUpdate === 'function') {\n                        instance.componentWillUpdate(newProps, newState, nextContext);\n                    }\n                    if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n                        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n                    }\n                }\n                if (typeof instance.componentDidUpdate === 'function') {\n                    workInProgress.flags |= Update;\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    workInProgress.flags |= Snapshot;\n                }\n            } else {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Update;\n                    }\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Snapshot;\n                    }\n                } // If shouldComponentUpdate returned false, we should still update the\n                // memoized props/state to indicate that this work can be reused.\n                workInProgress.memoizedProps = newProps;\n                workInProgress.memoizedState = newState;\n            } // Update the existing instance's state, props, and context pointers even\n            // if shouldComponentUpdate returns false.\n            instance.props = newProps;\n            instance.state = newState;\n            instance.context = nextContext;\n            return shouldUpdate;\n        }\n        function resolveClassComponentProps(Component, baseProps, // would have already been resolved by the JSX runtime.\n        // TODO: We're going to remove default prop resolution from the JSX runtime\n        // and keep it only for class components. As part of that change, we should\n        // remove this extra check.\n        alreadyResolvedDefaultProps) {\n            var newProps = baseProps;\n            {\n                // Remove ref from the props object, if it exists.\n                if ('ref' in baseProps) {\n                    newProps = {};\n                    for(var propName in baseProps){\n                        if (propName !== 'ref') {\n                            newProps[propName] = baseProps[propName];\n                        }\n                    }\n                }\n            }\n            var defaultProps = Component.defaultProps;\n            if (defaultProps && // default props here in the reconciler, rather than in the JSX runtime.\n            disableDefaultPropsExceptForClasses) {\n                // We may have already copied the props object above to remove ref. If so,\n                // we can modify that. Otherwise, copy the props object with Object.assign.\n                if (newProps === baseProps) {\n                    newProps = assign({}, newProps);\n                } // Taken from old JSX runtime, where this used to live.\n                for(var _propName in defaultProps){\n                    if (newProps[_propName] === undefined) {\n                        newProps[_propName] = defaultProps[_propName];\n                    }\n                }\n            }\n            return newProps;\n        }\n        var reportGlobalError = typeof reportError === 'function' ? // emulating an uncaught JavaScript error.\n        reportError : function(error) {\n            if (false) { var shouldLog, event, message; } else if (typeof process === 'object' && // $FlowFixMe[method-unbinding]\n            typeof process.emit === 'function') {\n                // Node Polyfill\n                process.emit('uncaughtException', error);\n                return;\n            } // eslint-disable-next-line react-internal/no-production-logging\n            console['error'](error);\n        };\n        var componentName = null;\n        var errorBoundaryName = null;\n        function defaultOnUncaughtError(error, errorInfo) {\n            // Overriding this can silence these warnings e.g. for tests.\n            // See https://github.com/facebook/react/pull/13384\n            // For uncaught root errors we report them as uncaught to the browser's\n            // onerror callback. This won't have component stacks and the error addendum.\n            // So we add those into a separate console.warn.\n            reportGlobalError(error);\n            {\n                var componentNameMessage = componentName ? \"An error occurred in the <\" + componentName + \"> component.\" : 'An error occurred in one of your React components.';\n                var errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://react.dev/link/error-boundaries to learn more about error boundaries.';\n                {\n                    // The current Fiber is disconnected at this point which means that console printing\n                    // cannot add a component stack since it terminates at the deletion node. This is not\n                    // a problem for owner stacks which are not disconnected but for the parent component\n                    // stacks we need to use the snapshot we've previously extracted.\n                    var componentStack = errorInfo.componentStack != null ? errorInfo.componentStack : ''; // Don't transform to our wrapper\n                    console['warn']('%s\\n\\n%s\\n%s', componentNameMessage, errorBoundaryMessage, componentStack);\n                }\n            }\n        }\n        function defaultOnCaughtError(error$1, errorInfo) {\n            // Overriding this can silence these warnings e.g. for tests.\n            // See https://github.com/facebook/react/pull/13384\n            // Caught by error boundary\n            {\n                var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component.\" : 'The above error occurred in one of your React components.'; // In development, we provide our own message which includes the component stack\n                // in addition to the error.\n                var recreateMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + (errorBoundaryName || 'Anonymous') + \".\");\n                {\n                    // The current Fiber is disconnected at this point which means that console printing\n                    // cannot add a component stack since it terminates at the deletion node. This is not\n                    // a problem for owner stacks which are not disconnected but for the parent component\n                    // stacks we need to use the snapshot we've previously extracted.\n                    var componentStack = errorInfo.componentStack != null ? errorInfo.componentStack : ''; // Don't transform to our wrapper\n                    console['error']('%o\\n\\n%s\\n\\n%s\\n%s', error$1, componentNameMessage, recreateMessage, componentStack);\n                }\n            }\n        }\n        function defaultOnRecoverableError(error, errorInfo) {\n            reportGlobalError(error);\n        }\n        function logUncaughtError(root, errorInfo) {\n            try {\n                if (true) {\n                    componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n                    errorBoundaryName = null;\n                }\n                var error = errorInfo.value;\n                if ( true && ReactSharedInternals.actQueue !== null) {\n                    // For uncaught errors inside act, we track them on the act and then\n                    // rethrow them into the test.\n                    ReactSharedInternals.thrownErrors.push(error);\n                    return;\n                }\n                var onUncaughtError = root.onUncaughtError;\n                onUncaughtError(error, {\n                    componentStack: errorInfo.stack\n                });\n            } catch (e) {\n                // This method must not throw, or React internal state will get messed up.\n                // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n                // we want to report this error outside of the normal stack as a last resort.\n                // https://github.com/facebook/react/issues/13188\n                setTimeout(function() {\n                    throw e;\n                });\n            }\n        }\n        function logCaughtError(root, boundary, errorInfo) {\n            try {\n                if (true) {\n                    componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n                    errorBoundaryName = getComponentNameFromFiber(boundary);\n                }\n                var error = errorInfo.value;\n                var onCaughtError = root.onCaughtError;\n                onCaughtError(error, {\n                    componentStack: errorInfo.stack,\n                    errorBoundary: boundary.tag === ClassComponent ? boundary.stateNode // This should always be the case as long as we only have class boundaries\n                     : null\n                });\n            } catch (e) {\n                // This method must not throw, or React internal state will get messed up.\n                // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n                // we want to report this error outside of the normal stack as a last resort.\n                // https://github.com/facebook/react/issues/13188\n                setTimeout(function() {\n                    throw e;\n                });\n            }\n        }\n        function createRootErrorUpdate(root, errorInfo, lane) {\n            var update = createUpdate(lane); // Unmount the root by rendering null.\n            update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            update.payload = {\n                element: null\n            };\n            update.callback = function() {\n                var prevFiber = getCurrentFiber(); // should just be the root\n                setCurrentDebugFiberInDEV(errorInfo.source);\n                logUncaughtError(root, errorInfo);\n                setCurrentDebugFiberInDEV(prevFiber);\n            };\n            return update;\n        }\n        function createClassErrorUpdate(lane) {\n            var update = createUpdate(lane);\n            update.tag = CaptureUpdate;\n            return update;\n        }\n        function initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n            if (typeof getDerivedStateFromError === 'function') {\n                var error$1 = errorInfo.value;\n                update.payload = function() {\n                    return getDerivedStateFromError(error$1);\n                };\n                update.callback = function() {\n                    {\n                        markFailedErrorBoundaryForHotReloading(fiber);\n                    }\n                    var prevFiber = getCurrentFiber(); // should be the error boundary\n                    setCurrentDebugFiberInDEV(errorInfo.source);\n                    logCaughtError(root, fiber, errorInfo);\n                    setCurrentDebugFiberInDEV(prevFiber);\n                };\n            }\n            var inst = fiber.stateNode;\n            if (inst !== null && typeof inst.componentDidCatch === 'function') {\n                // $FlowFixMe[missing-this-annot]\n                update.callback = function callback() {\n                    {\n                        markFailedErrorBoundaryForHotReloading(fiber);\n                    }\n                    var prevFiber = getCurrentFiber(); // should be the error boundary\n                    setCurrentDebugFiberInDEV(errorInfo.source);\n                    logCaughtError(root, fiber, errorInfo);\n                    setCurrentDebugFiberInDEV(prevFiber);\n                    if (typeof getDerivedStateFromError !== 'function') {\n                        // To preserve the preexisting retry behavior of error boundaries,\n                        // we keep track of which ones already failed during this batch.\n                        // This gets reset before we yield back to the browser.\n                        // TODO: Warn in strict mode if getDerivedStateFromError is\n                        // not defined.\n                        markLegacyErrorBoundaryAsFailed(this);\n                    }\n                    var error$1 = errorInfo.value;\n                    var stack = errorInfo.stack;\n                    this.componentDidCatch(error$1, {\n                        componentStack: stack !== null ? stack : ''\n                    });\n                    {\n                        if (typeof getDerivedStateFromError !== 'function') {\n                            // If componentDidCatch is the only error boundary method defined,\n                            // then it needs to call setState to recover from errors.\n                            // If no state update is scheduled then the boundary will swallow the error.\n                            if (!includesSomeLane(fiber.lanes, SyncLane)) {\n                                error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentNameFromFiber(fiber) || 'Unknown');\n                            }\n                        }\n                    }\n                };\n            }\n        }\n        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {\n            // with the normal suspend path.\n            //\n            // After this we'll use a set of heuristics to determine whether this\n            // render pass will run to completion or restart or \"suspend\" the commit.\n            // The actual logic for this is spread out in different places.\n            //\n            // This first principle is that if we're going to suspend when we complete\n            // a root, then we should also restart if we get an update or ping that\n            // might unsuspend it, and vice versa. The only reason to suspend is\n            // because you think you might want to restart before committing. However,\n            // it doesn't make sense to restart only while in the period we're suspended.\n            //\n            // Restarting too aggressively is also not good because it starves out any\n            // intermediate loading state. So we use heuristics to determine when.\n            // Suspense Heuristics\n            //\n            // If nothing threw a Promise or all the same fallbacks are already showing,\n            // then don't suspend/restart.\n            //\n            // If this is an initial render of a new tree of Suspense boundaries and\n            // those trigger a fallback, then don't suspend/restart. We want to ensure\n            // that we can show the initial loading state as quickly as possible.\n            //\n            // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n            // a fallback, then we should always suspend/restart. Transitions apply\n            // to this case. If none is defined, JND is used instead.\n            //\n            // If we're already showing a fallback and it gets \"retried\", allowing us to show\n            // another level, but there's still an inner boundary that would show a fallback,\n            // then we suspend/restart for 500ms since the last time we showed a fallback\n            // anywhere in the tree. This effectively throttles progressive loading into a\n            // consistent train of commits. This also gives us an opportunity to restart to\n            // get to the completed state slightly earlier.\n            //\n            // If there's ambiguity due to batching it's resolved in preference of:\n            // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n            //\n            // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n            // ensure that new initial loading states can commit as soon as possible.\n            suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in\n            // the begin phase to prevent an early bailout.\n            suspenseBoundary.lanes = rootRenderLanes;\n            return suspenseBoundary;\n        }\n        function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n            // The source fiber did not complete.\n            sourceFiber.flags |= Incomplete;\n            {\n                if (isDevToolsPresent) {\n                    // If we have pending work still, restore the original updaters\n                    restorePendingUpdaters(root, rootRenderLanes);\n                }\n            }\n            if (value !== null && typeof value === 'object') {\n                if (typeof value.then === 'function') {\n                    // This is a wakeable. The component suspended.\n                    var wakeable = value;\n                    {\n                        if (getIsHydrating() && disableLegacyMode) {\n                            markDidThrowWhileHydratingDEV();\n                        }\n                    }\n                    var suspenseBoundary = getSuspenseHandler();\n                    if (suspenseBoundary !== null) {\n                        switch(suspenseBoundary.tag){\n                            case SuspenseComponent:\n                                {\n                                    // If this suspense boundary is not already showing a fallback, mark\n                                    // the in-progress render as suspended. We try to perform this logic\n                                    // as soon as soon as possible during the render phase, so the work\n                                    // loop can know things like whether it's OK to switch to other tasks,\n                                    // or whether it can wait for data to resolve before continuing.\n                                    // TODO: Most of these checks are already performed when entering a\n                                    // Suspense boundary. We should track the information on the stack so\n                                    // we don't have to recompute it on demand. This would also allow us\n                                    // to unify with `use` which needs to perform this logic even sooner,\n                                    // before `throwException` is called.\n                                    {\n                                        if (getShellBoundary() === null) {\n                                            // Suspended in the \"shell\" of the app. This is an undesirable\n                                            // loading state. We should avoid committing this tree.\n                                            renderDidSuspendDelayIfPossible();\n                                        } else {\n                                            // If we suspended deeper than the shell, we don't need to delay\n                                            // the commmit. However, we still call renderDidSuspend if this is\n                                            // a new boundary, to tell the work loop that a new fallback has\n                                            // appeared during this render.\n                                            // TODO: Theoretically we should be able to delete this branch.\n                                            // It's currently used for two things: 1) to throttle the\n                                            // appearance of successive loading states, and 2) in\n                                            // SuspenseList, to determine whether the children include any\n                                            // pending fallbacks. For 1, we should apply throttling to all\n                                            // retries, not just ones that render an additional fallback. For\n                                            // 2, we should check subtreeFlags instead. Then we can delete\n                                            // this branch.\n                                            var current = suspenseBoundary.alternate;\n                                            if (current === null) {\n                                                renderDidSuspend();\n                                            }\n                                        }\n                                    }\n                                    suspenseBoundary.flags &= ~ForceClientRender;\n                                    markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Retry listener\n                                    //\n                                    // If the fallback does commit, we need to attach a different type of\n                                    // listener. This one schedules an update on the Suspense boundary to\n                                    // turn the fallback state off.\n                                    //\n                                    // Stash the wakeable on the boundary fiber so we can access it in the\n                                    // commit phase.\n                                    //\n                                    // When the wakeable resolves, we'll attempt to render the boundary\n                                    // again (\"retry\").\n                                    // Check if this is a Suspensey resource. We do not attach retry\n                                    // listeners to these, because we don't actually need them for\n                                    // rendering. Only for committing. Instead, if a fallback commits\n                                    // and the only thing that suspended was a Suspensey resource, we\n                                    // retry immediately.\n                                    // TODO: Refactor throwException so that we don't have to do this type\n                                    // check. The caller already knows what the cause was.\n                                    var isSuspenseyResource = wakeable === noopSuspenseyCommitThenable;\n                                    if (isSuspenseyResource) {\n                                        suspenseBoundary.flags |= ScheduleRetry;\n                                    } else {\n                                        var retryQueue = suspenseBoundary.updateQueue;\n                                        if (retryQueue === null) {\n                                            suspenseBoundary.updateQueue = new Set([\n                                                wakeable\n                                            ]);\n                                        } else {\n                                            retryQueue.add(wakeable);\n                                        } // We only attach ping listeners in concurrent mode. Legacy\n                                        // Suspense always commits fallbacks synchronously, so there are\n                                        // no pings.\n                                        {\n                                            attachPingListener(root, wakeable, rootRenderLanes);\n                                        }\n                                    }\n                                    return false;\n                                }\n                            case OffscreenComponent:\n                                {\n                                    {\n                                        suspenseBoundary.flags |= ShouldCapture;\n                                        var _isSuspenseyResource = wakeable === noopSuspenseyCommitThenable;\n                                        if (_isSuspenseyResource) {\n                                            suspenseBoundary.flags |= ScheduleRetry;\n                                        } else {\n                                            var offscreenQueue = suspenseBoundary.updateQueue;\n                                            if (offscreenQueue === null) {\n                                                var newOffscreenQueue = {\n                                                    transitions: null,\n                                                    markerInstances: null,\n                                                    retryQueue: new Set([\n                                                        wakeable\n                                                    ])\n                                                };\n                                                suspenseBoundary.updateQueue = newOffscreenQueue;\n                                            } else {\n                                                var _retryQueue = offscreenQueue.retryQueue;\n                                                if (_retryQueue === null) {\n                                                    offscreenQueue.retryQueue = new Set([\n                                                        wakeable\n                                                    ]);\n                                                } else {\n                                                    _retryQueue.add(wakeable);\n                                                }\n                                            }\n                                            attachPingListener(root, wakeable, rootRenderLanes);\n                                        }\n                                        return false;\n                                    }\n                                }\n                        }\n                        throw new Error(\"Unexpected Suspense handler tag (\" + suspenseBoundary.tag + \"). This \" + 'is a bug in React.');\n                    } else {\n                        // No boundary was found. Unless this is a sync update, this is OK.\n                        // We can suspend and wait for more data to arrive.\n                        {\n                            // In a concurrent root, suspending without a Suspense boundary is\n                            // allowed. It will suspend indefinitely without committing.\n                            //\n                            // TODO: Should we have different behavior for discrete updates? What\n                            // about flushSync? Maybe it should put the tree into an inert state,\n                            // and potentially log a warning. Revisit this for a future release.\n                            attachPingListener(root, wakeable, rootRenderLanes);\n                            renderDidSuspendDelayIfPossible();\n                            return false;\n                        }\n                    }\n                }\n            } // This is a regular error, not a Suspense wakeable.\n            if (getIsHydrating() && disableLegacyMode) {\n                markDidThrowWhileHydratingDEV();\n                var _suspenseBoundary = getSuspenseHandler(); // If the error was thrown during hydration, we may be able to recover by\n                // discarding the dehydrated content and switching to a client render.\n                // Instead of surfacing the error, find the nearest Suspense boundary\n                // and render it again without hydration.\n                if (_suspenseBoundary !== null) {\n                    if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags$1) {\n                        // Set a flag to indicate that we should try rendering the normal\n                        // children again, not the fallback.\n                        _suspenseBoundary.flags |= ForceClientRender;\n                    }\n                    markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Even though the user may not be affected by this error, we should\n                    // still log it so it can be fixed.\n                    if (value !== HydrationMismatchException) {\n                        var _wrapperError = new Error('There was an error while hydrating but React was able to recover by ' + 'instead client rendering from the nearest Suspense boundary.', {\n                            cause: value\n                        });\n                        queueHydrationError(createCapturedValueAtFiber(_wrapperError, sourceFiber));\n                    }\n                    return false;\n                } else {\n                    if (value !== HydrationMismatchException) {\n                        var _wrapperError2 = new Error('There was an error while hydrating but React was able to recover by ' + 'instead client rendering the entire root.', {\n                            cause: value\n                        });\n                        queueHydrationError(createCapturedValueAtFiber(_wrapperError2, sourceFiber));\n                    }\n                    var _workInProgress = root.current.alternate; // Schedule an update at the root to log the error but this shouldn't\n                    // actually happen because we should recover.\n                    _workInProgress.flags |= ShouldCapture;\n                    var lane = pickArbitraryLane(rootRenderLanes);\n                    _workInProgress.lanes = mergeLanes(_workInProgress.lanes, lane);\n                    var rootErrorInfo = createCapturedValueAtFiber(value, sourceFiber);\n                    var update = createRootErrorUpdate(_workInProgress.stateNode, rootErrorInfo, lane);\n                    enqueueCapturedUpdate(_workInProgress, update);\n                    renderDidError();\n                    return false;\n                }\n            }\n            var wrapperError = new Error('There was an error during concurrent rendering but React was able to recover by ' + 'instead synchronously rendering the entire root.', {\n                cause: value\n            });\n            queueConcurrentError(createCapturedValueAtFiber(wrapperError, sourceFiber));\n            renderDidError(); // We didn't find a boundary that could handle this type of exception. Start\n            // over and traverse parent path again, this time treating the exception\n            // as an error.\n            if (returnFiber === null) {\n                // There's no return fiber, which means the root errored. This should never\n                // happen. Return `true` to trigger a fatal error (panic).\n                return true;\n            }\n            var errorInfo = createCapturedValueAtFiber(value, sourceFiber);\n            var workInProgress = returnFiber;\n            do {\n                switch(workInProgress.tag){\n                    case HostRoot:\n                        {\n                            workInProgress.flags |= ShouldCapture;\n                            var _lane = pickArbitraryLane(rootRenderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane);\n                            var _update = createRootErrorUpdate(workInProgress.stateNode, errorInfo, _lane);\n                            enqueueCapturedUpdate(workInProgress, _update);\n                            return false;\n                        }\n                    case ClassComponent:\n                        // Capture and retry\n                        var ctor = workInProgress.type;\n                        var instance = workInProgress.stateNode;\n                        if ((workInProgress.flags & DidCapture) === NoFlags$1 && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n                            workInProgress.flags |= ShouldCapture;\n                            var _lane2 = pickArbitraryLane(rootRenderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane2); // Schedule the error boundary to re-render using updated state\n                            var _update2 = createClassErrorUpdate(_lane2);\n                            initializeClassErrorUpdate(_update2, root, workInProgress, errorInfo);\n                            enqueueCapturedUpdate(workInProgress, _update2);\n                            return false;\n                        }\n                        break;\n                } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                workInProgress = workInProgress.return;\n            }while (workInProgress !== null);\n            return false;\n        }\n        // into a dehydrated boundary.\n        var SelectiveHydrationException = new Error(\"This is not a real error. It's an implementation detail of React's \" + \"selective hydration feature. If this leaks into userspace, it's a bug in \" + 'React. Please file an issue.');\n        var didReceiveUpdate = false;\n        var didWarnAboutBadClass;\n        var didWarnAboutContextTypeOnFunctionComponent;\n        var didWarnAboutGetDerivedStateOnFunctionComponent;\n        var didWarnAboutReassigningProps;\n        var didWarnAboutRevealOrder;\n        var didWarnAboutTailOptions;\n        {\n            didWarnAboutBadClass = {};\n            didWarnAboutContextTypeOnFunctionComponent = {};\n            didWarnAboutGetDerivedStateOnFunctionComponent = {};\n            didWarnAboutReassigningProps = false;\n            didWarnAboutRevealOrder = {};\n            didWarnAboutTailOptions = {};\n        }\n        function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n            if (current === null) {\n                // If this is a fresh new component that hasn't been rendered yet, we\n                // won't update its child set by applying minimal side-effects. Instead,\n                // we will add them all to the child before it gets rendered. That means\n                // we can optimize this reconciliation pass by not tracking side-effects.\n                workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                // If the current child is the same as the work in progress, it means that\n                // we haven't yet started any work on these children. Therefore, we use\n                // the clone algorithm to create a copy of all the current children.\n                // If we had any progressed work already, that is invalid at this point so\n                // let's throw it out.\n                workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n            }\n        }\n        function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\n            // This function is fork of reconcileChildren. It's used in cases where we\n            // want to reconcile without matching against the existing set. This has the\n            // effect of all current children being unmounted; even if the type and key\n            // are the same, the old child is unmounted and a new child is created.\n            //\n            // To do this, we're going to go through the reconcile algorithm twice. In\n            // the first pass, we schedule a deletion for all the current children by\n            // passing null.\n            workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\n            // pass null in place of where we usually pass the current child set. This has\n            // the effect of remounting all children regardless of whether their\n            // identities match.\n            workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n        }\n        function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n            // TODO: current can be non-null here even if the component\n            // hasn't yet mounted. This happens after the first render suspends.\n            // We'll need to figure out if this is fine or can cause issues.\n            var render = Component.render;\n            var ref = workInProgress.ref;\n            var propsWithoutRef;\n            if ('ref' in nextProps) {\n                // `ref` is just a prop now, but `forwardRef` expects it to not appear in\n                // the props object. This used to happen in the JSX runtime, but now we do\n                // it here.\n                propsWithoutRef = {};\n                for(var key in nextProps){\n                    // Since `ref` should only appear in props via the JSX transform, we can\n                    // assume that this is a plain object. So we don't need a\n                    // hasOwnProperty check.\n                    if (key !== 'ref') {\n                        propsWithoutRef[key] = nextProps[key];\n                    }\n                }\n            } else {\n                propsWithoutRef = nextProps;\n            } // The rest is a fork of updateFunctionComponent\n            var nextChildren;\n            var hasId;\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                setIsRendering(true);\n                nextChildren = renderWithHooks(current, workInProgress, render, propsWithoutRef, ref, renderLanes);\n                hasId = checkDidRenderIdHook();\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            if (current === null) {\n                var type = Component.type;\n                if (isSimpleFunctionComponent(type) && Component.compare === null && disableDefaultPropsExceptForClasses) {\n                    var resolvedType = type;\n                    {\n                        resolvedType = resolveFunctionForHotReloading(type);\n                    }\n                    // and with only the default shallow comparison, we upgrade it\n                    // to a SimpleMemoComponent to allow fast path updates.\n                    workInProgress.tag = SimpleMemoComponent;\n                    workInProgress.type = resolvedType;\n                    {\n                        validateFunctionComponentInDev(workInProgress, type);\n                    }\n                    return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);\n                }\n                var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n                child.ref = workInProgress.ref;\n                child.return = workInProgress;\n                workInProgress.child = child;\n                return child;\n            }\n            var currentChild = current.child; // This is always exactly one child\n            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n            if (!hasScheduledUpdateOrContext) {\n                // This will be the props with resolved defaultProps,\n                // unlike current.memoizedProps which will be the unresolved ones.\n                var prevProps = currentChild.memoizedProps; // Default to shallow comparison\n                var compare = Component.compare;\n                compare = compare !== null ? compare : shallowEqual;\n                if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                }\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            var newChild = createWorkInProgress(currentChild, nextProps);\n            newChild.ref = workInProgress.ref;\n            newChild.return = workInProgress;\n            workInProgress.child = newChild;\n            return newChild;\n        }\n        function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            // TODO: current can be non-null here even if the component\n            // hasn't yet mounted. This happens when the inner render suspends.\n            // We'll need to figure out if this is fine or can cause issues.\n            if (current !== null) {\n                var prevProps = current.memoizedProps;\n                if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) {\n                    didReceiveUpdate = false; // The props are shallowly equal. Reuse the previous props object, like we\n                    // would during a normal fiber bailout.\n                    //\n                    // We don't have strong guarantees that the props object is referentially\n                    // equal during updates where we can't bail out anyway — like if the props\n                    // are shallowly equal, but there's a local state or context update in the\n                    // same batch.\n                    //\n                    // However, as a principle, we should aim to make the behavior consistent\n                    // across different ways of memoizing a component. For example, React.memo\n                    // has a different internal Fiber layout if you pass a normal function\n                    // component (SimpleMemoComponent) versus if you pass a different type\n                    // like forwardRef (MemoComponent). But this is an implementation detail.\n                    // Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n                    // affect whether the props object is reused during a bailout.\n                    workInProgress.pendingProps = nextProps = prevProps;\n                    if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n                        // The pending lanes were cleared at the beginning of beginWork. We're\n                        // about to bail out, but there might be other lanes that weren't\n                        // included in the current render. Usually, the priority level of the\n                        // remaining updates is accumulated during the evaluation of the\n                        // component (i.e. when processing the update queue). But since since\n                        // we're bailing out early *without* evaluating the component, we need\n                        // to account for it here, too. Reset to the value of the current fiber.\n                        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n                        // because a MemoComponent fiber does not have hooks or an update queue;\n                        // rather, it wraps around an inner component, which may or may not\n                        // contains hooks.\n                        // TODO: Move the reset at in beginWork out of the common path so that\n                        // this is no longer necessary.\n                        workInProgress.lanes = current.lanes;\n                        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags$1) {\n                        // This is a special case that only exists for legacy mode.\n                        // See https://github.com/facebook/react/pull/19216.\n                        didReceiveUpdate = true;\n                    }\n                }\n            }\n            return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n        }\n        function updateOffscreenComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps;\n            var nextChildren = nextProps.children;\n            var nextIsDetached = (workInProgress.stateNode._pendingVisibility & OffscreenDetached) !== 0;\n            var prevState = current !== null ? current.memoizedState : null;\n            markRef(current, workInProgress);\n            if (nextProps.mode === 'hidden' || enableLegacyHidden || nextIsDetached) {\n                // Rendering a hidden tree.\n                var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags$1;\n                if (didSuspend) {\n                    // Something suspended inside a hidden tree\n                    // Include the base lanes from the last render\n                    var nextBaseLanes = prevState !== null ? mergeLanes(prevState.baseLanes, renderLanes) : renderLanes;\n                    if (current !== null) {\n                        // Reset to the current children\n                        var currentChild = workInProgress.child = current.child; // The current render suspended, but there may be other lanes with\n                        // pending work. We can't read `childLanes` from the current Offscreen\n                        // fiber because we reset it when it was deferred; however, we can read\n                        // the pending lanes from the child fibers.\n                        var currentChildLanes = NoLanes;\n                        while(currentChild !== null){\n                            currentChildLanes = mergeLanes(mergeLanes(currentChildLanes, currentChild.lanes), currentChild.childLanes);\n                            currentChild = currentChild.sibling;\n                        }\n                        var lanesWeJustAttempted = nextBaseLanes;\n                        var remainingChildLanes = removeLanes(currentChildLanes, lanesWeJustAttempted);\n                        workInProgress.childLanes = remainingChildLanes;\n                    } else {\n                        workInProgress.childLanes = NoLanes;\n                        workInProgress.child = null;\n                    }\n                    return deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes);\n                }\n                if (!includesSomeLane(renderLanes, OffscreenLane)) {\n                    // We're hidden, and we're not rendering at Offscreen. We will bail out\n                    // and resume this tree later.\n                    // Schedule this fiber to re-render at Offscreen priority\n                    workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane); // Include the base lanes from the last render\n                    var _nextBaseLanes = prevState !== null ? mergeLanes(prevState.baseLanes, renderLanes) : renderLanes;\n                    return deferHiddenOffscreenComponent(current, workInProgress, _nextBaseLanes);\n                } else {\n                    // This is the second render. The surrounding visible content has already\n                    // committed. Now we resume rendering the hidden tree.\n                    // Rendering at offscreen, so we can clear the base lanes.\n                    var _nextState = {\n                        baseLanes: NoLanes,\n                        cachePool: null\n                    };\n                    workInProgress.memoizedState = _nextState;\n                    if (current !== null) {\n                        // If the render that spawned this one accessed the cache pool, resume\n                        // using the same cache. Unless the parent changed, since that means\n                        // there was a refresh.\n                        var prevCachePool = prevState !== null ? prevState.cachePool : null; // TODO: Consider if and how Offscreen pre-rendering should\n                        // be attributed to the transition that spawned it\n                        pushTransition(workInProgress, prevCachePool);\n                    } // Push the lanes that were skipped when we bailed out.\n                    if (prevState !== null) {\n                        pushHiddenContext(workInProgress, prevState);\n                    } else {\n                        reuseHiddenContextOnStack(workInProgress);\n                    }\n                    pushOffscreenSuspenseHandler(workInProgress);\n                }\n            } else {\n                // Rendering a visible tree.\n                if (prevState !== null) {\n                    // We're going from hidden -> visible.\n                    var _prevCachePool = null;\n                    {\n                        // If the render that spawned this one accessed the cache pool, resume\n                        // using the same cache. Unless the parent changed, since that means\n                        // there was a refresh.\n                        _prevCachePool = prevState.cachePool;\n                    }\n                    pushTransition(workInProgress, _prevCachePool); // Push the lanes that were skipped when we bailed out.\n                    pushHiddenContext(workInProgress, prevState);\n                    reuseSuspenseHandlerOnStack(workInProgress); // Since we're not hidden anymore, reset the state\n                    workInProgress.memoizedState = null;\n                } else {\n                    // We weren't previously hidden, and we still aren't, so there's nothing\n                    // special to do. Need to push to the stack regardless, though, to avoid\n                    // a push/pop misalignment.\n                    {\n                        // If the render that spawned this one accessed the cache pool, resume\n                        // using the same cache. Unless the parent changed, since that means\n                        // there was a refresh.\n                        if (current !== null) {\n                            pushTransition(workInProgress, null);\n                        }\n                    }\n                    // to avoid a push/pop misalignment.\n                    reuseHiddenContextOnStack(workInProgress);\n                    reuseSuspenseHandlerOnStack(workInProgress);\n                }\n            }\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {\n            var nextState = {\n                baseLanes: nextBaseLanes,\n                // Save the cache pool so we can resume later.\n                cachePool: getOffscreenDeferredCache()\n            };\n            workInProgress.memoizedState = nextState;\n            {\n                // push the cache pool even though we're going to bail out\n                // because otherwise there'd be a context mismatch\n                if (current !== null) {\n                    pushTransition(workInProgress, null);\n                }\n            }\n            // to avoid a push/pop misalignment.\n            reuseHiddenContextOnStack(workInProgress);\n            pushOffscreenSuspenseHandler(workInProgress);\n            return null;\n        } // Note: These happen to have identical begin phases, for now. We shouldn't hold\n        function updateCacheComponent(current, workInProgress, renderLanes) {\n            prepareToReadContext(workInProgress, renderLanes);\n            var parentCache = readContext(CacheContext);\n            if (current === null) {\n                // Initial mount. Request a fresh cache from the pool.\n                var freshCache = requestCacheFromPool(renderLanes);\n                var initialState = {\n                    parent: parentCache,\n                    cache: freshCache\n                };\n                workInProgress.memoizedState = initialState;\n                initializeUpdateQueue(workInProgress);\n                pushCacheProvider(workInProgress, freshCache);\n            } else {\n                // Check for updates\n                if (includesSomeLane(current.lanes, renderLanes)) {\n                    cloneUpdateQueue(current, workInProgress);\n                    processUpdateQueue(workInProgress, null, null, renderLanes);\n                    suspendIfUpdateReadFromEntangledAsyncAction();\n                }\n                var prevState = current.memoizedState;\n                var nextState = workInProgress.memoizedState; // Compare the new parent cache to the previous to see detect there was\n                // a refresh.\n                if (prevState.parent !== parentCache) {\n                    // Refresh in parent. Update the parent.\n                    var derivedState = {\n                        parent: parentCache,\n                        cache: parentCache\n                    }; // Copied from getDerivedStateFromProps implementation. Once the update\n                    // queue is empty, persist the derived state onto the base state.\n                    workInProgress.memoizedState = derivedState;\n                    if (workInProgress.lanes === NoLanes) {\n                        var updateQueue = workInProgress.updateQueue;\n                        workInProgress.memoizedState = updateQueue.baseState = derivedState;\n                    }\n                    pushCacheProvider(workInProgress, parentCache); // No need to propagate a context change because the refreshed parent\n                // already did.\n                } else {\n                    // The parent didn't refresh. Now check if this cache did.\n                    var nextCache = nextState.cache;\n                    pushCacheProvider(workInProgress, nextCache);\n                    if (nextCache !== prevState.cache) {\n                        // This cache refreshed. Propagate a context change.\n                        propagateContextChange(workInProgress, CacheContext, renderLanes);\n                    }\n                }\n            }\n            var nextChildren = workInProgress.pendingProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        } // This should only be called if the name changes\n        function updateFragment(current, workInProgress, renderLanes) {\n            var nextChildren = workInProgress.pendingProps;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateMode(current, workInProgress, renderLanes) {\n            var nextChildren = workInProgress.pendingProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateProfiler(current, workInProgress, renderLanes) {\n            {\n                workInProgress.flags |= Update;\n                {\n                    // Reset effect durations for the next eventual effect phase.\n                    // These are reset during render to allow the DevTools commit hook a chance to read them,\n                    var stateNode = workInProgress.stateNode;\n                    stateNode.effectDuration = 0;\n                    stateNode.passiveEffectDuration = 0;\n                }\n            }\n            var nextProps = workInProgress.pendingProps;\n            var nextChildren = nextProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function markRef(current, workInProgress) {\n            // TODO: Check props.ref instead of fiber.ref when enableRefAsProp is on.\n            var ref = workInProgress.ref;\n            if (ref === null) {\n                if (current !== null && current.ref !== null) {\n                    // Schedule a Ref effect\n                    workInProgress.flags |= Ref | RefStatic;\n                }\n            } else {\n                if (typeof ref !== 'function' && typeof ref !== 'object') {\n                    throw new Error('Expected ref to be a function, an object returned by React.createRef(), or undefined/null.');\n                }\n                if (current === null || current.ref !== ref) {\n                    workInProgress.flags |= Ref | RefStatic;\n                }\n            }\n        }\n        function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            {\n                if (Component.prototype && typeof Component.prototype.render === 'function') {\n                    var componentName = getComponentNameFromType(Component) || 'Unknown';\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n                if (workInProgress.mode & StrictLegacyMode) {\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n                }\n                if (current === null) {\n                    // Some validations were previously done in mountIndeterminateComponent however and are now run\n                    // in updateFuntionComponent but only on mount\n                    validateFunctionComponentInDev(workInProgress, workInProgress.type);\n                    if (Component.contextTypes) {\n                        error('%s uses the legacy contextTypes API which was removed in React 19. ' + 'Use React.createContext() with React.useContext() instead.', getComponentNameFromType(Component) || 'Unknown');\n                    }\n                }\n            }\n            var context;\n            var nextChildren;\n            var hasId;\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                setIsRendering(true);\n                nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n                hasId = checkDidRenderIdHook();\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {\n            // This function is used to replay a component that previously suspended,\n            // after its data resolves. It's a simplified version of\n            // updateFunctionComponent that reuses the hooks from the previous attempt.\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            var nextChildren = replaySuspendedComponentWithHooks(current, workInProgress, Component, nextProps, secondArg);\n            var hasId = checkDidRenderIdHook();\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            {\n                // This is used by DevTools to force a boundary to error.\n                switch(shouldError(workInProgress)){\n                    case false:\n                        {\n                            var _instance = workInProgress.stateNode;\n                            var ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.\n                            // Is there a better way to do this?\n                            var tempInstance = new ctor(workInProgress.memoizedProps, _instance.context);\n                            var state = tempInstance.state;\n                            _instance.updater.enqueueSetState(_instance, state, null);\n                            break;\n                        }\n                    case true:\n                        {\n                            workInProgress.flags |= DidCapture;\n                            workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes\n                            var error$1 = new Error('Simulated error coming from DevTools');\n                            var lane = pickArbitraryLane(renderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n                            var root = getWorkInProgressRoot();\n                            if (root === null) {\n                                throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n                            }\n                            var update = createClassErrorUpdate(lane);\n                            initializeClassErrorUpdate(update, root, workInProgress, createCapturedValueAtFiber(error$1, workInProgress));\n                            enqueueCapturedUpdate(workInProgress, update);\n                            break;\n                        }\n                }\n            }\n            // During mounting we don't know the child context yet as the instance doesn't exist.\n            // We will invalidate the child context in finishClassComponent() right after rendering.\n            var hasContext;\n            if (isContextProvider()) {\n                hasContext = true;\n            } else {\n                hasContext = false;\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var instance = workInProgress.stateNode;\n            var shouldUpdate;\n            if (instance === null) {\n                constructClassInstance(workInProgress, Component, nextProps);\n                mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n                shouldUpdate = true;\n            } else if (current === null) {\n                // In a resume, we'll already have an instance we can reuse.\n                shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\n            } else {\n                shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\n            }\n            var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\n            {\n                var inst = workInProgress.stateNode;\n                if (shouldUpdate && inst.props !== nextProps) {\n                    if (!didWarnAboutReassigningProps) {\n                        error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentNameFromFiber(workInProgress) || 'a component');\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            return nextUnitOfWork;\n        }\n        function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\n            // Refs should update even if shouldComponentUpdate returns false\n            markRef(current, workInProgress);\n            var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags$1;\n            if (!shouldUpdate && !didCaptureError) {\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            var instance = workInProgress.stateNode; // Rerender\n            {\n                setCurrentFiber(workInProgress);\n            }\n            var nextChildren;\n            if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {\n                // If we captured an error, but getDerivedStateFromError is not defined,\n                // unmount all the children. componentDidCatch will schedule an update to\n                // re-render a fallback. This is temporary until we migrate everyone to\n                // the new API.\n                // TODO: Warn in a future release.\n                nextChildren = null;\n                {\n                    stopProfilerTimerIfRunning();\n                }\n            } else {\n                {\n                    markComponentRenderStarted(workInProgress);\n                }\n                {\n                    setIsRendering(true);\n                    nextChildren = instance.render();\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            instance.render();\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                    setIsRendering(false);\n                }\n                {\n                    markComponentRenderStopped();\n                }\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            if (current !== null && didCaptureError) {\n                // If we're recovering from an error, reconcile without reusing any of\n                // the existing children. Conceptually, the normal children and the children\n                // that are shown on error are two different sets, so we shouldn't reuse\n                // normal children even if their identities match.\n                forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            } // Memoize state using the values we just used to render.\n            // TODO: Restructure so we never read values from the instance.\n            workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n            return workInProgress.child;\n        }\n        function pushHostRootContext(workInProgress) {\n            var root = workInProgress.stateNode;\n            pushHostContainer(workInProgress, root.containerInfo);\n        }\n        function updateHostRoot(current, workInProgress, renderLanes) {\n            pushHostRootContext(workInProgress);\n            if (current === null) {\n                throw new Error('Should have a current fiber. This is a bug in React.');\n            }\n            var nextProps = workInProgress.pendingProps;\n            var prevState = workInProgress.memoizedState;\n            var prevChildren = prevState.element;\n            cloneUpdateQueue(current, workInProgress);\n            processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n            var nextState = workInProgress.memoizedState;\n            {\n                var nextCache = nextState.cache;\n                pushCacheProvider(workInProgress, nextCache);\n                if (nextCache !== prevState.cache) {\n                    // The root cache refreshed.\n                    propagateContextChange(workInProgress, CacheContext, renderLanes);\n                }\n            }\n            // it needs to happen after the `pushCacheProvider` call above to avoid a\n            // context stack mismatch. A bit unfortunate.\n            suspendIfUpdateReadFromEntangledAsyncAction(); // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            var nextChildren = nextState.element;\n            if (supportsHydration && prevState.isDehydrated) {\n                // This is a hydration root whose shell has not yet hydrated. We should\n                // attempt to hydrate.\n                // Flip isDehydrated to false to indicate that when this render\n                // finishes, the root will no longer be dehydrated.\n                var overrideState = {\n                    element: nextChildren,\n                    isDehydrated: false,\n                    cache: nextState.cache\n                };\n                var updateQueue = workInProgress.updateQueue; // `baseState` can always be the last state because the root doesn't\n                // have reducer functions so it doesn't need rebasing.\n                updateQueue.baseState = overrideState;\n                workInProgress.memoizedState = overrideState;\n                if (workInProgress.flags & ForceClientRender) {\n                    // Something errored during a previous attempt to hydrate the shell, so we\n                    // forced a client render. We should have a recoverable error already scheduled.\n                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes);\n                } else if (nextChildren !== prevChildren) {\n                    var recoverableError = createCapturedValueAtFiber(new Error('This root received an early update, before anything was able ' + 'hydrate. Switched the entire root to client rendering.'), workInProgress);\n                    queueHydrationError(recoverableError);\n                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes);\n                } else {\n                    // The outermost shell has not hydrated yet. Start hydrating.\n                    enterHydrationState(workInProgress);\n                    var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n                    workInProgress.child = child;\n                    var node = child;\n                    while(node){\n                        // Mark each child as hydrating. This is a fast path to know whether this\n                        // tree is part of a hydrating tree. This is used to determine if a child\n                        // node has fully mounted yet, and for scheduling event replaying.\n                        // Conceptually this is similar to Placement in that a new subtree is\n                        // inserted into the React tree here. It just happens to not need DOM\n                        // mutations because it already exists.\n                        node.flags = node.flags & ~Placement | Hydrating;\n                        node = node.sibling;\n                    }\n                }\n            } else {\n                // Root is not dehydrated. Either this is a client-only root, or it\n                // already hydrated.\n                resetHydrationState();\n                if (nextChildren === prevChildren) {\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                }\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            return workInProgress.child;\n        }\n        function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {\n            // Revert to client rendering.\n            resetHydrationState();\n            workInProgress.flags |= ForceClientRender;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateHostComponent$1(current, workInProgress, renderLanes) {\n            if (current === null) {\n                tryToClaimNextHydratableInstance(workInProgress);\n            }\n            pushHostContext(workInProgress);\n            var type = workInProgress.type;\n            var nextProps = workInProgress.pendingProps;\n            var prevProps = current !== null ? current.memoizedProps : null;\n            var nextChildren = nextProps.children;\n            var isDirectTextChild = shouldSetTextContent(type, nextProps);\n            if (isDirectTextChild) {\n                // We special case a direct text child of a host node. This is a common\n                // case. We won't handle it as a reified child. We will instead handle\n                // this in the host environment that also has access to this prop. That\n                // avoids allocating another HostText fiber and traversing it.\n                nextChildren = null;\n            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n                // If we're switching from a direct text child to a normal child, or to\n                // empty, we need to schedule the text content to be reset.\n                workInProgress.flags |= ContentReset;\n            }\n            {\n                var memoizedState = workInProgress.memoizedState;\n                if (memoizedState !== null) {\n                    // This fiber has been upgraded to a stateful component. The only way\n                    // happens currently is for form actions. We use hooks to track the\n                    // pending and error state of the form.\n                    //\n                    // Once a fiber is upgraded to be stateful, it remains stateful for the\n                    // rest of its lifetime.\n                    var newState = renderTransitionAwareHostComponentWithHooks(current, workInProgress, renderLanes); // If the transition state changed, propagate the change to all the\n                    // descendents. We use Context as an implementation detail for this.\n                    //\n                    // This is intentionally set here instead of pushHostContext because\n                    // pushHostContext gets called before we process the state hook, to avoid\n                    // a state mismatch in the event that something suspends.\n                    //\n                    // NOTE: This assumes that there cannot be nested transition providers,\n                    // because the only renderer that implements this feature is React DOM,\n                    // and forms cannot be nested. If we did support nested providers, then\n                    // we would need to push a context value even for host fibers that\n                    // haven't been upgraded yet.\n                    if (isPrimaryRenderer) {\n                        HostTransitionContext._currentValue = newState;\n                    } else {\n                        HostTransitionContext._currentValue2 = newState;\n                    }\n                    {\n                        if (didReceiveUpdate) {\n                            if (current !== null) {\n                                var oldStateHook = current.memoizedState;\n                                var oldState = oldStateHook.memoizedState; // This uses regular equality instead of Object.is because we assume\n                                // that host transition state doesn't include NaN as a valid type.\n                                if (oldState !== newState) {\n                                    propagateContextChange(workInProgress, HostTransitionContext, renderLanes);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            markRef(current, workInProgress);\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateHostHoistable(current, workInProgress, renderLanes) {\n            markRef(current, workInProgress);\n            var currentProps = current === null ? null : current.memoizedProps;\n            var resource = workInProgress.memoizedState = getResource(workInProgress.type, currentProps, workInProgress.pendingProps);\n            if (current === null) {\n                if (!getIsHydrating() && resource === null) {\n                    // This is not a Resource Hoistable and we aren't hydrating so we construct the instance.\n                    workInProgress.stateNode = createHoistableInstance(workInProgress.type, workInProgress.pendingProps, getRootHostContainer(), workInProgress);\n                }\n            } // Resources never have reconciler managed children. It is possible for\n            // the host implementation of getResource to consider children in the\n            // resource construction but they will otherwise be discarded. In practice\n            // this precludes all but the simplest children and Host specific warnings\n            // should be implemented to warn when children are passsed when otherwise not\n            // expected\n            return null;\n        }\n        function updateHostSingleton(current, workInProgress, renderLanes) {\n            pushHostContext(workInProgress);\n            if (current === null) {\n                claimHydratableSingleton(workInProgress);\n            }\n            var nextChildren = workInProgress.pendingProps.children;\n            if (current === null && !getIsHydrating()) {\n                // Similar to Portals we append Singleton children in the commit phase. So we\n                // Track insertions even on mount.\n                // TODO: Consider unifying this with how the root works.\n                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            markRef(current, workInProgress);\n            return workInProgress.child;\n        }\n        function updateHostText$1(current, workInProgress) {\n            if (current === null) {\n                tryToClaimNextHydratableTextInstance(workInProgress);\n            } // Nothing to do here. This is terminal. We'll do the completion step\n            // immediately after.\n            return null;\n        }\n        function mountLazyComponent(_current, workInProgress, elementType, renderLanes) {\n            var props = workInProgress.pendingProps;\n            var lazyComponent = elementType;\n            var payload = lazyComponent._payload;\n            var init = lazyComponent._init;\n            var Component = init(payload); // Store the unwrapped component in the type.\n            workInProgress.type = Component;\n            if (typeof Component === 'function') {\n                if (isFunctionClassComponent(Component)) {\n                    var resolvedProps = resolveClassComponentProps(Component, props);\n                    workInProgress.tag = ClassComponent;\n                    {\n                        workInProgress.type = Component = resolveClassForHotReloading(Component);\n                    }\n                    return updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n                } else {\n                    var _resolvedProps = props;\n                    workInProgress.tag = FunctionComponent;\n                    {\n                        validateFunctionComponentInDev(workInProgress, Component);\n                        workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n                    }\n                    return updateFunctionComponent(null, workInProgress, Component, _resolvedProps, renderLanes);\n                }\n            } else if (Component !== undefined && Component !== null) {\n                var $$typeof = Component.$$typeof;\n                if ($$typeof === REACT_FORWARD_REF_TYPE) {\n                    var _resolvedProps2 = props;\n                    workInProgress.tag = ForwardRef;\n                    {\n                        workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n                    }\n                    return updateForwardRef(null, workInProgress, Component, _resolvedProps2, renderLanes);\n                } else if ($$typeof === REACT_MEMO_TYPE) {\n                    var _resolvedProps3 = props;\n                    workInProgress.tag = MemoComponent;\n                    return updateMemoComponent(null, workInProgress, Component, _resolvedProps3, renderLanes);\n                }\n            }\n            var hint = '';\n            {\n                if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {\n                    hint = ' Did you wrap a component in React.lazy() more than once?';\n                }\n            }\n            // because the fact that it's a separate type of work is an\n            // implementation detail.\n            throw new Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". \" + (\"Lazy element type must resolve to a class or function.\" + hint));\n        }\n        function validateFunctionComponentInDev(workInProgress, Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error('childContextTypes cannot be defined on a function component.\\n' + '  %s.childContextTypes = ...', Component.displayName || Component.name || 'Component');\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === 'function') {\n                    var _componentName2 = getComponentNameFromType(Component) || 'Unknown';\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2]) {\n                        error('%s: Function components do not support getDerivedStateFromProps.', _componentName2);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = true;\n                    }\n                }\n                if (typeof Component.contextType === 'object' && Component.contextType !== null) {\n                    var _componentName3 = getComponentNameFromType(Component) || 'Unknown';\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName3]) {\n                        error('%s: Function components do not support contextType.', _componentName3);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n            }\n        }\n        var SUSPENDED_MARKER = {\n            dehydrated: null,\n            treeContext: null,\n            retryLane: NoLane\n        };\n        function mountSuspenseOffscreenState(renderLanes) {\n            return {\n                baseLanes: renderLanes,\n                cachePool: getSuspendedCache()\n            };\n        }\n        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\n            var cachePool = null;\n            {\n                var prevCachePool = prevOffscreenState.cachePool;\n                if (prevCachePool !== null) {\n                    var parentCache = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2;\n                    if (prevCachePool.parent !== parentCache) {\n                        // Detected a refresh in the parent. This overrides any previously\n                        // suspended cache.\n                        cachePool = {\n                            parent: parentCache,\n                            pool: parentCache\n                        };\n                    } else {\n                        // We can reuse the cache from last time. The only thing that would have\n                        // overridden it is a parent refresh, which we checked for above.\n                        cachePool = prevCachePool;\n                    }\n                } else {\n                    // If there's no previous cache pool, grab the current one.\n                    cachePool = getSuspendedCache();\n                }\n            }\n            return {\n                baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n                cachePool: cachePool\n            };\n        } // TODO: Probably should inline this back\n        function shouldRemainOnFallback(current, workInProgress, renderLanes) {\n            // If we're already showing a fallback, there are cases where we need to\n            // remain on that fallback regardless of whether the content has resolved.\n            // For example, SuspenseList coordinates when nested content appears.\n            // TODO: For compatibility with offscreen prerendering, this should also check\n            // whether the current fiber (if it exists) was visible in the previous tree.\n            if (current !== null) {\n                var suspenseState = current.memoizedState;\n                if (suspenseState === null) {\n                    // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n                    // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n                    // Note: This is a factoring smell. Can't remain on a fallback if there's\n                    // no fallback to remain on.\n                    return false;\n                }\n            } // Not currently showing content. Consult the Suspense context.\n            var suspenseContext = suspenseStackCursor.current;\n            return hasSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n        }\n        function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {\n            var remainingLanes = current !== null ? removeLanes(current.childLanes, renderLanes) : NoLanes;\n            if (primaryTreeDidDefer) {\n                // A useDeferredValue hook spawned a deferred task inside the primary tree.\n                // Ensure that we retry this component at the deferred priority.\n                // TODO: We could make this a per-subtree value instead of a global one.\n                // Would need to track it on the context stack somehow, similar to what\n                // we'd have to do for resumable contexts.\n                remainingLanes = mergeLanes(remainingLanes, peekDeferredLane());\n            }\n            return remainingLanes;\n        }\n        function updateSuspenseComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n            {\n                if (shouldSuspend(workInProgress)) {\n                    workInProgress.flags |= DidCapture;\n                }\n            }\n            var showFallback = false;\n            var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags$1;\n            if (didSuspend || shouldRemainOnFallback(current)) {\n                // Something in this boundary's subtree already suspended. Switch to\n                // rendering the fallback children.\n                showFallback = true;\n                workInProgress.flags &= ~DidCapture;\n            } // Check if the primary children spawned a deferred task (useDeferredValue)\n            // during the first pass.\n            var didPrimaryChildrenDefer = (workInProgress.flags & DidDefer) !== NoFlags$1;\n            workInProgress.flags &= ~DidDefer; // OK, the next part is confusing. We're about to reconcile the Suspense\n            // boundary's children. This involves some custom reconciliation logic. Two\n            // main reasons this is so complicated.\n            //\n            // First, Legacy Mode has different semantics for backwards compatibility. The\n            // primary tree will commit in an inconsistent state, so when we do the\n            // second pass to render the fallback, we do some exceedingly, uh, clever\n            // hacks to make that not totally break. Like transferring effects and\n            // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n            // because we bailout on the primary tree completely and leave it in its old\n            // state, no effects. Same as what we do for Offscreen (except that\n            // Offscreen doesn't have the first render pass).\n            //\n            // Second is hydration. During hydration, the Suspense fiber has a slightly\n            // different layout, where the child points to a dehydrated fragment, which\n            // contains the DOM rendered by the server.\n            //\n            // Third, even if you set all that aside, Suspense is like error boundaries in\n            // that we first we try to render one tree, and if that fails, we render again\n            // and switch to a different tree. Like a try/catch block. So we have to track\n            // which branch we're currently rendering. Ideally we would model this using\n            // a stack.\n            if (current === null) {\n                // Initial mount\n                // Special path for hydration\n                // If we're currently hydrating, try to hydrate this boundary.\n                if (getIsHydrating()) {\n                    // We must push the suspense handler context *before* attempting to\n                    // hydrate, to avoid a mismatch in case it errors.\n                    if (showFallback) {\n                        pushPrimaryTreeSuspenseHandler(workInProgress);\n                    } else {\n                        pushFallbackTreeSuspenseHandler(workInProgress);\n                    }\n                    tryToClaimNextHydratableSuspenseInstance(workInProgress); // This could've been a dehydrated suspense component.\n                    var suspenseState = workInProgress.memoizedState;\n                    if (suspenseState !== null) {\n                        var dehydrated = suspenseState.dehydrated;\n                        if (dehydrated !== null) {\n                            return mountDehydratedSuspenseComponent(workInProgress, dehydrated);\n                        }\n                    } // If hydration didn't succeed, fall through to the normal Suspense path.\n                    // To avoid a stack mismatch we need to pop the Suspense handler that we\n                    // pushed above. This will become less awkward when move the hydration\n                    // logic to its own fiber.\n                    popSuspenseHandler(workInProgress);\n                }\n                var nextPrimaryChildren = nextProps.children;\n                var nextFallbackChildren = nextProps.fallback;\n                if (showFallback) {\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n                    var primaryChildFragment = workInProgress.child;\n                    primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n                    primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(current, didPrimaryChildrenDefer, renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackFragment;\n                } else {\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);\n                }\n            } else {\n                // This is an update.\n                // Special path for hydration\n                var prevState = current.memoizedState;\n                if (prevState !== null) {\n                    var _dehydrated = prevState.dehydrated;\n                    if (_dehydrated !== null) {\n                        return updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, didPrimaryChildrenDefer, nextProps, _dehydrated, prevState, renderLanes);\n                    }\n                }\n                if (showFallback) {\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    var _nextFallbackChildren = nextProps.fallback;\n                    var _nextPrimaryChildren = nextProps.children;\n                    var fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);\n                    var _primaryChildFragment2 = workInProgress.child;\n                    var prevOffscreenState = current.child.memoizedState;\n                    _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n                    _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current, didPrimaryChildrenDefer, renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackChildFragment;\n                } else {\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    var _nextPrimaryChildren2 = nextProps.children;\n                    var _primaryChildFragment3 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren2);\n                    workInProgress.memoizedState = null;\n                    return _primaryChildFragment3;\n                }\n            }\n        }\n        function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: 'visible',\n                children: primaryChildren\n            };\n            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n            primaryChildFragment.return = workInProgress;\n            workInProgress.child = primaryChildFragment;\n            return primaryChildFragment;\n        }\n        function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: 'hidden',\n                children: primaryChildren\n            };\n            var primaryChildFragment;\n            var fallbackChildFragment;\n            {\n                primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n            }\n            primaryChildFragment.return = workInProgress;\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            return fallbackChildFragment;\n        }\n        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {\n            // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n            // this wrapper function to constrain it.\n            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n        }\n        function updateWorkInProgressOffscreenFiber(current, offscreenProps) {\n            // The props argument to `createWorkInProgress` is `any` typed, so we use this\n            // wrapper function to constrain it.\n            return createWorkInProgress(current, offscreenProps);\n        }\n        function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\n            var currentPrimaryChildFragment = current.child;\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n                mode: 'visible',\n                children: primaryChildren\n            });\n            primaryChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = null;\n            if (currentFallbackChildFragment !== null) {\n                // Delete the fallback child fragment\n                var deletions = workInProgress.deletions;\n                if (deletions === null) {\n                    workInProgress.deletions = [\n                        currentFallbackChildFragment\n                    ];\n                    workInProgress.flags |= ChildDeletion;\n                } else {\n                    deletions.push(currentFallbackChildFragment);\n                }\n            }\n            workInProgress.child = primaryChildFragment;\n            return primaryChildFragment;\n        }\n        function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var currentPrimaryChildFragment = current.child;\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n            var primaryChildProps = {\n                mode: 'hidden',\n                children: primaryChildren\n            };\n            var primaryChildFragment;\n            {\n                primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps); // Since we're reusing a current tree, we need to reuse the flags, too.\n                // (We don't do this in legacy mode, because in legacy mode we don't re-use\n                // the current tree; see previous branch.)\n                primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n            }\n            var fallbackChildFragment;\n            if (currentFallbackChildFragment !== null) {\n                fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n            } else {\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\n                // mounted but this is a new fiber.\n                fallbackChildFragment.flags |= Placement;\n            }\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            return fallbackChildFragment;\n        }\n        function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {\n            // Falling back to client rendering. Because this has performance\n            // implications, it's considered a recoverable error, even though the user\n            // likely won't observe anything wrong with the UI.\n            // This will add the old fiber to the deletion list\n            reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.\n            var nextProps = workInProgress.pendingProps;\n            var primaryChildren = nextProps.children;\n            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Needs a placement effect because the parent (the Suspense boundary) already\n            // mounted but this is a new fiber.\n            primaryChildFragment.flags |= Placement;\n            workInProgress.memoizedState = null;\n            return primaryChildFragment;\n        }\n        function mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var fiberMode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: 'visible',\n                children: primaryChildren\n            };\n            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);\n            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense\n            // boundary) already mounted but this is a new fiber.\n            fallbackChildFragment.flags |= Placement;\n            primaryChildFragment.return = workInProgress;\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            {\n                // We will have dropped the effect list which contains the\n                // deletion. We need to reconcile to delete the current child.\n                reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n            }\n            return fallbackChildFragment;\n        }\n        function mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {\n            // During the first pass, we'll bail out and not drill into the children.\n            // Instead, we'll leave the content in place and try to hydrate it later.\n            if (isSuspenseInstanceFallback(suspenseInstance)) {\n                // This is a client-only boundary. Since we won't get any content from the server\n                // for this, we need to schedule that at a higher priority based on when it would\n                // have timed out. In theory we could render it in this pass but it would have the\n                // wrong priority associated with it and will prevent hydration of parent path.\n                // Instead, we'll leave work left on it to render it in a separate commit.\n                // TODO This time should be the time at which the server rendered response that is\n                // a parent to this boundary was displayed. However, since we currently don't have\n                // a protocol to transfer that time, we'll just estimate it by using the current\n                // time. This will mean that Suspense timeouts are slightly shifted to later than\n                // they should be.\n                // Schedule a normal pri update to render this content.\n                workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n            } else {\n                // We'll continue hydrating the rest at offscreen priority since we'll already\n                // be showing the right content coming from the server, it is no rush.\n                workInProgress.lanes = laneToLanes(OffscreenLane);\n            }\n            return null;\n        }\n        function updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, didPrimaryChildrenDefer, nextProps, suspenseInstance, suspenseState, renderLanes) {\n            if (!didSuspend) {\n                // This is the first render pass. Attempt to hydrate.\n                pushPrimaryTreeSuspenseHandler(workInProgress); // We should never be hydrating at this point because it is the first pass,\n                // but after we've already committed once.\n                warnIfHydrating();\n                if (isSuspenseInstanceFallback(suspenseInstance)) {\n                    // This boundary is in a permanent fallback state. In this case, we'll never\n                    // get an update and we'll never be able to hydrate the final content. Let's just try the\n                    // client side render instead.\n                    var digest;\n                    var message;\n                    var stack = null;\n                    var componentStack = null;\n                    {\n                        var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);\n                        digest = _getSuspenseInstanceF.digest;\n                        message = _getSuspenseInstanceF.message;\n                        stack = _getSuspenseInstanceF.stack;\n                        componentStack = _getSuspenseInstanceF.componentStack;\n                    }\n                    {\n                        var error;\n                        if (message) {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            error = new Error(message);\n                        } else {\n                            error = new Error('The server could not finish this Suspense boundary, likely ' + 'due to an error during server rendering. ' + 'Switched to client rendering.');\n                        } // Replace the stack with the server stack\n                        error.stack = stack || '';\n                        error.digest = digest;\n                        var capturedValue = createCapturedValueFromError(error, componentStack === undefined ? null : componentStack);\n                        queueHydrationError(capturedValue);\n                    }\n                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n                }\n                // any context has changed, we need to treat is as if the input might have changed.\n                var hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n                if (didReceiveUpdate || hasContextChanged) {\n                    // This boundary has changed since the first render. This means that we are now unable to\n                    // hydrate it. We might still be able to hydrate it using a higher priority lane.\n                    var root = getWorkInProgressRoot();\n                    if (root !== null) {\n                        var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);\n                        if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n                            // Intentionally mutating since this render will get interrupted. This\n                            // is one of the very rare times where we mutate the current tree\n                            // during the render phase.\n                            suspenseState.retryLane = attemptHydrationAtLane;\n                            enqueueConcurrentRenderForLane(current, attemptHydrationAtLane);\n                            scheduleUpdateOnFiber(root, current, attemptHydrationAtLane); // Throw a special object that signals to the work loop that it should\n                            // interrupt the current render.\n                            //\n                            // Because we're inside a React-only execution stack, we don't\n                            // strictly need to throw here — we could instead modify some internal\n                            // work loop state. But using an exception means we don't need to\n                            // check for this case on every iteration of the work loop. So doing\n                            // it this way moves the check out of the fast path.\n                            throw SelectiveHydrationException;\n                        }\n                    } // If we did not selectively hydrate, we'll continue rendering without\n                    // hydrating. Mark this tree as suspended to prevent it from committing\n                    // outside a transition.\n                    //\n                    // This path should only happen if the hydration lane already suspended.\n                    // Currently, it also happens during sync updates because there is no\n                    // hydration lane for sync updates.\n                    // TODO: We should ideally have a sync hydration lane that we can apply to do\n                    // a pass where we hydrate this subtree in place using the previous Context and then\n                    // reapply the update afterwards.\n                    if (isSuspenseInstancePending(suspenseInstance)) ;\n                    else {\n                        renderDidSuspendDelayIfPossible();\n                    }\n                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n                } else if (isSuspenseInstancePending(suspenseInstance)) {\n                    // This component is still pending more data from the server, so we can't hydrate its\n                    // content. We treat it as if this component suspended itself. It might seem as if\n                    // we could just try to render it client-side instead. However, this will perform a\n                    // lot of unnecessary work and is unlikely to complete since it often will suspend\n                    // on missing data anyway. Additionally, the server might be able to render more\n                    // than we can on the client yet. In that case we'd end up with more fallback states\n                    // on the client than if we just leave it alone. If the server times out or errors\n                    // these should update this boundary to the permanent Fallback state instead.\n                    // Mark it as having captured (i.e. suspended).\n                    workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n                    workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n                    var retry = retryDehydratedSuspenseBoundary.bind(null, current);\n                    registerSuspenseInstanceRetry(suspenseInstance, retry);\n                    return null;\n                } else {\n                    // This is the first attempt.\n                    reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);\n                    var primaryChildren = nextProps.children;\n                    var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Mark the children as hydrating. This is a fast path to know whether this\n                    // tree is part of a hydrating tree. This is used to determine if a child\n                    // node has fully mounted yet, and for scheduling event replaying.\n                    // Conceptually this is similar to Placement in that a new subtree is\n                    // inserted into the React tree here. It just happens to not need DOM\n                    // mutations because it already exists.\n                    primaryChildFragment.flags |= Hydrating;\n                    return primaryChildFragment;\n                }\n            } else {\n                // This is the second render pass. We already attempted to hydrated, but\n                // something either suspended or errored.\n                if (workInProgress.flags & ForceClientRender) {\n                    // Something errored during hydration. Try again without hydrating.\n                    // The error should've already been logged in throwException.\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    workInProgress.flags &= ~ForceClientRender;\n                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n                } else if (workInProgress.memoizedState !== null) {\n                    // Something suspended and we should still be in dehydrated mode.\n                    // Leave the existing child in place.\n                    // Push to avoid a mismatch\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n                    // but the normal suspense pass doesn't.\n                    workInProgress.flags |= DidCapture;\n                    return null;\n                } else {\n                    // Suspended but we should no longer be in dehydrated mode.\n                    // Therefore we now have to render the fallback.\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    var nextPrimaryChildren = nextProps.children;\n                    var nextFallbackChildren = nextProps.fallback;\n                    var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n                    var _primaryChildFragment4 = workInProgress.child;\n                    _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes);\n                    _primaryChildFragment4.childLanes = getRemainingWorkInPrimaryTree(current, didPrimaryChildrenDefer, renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackChildFragment;\n                }\n            }\n        }\n        function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n            }\n            scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n        }\n        function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\n            // Mark any Suspense boundaries with fallbacks as having work to do.\n            // If they were previously forced into fallbacks, they may now be able\n            // to unblock.\n            var node = firstChild;\n            while(node !== null){\n                if (node.tag === SuspenseComponent) {\n                    var state = node.memoizedState;\n                    if (state !== null) {\n                        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n                    }\n                } else if (node.tag === SuspenseListComponent) {\n                    // If the tail is hidden there might not be an Suspense boundaries\n                    // to schedule work on. In this case we have to schedule it on the\n                    // list itself.\n                    // We don't have to traverse to the children of the list since\n                    // the list will propagate the change when it rerenders.\n                    scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n                } else if (node.child !== null) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === workInProgress) {\n                    return;\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                while(node.sibling === null){\n                    // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    if (node.return === null || node.return === workInProgress) {\n                        return;\n                    }\n                    node = node.return;\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        function findLastContentRow(firstChild) {\n            // This is going to find the last row among these children that is already\n            // showing content on the screen, as opposed to being in fallback state or\n            // new. If a row has multiple Suspense boundaries, any of them being in the\n            // fallback state, counts as the whole row being in a fallback state.\n            // Note that the \"rows\" will be workInProgress, but any nested children\n            // will still be current since we haven't rendered them yet. The mounted\n            // order may not be the same as the new order. We use the new order.\n            var row = firstChild;\n            var lastContentRow = null;\n            while(row !== null){\n                var currentRow = row.alternate; // New rows can't be content rows.\n                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                    lastContentRow = row;\n                }\n                row = row.sibling;\n            }\n            return lastContentRow;\n        }\n        function validateRevealOrder(revealOrder) {\n            {\n                if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {\n                    didWarnAboutRevealOrder[revealOrder] = true;\n                    if (typeof revealOrder === 'string') {\n                        switch(revealOrder.toLowerCase()){\n                            case 'together':\n                            case 'forwards':\n                            case 'backwards':\n                                {\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                                    break;\n                                }\n                            case 'forward':\n                            case 'backward':\n                                {\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                                    break;\n                                }\n                            default:\n                                error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                                break;\n                        }\n                    } else {\n                        error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                    }\n                }\n            }\n        }\n        function validateTailOptions(tailMode, revealOrder) {\n            {\n                if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n                    if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n                        didWarnAboutTailOptions[tailMode] = true;\n                        error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n                    } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n                        didWarnAboutTailOptions[tailMode] = true;\n                        error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n                    }\n                }\n            }\n        }\n        function validateSuspenseListNestedChild(childSlot, index) {\n            {\n                var isAnArray = isArray(childSlot);\n                var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === 'function';\n                if (isAnArray || isIterable) {\n                    var type = isAnArray ? 'array' : 'iterable';\n                    error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);\n                    return false;\n                }\n            }\n            return true;\n        }\n        function validateSuspenseListChildren(children, revealOrder) {\n            {\n                if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {\n                    if (isArray(children)) {\n                        for(var i = 0; i < children.length; i++){\n                            if (!validateSuspenseListNestedChild(children[i], i)) {\n                                return;\n                            }\n                        }\n                    } else {\n                        var iteratorFn = getIteratorFn(children);\n                        if (typeof iteratorFn === 'function') {\n                            var childrenIterator = iteratorFn.call(children);\n                            if (childrenIterator) {\n                                var step = childrenIterator.next();\n                                var _i = 0;\n                                for(; !step.done; step = childrenIterator.next()){\n                                    if (!validateSuspenseListNestedChild(step.value, _i)) {\n                                        return;\n                                    }\n                                    _i++;\n                                }\n                            }\n                        } else {\n                            error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);\n                        }\n                    }\n                }\n            }\n        }\n        function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n            var renderState = workInProgress.memoizedState;\n            if (renderState === null) {\n                workInProgress.memoizedState = {\n                    isBackwards: isBackwards,\n                    rendering: null,\n                    renderingStartTime: 0,\n                    last: lastContentRow,\n                    tail: tail,\n                    tailMode: tailMode\n                };\n            } else {\n                // We can reuse the existing object from previous renders.\n                renderState.isBackwards = isBackwards;\n                renderState.rendering = null;\n                renderState.renderingStartTime = 0;\n                renderState.last = lastContentRow;\n                renderState.tail = tail;\n                renderState.tailMode = tailMode;\n            }\n        } // This can end up rendering this component multiple passes.\n        // The first pass splits the children fibers into two sets. A head and tail.\n        // We first render the head. If anything is in fallback state, we do another\n        // pass through beginWork to rerender all children (including the tail) with\n        // the force suspend context. If the first render didn't have anything in\n        // in fallback state. Then we render each row in the tail one-by-one.\n        // That happens in the completeWork phase without going back to beginWork.\n        function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps;\n            var revealOrder = nextProps.revealOrder;\n            var tailMode = nextProps.tail;\n            var newChildren = nextProps.children;\n            validateRevealOrder(revealOrder);\n            validateTailOptions(tailMode, revealOrder);\n            validateSuspenseListChildren(newChildren, revealOrder);\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            var suspenseContext = suspenseStackCursor.current;\n            var shouldForceFallback = hasSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n            if (shouldForceFallback) {\n                suspenseContext = setShallowSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n                workInProgress.flags |= DidCapture;\n            } else {\n                var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags$1;\n                if (didSuspendBefore) {\n                    // If we previously forced a fallback, we need to schedule work\n                    // on any nested boundaries to let them know to try to render\n                    // again. This is the same as context updating.\n                    propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\n                }\n                suspenseContext = setDefaultShallowSuspenseListContext(suspenseContext);\n            }\n            pushSuspenseListContext(workInProgress, suspenseContext);\n            {\n                switch(revealOrder){\n                    case 'forwards':\n                        {\n                            var lastContentRow = findLastContentRow(workInProgress.child);\n                            var tail;\n                            if (lastContentRow === null) {\n                                // The whole list is part of the tail.\n                                // TODO: We could fast path by just rendering the tail now.\n                                tail = workInProgress.child;\n                                workInProgress.child = null;\n                            } else {\n                                // Disconnect the tail rows after the content row.\n                                // We're going to render them separately later.\n                                tail = lastContentRow.sibling;\n                                lastContentRow.sibling = null;\n                            }\n                            initSuspenseListRenderState(workInProgress, false, tail, lastContentRow, tailMode);\n                            break;\n                        }\n                    case 'backwards':\n                        {\n                            // We're going to find the first row that has existing content.\n                            // At the same time we're going to reverse the list of everything\n                            // we pass in the meantime. That's going to be our tail in reverse\n                            // order.\n                            var _tail = null;\n                            var row = workInProgress.child;\n                            workInProgress.child = null;\n                            while(row !== null){\n                                var currentRow = row.alternate; // New rows can't be content rows.\n                                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                                    // This is the beginning of the main content.\n                                    workInProgress.child = row;\n                                    break;\n                                }\n                                var nextRow = row.sibling;\n                                row.sibling = _tail;\n                                _tail = row;\n                                row = nextRow;\n                            } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n                            initSuspenseListRenderState(workInProgress, true, _tail, null, tailMode);\n                            break;\n                        }\n                    case 'together':\n                        {\n                            initSuspenseListRenderState(workInProgress, false, null, null, undefined);\n                            break;\n                        }\n                    default:\n                        {\n                            // The default reveal order is the same as not having\n                            // a boundary.\n                            workInProgress.memoizedState = null;\n                        }\n                }\n            }\n            return workInProgress.child;\n        }\n        function updatePortalComponent(current, workInProgress, renderLanes) {\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n            var nextChildren = workInProgress.pendingProps;\n            if (current === null) {\n                // Portals are special because we don't append the children during mount\n                // but at commit. Therefore we need to track insertions which the normal\n                // flow doesn't do during mount. This doesn't happen at the root because\n                // the root always starts with a \"current\" with a null child.\n                // TODO: Consider unifying this with how the root works.\n                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            return workInProgress.child;\n        }\n        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n        function updateContextProvider(current, workInProgress, renderLanes) {\n            var context;\n            {\n                context = workInProgress.type;\n            }\n            var newProps = workInProgress.pendingProps;\n            var oldProps = workInProgress.memoizedProps;\n            var newValue = newProps.value;\n            {\n                if (!('value' in newProps)) {\n                    if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n                        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n                        error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');\n                    }\n                }\n            }\n            pushProvider(workInProgress, context, newValue);\n            {\n                if (oldProps !== null) {\n                    var oldValue = oldProps.value;\n                    if (objectIs(oldValue, newValue)) {\n                        // No change. Bailout early if children are the same.\n                        if (oldProps.children === newProps.children && !hasContextChanged()) {\n                            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                        }\n                    } else {\n                        // The context value changed. Search for matching consumers and schedule\n                        // them to update.\n                        propagateContextChange(workInProgress, context, renderLanes);\n                    }\n                }\n            }\n            var newChildren = newProps.children;\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateContextConsumer(current, workInProgress, renderLanes) {\n            var context;\n            {\n                var consumerType = workInProgress.type;\n                context = consumerType._context;\n            }\n            var newProps = workInProgress.pendingProps;\n            var render = newProps.children;\n            {\n                if (typeof render !== 'function') {\n                    error('A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');\n                }\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var newValue = readContext(context);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            var newChildren;\n            {\n                setIsRendering(true);\n                newChildren = render(newValue);\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function markWorkInProgressReceivedUpdate() {\n            didReceiveUpdate = true;\n        }\n        function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n            if (current !== null) {\n                // Reuse previous dependencies\n                workInProgress.dependencies = current.dependencies;\n            }\n            {\n                // Don't update \"base\" render times for bailouts.\n                stopProfilerTimerIfRunning();\n            }\n            markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.\n            if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n                // The children don't have any work either. We can skip them.\n                // TODO: Once we add back resuming, we should check if the children are\n                // a work-in-progress set. If so, we need to transfer their effects.\n                {\n                    return null;\n                }\n            } // This fiber doesn't have work, but its subtree does. Clone the child\n            // fibers and continue.\n            cloneChildFibers(current, workInProgress);\n            return workInProgress.child;\n        }\n        function remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n            {\n                var returnFiber = oldWorkInProgress.return;\n                if (returnFiber === null) {\n                    // eslint-disable-next-line react-internal/prod-error-codes\n                    throw new Error('Cannot swap the root fiber.');\n                } // Disconnect from the old current.\n                // It will get deleted.\n                current.alternate = null;\n                oldWorkInProgress.alternate = null; // Connect to the new tree.\n                newWorkInProgress.index = oldWorkInProgress.index;\n                newWorkInProgress.sibling = oldWorkInProgress.sibling;\n                newWorkInProgress.return = oldWorkInProgress.return;\n                newWorkInProgress.ref = oldWorkInProgress.ref;\n                {\n                    newWorkInProgress._debugInfo = oldWorkInProgress._debugInfo;\n                }\n                if (oldWorkInProgress === returnFiber.child) {\n                    returnFiber.child = newWorkInProgress;\n                } else {\n                    var prevSibling = returnFiber.child;\n                    if (prevSibling === null) {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error('Expected parent to have a child.');\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(prevSibling.sibling !== oldWorkInProgress){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        prevSibling = prevSibling.sibling;\n                        if (prevSibling === null) {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error('Expected to find the previous sibling.');\n                        }\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    prevSibling.sibling = newWorkInProgress;\n                } // Delete the old fiber and place the new one.\n                // Since the old fiber is disconnected, we have to schedule it manually.\n                var deletions = returnFiber.deletions;\n                if (deletions === null) {\n                    returnFiber.deletions = [\n                        current\n                    ];\n                    returnFiber.flags |= ChildDeletion;\n                } else {\n                    deletions.push(current);\n                }\n                newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\n                return newWorkInProgress;\n            }\n        }\n        function checkScheduledUpdateOrContext(current, renderLanes) {\n            // Before performing an early bailout, we must check if there are pending\n            // updates or context.\n            var updateLanes = current.lanes;\n            if (includesSomeLane(updateLanes, renderLanes)) {\n                return true;\n            } // No pending update, but because context is propagated lazily, we need\n            return false;\n        }\n        function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n            // This fiber does not have any pending work. Bailout without entering\n            // the begin phase. There's still some bookkeeping we that needs to be done\n            // in this optimized path, mostly pushing stuff onto the stack.\n            switch(workInProgress.tag){\n                case HostRoot:\n                    pushHostRootContext(workInProgress);\n                    {\n                        var cache = current.memoizedState.cache;\n                        pushCacheProvider(workInProgress, cache);\n                    }\n                    resetHydrationState();\n                    break;\n                case HostSingleton:\n                case HostComponent:\n                    pushHostContext(workInProgress);\n                    break;\n                case ClassComponent:\n                    {\n                        break;\n                    }\n                case HostPortal:\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    break;\n                case ContextProvider:\n                    {\n                        var newValue = workInProgress.memoizedProps.value;\n                        var context;\n                        {\n                            context = workInProgress.type;\n                        }\n                        pushProvider(workInProgress, context, newValue);\n                        break;\n                    }\n                case Profiler:\n                    {\n                        // Profiler should only call onRender when one of its descendants actually rendered.\n                        var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n                        if (hasChildWork) {\n                            workInProgress.flags |= Update;\n                        }\n                        {\n                            // Reset effect durations for the next eventual effect phase.\n                            // These are reset during render to allow the DevTools commit hook a chance to read them,\n                            var stateNode = workInProgress.stateNode;\n                            stateNode.effectDuration = 0;\n                            stateNode.passiveEffectDuration = 0;\n                        }\n                    }\n                    break;\n                case SuspenseComponent:\n                    {\n                        var state = workInProgress.memoizedState;\n                        if (state !== null) {\n                            if (state.dehydrated !== null) {\n                                // We're not going to render the children, so this is just to maintain\n                                // push/pop symmetry\n                                pushPrimaryTreeSuspenseHandler(workInProgress); // We know that this component will suspend again because if it has\n                                // been unsuspended it has committed as a resolved Suspense component.\n                                // If it needs to be retried, it should have work scheduled on it.\n                                workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we\n                                // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n                                return null;\n                            } // If this boundary is currently timed out, we need to decide\n                            // whether to retry the primary children, or to skip over it and\n                            // go straight to the fallback. Check the priority of the primary\n                            // child fragment.\n                            var primaryChildFragment = workInProgress.child;\n                            var primaryChildLanes = primaryChildFragment.childLanes;\n                            if (includesSomeLane(renderLanes, primaryChildLanes)) {\n                                // The primary children have pending work. Use the normal path\n                                // to attempt to render the primary children again.\n                                return updateSuspenseComponent(current, workInProgress, renderLanes);\n                            } else {\n                                // The primary child fragment does not have pending work marked\n                                // on it\n                                pushPrimaryTreeSuspenseHandler(workInProgress); // The primary children do not have pending work with sufficient\n                                // priority. Bailout.\n                                var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                                if (child !== null) {\n                                    // The fallback children have pending work. Skip over the\n                                    // primary children and work on the fallback.\n                                    return child.sibling;\n                                } else {\n                                    // Note: We can return `null` here because we already checked\n                                    // whether there were nested context consumers, via the call to\n                                    // `bailoutOnAlreadyFinishedWork` above.\n                                    return null;\n                                }\n                            }\n                        } else {\n                            pushPrimaryTreeSuspenseHandler(workInProgress);\n                        }\n                        break;\n                    }\n                case SuspenseListComponent:\n                    {\n                        var didSuspendBefore = (current.flags & DidCapture) !== NoFlags$1;\n                        var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n                        if (didSuspendBefore) {\n                            if (_hasChildWork) {\n                                // If something was in fallback state last time, and we have all the\n                                // same children then we're still in progressive loading state.\n                                // Something might get unblocked by state updates or retries in the\n                                // tree which will affect the tail. So we need to use the normal\n                                // path to compute the correct tail.\n                                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                            } // If none of the children had any work, that means that none of\n                            // them got retried so they'll still be blocked in the same way\n                            // as before. We can fast bail out.\n                            workInProgress.flags |= DidCapture;\n                        } // If nothing suspended before and we're rendering the same children,\n                        // then the tail doesn't matter. Anything new that suspends will work\n                        // in the \"together\" mode, so we can continue from the state we had.\n                        var renderState = workInProgress.memoizedState;\n                        if (renderState !== null) {\n                            // Reset to the \"together\" mode in case we've started a different\n                            // update in the past but didn't complete it.\n                            renderState.rendering = null;\n                            renderState.tail = null;\n                            renderState.lastEffect = null;\n                        }\n                        pushSuspenseListContext(workInProgress, suspenseStackCursor.current);\n                        if (_hasChildWork) {\n                            break;\n                        } else {\n                            // If none of the children had any work, that means that none of\n                            // them got retried so they'll still be blocked in the same way\n                            // as before. We can fast bail out.\n                            return null;\n                        }\n                    }\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        // Need to check if the tree still needs to be deferred. This is\n                        // almost identical to the logic used in the normal update path,\n                        // so we'll just enter that. The only difference is we'll bail out\n                        // at the next level instead of this one, because the child props\n                        // have not changed. Which is fine.\n                        // TODO: Probably should refactor `beginWork` to split the bailout\n                        // path from the normal path. I'm tempted to do a labeled break here\n                        // but I won't :)\n                        workInProgress.lanes = NoLanes;\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            var _cache = current.memoizedState.cache;\n                            pushCacheProvider(workInProgress, _cache);\n                        }\n                        break;\n                    }\n            }\n            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        function beginWork(current, workInProgress, renderLanes) {\n            {\n                if (workInProgress._debugNeedsRemount && current !== null) {\n                    // This will restart the begin phase with a new fiber.\n                    return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));\n                }\n            }\n            if (current !== null) {\n                var oldProps = current.memoizedProps;\n                var newProps = workInProgress.pendingProps;\n                if (oldProps !== newProps || hasContextChanged() || workInProgress.type !== current.type) {\n                    // If props or context changed, mark the fiber as having performed work.\n                    // This may be unset if the props are determined to be equal later (memo).\n                    didReceiveUpdate = true;\n                } else {\n                    // Neither props nor legacy context changes. Check if there's a pending\n                    // update or context change.\n                    var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n                    if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n                    // may not be work scheduled on `current`, so we check for this flag.\n                    (workInProgress.flags & DidCapture) === NoFlags$1) {\n                        // No pending updates or context. Bail out now.\n                        didReceiveUpdate = false;\n                        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n                    }\n                    if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags$1) {\n                        // This is a special case that only exists for legacy mode.\n                        // See https://github.com/facebook/react/pull/19216.\n                        didReceiveUpdate = true;\n                    } else {\n                        // An update was scheduled on this fiber, but there are no new props\n                        // nor legacy context. Set this to false. If an update queue or context\n                        // consumer produces a changed value, it will set this to true. Otherwise,\n                        // the component will assume the children have not changed and bail out.\n                        didReceiveUpdate = false;\n                    }\n                }\n            } else {\n                didReceiveUpdate = false;\n                if (getIsHydrating() && isForkedChild(workInProgress)) {\n                    // Check if this child belongs to a list of muliple children in\n                    // its parent.\n                    //\n                    // In a true multi-threaded implementation, we would render children on\n                    // parallel threads. This would represent the beginning of a new render\n                    // thread for this subtree.\n                    //\n                    // We only use this for id generation during hydration, which is why the\n                    // logic is located in this special branch.\n                    var slotIndex = workInProgress.index;\n                    var numberOfForks = getForksAtLevel();\n                    pushTreeId(workInProgress, numberOfForks, slotIndex);\n                }\n            } // Before entering the begin phase, clear pending update priority.\n            // TODO: This assumes that we're about to evaluate the component and process\n            // the update queue. However, there's an exception: SimpleMemoComponent\n            // sometimes bails out later in the begin phase. This indicates that we should\n            // move this assignment out of the common path and into each branch.\n            workInProgress.lanes = NoLanes;\n            switch(workInProgress.tag){\n                case LazyComponent:\n                    {\n                        var elementType = workInProgress.elementType;\n                        return mountLazyComponent(current, workInProgress, elementType, renderLanes);\n                    }\n                case FunctionComponent:\n                    {\n                        var Component = workInProgress.type;\n                        var unresolvedProps = workInProgress.pendingProps;\n                        var resolvedProps = unresolvedProps;\n                        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n                    }\n                case ClassComponent:\n                    {\n                        var _Component = workInProgress.type;\n                        var _unresolvedProps = workInProgress.pendingProps;\n                        var _resolvedProps4 = resolveClassComponentProps(_Component, _unresolvedProps);\n                        return updateClassComponent(current, workInProgress, _Component, _resolvedProps4, renderLanes);\n                    }\n                case HostRoot:\n                    return updateHostRoot(current, workInProgress, renderLanes);\n                case HostHoistable:\n                    if (supportsResources) {\n                        return updateHostHoistable(current, workInProgress);\n                    }\n                // Fall through\n                case HostSingleton:\n                    if (supportsSingletons) {\n                        return updateHostSingleton(current, workInProgress, renderLanes);\n                    }\n                // Fall through\n                case HostComponent:\n                    return updateHostComponent$1(current, workInProgress, renderLanes);\n                case HostText:\n                    return updateHostText$1(current, workInProgress);\n                case SuspenseComponent:\n                    return updateSuspenseComponent(current, workInProgress, renderLanes);\n                case HostPortal:\n                    return updatePortalComponent(current, workInProgress, renderLanes);\n                case ForwardRef:\n                    {\n                        var type = workInProgress.type;\n                        var _unresolvedProps2 = workInProgress.pendingProps;\n                        var _resolvedProps5 = _unresolvedProps2;\n                        return updateForwardRef(current, workInProgress, type, _resolvedProps5, renderLanes);\n                    }\n                case Fragment:\n                    return updateFragment(current, workInProgress, renderLanes);\n                case Mode:\n                    return updateMode(current, workInProgress, renderLanes);\n                case Profiler:\n                    return updateProfiler(current, workInProgress, renderLanes);\n                case ContextProvider:\n                    return updateContextProvider(current, workInProgress, renderLanes);\n                case ContextConsumer:\n                    return updateContextConsumer(current, workInProgress, renderLanes);\n                case MemoComponent:\n                    {\n                        var _type = workInProgress.type;\n                        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n                        var _resolvedProps6 = _unresolvedProps3;\n                        _resolvedProps6 = _resolvedProps6;\n                        return updateMemoComponent(current, workInProgress, _type, _resolvedProps6, renderLanes);\n                    }\n                case SimpleMemoComponent:\n                    {\n                        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n                    }\n                case IncompleteClassComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case IncompleteFunctionComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case SuspenseListComponent:\n                    {\n                        return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    }\n                case ScopeComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\n                    }\n                case LegacyHiddenComponent:\n                    {\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            return updateCacheComponent(current, workInProgress, renderLanes);\n                        }\n                    }\n            }\n            throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n        }\n        var valueCursor = createCursor(null);\n        var rendererCursorDEV;\n        {\n            rendererCursorDEV = createCursor(null);\n        }\n        var renderer2CursorDEV;\n        {\n            renderer2CursorDEV = createCursor(null);\n        }\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        var currentlyRenderingFiber = null;\n        var lastContextDependency = null;\n        var lastFullyObservedContext = null;\n        var isDisallowedContextReadInDEV = false;\n        function resetContextDependencies() {\n            // This is called right before React yields execution, to ensure `readContext`\n            // cannot be called outside the render phase.\n            currentlyRenderingFiber = null;\n            lastContextDependency = null;\n            lastFullyObservedContext = null;\n            {\n                isDisallowedContextReadInDEV = false;\n            }\n        }\n        function enterDisallowedContextReadInDEV() {\n            {\n                isDisallowedContextReadInDEV = true;\n            }\n        }\n        function exitDisallowedContextReadInDEV() {\n            {\n                isDisallowedContextReadInDEV = false;\n            }\n        }\n        function pushProvider(providerFiber, context, nextValue) {\n            if (isPrimaryRenderer) {\n                push(valueCursor, context._currentValue, providerFiber);\n                context._currentValue = nextValue;\n                {\n                    push(rendererCursorDEV, context._currentRenderer, providerFiber);\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            } else {\n                push(valueCursor, context._currentValue2, providerFiber);\n                context._currentValue2 = nextValue;\n                {\n                    push(renderer2CursorDEV, context._currentRenderer2, providerFiber);\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n        }\n        function popProvider(context, providerFiber) {\n            var currentValue = valueCursor.current;\n            if (isPrimaryRenderer) {\n                context._currentValue = currentValue;\n                {\n                    var currentRenderer = rendererCursorDEV.current;\n                    pop(rendererCursorDEV, providerFiber);\n                    context._currentRenderer = currentRenderer;\n                }\n            } else {\n                context._currentValue2 = currentValue;\n                {\n                    var currentRenderer2 = renderer2CursorDEV.current;\n                    pop(renderer2CursorDEV, providerFiber);\n                    context._currentRenderer2 = currentRenderer2;\n                }\n            }\n            pop(valueCursor, providerFiber);\n        }\n        function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n            // Update the child lanes of all the ancestors, including the alternates.\n            var node = parent;\n            while(node !== null){\n                var alternate = node.alternate;\n                if (!isSubsetOfLanes(node.childLanes, renderLanes)) {\n                    node.childLanes = mergeLanes(node.childLanes, renderLanes);\n                    if (alternate !== null) {\n                        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n                    }\n                } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {\n                    alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n                } else ;\n                if (node === propagationRoot) {\n                    break;\n                }\n                node = node.return;\n            }\n            {\n                if (node !== propagationRoot) {\n                    error('Expected to find the propagation root when scheduling context work. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n                }\n            }\n        }\n        function propagateContextChange(workInProgress, context, renderLanes) {\n            {\n                propagateContextChange_eager(workInProgress, context, renderLanes);\n            }\n        }\n        function propagateContextChange_eager(workInProgress, context, renderLanes) {\n            var fiber = workInProgress.child;\n            if (fiber !== null) {\n                // Set the return pointer of the child to the work-in-progress fiber.\n                fiber.return = workInProgress;\n            }\n            while(fiber !== null){\n                var nextFiber = void 0; // Visit this fiber.\n                var list = fiber.dependencies;\n                if (list !== null) {\n                    nextFiber = fiber.child;\n                    var dependency = list.firstContext;\n                    while(dependency !== null){\n                        // Check if the context matches.\n                        if (dependency.context === context) {\n                            // Match! Schedule an update on this fiber.\n                            if (fiber.tag === ClassComponent) {\n                                // Schedule a force update on the work-in-progress.\n                                var lane = pickArbitraryLane(renderLanes);\n                                var update = createUpdate(lane);\n                                update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the\n                                // update to the current fiber, too, which means it will persist even if\n                                // this render is thrown away. Since it's a race condition, not sure it's\n                                // worth fixing.\n                                // Inlined `enqueueUpdate` to remove interleaved update check\n                                var updateQueue = fiber.updateQueue;\n                                if (updateQueue === null) ;\n                                else {\n                                    var sharedQueue = updateQueue.shared;\n                                    var pending = sharedQueue.pending;\n                                    if (pending === null) {\n                                        // This is the first update. Create a circular list.\n                                        update.next = update;\n                                    } else {\n                                        update.next = pending.next;\n                                        pending.next = update;\n                                    }\n                                    sharedQueue.pending = update;\n                                }\n                            }\n                            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n                            var alternate = fiber.alternate;\n                            if (alternate !== null) {\n                                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n                            }\n                            scheduleContextWorkOnParentPath(fiber.return, renderLanes, workInProgress); // Mark the updated lanes on the list, too.\n                            list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the\n                            break;\n                        }\n                        dependency = dependency.next;\n                    }\n                } else if (fiber.tag === ContextProvider) {\n                    // Don't scan deeper if this is a matching provider\n                    nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n                } else if (fiber.tag === DehydratedFragment) {\n                    // If a dehydrated suspense boundary is in this subtree, we don't know\n                    // if it will have any context consumers in it. The best we can do is\n                    // mark it as having updates.\n                    var parentSuspense = fiber.return;\n                    if (parentSuspense === null) {\n                        throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');\n                    }\n                    parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);\n                    var _alternate = parentSuspense.alternate;\n                    if (_alternate !== null) {\n                        _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);\n                    } // This is intentionally passing this fiber as the parent\n                    // because we want to schedule this fiber as having work\n                    // on its children. We'll use the childLanes on\n                    // this fiber to indicate that a context has changed.\n                    scheduleContextWorkOnParentPath(parentSuspense, renderLanes, workInProgress);\n                    nextFiber = fiber.sibling;\n                } else {\n                    // Traverse down.\n                    nextFiber = fiber.child;\n                }\n                if (nextFiber !== null) {\n                    // Set the return pointer of the child to the work-in-progress fiber.\n                    nextFiber.return = fiber;\n                } else {\n                    // No child. Traverse to next sibling.\n                    nextFiber = fiber;\n                    while(nextFiber !== null){\n                        if (nextFiber === workInProgress) {\n                            // We're back to the root of this subtree. Exit.\n                            nextFiber = null;\n                            break;\n                        }\n                        var sibling = nextFiber.sibling;\n                        if (sibling !== null) {\n                            // Set the return pointer of the sibling to the work-in-progress fiber.\n                            sibling.return = nextFiber.return;\n                            nextFiber = sibling;\n                            break;\n                        } // No more siblings. Traverse up.\n                        nextFiber = nextFiber.return;\n                    }\n                }\n                fiber = nextFiber;\n            }\n        }\n        function prepareToReadContext(workInProgress, renderLanes) {\n            currentlyRenderingFiber = workInProgress;\n            lastContextDependency = null;\n            lastFullyObservedContext = null;\n            var dependencies = workInProgress.dependencies;\n            if (dependencies !== null) {\n                {\n                    var firstContext = dependencies.firstContext;\n                    if (firstContext !== null) {\n                        if (includesSomeLane(dependencies.lanes, renderLanes)) {\n                            // Context list has a pending update. Mark that this fiber performed work.\n                            markWorkInProgressReceivedUpdate();\n                        } // Reset the work-in-progress list\n                        dependencies.firstContext = null;\n                    }\n                }\n            }\n        }\n        function readContext(context) {\n            {\n                // This warning would fire if you read context inside a Hook like useMemo.\n                // Unlike the class check below, it's not enforced in production for perf.\n                if (isDisallowedContextReadInDEV) {\n                    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n                }\n            }\n            return readContextForConsumer(currentlyRenderingFiber, context);\n        }\n        function readContextDuringReconciliation(consumer, context, renderLanes) {\n            if (currentlyRenderingFiber === null) {\n                prepareToReadContext(consumer, renderLanes);\n            }\n            return readContextForConsumer(consumer, context);\n        }\n        function readContextForConsumer(consumer, context) {\n            var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n            if (lastFullyObservedContext === context) ;\n            else {\n                var contextItem = {\n                    context: context,\n                    memoizedValue: value,\n                    next: null\n                };\n                if (lastContextDependency === null) {\n                    if (consumer === null) {\n                        throw new Error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n                    } // This is the first dependency for this component. Create a new list.\n                    lastContextDependency = contextItem;\n                    consumer.dependencies = {\n                        lanes: NoLanes,\n                        firstContext: contextItem\n                    };\n                } else {\n                    // Append a new context item.\n                    lastContextDependency = lastContextDependency.next = contextItem;\n                }\n            }\n            return value;\n        }\n        // replace it with a lightweight shim that only has the features we use.\n        var AbortControllerLocal = typeof AbortController !== 'undefined' ? AbortController : // $FlowFixMe[prop-missing]\n        function AbortControllerShim() {\n            var listeners = [];\n            var signal = this.signal = {\n                aborted: false,\n                addEventListener: function(type, listener) {\n                    listeners.push(listener);\n                }\n            };\n            this.abort = function() {\n                signal.aborted = true;\n                listeners.forEach(function(listener) {\n                    return listener();\n                });\n            };\n        }; // Intentionally not named imports because Rollup would\n        // use dynamic dispatch for CommonJS interop named imports.\n        var scheduleCallback$1 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority;\n        var CacheContext = {\n            $$typeof: REACT_CONTEXT_TYPE,\n            // We don't use Consumer/Provider for Cache components. So we'll cheat.\n            Consumer: null,\n            Provider: null,\n            // We'll initialize these at the root.\n            _currentValue: null,\n            _currentValue2: null,\n            _threadCount: 0\n        };\n        {\n            CacheContext._currentRenderer = null;\n            CacheContext._currentRenderer2 = null;\n        }\n        // for retaining the cache once it is in use (retainCache), and releasing the cache\n        // once it is no longer needed (releaseCache).\n        function createCache() {\n            var cache = {\n                controller: new AbortControllerLocal(),\n                data: new Map(),\n                refCount: 0\n            };\n            return cache;\n        }\n        function retainCache(cache) {\n            {\n                if (cache.controller.signal.aborted) {\n                    warn('A cache instance was retained after it was already freed. ' + 'This likely indicates a bug in React.');\n                }\n            }\n            cache.refCount++;\n        } // Cleanup a cache instance, potentially freeing it if there are no more references\n        function releaseCache(cache) {\n            cache.refCount--;\n            {\n                if (cache.refCount < 0) {\n                    warn('A cache instance was released after it was already freed. ' + 'This likely indicates a bug in React.');\n                }\n            }\n            if (cache.refCount === 0) {\n                scheduleCallback$1(NormalPriority, function() {\n                    cache.controller.abort();\n                });\n            }\n        }\n        function pushCacheProvider(workInProgress, cache) {\n            pushProvider(workInProgress, CacheContext, cache);\n        }\n        function popCacheProvider(workInProgress, cache) {\n            popProvider(CacheContext, workInProgress);\n        }\n        // the shared internals object. This is used by the isomorphic implementation of\n        // startTransition to compose all the startTransitions together.\n        //\n        //   function startTransition(fn) {\n        //     return startTransitionDOM(() => {\n        //       return startTransitionART(() => {\n        //         return startTransitionThreeFiber(() => {\n        //           // and so on...\n        //           return fn();\n        //         });\n        //       });\n        //     });\n        //   }\n        //\n        // Currently we only compose together the code that runs at the end of each\n        // startTransition, because for now that's sufficient — the part that sets\n        // isTransition=true on the stack uses a separate shared internal field. But\n        // really we should delete the shared field and track isTransition per\n        // reconciler. Leaving this for a future PR.\n        var prevOnStartTransitionFinish = ReactSharedInternals.S;\n        ReactSharedInternals.S = function onStartTransitionFinishForReconciler(transition, returnValue) {\n            if (typeof returnValue === 'object' && returnValue !== null && typeof returnValue.then === 'function') {\n                // This is an async action\n                var thenable = returnValue;\n                entangleAsyncAction(transition, thenable);\n            }\n            if (prevOnStartTransitionFinish !== null) {\n                prevOnStartTransitionFinish(transition, returnValue);\n            }\n        };\n        function requestCurrentTransition() {\n            return ReactSharedInternals.T;\n        } // When retrying a Suspense/Offscreen boundary, we restore the cache that was\n        // used during the previous render by placing it here, on the stack.\n        var resumedCache = createCursor(null); // During the render/synchronous commit phase, we don't actually process the\n        function peekCacheFromPool() {\n            // If we're rendering inside a Suspense boundary that is currently hidden,\n            // we should use the same cache that we used during the previous render, if\n            // one exists.\n            var cacheResumedFromPreviousRender = resumedCache.current;\n            if (cacheResumedFromPreviousRender !== null) {\n                return cacheResumedFromPreviousRender;\n            } // Otherwise, check the root's cache pool.\n            var root = getWorkInProgressRoot();\n            var cacheFromRootCachePool = root.pooledCache;\n            return cacheFromRootCachePool;\n        }\n        function requestCacheFromPool(renderLanes) {\n            // Similar to previous function, except if there's not already a cache in the\n            // pool, we allocate a new one.\n            var cacheFromPool = peekCacheFromPool();\n            if (cacheFromPool !== null) {\n                return cacheFromPool;\n            } // Create a fresh cache and add it to the root cache pool. A cache can have\n            // multiple owners:\n            // - A cache pool that lives on the FiberRoot. This is where all fresh caches\n            //   are originally created (TODO: except during refreshes, until we implement\n            //   this correctly). The root takes ownership immediately when the cache is\n            //   created. Conceptually, root.pooledCache is an Option<Arc<Cache>> (owned),\n            //   and the return value of this function is a &Arc<Cache> (borrowed).\n            // - One of several fiber types: host root, cache boundary, suspense\n            //   component. These retain and release in the commit phase.\n            var root = getWorkInProgressRoot();\n            var freshCache = createCache();\n            root.pooledCache = freshCache;\n            retainCache(freshCache);\n            if (freshCache !== null) {\n                root.pooledCacheLanes |= renderLanes;\n            }\n            return freshCache;\n        }\n        function pushTransition(offscreenWorkInProgress, prevCachePool, newTransitions) {\n            {\n                if (prevCachePool === null) {\n                    push(resumedCache, resumedCache.current, offscreenWorkInProgress);\n                } else {\n                    push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n                }\n            }\n        }\n        function popTransition(workInProgress, current) {\n            if (current !== null) {\n                {\n                    pop(resumedCache, workInProgress);\n                }\n            }\n        }\n        function getSuspendedCache() {\n            // cache that would have been used to render fresh data during this render,\n            // if there was any, so that we can resume rendering with the same cache when\n            // we receive more data.\n            var cacheFromPool = peekCacheFromPool();\n            if (cacheFromPool === null) {\n                return null;\n            }\n            return {\n                // We must also save the parent, so that when we resume we can detect\n                // a refresh.\n                parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n                pool: cacheFromPool\n            };\n        }\n        function getOffscreenDeferredCache() {\n            var cacheFromPool = peekCacheFromPool();\n            if (cacheFromPool === null) {\n                return null;\n            }\n            return {\n                // We must also store the parent, so that when we resume we can detect\n                // a refresh.\n                parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n                pool: cacheFromPool\n            };\n        }\n        /**\n * Tag the fiber with an update effect. This turns a Placement into\n * a PlacementAndUpdate.\n */ function markUpdate(workInProgress) {\n            workInProgress.flags |= Update;\n        }\n        /**\n * In persistent mode, return whether this update needs to clone the subtree.\n */ function doesRequireClone(current, completedWork) {\n            var didBailout = current !== null && current.child === completedWork.child;\n            if (didBailout) {\n                return false;\n            }\n            if ((completedWork.flags & ChildDeletion) !== NoFlags$1) {\n                return true;\n            } // TODO: If we move the `doesRequireClone` call after `bubbleProperties`\n            // then we only have to check the `completedWork.subtreeFlags`.\n            var child = completedWork.child;\n            while(child !== null){\n                if ((child.flags & MutationMask) !== NoFlags$1 || (child.subtreeFlags & MutationMask) !== NoFlags$1) {\n                    return true;\n                }\n                child = child.sibling;\n            }\n            return false;\n        }\n        function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {\n            if (supportsMutation) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    if (node.tag === HostComponent || node.tag === HostText) {\n                        appendInitialChild(parent, node.stateNode);\n                    } else if (node.tag === HostPortal || (supportsSingletons ? node.tag === HostSingleton : false)) ;\n                    else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === workInProgress) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(node.sibling === null){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            } else if (supportsPersistence) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var _node = workInProgress.child;\n                while(_node !== null){\n                    if (_node.tag === HostComponent) {\n                        var instance = _node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var props = _node.memoizedProps;\n                            var type = _node.type;\n                            instance = cloneHiddenInstance(instance, type, props);\n                        }\n                        appendInitialChild(parent, instance);\n                    } else if (_node.tag === HostText) {\n                        var _instance = _node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var text = _node.memoizedProps;\n                            _instance = cloneHiddenTextInstance(_instance, text);\n                        }\n                        appendInitialChild(parent, _instance);\n                    } else if (_node.tag === HostPortal) ;\n                    else if (_node.tag === OffscreenComponent && _node.memoizedState !== null) {\n                        // The children in this boundary are hidden. Toggle their visibility\n                        // before appending.\n                        var child = _node.child;\n                        if (child !== null) {\n                            child.return = _node;\n                        }\n                        appendAllChildren(parent, _node, /* needsVisibilityToggle */ true, /* isHidden */ true);\n                    } else if (_node.child !== null) {\n                        _node.child.return = _node;\n                        _node = _node.child;\n                        continue;\n                    }\n                    if (_node === workInProgress) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(_node.sibling === null){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        if (_node.return === null || _node.return === workInProgress) {\n                            return;\n                        }\n                        _node = _node.return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    _node.sibling.return = _node.return;\n                    _node = _node.sibling;\n                }\n            }\n        } // An unfortunate fork of appendAllChildren because we have two different parent types.\n        function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n            if (supportsPersistence) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    if (node.tag === HostComponent) {\n                        var instance = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var props = node.memoizedProps;\n                            var type = node.type;\n                            instance = cloneHiddenInstance(instance, type, props);\n                        }\n                        appendChildToContainerChildSet(containerChildSet, instance);\n                    } else if (node.tag === HostText) {\n                        var _instance2 = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var text = node.memoizedProps;\n                            _instance2 = cloneHiddenTextInstance(_instance2, text);\n                        }\n                        appendChildToContainerChildSet(containerChildSet, _instance2);\n                    } else if (node.tag === HostPortal) ;\n                    else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n                        // The children in this boundary are hidden. Toggle their visibility\n                        // before appending.\n                        var child = node.child;\n                        if (child !== null) {\n                            child.return = node;\n                        } // If Offscreen is not in manual mode, detached tree is hidden from user space.\n                        var _needsVisibilityToggle = !isOffscreenManual(node);\n                        appendAllChildrenToContainer(containerChildSet, node, /* needsVisibilityToggle */ _needsVisibilityToggle, /* isHidden */ true);\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    node = node;\n                    if (node === workInProgress) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(node.sibling === null){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n        }\n        function updateHostContainer(current, workInProgress) {\n            if (supportsPersistence) {\n                if (doesRequireClone(current, workInProgress)) {\n                    var portalOrRoot = workInProgress.stateNode;\n                    var container = portalOrRoot.containerInfo;\n                    var newChildSet = createContainerChildSet(); // If children might have changed, we have to add them all to the set.\n                    appendAllChildrenToContainer(newChildSet, workInProgress, /* needsVisibilityToggle */ false, /* isHidden */ false);\n                    portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n                    markUpdate(workInProgress);\n                    finalizeContainerChildren(container, newChildSet);\n                }\n            }\n        }\n        function updateHostComponent(current, workInProgress, type, newProps, renderLanes) {\n            if (supportsMutation) {\n                // If we have an alternate, that means this is an update and we need to\n                // schedule a side-effect to do the updates.\n                var oldProps = current.memoizedProps;\n                if (oldProps === newProps) {\n                    // In mutation mode, this is sufficient for a bailout because\n                    // we won't touch this node even if children changed.\n                    return;\n                }\n                markUpdate(workInProgress);\n            } else if (supportsPersistence) {\n                var currentInstance = current.stateNode;\n                var _oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n                // This guarantees that we can reuse all of them.\n                var requiresClone = doesRequireClone(current, workInProgress);\n                if (!requiresClone && _oldProps === newProps) {\n                    // No changes, just reuse the existing instance.\n                    // Note that this might release a previous clone.\n                    workInProgress.stateNode = currentInstance;\n                    return;\n                }\n                var currentHostContext = getHostContext();\n                var newChildSet = null;\n                if (requiresClone && passChildrenWhenCloningPersistedNodes) {\n                    newChildSet = createContainerChildSet(); // If children might have changed, we have to add them all to the set.\n                    appendAllChildrenToContainer(newChildSet, workInProgress, /* needsVisibilityToggle */ false, /* isHidden */ false);\n                }\n                var newInstance = cloneInstance(currentInstance, type, _oldProps, newProps, !requiresClone, newChildSet);\n                if (newInstance === currentInstance) {\n                    // No changes, just reuse the existing instance.\n                    // Note that this might release a previous clone.\n                    workInProgress.stateNode = currentInstance;\n                    return;\n                } // Certain renderers require commit-time effects for initial mount.\n                // (eg DOM renderer supports auto-focus for certain elements).\n                // Make sure such renderers get scheduled for later work.\n                if (finalizeInitialChildren(newInstance, type, newProps, currentHostContext)) {\n                    markUpdate(workInProgress);\n                }\n                workInProgress.stateNode = newInstance;\n                if (!requiresClone) {\n                    // If there are no other effects in this tree, we need to flag this node as having one.\n                    // Even though we're not going to use it for anything.\n                    // Otherwise parents won't know that there are new children to propagate upwards.\n                    markUpdate(workInProgress);\n                } else {\n                    // If children might have changed, we have to add them all to the set.\n                    appendAllChildren(newInstance, workInProgress, /* needsVisibilityToggle */ false, /* isHidden */ false);\n                }\n            }\n        } // This function must be called at the very end of the complete phase, because\n        // it might throw to suspend, and if the resource immediately loads, the work\n        // loop will resume rendering as if the work-in-progress completed. So it must\n        // fully complete.\n        // TODO: This should ideally move to begin phase, but currently the instance is\n        // not created until the complete phase. For our existing use cases, host nodes\n        // that suspend don't have children, so it doesn't matter. But that might not\n        // always be true in the future.\n        function preloadInstanceAndSuspendIfNeeded(workInProgress, type, props, renderLanes) {\n            if (!maySuspendCommit(type, props)) {\n                // If this flag was set previously, we can remove it. The flag\n                // represents whether this particular set of props might ever need to\n                // suspend. The safest thing to do is for maySuspendCommit to always\n                // return true, but if the renderer is reasonably confident that the\n                // underlying resource won't be evicted, it can return false as a\n                // performance optimization.\n                workInProgress.flags &= ~MaySuspendCommit;\n                return;\n            } // Mark this fiber with a flag. This gets set on all host instances\n            // that might possibly suspend, even if they don't need to suspend\n            // currently. We use this when revealing a prerendered tree, because\n            // even though the tree has \"mounted\", its resources might not have\n            // loaded yet.\n            workInProgress.flags |= MaySuspendCommit; // preload the instance if necessary. Even if this is an urgent render there\n            // could be benefits to preloading early.\n            // @TODO we should probably do the preload in begin work\n            var isReady = preloadInstance(type, props);\n            if (!isReady) {\n                if (shouldRemainOnPreviousScreen()) {\n                    workInProgress.flags |= ShouldSuspendCommit;\n                } else {\n                    suspendCommit();\n                }\n            }\n        }\n        function preloadResourceAndSuspendIfNeeded(workInProgress, resource, type, props, renderLanes) {\n            // This is a fork of preloadInstanceAndSuspendIfNeeded, but for resources.\n            if (!mayResourceSuspendCommit(resource)) {\n                workInProgress.flags &= ~MaySuspendCommit;\n                return;\n            }\n            workInProgress.flags |= MaySuspendCommit;\n            var isReady = preloadResource(resource);\n            if (!isReady) {\n                if (shouldRemainOnPreviousScreen()) {\n                    workInProgress.flags |= ShouldSuspendCommit;\n                } else {\n                    suspendCommit();\n                }\n            }\n        }\n        function scheduleRetryEffect(workInProgress, retryQueue) {\n            var wakeables = retryQueue;\n            if (wakeables !== null) {\n                // Schedule an effect to attach a retry listener to the promise.\n                // TODO: Move to passive phase\n                workInProgress.flags |= Update;\n            } else {\n                // This boundary suspended, but no wakeables were added to the retry\n                // queue. Check if the renderer suspended commit. If so, this means\n                // that once the fallback is committed, we can immediately retry\n                // rendering again, because rendering wasn't actually blocked. Only\n                // the commit phase.\n                // TODO: Consider a model where we always schedule an immediate retry, even\n                // for normal Suspense. That way the retry can partially render up to the\n                // first thing that suspends.\n                if (workInProgress.flags & ScheduleRetry) {\n                    var retryLane = // I also suspect that we need some further consolidation of offscreen\n                    // and retry lanes.\n                    workInProgress.tag !== OffscreenComponent ? claimNextRetryLane() : OffscreenLane;\n                    workInProgress.lanes = mergeLanes(workInProgress.lanes, retryLane);\n                }\n            }\n        }\n        function updateHostText(current, workInProgress, oldText, newText) {\n            if (supportsMutation) {\n                // If the text differs, mark it as an update. All the work in done in commitWork.\n                if (oldText !== newText) {\n                    markUpdate(workInProgress);\n                }\n            } else if (supportsPersistence) {\n                if (oldText !== newText) {\n                    // If the text content differs, we'll create a new text instance for it.\n                    var rootContainerInstance = getRootHostContainer();\n                    var currentHostContext = getHostContext();\n                    workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n                    // This lets the parents know that at least one of their children has changed.\n                    markUpdate(workInProgress);\n                } else {\n                    workInProgress.stateNode = current.stateNode;\n                }\n            }\n        }\n        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n            if (getIsHydrating()) {\n                // If we're hydrating, we should consume as many items as we can\n                // so we don't leave any behind.\n                return;\n            }\n            switch(renderState.tailMode){\n                case 'hidden':\n                    {\n                        // Any insertions at the end of the tail list after this point\n                        // should be invisible. If there are already mounted boundaries\n                        // anything before them are not considered for collapsing.\n                        // Therefore we need to go through the whole tail to find if\n                        // there are any.\n                        var tailNode = renderState.tail;\n                        var lastTailNode = null;\n                        while(tailNode !== null){\n                            if (tailNode.alternate !== null) {\n                                lastTailNode = tailNode;\n                            }\n                            tailNode = tailNode.sibling;\n                        } // Next we're simply going to delete all insertions after the\n                        // last rendered item.\n                        if (lastTailNode === null) {\n                            // All remaining items in the tail are insertions.\n                            renderState.tail = null;\n                        } else {\n                            // Detach the insertion after the last node that was already\n                            // inserted.\n                            lastTailNode.sibling = null;\n                        }\n                        break;\n                    }\n                case 'collapsed':\n                    {\n                        // Any insertions at the end of the tail list after this point\n                        // should be invisible. If there are already mounted boundaries\n                        // anything before them are not considered for collapsing.\n                        // Therefore we need to go through the whole tail to find if\n                        // there are any.\n                        var _tailNode = renderState.tail;\n                        var _lastTailNode = null;\n                        while(_tailNode !== null){\n                            if (_tailNode.alternate !== null) {\n                                _lastTailNode = _tailNode;\n                            }\n                            _tailNode = _tailNode.sibling;\n                        } // Next we're simply going to delete all insertions after the\n                        // last rendered item.\n                        if (_lastTailNode === null) {\n                            // All remaining items in the tail are insertions.\n                            if (!hasRenderedATailFallback && renderState.tail !== null) {\n                                // We suspended during the head. We want to show at least one\n                                // row at the tail. So we'll keep on and cut off the rest.\n                                renderState.tail.sibling = null;\n                            } else {\n                                renderState.tail = null;\n                            }\n                        } else {\n                            // Detach the insertion after the last node that was already\n                            // inserted.\n                            _lastTailNode.sibling = null;\n                        }\n                        break;\n                    }\n            }\n        }\n        function bubbleProperties(completedWork) {\n            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n            var newChildLanes = NoLanes;\n            var subtreeFlags = NoFlags$1;\n            if (!didBailout) {\n                // Bubble up the earliest expiration time.\n                if ((completedWork.mode & ProfileMode) !== NoMode) {\n                    // In profiling mode, resetChildExpirationTime is also used to reset\n                    // profiler durations.\n                    var actualDuration = completedWork.actualDuration;\n                    var treeBaseDuration = completedWork.selfBaseDuration;\n                    var child = completedWork.child;\n                    while(child !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n                        subtreeFlags |= child.subtreeFlags;\n                        subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n                        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n                        // When work is done, it should bubble to the parent's actualDuration. If\n                        // the fiber has not been cloned though, (meaning no work was done), then\n                        // this value will reflect the amount of time spent working on a previous\n                        // render. In that case it should not bubble. We determine whether it was\n                        // cloned by comparing the child pointer.\n                        // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        actualDuration += child.actualDuration; // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        treeBaseDuration += child.treeBaseDuration;\n                        child = child.sibling;\n                    }\n                    completedWork.actualDuration = actualDuration;\n                    completedWork.treeBaseDuration = treeBaseDuration;\n                } else {\n                    var _child = completedWork.child;\n                    while(_child !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\n                        subtreeFlags |= _child.subtreeFlags;\n                        subtreeFlags |= _child.flags; // Update the return pointer so the tree is consistent. This is a code\n                        // smell because it assumes the commit phase is never concurrent with\n                        // the render phase. Will address during refactor to alternate model.\n                        _child.return = completedWork;\n                        _child = _child.sibling;\n                    }\n                }\n                completedWork.subtreeFlags |= subtreeFlags;\n            } else {\n                // Bubble up the earliest expiration time.\n                if ((completedWork.mode & ProfileMode) !== NoMode) {\n                    // In profiling mode, resetChildExpirationTime is also used to reset\n                    // profiler durations.\n                    var _treeBaseDuration = completedWork.selfBaseDuration;\n                    var _child2 = completedWork.child;\n                    while(_child2 !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n                        // so we should bubble those up even during a bailout. All the other\n                        // flags have a lifetime only of a single render + commit, so we should\n                        // ignore them.\n                        subtreeFlags |= _child2.subtreeFlags & StaticMask;\n                        subtreeFlags |= _child2.flags & StaticMask; // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        _treeBaseDuration += _child2.treeBaseDuration;\n                        _child2 = _child2.sibling;\n                    }\n                    completedWork.treeBaseDuration = _treeBaseDuration;\n                } else {\n                    var _child3 = completedWork.child;\n                    while(_child3 !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n                        // so we should bubble those up even during a bailout. All the other\n                        // flags have a lifetime only of a single render + commit, so we should\n                        // ignore them.\n                        subtreeFlags |= _child3.subtreeFlags & StaticMask;\n                        subtreeFlags |= _child3.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code\n                        // smell because it assumes the commit phase is never concurrent with\n                        // the render phase. Will address during refactor to alternate model.\n                        _child3.return = completedWork;\n                        _child3 = _child3.sibling;\n                    }\n                }\n                completedWork.subtreeFlags |= subtreeFlags;\n            }\n            completedWork.childLanes = newChildLanes;\n            return didBailout;\n        }\n        function completeDehydratedSuspenseBoundary(current, workInProgress, nextState) {\n            var wasHydrated = popHydrationState(workInProgress);\n            if (nextState !== null && nextState.dehydrated !== null) {\n                // We might be inside a hydration state the first time we're picking up this\n                // Suspense boundary, and also after we've reentered it for further hydration.\n                if (current === null) {\n                    if (!wasHydrated) {\n                        throw new Error('A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');\n                    }\n                    prepareToHydrateHostSuspenseInstance(workInProgress);\n                    bubbleProperties(workInProgress);\n                    {\n                        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                            var isTimedOutSuspense = nextState !== null;\n                            if (isTimedOutSuspense) {\n                                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                var primaryChildFragment = workInProgress.child;\n                                if (primaryChildFragment !== null) {\n                                    // $FlowFixMe[unsafe-arithmetic] Flow doesn't support type casting in combination with the -= operator\n                                    workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                } else {\n                    emitPendingHydrationWarnings(); // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n                    // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n                    resetHydrationState();\n                    if ((workInProgress.flags & DidCapture) === NoFlags$1) {\n                        // This boundary did not suspend so it's now hydrated and unsuspended.\n                        workInProgress.memoizedState = null;\n                    } // If nothing suspended, we need to schedule an effect to mark this boundary\n                    // as having hydrated so events know that they're free to be invoked.\n                    // It's also a signal to replay events and the suspense callback.\n                    // If something suspended, schedule an effect to attach retry listeners.\n                    // So we might as well always mark this.\n                    workInProgress.flags |= Update;\n                    bubbleProperties(workInProgress);\n                    {\n                        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                            var _isTimedOutSuspense = nextState !== null;\n                            if (_isTimedOutSuspense) {\n                                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                var _primaryChildFragment = workInProgress.child;\n                                if (_primaryChildFragment !== null) {\n                                    // $FlowFixMe[unsafe-arithmetic] Flow doesn't support type casting in combination with the -= operator\n                                    workInProgress.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                }\n            } else {\n                // Successfully completed this tree. If this was a forced client render,\n                // there may have been recoverable errors during first hydration\n                // attempt. If so, add them to a queue so we can log them in the\n                // commit phase.\n                upgradeHydrationErrorsToRecoverable(); // Fall through to normal Suspense path\n                return true;\n            }\n        }\n        function completeWork(current, workInProgress, renderLanes) {\n            var newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(workInProgress);\n            switch(workInProgress.tag){\n                case IncompleteFunctionComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case LazyComponent:\n                case SimpleMemoComponent:\n                case FunctionComponent:\n                case ForwardRef:\n                case Fragment:\n                case Mode:\n                case Profiler:\n                case ContextConsumer:\n                case MemoComponent:\n                    bubbleProperties(workInProgress);\n                    return null;\n                case ClassComponent:\n                    {\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostRoot:\n                    {\n                        var fiberRoot = workInProgress.stateNode;\n                        {\n                            var previousCache = null;\n                            if (current !== null) {\n                                previousCache = current.memoizedState.cache;\n                            }\n                            var cache = workInProgress.memoizedState.cache;\n                            if (cache !== previousCache) {\n                                // Run passive effects to retain/release the cache.\n                                workInProgress.flags |= Passive$1;\n                            }\n                            popCacheProvider(workInProgress);\n                        }\n                        popHostContainer(workInProgress);\n                        if (fiberRoot.pendingContext) {\n                            fiberRoot.context = fiberRoot.pendingContext;\n                            fiberRoot.pendingContext = null;\n                        }\n                        if (current === null || current.child === null) {\n                            // If we hydrated, pop so that we can delete any remaining children\n                            // that weren't hydrated.\n                            var wasHydrated = popHydrationState(workInProgress);\n                            if (wasHydrated) {\n                                emitPendingHydrationWarnings(); // If we hydrated, then we'll need to schedule an update for\n                                // the commit side-effects on the root.\n                                markUpdate(workInProgress);\n                            } else {\n                                if (current !== null) {\n                                    var prevState = current.memoizedState;\n                                    if (!prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n                                    (workInProgress.flags & ForceClientRender) !== NoFlags$1) {\n                                        // Schedule an effect to clear this container at the start of the\n                                        // next commit. This handles the case of React rendering into a\n                                        // container with previous children. It's also safe to do for\n                                        // updates too, because current.child would only be null if the\n                                        // previous render was null (so the container would already\n                                        // be empty).\n                                        workInProgress.flags |= Snapshot; // If this was a forced client render, there may have been\n                                        // recoverable errors during first hydration attempt. If so, add\n                                        // them to a queue so we can log them in the commit phase.\n                                        upgradeHydrationErrorsToRecoverable();\n                                    }\n                                }\n                            }\n                        }\n                        updateHostContainer(current, workInProgress);\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            // The branching here is more complicated than you might expect because\n                            // a HostHoistable sometimes corresponds to a Resource and sometimes\n                            // corresponds to an Instance. It can also switch during an update.\n                            var type = workInProgress.type;\n                            var nextResource = workInProgress.memoizedState;\n                            if (current === null) {\n                                // We are mounting and must Update this Hoistable in this commit\n                                // @TODO refactor this block to create the instance here in complete\n                                // phase if we are not hydrating.\n                                markUpdate(workInProgress);\n                                if (nextResource !== null) {\n                                    // This is a Hoistable Resource\n                                    // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    preloadResourceAndSuspendIfNeeded(workInProgress, nextResource);\n                                    return null;\n                                } else {\n                                    // This is a Hoistable Instance\n                                    // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    preloadInstanceAndSuspendIfNeeded(workInProgress, type, newProps);\n                                    return null;\n                                }\n                            } else {\n                                // We are updating.\n                                var currentResource = current.memoizedState;\n                                if (nextResource !== currentResource) {\n                                    // We are transitioning to, from, or between Hoistable Resources\n                                    // and require an update\n                                    markUpdate(workInProgress);\n                                }\n                                if (nextResource !== null) {\n                                    // This is a Hoistable Resource\n                                    // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    if (nextResource === currentResource) {\n                                        workInProgress.flags &= ~MaySuspendCommit;\n                                    } else {\n                                        preloadResourceAndSuspendIfNeeded(workInProgress, nextResource);\n                                    }\n                                    return null;\n                                } else {\n                                    // This is a Hoistable Instance\n                                    // We may have props to update on the Hoistable instance.\n                                    if (supportsMutation) {\n                                        var oldProps = current.memoizedProps;\n                                        if (oldProps !== newProps) {\n                                            markUpdate(workInProgress);\n                                        }\n                                    } else {\n                                        // We use the updateHostComponent path becuase it produces\n                                        // the update queue we need for Hoistables.\n                                        updateHostComponent(current, workInProgress, type, newProps);\n                                    } // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    preloadInstanceAndSuspendIfNeeded(workInProgress, type, newProps);\n                                    return null;\n                                }\n                            }\n                        } // Fall through\n                    }\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            popHostContext(workInProgress);\n                            var rootContainerInstance = getRootHostContainer();\n                            var _type = workInProgress.type;\n                            if (current !== null && workInProgress.stateNode != null) {\n                                if (supportsMutation) {\n                                    var _oldProps2 = current.memoizedProps;\n                                    if (_oldProps2 !== newProps) {\n                                        markUpdate(workInProgress);\n                                    }\n                                } else {\n                                    updateHostComponent(current, workInProgress, _type, newProps);\n                                }\n                            } else {\n                                if (!newProps) {\n                                    if (workInProgress.stateNode === null) {\n                                        throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                    } // This can happen when we abort work.\n                                    bubbleProperties(workInProgress);\n                                    return null;\n                                }\n                                var currentHostContext = getHostContext();\n                                var _wasHydrated = popHydrationState(workInProgress);\n                                var instance;\n                                if (_wasHydrated) {\n                                    // We ignore the boolean indicating there is an updateQueue because\n                                    // it is used only to set text children and HostSingletons do not\n                                    // use them.\n                                    prepareToHydrateHostInstance(workInProgress, currentHostContext);\n                                    instance = workInProgress.stateNode;\n                                } else {\n                                    instance = resolveSingletonInstance(_type, newProps, rootContainerInstance, currentHostContext, true);\n                                    workInProgress.stateNode = instance;\n                                    markUpdate(workInProgress);\n                                }\n                            }\n                            bubbleProperties(workInProgress);\n                            return null;\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        popHostContext(workInProgress);\n                        var _type2 = workInProgress.type;\n                        if (current !== null && workInProgress.stateNode != null) {\n                            updateHostComponent(current, workInProgress, _type2, newProps);\n                        } else {\n                            if (!newProps) {\n                                if (workInProgress.stateNode === null) {\n                                    throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                } // This can happen when we abort work.\n                                bubbleProperties(workInProgress);\n                                return null;\n                            }\n                            var _currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n                            // \"stack\" as the parent. Then append children as we go in beginWork\n                            // or completeWork depending on whether we want to add them top->down or\n                            // bottom->up. Top->down is faster in IE11.\n                            var _wasHydrated2 = popHydrationState(workInProgress);\n                            if (_wasHydrated2) {\n                                // TODO: Move this and createInstance step into the beginPhase\n                                // to consolidate.\n                                prepareToHydrateHostInstance(workInProgress, _currentHostContext);\n                            } else {\n                                var _rootContainerInstance = getRootHostContainer();\n                                var _instance3 = createInstance(_type2, newProps, _rootContainerInstance, _currentHostContext, workInProgress); // TODO: For persistent renderers, we should pass children as part\n                                // of the initial instance creation\n                                appendAllChildren(_instance3, workInProgress, false, false);\n                                workInProgress.stateNode = _instance3; // Certain renderers require commit-time effects for initial mount.\n                                // (eg DOM renderer supports auto-focus for certain elements).\n                                // Make sure such renderers get scheduled for later work.\n                                if (finalizeInitialChildren(_instance3, _type2, newProps, _currentHostContext)) {\n                                    markUpdate(workInProgress);\n                                }\n                            }\n                        }\n                        bubbleProperties(workInProgress); // This must come at the very end of the complete phase, because it might\n                        // throw to suspend, and if the resource immediately loads, the work loop\n                        // will resume rendering as if the work-in-progress completed. So it must\n                        // fully complete.\n                        preloadInstanceAndSuspendIfNeeded(workInProgress, workInProgress.type, workInProgress.pendingProps);\n                        return null;\n                    }\n                case HostText:\n                    {\n                        var newText = newProps;\n                        if (current && workInProgress.stateNode != null) {\n                            var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n                            // to schedule a side-effect to do the updates.\n                            updateHostText(current, workInProgress, oldText, newText);\n                        } else {\n                            if (typeof newText !== 'string') {\n                                if (workInProgress.stateNode === null) {\n                                    throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                } // This can happen when we abort work.\n                            }\n                            var _rootContainerInstance2 = getRootHostContainer();\n                            var _currentHostContext2 = getHostContext();\n                            var _wasHydrated3 = popHydrationState(workInProgress);\n                            if (_wasHydrated3) {\n                                prepareToHydrateHostTextInstance(workInProgress);\n                            } else {\n                                workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance2, _currentHostContext2, workInProgress);\n                            }\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case SuspenseComponent:\n                    {\n                        var nextState = workInProgress.memoizedState; // Special path for dehydrated boundaries. We may eventually move this\n                        // to its own fiber type so that we can add other kinds of hydration\n                        // boundaries that aren't associated with a Suspense tree. In anticipation\n                        // of such a refactor, all the hydration logic is contained in\n                        // this branch.\n                        if (current === null || current.memoizedState !== null && current.memoizedState.dehydrated !== null) {\n                            var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current, workInProgress, nextState);\n                            if (!fallthroughToNormalSuspensePath) {\n                                if (workInProgress.flags & ForceClientRender) {\n                                    popSuspenseHandler(workInProgress); // Special case. There were remaining unhydrated nodes. We treat\n                                    // this as a mismatch. Revert to client rendering.\n                                    return workInProgress;\n                                } else {\n                                    popSuspenseHandler(workInProgress); // Did not finish hydrating, either because this is the initial\n                                    // render or because something suspended.\n                                    return null;\n                                }\n                            } // Continue with the normal Suspense path.\n                        }\n                        popSuspenseHandler(workInProgress);\n                        if ((workInProgress.flags & DidCapture) !== NoFlags$1) {\n                            // Something suspended. Re-render with the fallback children.\n                            workInProgress.lanes = renderLanes; // Do not reset the effect list.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            } // Don't bubble properties in this case.\n                            return workInProgress;\n                        }\n                        var nextDidTimeout = nextState !== null;\n                        var prevDidTimeout = current !== null && current.memoizedState !== null;\n                        if (nextDidTimeout) {\n                            var offscreenFiber = workInProgress.child;\n                            var _previousCache = null;\n                            if (offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null && offscreenFiber.alternate.memoizedState.cachePool !== null) {\n                                _previousCache = offscreenFiber.alternate.memoizedState.cachePool.pool;\n                            }\n                            var _cache = null;\n                            if (offscreenFiber.memoizedState !== null && offscreenFiber.memoizedState.cachePool !== null) {\n                                _cache = offscreenFiber.memoizedState.cachePool.pool;\n                            }\n                            if (_cache !== _previousCache) {\n                                // Run passive effects to retain/release the cache.\n                                offscreenFiber.flags |= Passive$1;\n                            }\n                        } // If the suspended state of the boundary changes, we need to schedule\n                        // a passive effect, which is when we process the transitions\n                        if (nextDidTimeout !== prevDidTimeout) {\n                            // an effect to toggle the subtree's visibility. When we switch from\n                            // fallback -> primary, the inner Offscreen fiber schedules this effect\n                            // as part of its normal complete phase. But when we switch from\n                            // primary -> fallback, the inner Offscreen fiber does not have a complete\n                            // phase. So we need to schedule its effect here.\n                            //\n                            // We also use this flag to connect/disconnect the effects, but the same\n                            // logic applies: when re-connecting, the Offscreen fiber's complete\n                            // phase will handle scheduling the effect. It's only when the fallback\n                            // is active that we have to do anything special.\n                            if (nextDidTimeout) {\n                                var _offscreenFiber2 = workInProgress.child;\n                                _offscreenFiber2.flags |= Visibility;\n                            }\n                        }\n                        var retryQueue = workInProgress.updateQueue;\n                        scheduleRetryEffect(workInProgress, retryQueue);\n                        bubbleProperties(workInProgress);\n                        {\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                if (nextDidTimeout) {\n                                    // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                    var primaryChildFragment = workInProgress.child;\n                                    if (primaryChildFragment !== null) {\n                                        // $FlowFixMe[unsafe-arithmetic] Flow doesn't support type casting in combination with the -= operator\n                                        workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                                    }\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                case HostPortal:\n                    popHostContainer(workInProgress);\n                    updateHostContainer(current, workInProgress);\n                    if (current === null) {\n                        preparePortalMount(workInProgress.stateNode.containerInfo);\n                    }\n                    bubbleProperties(workInProgress);\n                    return null;\n                case ContextProvider:\n                    // Pop provider fiber\n                    var context;\n                    {\n                        context = workInProgress.type;\n                    }\n                    popProvider(context, workInProgress);\n                    bubbleProperties(workInProgress);\n                    return null;\n                case IncompleteClassComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case SuspenseListComponent:\n                    {\n                        popSuspenseListContext(workInProgress);\n                        var renderState = workInProgress.memoizedState;\n                        if (renderState === null) {\n                            // We're running in the default, \"independent\" mode.\n                            // We don't do anything in this mode.\n                            bubbleProperties(workInProgress);\n                            return null;\n                        }\n                        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags$1;\n                        var renderedTail = renderState.rendering;\n                        if (renderedTail === null) {\n                            // We just rendered the head.\n                            if (!didSuspendAlready) {\n                                // This is the first pass. We need to figure out if anything is still\n                                // suspended in the rendered set.\n                                // If new content unsuspended, but there's still some content that\n                                // didn't. Then we need to do a second pass that forces everything\n                                // to keep showing their fallbacks.\n                                // We might be suspended if something in this render pass suspended, or\n                                // something in the previous committed pass suspended. Otherwise,\n                                // there's no chance so we can skip the expensive call to\n                                // findFirstSuspended.\n                                var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags$1);\n                                if (!cannotBeSuspended) {\n                                    var row = workInProgress.child;\n                                    while(row !== null){\n                                        var suspended = findFirstSuspended(row);\n                                        if (suspended !== null) {\n                                            didSuspendAlready = true;\n                                            workInProgress.flags |= DidCapture;\n                                            cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n                                            // part of the second pass. In that case nothing will subscribe to\n                                            // its thenables. Instead, we'll transfer its thenables to the\n                                            // SuspenseList so that it can retry if they resolve.\n                                            // There might be multiple of these in the list but since we're\n                                            // going to wait for all of them anyway, it doesn't really matter\n                                            // which ones gets to ping. In theory we could get clever and keep\n                                            // track of how many dependencies remain but it gets tricky because\n                                            // in the meantime, we can add/remove/change items and dependencies.\n                                            // We might bail out of the loop before finding any but that\n                                            // doesn't matter since that means that the other boundaries that\n                                            // we did find already has their listeners attached.\n                                            var _retryQueue = suspended.updateQueue;\n                                            workInProgress.updateQueue = _retryQueue;\n                                            scheduleRetryEffect(workInProgress, _retryQueue); // Rerender the whole list, but this time, we'll force fallbacks\n                                            // to stay in place.\n                                            // Reset the effect flags before doing the second pass since that's now invalid.\n                                            // Reset the child fibers to their original state.\n                                            workInProgress.subtreeFlags = NoFlags$1;\n                                            resetChildFibers(workInProgress, renderLanes); // Set up the Suspense List Context to force suspense and\n                                            // immediately rerender the children.\n                                            pushSuspenseListContext(workInProgress, setShallowSuspenseListContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.\n                                            return workInProgress.child;\n                                        }\n                                        row = row.sibling;\n                                    }\n                                }\n                                if (renderState.tail !== null && now$1() > getRenderTargetTime()) {\n                                    // We have already passed our CPU deadline but we still have rows\n                                    // left in the tail. We'll just give up further attempts to render\n                                    // the main content and only render fallbacks.\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true;\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n                                    // to get it started back up to attempt the next item. While in terms\n                                    // of priority this work has the same priority as this current render,\n                                    // it's not part of the same transition once the transition has\n                                    // committed. If it's sync, we still want to yield so that it can be\n                                    // painted. Conceptually, this is really the same as pinging.\n                                    // We can use any RetryLane even if it's the one currently rendering\n                                    // since we're leaving it behind on this node.\n                                    workInProgress.lanes = SomeRetryLane;\n                                }\n                            } else {\n                                cutOffTailIfNeeded(renderState, false);\n                            } // Next we're going to render the tail.\n                        } else {\n                            // Append the rendered row to the child list.\n                            if (!didSuspendAlready) {\n                                var _suspended = findFirstSuspended(renderedTail);\n                                if (_suspended !== null) {\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n                                    // get lost if this row ends up dropped during a second pass.\n                                    var _retryQueue2 = _suspended.updateQueue;\n                                    workInProgress.updateQueue = _retryQueue2;\n                                    scheduleRetryEffect(workInProgress, _retryQueue2);\n                                    cutOffTailIfNeeded(renderState, true); // This might have been modified.\n                                    if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\n                                    ) {\n                                        // We're done.\n                                        bubbleProperties(workInProgress);\n                                        return null;\n                                    }\n                                } else if (// time we have to render. So rendering one more row would likely\n                                // exceed it.\n                                now$1() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\n                                    // We have now passed our CPU deadline and we'll just give up further\n                                    // attempts to render the main content and only render fallbacks.\n                                    // The assumption is that this is usually faster.\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true;\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n                                    // to get it started back up to attempt the next item. While in terms\n                                    // of priority this work has the same priority as this current render,\n                                    // it's not part of the same transition once the transition has\n                                    // committed. If it's sync, we still want to yield so that it can be\n                                    // painted. Conceptually, this is really the same as pinging.\n                                    // We can use any RetryLane even if it's the one currently rendering\n                                    // since we're leaving it behind on this node.\n                                    workInProgress.lanes = SomeRetryLane;\n                                }\n                            }\n                            if (renderState.isBackwards) {\n                                // The effect list of the backwards tail will have been added\n                                // to the end. This breaks the guarantee that life-cycles fire in\n                                // sibling order but that isn't a strong guarantee promised by React.\n                                // Especially since these might also just pop in during future commits.\n                                // Append to the beginning of the list.\n                                renderedTail.sibling = workInProgress.child;\n                                workInProgress.child = renderedTail;\n                            } else {\n                                var previousSibling = renderState.last;\n                                if (previousSibling !== null) {\n                                    previousSibling.sibling = renderedTail;\n                                } else {\n                                    workInProgress.child = renderedTail;\n                                }\n                                renderState.last = renderedTail;\n                            }\n                        }\n                        if (renderState.tail !== null) {\n                            // We still have tail rows to render.\n                            // Pop a row.\n                            var next = renderState.tail;\n                            renderState.rendering = next;\n                            renderState.tail = next.sibling;\n                            renderState.renderingStartTime = now$1();\n                            next.sibling = null; // Restore the context.\n                            // TODO: We can probably just avoid popping it instead and only\n                            // setting it the first time we go from not suspended to suspended.\n                            var suspenseContext = suspenseStackCursor.current;\n                            if (didSuspendAlready) {\n                                suspenseContext = setShallowSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n                            } else {\n                                suspenseContext = setDefaultShallowSuspenseListContext(suspenseContext);\n                            }\n                            pushSuspenseListContext(workInProgress, suspenseContext); // Do a pass over the next row.\n                            // Don't bubble properties in this case.\n                            return next;\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case ScopeComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        popSuspenseHandler(workInProgress);\n                        popHiddenContext(workInProgress);\n                        var _nextState = workInProgress.memoizedState;\n                        var nextIsHidden = _nextState !== null; // Schedule a Visibility effect if the visibility has changed\n                        {\n                            if (current !== null) {\n                                var _prevState = current.memoizedState;\n                                var prevIsHidden = _prevState !== null;\n                                if (prevIsHidden !== nextIsHidden) {\n                                    workInProgress.flags |= Visibility;\n                                }\n                            } else {\n                                // On initial mount, we only need a Visibility effect if the tree\n                                // is hidden.\n                                if (nextIsHidden) {\n                                    workInProgress.flags |= Visibility;\n                                }\n                            }\n                        }\n                        if (!nextIsHidden || !disableLegacyMode) {\n                            bubbleProperties(workInProgress);\n                        } else {\n                            // Don't bubble properties for hidden children unless we're rendering\n                            // at offscreen priority.\n                            if (includesSomeLane(renderLanes, OffscreenLane) && // Also don't bubble if the tree suspended\n                            (workInProgress.flags & DidCapture) === NoLanes) {\n                                bubbleProperties(workInProgress); // Check if there was an insertion or update in the hidden subtree.\n                                // If so, we need to hide those nodes in the commit phase, so\n                                // schedule a visibility effect.\n                                if (workInProgress.subtreeFlags & (Placement | Update)) {\n                                    workInProgress.flags |= Visibility;\n                                }\n                            }\n                        }\n                        var offscreenQueue = workInProgress.updateQueue;\n                        if (offscreenQueue !== null) {\n                            var _retryQueue3 = offscreenQueue.retryQueue;\n                            scheduleRetryEffect(workInProgress, _retryQueue3);\n                        }\n                        {\n                            var _previousCache2 = null;\n                            if (current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n                                _previousCache2 = current.memoizedState.cachePool.pool;\n                            }\n                            var _cache2 = null;\n                            if (workInProgress.memoizedState !== null && workInProgress.memoizedState.cachePool !== null) {\n                                _cache2 = workInProgress.memoizedState.cachePool.pool;\n                            }\n                            if (_cache2 !== _previousCache2) {\n                                // Run passive effects to retain/release the cache.\n                                workInProgress.flags |= Passive$1;\n                            }\n                        }\n                        popTransition(workInProgress, current);\n                        return null;\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            var _previousCache3 = null;\n                            if (current !== null) {\n                                _previousCache3 = current.memoizedState.cache;\n                            }\n                            var _cache3 = workInProgress.memoizedState.cache;\n                            if (_cache3 !== _previousCache3) {\n                                // Run passive effects to retain/release the cache.\n                                workInProgress.flags |= Passive$1;\n                            }\n                            popCacheProvider(workInProgress);\n                            bubbleProperties(workInProgress);\n                        }\n                        return null;\n                    }\n                case TracingMarkerComponent:\n                    {\n                        return null;\n                    }\n            }\n            throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n        }\n        function unwindWork(current, workInProgress, renderLanes) {\n            // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(workInProgress);\n            switch(workInProgress.tag){\n                case ClassComponent:\n                    {\n                        var flags = workInProgress.flags;\n                        if (flags & ShouldCapture) {\n                            workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case HostRoot:\n                    {\n                        {\n                            popCacheProvider(workInProgress);\n                        }\n                        popHostContainer(workInProgress);\n                        var _flags = workInProgress.flags;\n                        if ((_flags & ShouldCapture) !== NoFlags$1 && (_flags & DidCapture) === NoFlags$1) {\n                            // There was an error during render that wasn't captured by a suspense\n                            // boundary. Do a second pass on the root to unmount the children.\n                            workInProgress.flags = _flags & ~ShouldCapture | DidCapture;\n                            return workInProgress;\n                        } // We unwound to the root without completing it. Exit.\n                        return null;\n                    }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        // TODO: popHydrationState\n                        popHostContext(workInProgress);\n                        return null;\n                    }\n                case SuspenseComponent:\n                    {\n                        popSuspenseHandler(workInProgress);\n                        var suspenseState = workInProgress.memoizedState;\n                        if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                            if (workInProgress.alternate === null) {\n                                throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in ' + 'React. Please file an issue.');\n                            }\n                            resetHydrationState();\n                        }\n                        var _flags2 = workInProgress.flags;\n                        if (_flags2 & ShouldCapture) {\n                            workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case SuspenseListComponent:\n                    {\n                        popSuspenseListContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been\n                        // caught by a nested boundary. If not, it should bubble through.\n                        return null;\n                    }\n                case HostPortal:\n                    popHostContainer(workInProgress);\n                    return null;\n                case ContextProvider:\n                    var context;\n                    {\n                        context = workInProgress.type;\n                    }\n                    popProvider(context, workInProgress);\n                    return null;\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        popSuspenseHandler(workInProgress);\n                        popHiddenContext(workInProgress);\n                        popTransition(workInProgress, current);\n                        var _flags3 = workInProgress.flags;\n                        if (_flags3 & ShouldCapture) {\n                            workInProgress.flags = _flags3 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case CacheComponent:\n                    {\n                        popCacheProvider(workInProgress);\n                    }\n                    return null;\n                case TracingMarkerComponent:\n                    return null;\n                default:\n                    return null;\n            }\n        }\n        function unwindInterruptedWork(current, interruptedWork, renderLanes) {\n            // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(interruptedWork);\n            switch(interruptedWork.tag){\n                case ClassComponent:\n                    {\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        {\n                            popCacheProvider(interruptedWork);\n                        }\n                        popHostContainer(interruptedWork);\n                        break;\n                    }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        popHostContext(interruptedWork);\n                        break;\n                    }\n                case HostPortal:\n                    popHostContainer(interruptedWork);\n                    break;\n                case SuspenseComponent:\n                    popSuspenseHandler(interruptedWork);\n                    break;\n                case SuspenseListComponent:\n                    popSuspenseListContext(interruptedWork);\n                    break;\n                case ContextProvider:\n                    var context;\n                    {\n                        context = interruptedWork.type;\n                    }\n                    popProvider(context, interruptedWork);\n                    break;\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    popSuspenseHandler(interruptedWork);\n                    popHiddenContext(interruptedWork);\n                    popTransition(interruptedWork, current);\n                    break;\n                case CacheComponent:\n                    {\n                        popCacheProvider(interruptedWork);\n                    }\n                    break;\n            }\n        }\n        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n        {\n            didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n        }\n        // Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n        var offscreenSubtreeIsHidden = false;\n        var offscreenSubtreeWasHidden = false; // Used to track if a form needs to be reset at the end of the mutation phase.\n        var needsFormReset = false;\n        var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\n        var nextEffect = null; // Used for Profiling builds to track updaters.\n        var inProgressLanes = null;\n        var inProgressRoot = null;\n        function shouldProfile(current) {\n            return (current.mode & ProfileMode) !== NoMode && (getExecutionContext() & CommitContext) !== NoContext;\n        }\n        function callComponentWillUnmountWithTimer(current, instance) {\n            instance.props = resolveClassComponentProps(current.type, current.memoizedProps);\n            instance.state = current.memoizedState;\n            if (shouldProfile(current)) {\n                try {\n                    startLayoutEffectTimer();\n                    instance.componentWillUnmount();\n                } finally{\n                    recordLayoutEffectDuration(current);\n                }\n            } else {\n                instance.componentWillUnmount();\n            }\n        } // Capture errors so they don't interrupt unmounting.\n        function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n            try {\n                callComponentWillUnmountWithTimer(current, instance);\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        } // Capture errors so they don't interrupt mounting.\n        function safelyAttachRef(current, nearestMountedAncestor) {\n            try {\n                commitAttachRef(current);\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n        function safelyDetachRef(current, nearestMountedAncestor) {\n            var ref = current.ref;\n            var refCleanup = current.refCleanup;\n            if (ref !== null) {\n                if (typeof refCleanup === 'function') {\n                    try {\n                        if (shouldProfile(current)) {\n                            try {\n                                startLayoutEffectTimer();\n                                refCleanup();\n                            } finally{\n                                recordLayoutEffectDuration(current);\n                            }\n                        } else {\n                            refCleanup();\n                        }\n                    } catch (error) {\n                        captureCommitPhaseError(current, nearestMountedAncestor, error);\n                    } finally{\n                        // `refCleanup` has been called. Nullify all references to it to prevent double invocation.\n                        current.refCleanup = null;\n                        var finishedWork = current.alternate;\n                        if (finishedWork != null) {\n                            finishedWork.refCleanup = null;\n                        }\n                    }\n                } else if (typeof ref === 'function') {\n                    try {\n                        if (shouldProfile(current)) {\n                            try {\n                                startLayoutEffectTimer();\n                                ref(null);\n                            } finally{\n                                recordLayoutEffectDuration(current);\n                            }\n                        } else {\n                            ref(null);\n                        }\n                    } catch (error) {\n                        captureCommitPhaseError(current, nearestMountedAncestor, error);\n                    }\n                } else {\n                    // $FlowFixMe[incompatible-use] unable to narrow type to RefObject\n                    ref.current = null;\n                }\n            }\n        }\n        function safelyCallDestroy(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n        var shouldFireAfterActiveInstanceBlur = false;\n        function commitBeforeMutationEffects(root, firstChild) {\n            prepareForCommit(root.containerInfo);\n            nextEffect = firstChild;\n            commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber\n            var shouldFire = shouldFireAfterActiveInstanceBlur;\n            shouldFireAfterActiveInstanceBlur = false;\n            return shouldFire;\n        }\n        function commitBeforeMutationEffects_begin() {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.\n                var child = fiber.child;\n                if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags$1 && child !== null) {\n                    child.return = fiber;\n                    nextEffect = child;\n                } else {\n                    commitBeforeMutationEffects_complete();\n                }\n            }\n        }\n        function commitBeforeMutationEffects_complete() {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                setCurrentDebugFiberInDEV(fiber);\n                try {\n                    commitBeforeMutationEffectsOnFiber(fiber);\n                } catch (error) {\n                    captureCommitPhaseError(fiber, fiber.return, error);\n                }\n                resetCurrentDebugFiberInDEV();\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    sibling.return = fiber.return;\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitBeforeMutationEffectsOnFiber(finishedWork) {\n            var current = finishedWork.alternate;\n            var flags = finishedWork.flags;\n            if ((flags & Snapshot) !== NoFlags$1) {\n                setCurrentDebugFiberInDEV(finishedWork);\n            }\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                    {\n                        break;\n                    }\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        if ((flags & Snapshot) !== NoFlags$1) {\n                            if (current !== null) {\n                                var prevProps = current.memoizedProps;\n                                var prevState = current.memoizedState;\n                                var instance = finishedWork.stateNode; // We could update instance props and state here,\n                                // but instead we rely on them being set during last render.\n                                // TODO: revisit this when we implement resuming.\n                                {\n                                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                                        if (instance.props !== finishedWork.memoizedProps) {\n                                            error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                                        }\n                                        if (instance.state !== finishedWork.memoizedState) {\n                                            error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                                        }\n                                    }\n                                }\n                                var snapshot = instance.getSnapshotBeforeUpdate(resolveClassComponentProps(finishedWork.type, prevProps), prevState);\n                                {\n                                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n                                    if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                                        didWarnSet.add(finishedWork.type);\n                                        error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentNameFromFiber(finishedWork));\n                                    }\n                                }\n                                instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n                            }\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        if ((flags & Snapshot) !== NoFlags$1) {\n                            if (supportsMutation) {\n                                var root = finishedWork.stateNode;\n                                clearContainer(root.containerInfo);\n                            }\n                        }\n                        break;\n                    }\n                case HostComponent:\n                case HostHoistable:\n                case HostSingleton:\n                case HostText:\n                case HostPortal:\n                case IncompleteClassComponent:\n                    break;\n                default:\n                    {\n                        if ((flags & Snapshot) !== NoFlags$1) {\n                            throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n                        }\n                    }\n            }\n            if ((flags & Snapshot) !== NoFlags$1) {\n                resetCurrentDebugFiberInDEV();\n            }\n        }\n        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n            var updateQueue = finishedWork.updateQueue;\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n            if (lastEffect !== null) {\n                var firstEffect = lastEffect.next;\n                var effect = firstEffect;\n                do {\n                    if ((effect.tag & flags) === flags) {\n                        // Unmount\n                        var inst = effect.inst;\n                        var destroy = inst.destroy;\n                        if (destroy !== undefined) {\n                            inst.destroy = undefined;\n                            {\n                                if ((flags & Passive) !== NoFlags) {\n                                    markComponentPassiveEffectUnmountStarted(finishedWork);\n                                } else if ((flags & Layout) !== NoFlags) {\n                                    markComponentLayoutEffectUnmountStarted(finishedWork);\n                                }\n                            }\n                            {\n                                if ((flags & Insertion) !== NoFlags) {\n                                    setIsRunningInsertionEffect(true);\n                                }\n                            }\n                            safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n                            {\n                                if ((flags & Insertion) !== NoFlags) {\n                                    setIsRunningInsertionEffect(false);\n                                }\n                            }\n                            {\n                                if ((flags & Passive) !== NoFlags) {\n                                    markComponentPassiveEffectUnmountStopped();\n                                } else if ((flags & Layout) !== NoFlags) {\n                                    markComponentLayoutEffectUnmountStopped();\n                                }\n                            }\n                        }\n                    }\n                    effect = effect.next;\n                }while (effect !== firstEffect);\n            }\n        }\n        function commitHookEffectListMount(flags, finishedWork) {\n            var updateQueue = finishedWork.updateQueue;\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n            if (lastEffect !== null) {\n                var firstEffect = lastEffect.next;\n                var effect = firstEffect;\n                do {\n                    if ((effect.tag & flags) === flags) {\n                        {\n                            if ((flags & Passive) !== NoFlags) {\n                                markComponentPassiveEffectMountStarted(finishedWork);\n                            } else if ((flags & Layout) !== NoFlags) {\n                                markComponentLayoutEffectMountStarted(finishedWork);\n                            }\n                        }\n                        var create = effect.create;\n                        {\n                            if ((flags & Insertion) !== NoFlags) {\n                                setIsRunningInsertionEffect(true);\n                            }\n                        }\n                        var inst = effect.inst;\n                        var destroy = create();\n                        inst.destroy = destroy;\n                        {\n                            if ((flags & Insertion) !== NoFlags) {\n                                setIsRunningInsertionEffect(false);\n                            }\n                        }\n                        {\n                            if ((flags & Passive) !== NoFlags) {\n                                markComponentPassiveEffectMountStopped();\n                            } else if ((flags & Layout) !== NoFlags) {\n                                markComponentLayoutEffectMountStopped();\n                            }\n                        }\n                        {\n                            if (destroy !== undefined && typeof destroy !== 'function') {\n                                var hookName = void 0;\n                                if ((effect.tag & Layout) !== NoFlags$1) {\n                                    hookName = 'useLayoutEffect';\n                                } else if ((effect.tag & Insertion) !== NoFlags$1) {\n                                    hookName = 'useInsertionEffect';\n                                } else {\n                                    hookName = 'useEffect';\n                                }\n                                var addendum = void 0;\n                                if (destroy === null) {\n                                    addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';\n                                } else if (typeof destroy.then === 'function') {\n                                    addendum = '\\n\\nIt looks like you wrote ' + hookName + '(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\\n\\n' + hookName + '(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + 'Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching';\n                                } else {\n                                    addendum = ' You returned: ' + destroy;\n                                }\n                                error('%s must not return anything besides a function, ' + 'which is used for clean-up.%s', hookName, addendum);\n                            }\n                        }\n                    }\n                    effect = effect.next;\n                }while (effect !== firstEffect);\n            }\n        }\n        function commitPassiveEffectDurations(finishedRoot, finishedWork) {\n            if (getExecutionContext() & CommitContext) {\n                // Only Profilers with work in their subtree will have an Update effect scheduled.\n                if ((finishedWork.flags & Update) !== NoFlags$1) {\n                    switch(finishedWork.tag){\n                        case Profiler:\n                            {\n                                var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;\n                                var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit; // This value will still reflect the previous commit phase.\n                                // It does not get reset until the start of the next commit phase.\n                                var commitTime = getCommitTime();\n                                var phase = finishedWork.alternate === null ? 'mount' : 'update';\n                                {\n                                    if (isCurrentUpdateNested()) {\n                                        phase = 'nested-update';\n                                    }\n                                }\n                                if (typeof onPostCommit === 'function') {\n                                    onPostCommit(id, phase, passiveEffectDuration, commitTime);\n                                } // Bubble times to the next nearest ancestor Profiler.\n                                // After we process that Profiler, we'll bubble further up.\n                                var parentFiber = finishedWork.return;\n                                outer: while(parentFiber !== null){\n                                    switch(parentFiber.tag){\n                                        case HostRoot:\n                                            var root = parentFiber.stateNode;\n                                            root.passiveEffectDuration += passiveEffectDuration;\n                                            break outer;\n                                        case Profiler:\n                                            var parentStateNode = parentFiber.stateNode;\n                                            parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                                            break outer;\n                                    }\n                                    parentFiber = parentFiber.return;\n                                }\n                                break;\n                            }\n                    }\n                }\n            }\n        }\n        function commitHookLayoutEffects(finishedWork, hookFlags) {\n            // At this point layout effects have already been destroyed (during mutation phase).\n            // This is done to prevent sibling component effects from interfering with each other,\n            // e.g. a destroy function in one component should never override a ref set\n            // by a create function in another component during the same commit.\n            if (shouldProfile(finishedWork)) {\n                try {\n                    startLayoutEffectTimer();\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n                recordLayoutEffectDuration(finishedWork);\n            } else {\n                try {\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitClassLayoutLifecycles(finishedWork, current) {\n            var instance = finishedWork.stateNode;\n            if (current === null) {\n                // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                {\n                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                        if (instance.props !== finishedWork.memoizedProps) {\n                            error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                        if (instance.state !== finishedWork.memoizedState) {\n                            error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                    }\n                }\n                if (shouldProfile(finishedWork)) {\n                    try {\n                        startLayoutEffectTimer();\n                        instance.componentDidMount();\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    recordLayoutEffectDuration(finishedWork);\n                } else {\n                    try {\n                        instance.componentDidMount();\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n            } else {\n                var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);\n                var prevState = current.memoizedState; // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                {\n                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                        if (instance.props !== finishedWork.memoizedProps) {\n                            error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                        if (instance.state !== finishedWork.memoizedState) {\n                            error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                    }\n                }\n                if (shouldProfile(finishedWork)) {\n                    try {\n                        startLayoutEffectTimer();\n                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    recordLayoutEffectDuration(finishedWork);\n                } else {\n                    try {\n                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n            }\n        }\n        function commitClassCallbacks(finishedWork) {\n            // TODO: I think this is now always non-null by the time it reaches the\n            // commit phase. Consider removing the type check.\n            var updateQueue = finishedWork.updateQueue;\n            if (updateQueue !== null) {\n                var instance = finishedWork.stateNode;\n                {\n                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                        if (instance.props !== finishedWork.memoizedProps) {\n                            error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                        if (instance.state !== finishedWork.memoizedState) {\n                            error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                    }\n                }\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                try {\n                    commitCallbacks(updateQueue, instance);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitHostComponentMount(finishedWork) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            var instance = finishedWork.stateNode;\n            try {\n                commitMount(instance, type, props, finishedWork);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n        function commitProfilerUpdate(finishedWork, current) {\n            if (getExecutionContext() & CommitContext) {\n                try {\n                    var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;\n                    var effectDuration = finishedWork.stateNode.effectDuration;\n                    var commitTime = getCommitTime();\n                    var phase = current === null ? 'mount' : 'update';\n                    if (enableProfilerNestedUpdatePhase) {\n                        if (isCurrentUpdateNested()) {\n                            phase = 'nested-update';\n                        }\n                    }\n                    if (typeof onRender === 'function') {\n                        onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);\n                    }\n                    if (enableProfilerCommitHooks) {\n                        if (typeof onCommit === 'function') {\n                            onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);\n                        } // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n                        // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n                        // because the effect is also where times bubble to parent Profilers.\n                        enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.\n                        // Do not reset these values until the next render so DevTools has a chance to read them first.\n                        var parentFiber = finishedWork.return;\n                        outer: while(parentFiber !== null){\n                            switch(parentFiber.tag){\n                                case HostRoot:\n                                    var root = parentFiber.stateNode;\n                                    root.effectDuration += effectDuration;\n                                    break outer;\n                                case Profiler:\n                                    var parentStateNode = parentFiber.stateNode;\n                                    parentStateNode.effectDuration += effectDuration;\n                                    break outer;\n                            }\n                            parentFiber = parentFiber.return;\n                        }\n                    }\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n            // When updating this function, also update reappearLayoutEffects, which does\n            // most of the same things when an offscreen tree goes from hidden -> visible.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        if (flags & Update) {\n                            commitHookLayoutEffects(finishedWork, Layout | HasEffect);\n                        }\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        if (flags & Update) {\n                            commitClassLayoutLifecycles(finishedWork, current);\n                        }\n                        if (flags & Callback) {\n                            commitClassCallbacks(finishedWork);\n                        }\n                        if (flags & Ref) {\n                            safelyAttachRef(finishedWork, finishedWork.return);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        if (flags & Callback) {\n                            // TODO: I think this is now always non-null by the time it reaches the\n                            // commit phase. Consider removing the type check.\n                            var updateQueue = finishedWork.updateQueue;\n                            if (updateQueue !== null) {\n                                var instance = null;\n                                if (finishedWork.child !== null) {\n                                    switch(finishedWork.child.tag){\n                                        case HostSingleton:\n                                        case HostComponent:\n                                            instance = getPublicInstance(finishedWork.child.stateNode);\n                                            break;\n                                        case ClassComponent:\n                                            instance = finishedWork.child.stateNode;\n                                            break;\n                                    }\n                                }\n                                try {\n                                    commitCallbacks(updateQueue, instance);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                            if (flags & Ref) {\n                                safelyAttachRef(finishedWork, finishedWork.return);\n                            }\n                            break;\n                        } // Fall through\n                    }\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork); // Renderers may schedule work to be done after host components are mounted\n                        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n                        // These effects should only be committed when components are first mounted,\n                        // aka when there is no current/alternate.\n                        if (current === null && flags & Update) {\n                            commitHostComponentMount(finishedWork);\n                        }\n                        if (flags & Ref) {\n                            safelyAttachRef(finishedWork, finishedWork.return);\n                        }\n                        break;\n                    }\n                case Profiler:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork); // TODO: Should this fire inside an offscreen tree? Or should it wait to\n                        // fire when the tree becomes visible again.\n                        if (flags & Update) {\n                            commitProfilerUpdate(finishedWork, current);\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        if (flags & Update) {\n                            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var isModernRoot = disableLegacyMode;\n                        if (isModernRoot) {\n                            var isHidden = finishedWork.memoizedState !== null;\n                            var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n                            if (newOffscreenSubtreeIsHidden) ;\n                            else {\n                                // The Offscreen tree is visible.\n                                var wasHidden = current !== null && current.memoizedState !== null;\n                                var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n                                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n                                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                                offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n                                offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n                                if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n                                    // This is the root of a reappearing boundary. As we continue\n                                    // traversing the layout effects, we must also re-mount layout\n                                    // effects that were unmounted when the Offscreen subtree was\n                                    // hidden. So this is a superset of the normal commitLayoutEffects.\n                                    var includeWorkInProgressEffects = (finishedWork.subtreeFlags & LayoutMask) !== NoFlags$1;\n                                    recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                                } else {\n                                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                                }\n                                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                            }\n                        } else {\n                            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        }\n                        if (flags & Ref) {\n                            var props = finishedWork.memoizedProps;\n                            if (props.mode === 'manual') {\n                                safelyAttachRef(finishedWork, finishedWork.return);\n                            } else {\n                                safelyDetachRef(finishedWork, finishedWork.return);\n                            }\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        break;\n                    }\n            }\n        }\n        function hideOrUnhideAllChildren(finishedWork, isHidden) {\n            // Only hide or unhide the top-most host nodes.\n            var hostSubtreeRoot = null;\n            if (supportsMutation) {\n                // We only have the top Fiber that was inserted but we need to recurse down its\n                // children to find all the terminal nodes.\n                var node = finishedWork;\n                while(true){\n                    if (node.tag === HostComponent || (supportsResources ? node.tag === HostHoistable : false) || (supportsSingletons ? node.tag === HostSingleton : false)) {\n                        if (hostSubtreeRoot === null) {\n                            hostSubtreeRoot = node;\n                            try {\n                                var instance = node.stateNode;\n                                if (isHidden) {\n                                    hideInstance(instance);\n                                } else {\n                                    unhideInstance(node.stateNode, node.memoizedProps);\n                                }\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        }\n                    } else if (node.tag === HostText) {\n                        if (hostSubtreeRoot === null) {\n                            try {\n                                var _instance = node.stateNode;\n                                if (isHidden) {\n                                    hideTextInstance(_instance);\n                                } else {\n                                    unhideTextInstance(_instance, node.memoizedProps);\n                                }\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        }\n                    } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;\n                    else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === finishedWork) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === finishedWork) {\n                            return;\n                        }\n                        if (hostSubtreeRoot === node) {\n                            hostSubtreeRoot = null;\n                        }\n                        node = node.return;\n                    }\n                    if (hostSubtreeRoot === node) {\n                        hostSubtreeRoot = null;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n        }\n        function commitAttachRef(finishedWork) {\n            var ref = finishedWork.ref;\n            if (ref !== null) {\n                var instance = finishedWork.stateNode;\n                var instanceToUse;\n                switch(finishedWork.tag){\n                    case HostHoistable:\n                    case HostSingleton:\n                    case HostComponent:\n                        instanceToUse = getPublicInstance(instance);\n                        break;\n                    default:\n                        instanceToUse = instance;\n                } // Moved outside to ensure DCE works with this flag\n                if (typeof ref === 'function') {\n                    if (shouldProfile(finishedWork)) {\n                        try {\n                            startLayoutEffectTimer();\n                            finishedWork.refCleanup = ref(instanceToUse);\n                        } finally{\n                            recordLayoutEffectDuration(finishedWork);\n                        }\n                    } else {\n                        finishedWork.refCleanup = ref(instanceToUse);\n                    }\n                } else {\n                    {\n                        // TODO: We should move these warnings to happen during the render\n                        // phase (markRef).\n                        if (typeof ref === 'string') {\n                            error('String refs are no longer supported.');\n                        } else if (!ref.hasOwnProperty('current')) {\n                            error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentNameFromFiber(finishedWork));\n                        }\n                    }\n                    ref.current = instanceToUse;\n                }\n            }\n        }\n        function detachFiberMutation(fiber) {\n            // Cut off the return pointer to disconnect it from the tree.\n            // This enables us to detect and warn against state updates on an unmounted component.\n            // It also prevents events from bubbling from within disconnected components.\n            //\n            // Ideally, we should also clear the child pointer of the parent alternate to let this\n            // get GC:ed but we don't know which for sure which parent is the current\n            // one so we'll settle for GC:ing the subtree of this child.\n            // This child itself will be GC:ed when the parent updates the next time.\n            //\n            // Note that we can't clear child or sibling pointers yet.\n            // They're needed for passive effects and for findDOMNode.\n            // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n            //\n            // Don't reset the alternate yet, either. We need that so we can detach the\n            // alternate's fields in the passive phase. Clearing the return pointer is\n            // sufficient for findDOMNode semantics.\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.return = null;\n            }\n            fiber.return = null;\n        }\n        function detachFiberAfterEffects(fiber) {\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                fiber.alternate = null;\n                detachFiberAfterEffects(alternate);\n            } // Clear cyclical Fiber fields. This level alone is designed to roughly\n            // approximate the planned Fiber refactor. In that world, `setState` will be\n            // bound to a special \"instance\" object instead of a Fiber. The Instance\n            // object will not have any of these fields. It will only be connected to\n            // the fiber tree via a single link at the root. So if this level alone is\n            // sufficient to fix memory issues, that bodes well for our plans.\n            fiber.child = null;\n            fiber.deletions = null;\n            fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host\n            // tree, which has its own pointers to children, parents, and siblings.\n            // The other host nodes also point back to fibers, so we should detach that\n            // one, too.\n            if (fiber.tag === HostComponent) {\n                var hostInstance = fiber.stateNode;\n                if (hostInstance !== null) {\n                    detachDeletedInstance(hostInstance);\n                }\n            }\n            fiber.stateNode = null;\n            {\n                fiber._debugOwner = null;\n            }\n            // disconnected the fiber from the tree. So even if something leaks this\n            // particular fiber, it won't leak anything else.\n            fiber.return = null;\n            fiber.dependencies = null;\n            fiber.memoizedProps = null;\n            fiber.memoizedState = null;\n            fiber.pendingProps = null;\n            fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n            fiber.updateQueue = null;\n        }\n        function emptyPortalContainer(current) {\n            if (!supportsPersistence) {\n                return;\n            }\n            var portal = current.stateNode;\n            var containerInfo = portal.containerInfo;\n            var emptyChildSet = createContainerChildSet();\n            replaceContainerChildren(containerInfo, emptyChildSet);\n        }\n        function getHostParentFiber(fiber) {\n            var parent = fiber.return;\n            while(parent !== null){\n                if (isHostParent(parent)) {\n                    return parent;\n                }\n                parent = parent.return;\n            }\n            throw new Error('Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n        }\n        function isHostParent(fiber) {\n            return fiber.tag === HostComponent || fiber.tag === HostRoot || (supportsResources ? fiber.tag === HostHoistable : false) || (supportsSingletons ? fiber.tag === HostSingleton : false) || fiber.tag === HostPortal;\n        }\n        function getHostSibling(fiber) {\n            // We're going to search forward into the tree until we find a sibling host\n            // node. Unfortunately, if multiple insertions are done in a row we have to\n            // search past them. This leads to exponential search for the next sibling.\n            // TODO: Find a more efficient way to do this.\n            var node = fiber;\n            siblings: while(true){\n                // If we didn't find anything, let's try the next sibling.\n                while(node.sibling === null){\n                    if (node.return === null || isHostParent(node.return)) {\n                        // If we pop out of the root or hit the parent the fiber we are the\n                        // last sibling.\n                        return null;\n                    } // $FlowFixMe[incompatible-type] found when upgrading Flow\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n                while(node.tag !== HostComponent && node.tag !== HostText && (!supportsSingletons ? true : node.tag !== HostSingleton) && node.tag !== DehydratedFragment){\n                    // If it is not host node and, we might have a host node inside it.\n                    // Try to search down until we find one.\n                    if (node.flags & Placement) {\n                        continue siblings;\n                    } // If we don't have a child, try the siblings instead.\n                    // We also skip portals because they are not part of this host tree.\n                    if (node.child === null || node.tag === HostPortal) {\n                        continue siblings;\n                    } else {\n                        node.child.return = node;\n                        node = node.child;\n                    }\n                } // Check if this host node is stable or about to be placed.\n                if (!(node.flags & Placement)) {\n                    // Found it!\n                    return node.stateNode;\n                }\n            }\n        }\n        function commitPlacement(finishedWork) {\n            if (!supportsMutation) {\n                return;\n            }\n            if (supportsSingletons) {\n                if (finishedWork.tag === HostSingleton) {\n                    // Singletons are already in the Host and don't need to be placed\n                    // Since they operate somewhat like Portals though their children will\n                    // have Placement and will get placed inside them\n                    return;\n                }\n            } // Recursively insert all host nodes into the parent.\n            var parentFiber = getHostParentFiber(finishedWork);\n            switch(parentFiber.tag){\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            var parent = parentFiber.stateNode;\n                            var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n                            // children to find all the terminal nodes.\n                            insertOrAppendPlacementNode(finishedWork, before, parent);\n                            break;\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        var _parent = parentFiber.stateNode;\n                        if (parentFiber.flags & ContentReset) {\n                            // Reset the text content of the parent before doing any insertions\n                            resetTextContent(_parent); // Clear ContentReset from the effect tag\n                            parentFiber.flags &= ~ContentReset;\n                        }\n                        var _before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n                        // children to find all the terminal nodes.\n                        insertOrAppendPlacementNode(finishedWork, _before, _parent);\n                        break;\n                    }\n                case HostRoot:\n                case HostPortal:\n                    {\n                        var _parent2 = parentFiber.stateNode.containerInfo;\n                        var _before2 = getHostSibling(finishedWork);\n                        insertOrAppendPlacementNodeIntoContainer(finishedWork, _before2, _parent2);\n                        break;\n                    }\n                default:\n                    throw new Error('Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n            }\n        }\n        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n            var tag = node.tag;\n            var isHost = tag === HostComponent || tag === HostText;\n            if (isHost) {\n                var stateNode = node.stateNode;\n                if (before) {\n                    insertInContainerBefore(parent, stateNode, before);\n                } else {\n                    appendChildToContainer(parent, stateNode);\n                }\n            } else if (tag === HostPortal || (supportsSingletons ? tag === HostSingleton : false)) ;\n            else {\n                var child = node.child;\n                if (child !== null) {\n                    insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n                    var sibling = child.sibling;\n                    while(sibling !== null){\n                        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n                        sibling = sibling.sibling;\n                    }\n                }\n            }\n        }\n        function insertOrAppendPlacementNode(node, before, parent) {\n            var tag = node.tag;\n            var isHost = tag === HostComponent || tag === HostText;\n            if (isHost) {\n                var stateNode = node.stateNode;\n                if (before) {\n                    insertBefore(parent, stateNode, before);\n                } else {\n                    appendChild(parent, stateNode);\n                }\n            } else if (tag === HostPortal || (supportsSingletons ? tag === HostSingleton : false)) ;\n            else {\n                var child = node.child;\n                if (child !== null) {\n                    insertOrAppendPlacementNode(child, before, parent);\n                    var sibling = child.sibling;\n                    while(sibling !== null){\n                        insertOrAppendPlacementNode(sibling, before, parent);\n                        sibling = sibling.sibling;\n                    }\n                }\n            }\n        } // These are tracked on the stack as we recursively traverse a\n        // deleted subtree.\n        // TODO: Update these during the whole mutation phase, not just during\n        // a deletion.\n        var hostParent = null;\n        var hostParentIsContainer = false;\n        function commitDeletionEffects(root, returnFiber, deletedFiber) {\n            if (supportsMutation) {\n                // We only have the top Fiber that was deleted but we need to recurse down its\n                // children to find all the terminal nodes.\n                // Recursively delete all host nodes from the parent, detach refs, clean\n                // up mounted layout effects, and call componentWillUnmount.\n                // We only need to remove the topmost host child in each branch. But then we\n                // still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n                // could split this into two separate traversals functions, where the second\n                // one doesn't include any removeChild logic. This is maybe the same\n                // function as \"disappearLayoutEffects\" (or whatever that turns into after\n                // the layout phase is refactored to use recursion).\n                // Before starting, find the nearest host parent on the stack so we know\n                // which instance/container to remove the children from.\n                // TODO: Instead of searching up the fiber return path on every deletion, we\n                // can track the nearest host component on the JS stack as we traverse the\n                // tree during the commit phase. This would make insertions faster, too.\n                var parent = returnFiber;\n                findParent: while(parent !== null){\n                    switch(parent.tag){\n                        case HostSingleton:\n                        case HostComponent:\n                            {\n                                hostParent = parent.stateNode;\n                                hostParentIsContainer = false;\n                                break findParent;\n                            }\n                        case HostRoot:\n                            {\n                                hostParent = parent.stateNode.containerInfo;\n                                hostParentIsContainer = true;\n                                break findParent;\n                            }\n                        case HostPortal:\n                            {\n                                hostParent = parent.stateNode.containerInfo;\n                                hostParentIsContainer = true;\n                                break findParent;\n                            }\n                    }\n                    parent = parent.return;\n                }\n                if (hostParent === null) {\n                    throw new Error('Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n                }\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n                hostParent = null;\n                hostParentIsContainer = false;\n            } else {\n                // Detach refs and call componentWillUnmount() on the whole subtree.\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n            }\n            detachFiberMutation(deletedFiber);\n        }\n        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n            // TODO: Use a static flag to skip trees that don't have unmount effects\n            var child = parent.child;\n            while(child !== null){\n                commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);\n                child = child.sibling;\n            }\n        }\n        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n            onCommitUnmount(deletedFiber); // The cases in this outer switch modify the stack before they traverse\n            // into their subtree. There are simpler cases in the inner switch\n            // that don't modify the stack.\n            switch(deletedFiber.tag){\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            if (!offscreenSubtreeWasHidden) {\n                                safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                            }\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            if (deletedFiber.memoizedState) {\n                                releaseResource(deletedFiber.memoizedState);\n                            } else if (deletedFiber.stateNode) {\n                                unmountHoistable(deletedFiber.stateNode);\n                            }\n                            return;\n                        } // Fall through\n                    }\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            if (!offscreenSubtreeWasHidden) {\n                                safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                            }\n                            var prevHostParent = hostParent;\n                            var prevHostParentIsContainer = hostParentIsContainer;\n                            hostParent = deletedFiber.stateNode;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber); // Normally this is called in passive unmount effect phase however with\n                            // HostSingleton we warn if you acquire one that is already associated to\n                            // a different fiber. To increase our chances of avoiding this, specifically\n                            // if you keyed a HostSingleton so there will be a delete followed by a Placement\n                            // we treat detach eagerly here\n                            releaseSingletonInstance(deletedFiber.stateNode);\n                            hostParent = prevHostParent;\n                            hostParentIsContainer = prevHostParentIsContainer;\n                            return;\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        if (!offscreenSubtreeWasHidden) {\n                            safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                        } // Intentional fallthrough to next branch\n                    }\n                case HostText:\n                    {\n                        // We only need to remove the nearest host child. Set the host parent\n                        // to `null` on the stack to indicate that nested children don't\n                        // need to be removed.\n                        if (supportsMutation) {\n                            var _prevHostParent = hostParent;\n                            var _prevHostParentIsContainer = hostParentIsContainer;\n                            hostParent = null;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            hostParent = _prevHostParent;\n                            hostParentIsContainer = _prevHostParentIsContainer;\n                            if (hostParent !== null) {\n                                // Now that all the child effects have unmounted, we can remove the\n                                // node from the tree.\n                                if (hostParentIsContainer) {\n                                    removeChildFromContainer(hostParent, deletedFiber.stateNode);\n                                } else {\n                                    removeChild(hostParent, deletedFiber.stateNode);\n                                }\n                            }\n                        } else {\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        }\n                        return;\n                    }\n                case DehydratedFragment:\n                    {\n                        // Delete the dehydrated suspense boundary and all of its content.\n                        if (supportsMutation) {\n                            if (hostParent !== null) {\n                                if (hostParentIsContainer) {\n                                    clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);\n                                } else {\n                                    clearSuspenseBoundary(hostParent, deletedFiber.stateNode);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case HostPortal:\n                    {\n                        if (supportsMutation) {\n                            // When we go into a portal, it becomes the parent to remove from.\n                            var _prevHostParent2 = hostParent;\n                            var _prevHostParentIsContainer2 = hostParentIsContainer;\n                            hostParent = deletedFiber.stateNode.containerInfo;\n                            hostParentIsContainer = true;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            hostParent = _prevHostParent2;\n                            hostParentIsContainer = _prevHostParentIsContainer2;\n                        } else {\n                            emptyPortalContainer(deletedFiber);\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        }\n                        return;\n                    }\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        if (!offscreenSubtreeWasHidden) {\n                            var updateQueue = deletedFiber.updateQueue;\n                            if (updateQueue !== null) {\n                                var lastEffect = updateQueue.lastEffect;\n                                if (lastEffect !== null) {\n                                    var firstEffect = lastEffect.next;\n                                    var effect = firstEffect;\n                                    do {\n                                        var tag = effect.tag;\n                                        var inst = effect.inst;\n                                        var destroy = inst.destroy;\n                                        if (destroy !== undefined) {\n                                            if ((tag & Insertion) !== NoFlags) {\n                                                inst.destroy = undefined;\n                                                safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                                            } else if ((tag & Layout) !== NoFlags) {\n                                                {\n                                                    markComponentLayoutEffectUnmountStarted(deletedFiber);\n                                                }\n                                                if (shouldProfile(deletedFiber)) {\n                                                    startLayoutEffectTimer();\n                                                    inst.destroy = undefined;\n                                                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                                                    recordLayoutEffectDuration(deletedFiber);\n                                                } else {\n                                                    inst.destroy = undefined;\n                                                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                                                }\n                                                {\n                                                    markComponentLayoutEffectUnmountStopped();\n                                                }\n                                            }\n                                        }\n                                        effect = effect.next;\n                                    }while (effect !== firstEffect);\n                                }\n                            }\n                        }\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n                case ClassComponent:\n                    {\n                        if (!offscreenSubtreeWasHidden) {\n                            safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                            var instance = deletedFiber.stateNode;\n                            if (typeof instance.componentWillUnmount === 'function') {\n                                safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);\n                            }\n                        }\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n                case ScopeComponent:\n                    {\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n                case OffscreenComponent:\n                    {\n                        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                        {\n                            // If this offscreen component is hidden, we already unmounted it. Before\n                            // deleting the children, track that it's already unmounted so that we\n                            // don't attempt to unmount the effects again.\n                            // TODO: If the tree is hidden, in most cases we should be able to skip\n                            // over the nested children entirely. An exception is we haven't yet found\n                            // the topmost host node to delete, which we already track on the stack.\n                            // But the other case is portals, which need to be detached no matter how\n                            // deeply they are nested. We should use a subtree flag to track whether a\n                            // subtree includes a nested portal.\n                            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n            }\n        }\n        function commitSuspenseCallback(finishedWork) {}\n        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n            if (!supportsHydration) {\n                return;\n            }\n            var newState = finishedWork.memoizedState;\n            if (newState === null) {\n                var current = finishedWork.alternate;\n                if (current !== null) {\n                    var prevState = current.memoizedState;\n                    if (prevState !== null) {\n                        var suspenseInstance = prevState.dehydrated;\n                        if (suspenseInstance !== null) {\n                            try {\n                                commitHydratedSuspenseInstance(suspenseInstance);\n                                var hydrationCallbacks, onHydrated;\n                                if (enableSuspenseCallback) ;\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        function getRetryCache(finishedWork) {\n            // TODO: Unify the interface for the retry cache so we don't have to switch\n            // on the tag like this.\n            switch(finishedWork.tag){\n                case SuspenseComponent:\n                case SuspenseListComponent:\n                    {\n                        var retryCache = finishedWork.stateNode;\n                        if (retryCache === null) {\n                            retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n                        }\n                        return retryCache;\n                    }\n                case OffscreenComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        var _retryCache = instance._retryCache;\n                        if (_retryCache === null) {\n                            _retryCache = instance._retryCache = new PossiblyWeakSet();\n                        }\n                        return _retryCache;\n                    }\n                default:\n                    {\n                        throw new Error(\"Unexpected Suspense handler tag (\" + finishedWork.tag + \"). This is a \" + 'bug in React.');\n                    }\n            }\n        }\n        function detachOffscreenInstance(instance) {\n            var fiber = instance._current;\n            if (fiber === null) {\n                throw new Error('Calling Offscreen.detach before instance handle has been set.');\n            }\n            if ((instance._pendingVisibility & OffscreenDetached) !== NoFlags$1) {\n                // The instance is already detached, this is a noop.\n                return;\n            } // TODO: There is an opportunity to optimise this by not entering commit phase\n            // and unmounting effects directly.\n            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root !== null) {\n                instance._pendingVisibility |= OffscreenDetached;\n                scheduleUpdateOnFiber(root, fiber, SyncLane);\n            }\n        }\n        function attachOffscreenInstance(instance) {\n            var fiber = instance._current;\n            if (fiber === null) {\n                throw new Error('Calling Offscreen.detach before instance handle has been set.');\n            }\n            if ((instance._pendingVisibility & OffscreenDetached) === NoFlags$1) {\n                // The instance is already attached, this is a noop.\n                return;\n            }\n            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root !== null) {\n                instance._pendingVisibility &= ~OffscreenDetached;\n                scheduleUpdateOnFiber(root, fiber, SyncLane);\n            }\n        }\n        function attachSuspenseRetryListeners(finishedWork, wakeables) {\n            // If this boundary just timed out, then it will have a set of wakeables.\n            // For each wakeable, attach a listener so that when it resolves, React\n            // attempts to re-render the boundary in the primary (pre-timeout) state.\n            var retryCache = getRetryCache(finishedWork);\n            wakeables.forEach(function(wakeable) {\n                // Memoize using the boundary fiber to prevent redundant listeners.\n                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n                if (!retryCache.has(wakeable)) {\n                    retryCache.add(wakeable);\n                    {\n                        if (isDevToolsPresent) {\n                            if (inProgressLanes !== null && inProgressRoot !== null) {\n                                // If we have pending work still, associate the original updaters with it.\n                                restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                            } else {\n                                throw Error('Expected finished root and lanes to be set. This is a bug in React.');\n                            }\n                        }\n                    }\n                    wakeable.then(retry, retry);\n                }\n            });\n        } // This function detects when a Suspense boundary goes from visible to hidden.\n        function commitMutationEffects(root, finishedWork, committedLanes) {\n            inProgressLanes = committedLanes;\n            inProgressRoot = root;\n            setCurrentDebugFiberInDEV(finishedWork);\n            commitMutationEffectsOnFiber(finishedWork, root);\n            resetCurrentDebugFiberInDEV();\n            inProgressLanes = null;\n            inProgressRoot = null;\n        }\n        function recursivelyTraverseMutationEffects(root, parentFiber, lanes) {\n            // Deletions effects can be scheduled on any fiber type. They need to happen\n            // before the children effects hae fired.\n            var deletions = parentFiber.deletions;\n            if (deletions !== null) {\n                for(var i = 0; i < deletions.length; i++){\n                    var childToDelete = deletions[i];\n                    try {\n                        commitDeletionEffects(root, parentFiber, childToDelete);\n                    } catch (error) {\n                        captureCommitPhaseError(childToDelete, parentFiber, error);\n                    }\n                }\n            }\n            var prevDebugFiber = getCurrentFiber();\n            if (parentFiber.subtreeFlags & MutationMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    commitMutationEffectsOnFiber(child, root);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        var currentHoistableRoot = null;\n        function commitMutationEffectsOnFiber(finishedWork, root, lanes) {\n            var current = finishedWork.alternate;\n            var flags = finishedWork.flags; // The effect flag should be checked *after* we refine the type of fiber,\n            // because the fiber tag is more specific. An exception is any flag related\n            // to reconciliation, because those can be set on all fiber types.\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Update) {\n                            try {\n                                commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n                                commitHookEffectListMount(Insertion | HasEffect, finishedWork);\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            } // Layout effects are destroyed during the mutation phase so that all\n                            // destroy functions for all fibers are called before any create functions.\n                            // This prevents sibling component effects from interfering with each other,\n                            // e.g. a destroy function in one component should never override a ref set\n                            // by a create function in another component during the same commit.\n                            if (shouldProfile(finishedWork)) {\n                                try {\n                                    startLayoutEffectTimer();\n                                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                                recordLayoutEffectDuration(finishedWork);\n                            } else {\n                                try {\n                                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case ClassComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Ref) {\n                            if (current !== null) {\n                                safelyDetachRef(current, current.return);\n                            }\n                        }\n                        if (flags & Callback && offscreenSubtreeIsHidden) {\n                            var updateQueue = finishedWork.updateQueue;\n                            if (updateQueue !== null) {\n                                deferHiddenCallbacks(updateQueue);\n                            }\n                        }\n                        return;\n                    }\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            // We cast because we always set the root at the React root and so it cannot be\n                            // null while we are processing mutation effects\n                            var hoistableRoot = currentHoistableRoot;\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            commitReconciliationEffects(finishedWork);\n                            if (flags & Ref) {\n                                if (current !== null) {\n                                    safelyDetachRef(current, current.return);\n                                }\n                            }\n                            if (flags & Update) {\n                                var currentResource = current !== null ? current.memoizedState : null;\n                                var newResource = finishedWork.memoizedState;\n                                if (current === null) {\n                                    // We are mounting a new HostHoistable Fiber. We fork the mount\n                                    // behavior based on whether this instance is a Hoistable Instance\n                                    // or a Hoistable Resource\n                                    if (newResource === null) {\n                                        if (finishedWork.stateNode === null) {\n                                            finishedWork.stateNode = hydrateHoistable(hoistableRoot, finishedWork.type, finishedWork.memoizedProps, finishedWork);\n                                        } else {\n                                            mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);\n                                        }\n                                    } else {\n                                        finishedWork.stateNode = acquireResource(hoistableRoot, newResource, finishedWork.memoizedProps);\n                                    }\n                                } else if (currentResource !== newResource) {\n                                    // We are moving to or from Hoistable Resource, or between different Hoistable Resources\n                                    if (currentResource === null) {\n                                        if (current.stateNode !== null) {\n                                            unmountHoistable(current.stateNode);\n                                        }\n                                    } else {\n                                        releaseResource(currentResource);\n                                    }\n                                    if (newResource === null) {\n                                        mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);\n                                    } else {\n                                        acquireResource(hoistableRoot, newResource, finishedWork.memoizedProps);\n                                    }\n                                } else if (newResource === null && finishedWork.stateNode !== null) {\n                                    try {\n                                        commitUpdate(finishedWork.stateNode, finishedWork.type, current.memoizedProps, finishedWork.memoizedProps, finishedWork);\n                                    } catch (error) {\n                                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                    }\n                                }\n                            }\n                            return;\n                        } // Fall through\n                    }\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            if (flags & Update) {\n                                var previousWork = finishedWork.alternate;\n                                if (previousWork === null) {\n                                    var singleton = finishedWork.stateNode;\n                                    var props = finishedWork.memoizedProps; // This was a new mount, we need to clear and set initial properties\n                                    clearSingleton(singleton);\n                                    acquireSingletonInstance(finishedWork.type, props, singleton, finishedWork);\n                                }\n                            }\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Ref) {\n                            if (current !== null) {\n                                safelyDetachRef(current, current.return);\n                            }\n                        }\n                        if (supportsMutation) {\n                            // TODO: ContentReset gets cleared by the children during the commit\n                            // phase. This is a refactor hazard because it means we must read\n                            // flags the flags after `commitReconciliationEffects` has already run;\n                            // the order matters. We should refactor so that ContentReset does not\n                            // rely on mutating the flag during commit. Like by setting a flag\n                            // during the render phase instead.\n                            if (finishedWork.flags & ContentReset) {\n                                var instance = finishedWork.stateNode;\n                                try {\n                                    resetTextContent(instance);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                            if (flags & Update) {\n                                var _instance2 = finishedWork.stateNode;\n                                if (_instance2 != null) {\n                                    // Commit the work prepared earlier.\n                                    var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                                    // as the newProps. The updatePayload will contain the real change in\n                                    // this case.\n                                    var oldProps = current !== null ? current.memoizedProps : newProps;\n                                    var type = finishedWork.type;\n                                    try {\n                                        commitUpdate(_instance2, type, oldProps, newProps, finishedWork);\n                                    } catch (error) {\n                                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                    }\n                                }\n                            }\n                            if (flags & FormReset) {\n                                needsFormReset = true;\n                                {\n                                    if (finishedWork.type !== 'form') {\n                                        // Paranoid coding. In case we accidentally start using the\n                                        // FormReset bit for something else.\n                                        error('Unexpected host component type. Expected a form. This is a ' + 'bug in React.');\n                                    }\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case HostText:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Update) {\n                            if (supportsMutation) {\n                                if (finishedWork.stateNode === null) {\n                                    throw new Error('This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                }\n                                var textInstance = finishedWork.stateNode;\n                                var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                                // as the newProps. The updatePayload will contain the real change in\n                                // this case.\n                                var oldText = current !== null ? current.memoizedProps : newText;\n                                try {\n                                    commitTextUpdate(textInstance, oldText, newText);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case HostRoot:\n                    {\n                        if (supportsResources) {\n                            prepareToCommitHoistables();\n                            var previousHoistableRoot = currentHoistableRoot;\n                            currentHoistableRoot = getHoistableRoot(root.containerInfo);\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            currentHoistableRoot = previousHoistableRoot;\n                            commitReconciliationEffects(finishedWork);\n                        } else {\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            commitReconciliationEffects(finishedWork);\n                        }\n                        if (flags & Update) {\n                            if (supportsMutation && supportsHydration) {\n                                if (current !== null) {\n                                    var prevRootState = current.memoizedState;\n                                    if (prevRootState.isDehydrated) {\n                                        try {\n                                            commitHydratedContainer(root.containerInfo);\n                                        } catch (error) {\n                                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                        }\n                                    }\n                                }\n                            }\n                            if (supportsPersistence) {\n                                var containerInfo = root.containerInfo;\n                                var pendingChildren = root.pendingChildren;\n                                try {\n                                    replaceContainerChildren(containerInfo, pendingChildren);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        if (needsFormReset) {\n                            // A form component requested to be reset during this commit. We do this\n                            // after all mutations in the rest of the tree so that `defaultValue`\n                            // will already be updated. This way you can update `defaultValue` using\n                            // data sent by the server as a result of the form submission.\n                            //\n                            // Theoretically we could check finishedWork.subtreeFlags & FormReset,\n                            // but the FormReset bit is overloaded with other flags used by other\n                            // fiber types. So this extra variable lets us skip traversing the tree\n                            // except when a form was actually submitted.\n                            needsFormReset = false;\n                            recursivelyResetForms(finishedWork);\n                        }\n                        return;\n                    }\n                case HostPortal:\n                    {\n                        if (supportsResources) {\n                            var _previousHoistableRoot = currentHoistableRoot;\n                            currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            commitReconciliationEffects(finishedWork);\n                            currentHoistableRoot = _previousHoistableRoot;\n                        } else {\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            commitReconciliationEffects(finishedWork);\n                        }\n                        if (flags & Update) {\n                            if (supportsPersistence) {\n                                var portal = finishedWork.stateNode;\n                                var _containerInfo = portal.containerInfo;\n                                var _pendingChildren = portal.pendingChildren;\n                                try {\n                                    replaceContainerChildren(_containerInfo, _pendingChildren);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case SuspenseComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork); // TODO: We should mark a flag on the Suspense fiber itself, rather than\n                        // relying on the Offscreen fiber having a flag also being marked. The\n                        // reason is that this offscreen fiber might not be part of the work-in-\n                        // progress tree! It could have been reused from a previous render. This\n                        // doesn't lead to incorrect behavior because we don't rely on the flag\n                        // check alone; we also compare the states explicitly below. But for\n                        // modeling purposes, we _should_ be able to rely on the flag check alone.\n                        // So this is a bit fragile.\n                        //\n                        // Also, all this logic could/should move to the passive phase so it\n                        // doesn't block paint.\n                        var offscreenFiber = finishedWork.child;\n                        if (offscreenFiber.flags & Visibility) {\n                            // Throttle the appearance and disappearance of Suspense fallbacks.\n                            var isShowingFallback = finishedWork.memoizedState !== null;\n                            var wasShowingFallback = current !== null && current.memoizedState !== null;\n                            {\n                                if (isShowingFallback !== wasShowingFallback) {\n                                    // A fallback is either appearing or disappearing.\n                                    markCommitTimeOfFallback();\n                                }\n                            }\n                        }\n                        if (flags & Update) {\n                            try {\n                                commitSuspenseCallback(finishedWork);\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                            var retryQueue = finishedWork.updateQueue;\n                            if (retryQueue !== null) {\n                                finishedWork.updateQueue = null;\n                                attachSuspenseRetryListeners(finishedWork, retryQueue);\n                            }\n                        }\n                        return;\n                    }\n                case OffscreenComponent:\n                    {\n                        if (flags & Ref) {\n                            if (current !== null) {\n                                safelyDetachRef(current, current.return);\n                            }\n                        }\n                        var newState = finishedWork.memoizedState;\n                        var isHidden = newState !== null;\n                        var wasHidden = current !== null && current.memoizedState !== null;\n                        {\n                            // Before committing the children, track on the stack whether this\n                            // offscreen subtree was already hidden, so that we don't unmount the\n                            // effects again.\n                            var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n                            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || isHidden;\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                        }\n                        commitReconciliationEffects(finishedWork);\n                        var offscreenInstance = finishedWork.stateNode; // TODO: Add explicit effect flag to set _current.\n                        offscreenInstance._current = finishedWork; // Offscreen stores pending changes to visibility in `_pendingVisibility`. This is\n                        // to support batching of `attach` and `detach` calls.\n                        offscreenInstance._visibility &= ~OffscreenDetached;\n                        offscreenInstance._visibility |= offscreenInstance._pendingVisibility & OffscreenDetached;\n                        if (flags & Visibility) {\n                            // Track the current state on the Offscreen instance so we can\n                            // read it during an event\n                            if (isHidden) {\n                                offscreenInstance._visibility &= ~OffscreenVisible;\n                            } else {\n                                offscreenInstance._visibility |= OffscreenVisible;\n                            }\n                            if (isHidden) {\n                                var isUpdate = current !== null;\n                                var wasHiddenByAncestorOffscreen = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden; // Only trigger disapper layout effects if:\n                                //   - This is an update, not first mount.\n                                //   - This Offscreen was not hidden before.\n                                //   - Ancestor Offscreen was not hidden in previous commit.\n                                if (isUpdate && !wasHidden && !wasHiddenByAncestorOffscreen) {\n                                    {\n                                        // Disappear the layout effects of all the children\n                                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                                    }\n                                }\n                            } // Offscreen with manual mode manages visibility manually.\n                            if (supportsMutation && !isOffscreenManual(finishedWork)) {\n                                // TODO: This needs to run whenever there's an insertion or update\n                                // inside a hidden Offscreen tree.\n                                hideOrUnhideAllChildren(finishedWork, isHidden);\n                            }\n                        } // TODO: Move to passive phase\n                        if (flags & Update) {\n                            var offscreenQueue = finishedWork.updateQueue;\n                            if (offscreenQueue !== null) {\n                                var _retryQueue = offscreenQueue.retryQueue;\n                                if (_retryQueue !== null) {\n                                    offscreenQueue.retryQueue = null;\n                                    attachSuspenseRetryListeners(finishedWork, _retryQueue);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case SuspenseListComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Update) {\n                            var _retryQueue2 = finishedWork.updateQueue;\n                            if (_retryQueue2 !== null) {\n                                finishedWork.updateQueue = null;\n                                attachSuspenseRetryListeners(finishedWork, _retryQueue2);\n                            }\n                        }\n                        return;\n                    }\n                case ScopeComponent:\n                    {\n                        return;\n                    }\n                default:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        return;\n                    }\n            }\n        }\n        function commitReconciliationEffects(finishedWork) {\n            // Placement effects (insertions, reorders) can be scheduled on any fiber\n            // type. They needs to happen after the children effects have fired, but\n            // before the effects on this fiber have fired.\n            var flags = finishedWork.flags;\n            if (flags & Placement) {\n                try {\n                    commitPlacement(finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                } // Clear the \"placement\" from effect tag so that we know that this is\n                // inserted, before any life-cycles like componentDidMount gets called.\n                // TODO: findDOMNode doesn't rely on this any more but isMounted does\n                // and isMounted is deprecated anyway so we should be able to kill this.\n                finishedWork.flags &= ~Placement;\n            }\n            if (flags & Hydrating) {\n                finishedWork.flags &= ~Hydrating;\n            }\n        }\n        function recursivelyResetForms(parentFiber) {\n            if (parentFiber.subtreeFlags & FormReset) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    resetFormOnFiber(child);\n                    child = child.sibling;\n                }\n            }\n        }\n        function resetFormOnFiber(fiber) {\n            recursivelyResetForms(fiber);\n            if (fiber.tag === HostComponent && fiber.flags & FormReset) {\n                var formInstance = fiber.stateNode;\n                resetFormInstance(formInstance);\n            }\n        }\n        function commitLayoutEffects(finishedWork, root, committedLanes) {\n            inProgressLanes = committedLanes;\n            inProgressRoot = root;\n            setCurrentDebugFiberInDEV(finishedWork);\n            var current = finishedWork.alternate;\n            commitLayoutEffectOnFiber(root, current, finishedWork);\n            resetCurrentDebugFiberInDEV();\n            inProgressLanes = null;\n            inProgressRoot = null;\n        }\n        function recursivelyTraverseLayoutEffects(root, parentFiber, lanes) {\n            var prevDebugFiber = getCurrentFiber();\n            if (parentFiber.subtreeFlags & LayoutMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    var current = child.alternate;\n                    commitLayoutEffectOnFiber(root, current, child);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function disappearLayoutEffects(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & LayoutStatic\n                        if (shouldProfile(finishedWork)) {\n                            try {\n                                startLayoutEffectTimer();\n                                commitHookEffectListUnmount(Layout, finishedWork, finishedWork.return);\n                            } finally{\n                                recordLayoutEffectDuration(finishedWork);\n                            }\n                        } else {\n                            commitHookEffectListUnmount(Layout, finishedWork, finishedWork.return);\n                        }\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & RefStatic\n                        safelyDetachRef(finishedWork, finishedWork.return);\n                        var instance = finishedWork.stateNode;\n                        if (typeof instance.componentWillUnmount === 'function') {\n                            safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);\n                        }\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & RefStatic\n                        safelyDetachRef(finishedWork, finishedWork.return);\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & RefStatic\n                        safelyDetachRef(finishedWork, finishedWork.return);\n                        var isHidden = finishedWork.memoizedState !== null;\n                        if (isHidden) ;\n                        else {\n                            recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n            // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n            var child = parentFiber.child;\n            while(child !== null){\n                disappearLayoutEffects(child);\n                child = child.sibling;\n            }\n        }\n        function reappearLayoutEffects(finishedRoot, current, finishedWork, // from a previously committed tree. We cannot check non-static flags if the\n        // node was reused.\n        includeWorkInProgressEffects) {\n            // Turn on layout effects in a tree that previously disappeared.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Check flags & LayoutStatic\n                        commitHookLayoutEffects(finishedWork, Layout);\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Check for LayoutStatic flag\n                        var instance = finishedWork.stateNode;\n                        if (typeof instance.componentDidMount === 'function') {\n                            try {\n                                instance.componentDidMount();\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        } // Commit any callbacks that would have fired while the component\n                        // was hidden.\n                        var updateQueue = finishedWork.updateQueue;\n                        if (updateQueue !== null) {\n                            commitHiddenCallbacks(updateQueue, instance);\n                        } // If this is newly finished work, check for setState callbacks\n                        if (includeWorkInProgressEffects && flags & Callback) {\n                            commitClassCallbacks(finishedWork);\n                        } // TODO: Check flags & RefStatic\n                        safelyAttachRef(finishedWork, finishedWork.return);\n                        break;\n                    }\n                // Unlike commitLayoutEffectsOnFiber, we don't need to handle HostRoot\n                // because this function only visits nodes that are inside an\n                // Offscreen fiber.\n                // case HostRoot: {\n                //  ...\n                // }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // Renderers may schedule work to be done after host components are mounted\n                        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n                        // These effects should only be committed when components are first mounted,\n                        // aka when there is no current/alternate.\n                        if (includeWorkInProgressEffects && current === null && flags & Update) {\n                            commitHostComponentMount(finishedWork);\n                        } // TODO: Check flags & Ref\n                        safelyAttachRef(finishedWork, finishedWork.return);\n                        break;\n                    }\n                case Profiler:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Figure out how Profiler updates should work with Offscreen\n                        if (includeWorkInProgressEffects && flags & Update) {\n                            commitProfilerUpdate(finishedWork, current);\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Figure out how Suspense hydration callbacks should work\n                        // with Offscreen.\n                        if (includeWorkInProgressEffects && flags & Update) {\n                            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var offscreenState = finishedWork.memoizedState;\n                        var isHidden = offscreenState !== null;\n                        if (isHidden) ;\n                        else {\n                            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                        } // TODO: Check flags & Ref\n                        safelyAttachRef(finishedWork, finishedWork.return);\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {\n            // This function visits both newly finished work and nodes that were re-used\n            // from a previously committed tree. We cannot check non-static flags if the\n            // node was reused.\n            var childShouldIncludeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & LayoutMask) !== NoFlags$1; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n            var prevDebugFiber = getCurrentFiber();\n            var child = parentFiber.child;\n            while(child !== null){\n                var current = child.alternate;\n                reappearLayoutEffects(finishedRoot, current, child, childShouldIncludeWorkInProgressEffects);\n                child = child.sibling;\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function commitHookPassiveMountEffects(finishedWork, hookFlags) {\n            if (shouldProfile(finishedWork)) {\n                startPassiveEffectTimer();\n                try {\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n                recordPassiveEffectDuration(finishedWork);\n            } else {\n                try {\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitOffscreenPassiveMountEffects(current, finishedWork, instance) {\n            {\n                var previousCache = null;\n                if (current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n                    previousCache = current.memoizedState.cachePool.pool;\n                }\n                var nextCache = null;\n                if (finishedWork.memoizedState !== null && finishedWork.memoizedState.cachePool !== null) {\n                    nextCache = finishedWork.memoizedState.cachePool.pool;\n                } // Retain/release the cache used for pending (suspended) nodes.\n                // Note that this is only reached in the non-suspended/visible case:\n                // when the content is suspended/hidden, the retain/release occurs\n                // via the parent Suspense component (see case above).\n                if (nextCache !== previousCache) {\n                    if (nextCache != null) {\n                        retainCache(nextCache);\n                    }\n                    if (previousCache != null) {\n                        releaseCache(previousCache);\n                    }\n                }\n            }\n        }\n        function commitCachePassiveMountEffect(current, finishedWork) {\n            {\n                var previousCache = null;\n                if (finishedWork.alternate !== null) {\n                    previousCache = finishedWork.alternate.memoizedState.cache;\n                }\n                var nextCache = finishedWork.memoizedState.cache; // Retain/release the cache. In theory the cache component\n                // could be \"borrowing\" a cache instance owned by some parent,\n                // in which case we could avoid retaining/releasing. But it\n                // is non-trivial to determine when that is the case, so we\n                // always retain/release.\n                if (nextCache !== previousCache) {\n                    retainCache(nextCache);\n                    if (previousCache != null) {\n                        releaseCache(previousCache);\n                    }\n                }\n            }\n        }\n        function commitPassiveMountEffects(root, finishedWork, committedLanes, committedTransitions) {\n            setCurrentDebugFiberInDEV(finishedWork);\n            commitPassiveMountOnFiber(root, finishedWork, committedLanes, committedTransitions);\n            resetCurrentDebugFiberInDEV();\n        }\n        function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {\n            var prevDebugFiber = getCurrentFiber();\n            if (parentFiber.subtreeFlags & PassiveMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    commitPassiveMountOnFiber(root, child, committedLanes, committedTransitions);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n            // When updating this function, also update reconnectPassiveEffects, which does\n            // most of the same things when an offscreen tree goes from hidden -> visible,\n            // or when toggling effects inside a hidden tree.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        if (flags & Passive$1) {\n                            commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        if (flags & Passive$1) {\n                            {\n                                var previousCache = null;\n                                if (finishedWork.alternate !== null) {\n                                    previousCache = finishedWork.alternate.memoizedState.cache;\n                                }\n                                var nextCache = finishedWork.memoizedState.cache; // Retain/release the root cache.\n                                // Note that on initial mount, previousCache and nextCache will be the same\n                                // and this retain won't occur. To counter this, we instead retain the HostRoot's\n                                // initial cache when creating the root itself (see createFiberRoot() in\n                                // ReactFiberRoot.js). Subsequent updates that change the cache are reflected\n                                // here, such that previous/next caches are retained correctly.\n                                if (nextCache !== previousCache) {\n                                    retainCache(nextCache);\n                                    if (previousCache != null) {\n                                        releaseCache(previousCache);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case LegacyHiddenComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        // TODO: Pass `current` as argument to this function\n                        var _instance3 = finishedWork.stateNode;\n                        var nextState = finishedWork.memoizedState;\n                        var isHidden = nextState !== null;\n                        if (isHidden) {\n                            if (_instance3._visibility & OffscreenPassiveEffectsConnected) {\n                                // The effects are currently connected. Update them.\n                                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                            } else {\n                                {\n                                    // The effects are currently disconnected. Since the tree is hidden,\n                                    // don't connect them. This also applies to the initial render.\n                                    {\n                                        // \"Atomic\" effects are ones that need to fire on every commit,\n                                        // even during pre-rendering. An example is updating the reference\n                                        // count on cache instances.\n                                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                                    }\n                                }\n                            }\n                        } else {\n                            // Tree is visible\n                            if (_instance3._visibility & OffscreenPassiveEffectsConnected) {\n                                // The effects are currently connected. Update them.\n                                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                            } else {\n                                // The effects are currently disconnected. Reconnect them, while also\n                                // firing effects inside newly mounted trees. This also applies to\n                                // the initial render.\n                                _instance3._visibility |= OffscreenPassiveEffectsConnected;\n                                var includeWorkInProgressEffects = (finishedWork.subtreeFlags & PassiveMask) !== NoFlags$1;\n                                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                            }\n                        }\n                        if (flags & Passive$1) {\n                            var _current = finishedWork.alternate;\n                            commitOffscreenPassiveMountEffects(_current, finishedWork);\n                        }\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        if (flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current2 = finishedWork.alternate;\n                            commitCachePassiveMountEffect(_current2, finishedWork);\n                        }\n                        break;\n                    }\n                case TracingMarkerComponent:\n                default:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n            // This function visits both newly finished work and nodes that were re-used\n            // from a previously committed tree. We cannot check non-static flags if the\n            // node was reused.\n            var childShouldIncludeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & PassiveMask) !== NoFlags$1; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n            var prevDebugFiber = getCurrentFiber();\n            var child = parentFiber.child;\n            while(child !== null){\n                reconnectPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, childShouldIncludeWorkInProgressEffects);\n                child = child.sibling;\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, // from a previously committed tree. We cannot check non-static flags if the\n        // node was reused.\n        includeWorkInProgressEffects) {\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects); // TODO: Check for PassiveStatic flag\n                        commitHookPassiveMountEffects(finishedWork, Passive);\n                        break;\n                    }\n                // Unlike commitPassiveMountOnFiber, we don't need to handle HostRoot\n                // because this function only visits nodes that are inside an\n                // Offscreen fiber.\n                // case HostRoot: {\n                //  ...\n                // }\n                case LegacyHiddenComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var _instance4 = finishedWork.stateNode;\n                        var nextState = finishedWork.memoizedState;\n                        var isHidden = nextState !== null;\n                        if (isHidden) {\n                            if (_instance4._visibility & OffscreenPassiveEffectsConnected) {\n                                // The effects are currently connected. Update them.\n                                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                            } else {\n                                {\n                                    // The effects are currently disconnected. Since the tree is hidden,\n                                    // don't connect them. This also applies to the initial render.\n                                    {\n                                        // \"Atomic\" effects are ones that need to fire on every commit,\n                                        // even during pre-rendering. An example is updating the reference\n                                        // count on cache instances.\n                                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                                    }\n                                }\n                            }\n                        } else {\n                            // Tree is visible\n                            // Since we're already inside a reconnecting tree, it doesn't matter\n                            // whether the effects are currently connected. In either case, we'll\n                            // continue traversing the tree and firing all the effects.\n                            //\n                            // We do need to set the \"connected\" flag on the instance, though.\n                            _instance4._visibility |= OffscreenPassiveEffectsConnected;\n                            recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                        }\n                        if (includeWorkInProgressEffects && flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current3 = finishedWork.alternate;\n                            commitOffscreenPassiveMountEffects(_current3, finishedWork);\n                        }\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                        if (includeWorkInProgressEffects && flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current4 = finishedWork.alternate;\n                            commitCachePassiveMountEffect(_current4, finishedWork);\n                        }\n                        break;\n                    }\n                case TracingMarkerComponent:\n                default:\n                    {\n                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseAtomicPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions) {\n            // \"Atomic\" effects are ones that need to fire on every commit, even during\n            // pre-rendering. We call this function when traversing a hidden tree whose\n            // regular effects are currently disconnected.\n            var prevDebugFiber = getCurrentFiber(); // TODO: Add special flag for atomic effects\n            if (parentFiber.subtreeFlags & PassiveMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    commitAtomicPassiveEffects(finishedRoot, child);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function commitAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n            // \"Atomic\" effects are ones that need to fire on every commit, even during\n            // pre-rendering. We call this function when traversing a hidden tree whose\n            // regular effects are currently disconnected.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case OffscreenComponent:\n                    {\n                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                        if (flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var current = finishedWork.alternate;\n                            commitOffscreenPassiveMountEffects(current, finishedWork);\n                        }\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                        if (flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current5 = finishedWork.alternate;\n                            commitCachePassiveMountEffect(_current5, finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                        break;\n                    }\n            }\n        }\n        function commitPassiveUnmountEffects(finishedWork) {\n            setCurrentDebugFiberInDEV(finishedWork);\n            commitPassiveUnmountOnFiber(finishedWork);\n            resetCurrentDebugFiberInDEV();\n        } // If we're inside a brand new tree, or a tree that was already visible, then we\n        // should only suspend host components that have a ShouldSuspendCommit flag.\n        // Components without it haven't changed since the last commit, so we can skip\n        // over those.\n        //\n        // When we enter a tree that is being revealed (going from hidden -> visible),\n        // we need to suspend _any_ component that _may_ suspend. Even if they're\n        // already in the \"current\" tree. Because their visibility has changed, the\n        // browser may not have prerendered them yet. So we check the MaySuspendCommit\n        // flag instead.\n        var suspenseyCommitFlag = ShouldSuspendCommit;\n        function accumulateSuspenseyCommit(finishedWork) {\n            accumulateSuspenseyCommitOnFiber(finishedWork);\n        }\n        function recursivelyAccumulateSuspenseyCommit(parentFiber) {\n            if (parentFiber.subtreeFlags & suspenseyCommitFlag) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    accumulateSuspenseyCommitOnFiber(child);\n                    child = child.sibling;\n                }\n            }\n        }\n        function accumulateSuspenseyCommitOnFiber(fiber) {\n            switch(fiber.tag){\n                case HostHoistable:\n                    {\n                        recursivelyAccumulateSuspenseyCommit(fiber);\n                        if (fiber.flags & suspenseyCommitFlag) {\n                            if (fiber.memoizedState !== null) {\n                                suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);\n                            } else {\n                                var type = fiber.type;\n                                var props = fiber.memoizedProps;\n                                suspendInstance(type, props);\n                            }\n                        }\n                        break;\n                    }\n                case HostComponent:\n                    {\n                        recursivelyAccumulateSuspenseyCommit(fiber);\n                        if (fiber.flags & suspenseyCommitFlag) {\n                            var _type = fiber.type;\n                            var _props = fiber.memoizedProps;\n                            suspendInstance(_type, _props);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                case HostPortal:\n                    {\n                        if (supportsResources) {\n                            var previousHoistableRoot = currentHoistableRoot;\n                            var container = fiber.stateNode.containerInfo;\n                            currentHoistableRoot = getHoistableRoot(container);\n                            recursivelyAccumulateSuspenseyCommit(fiber);\n                            currentHoistableRoot = previousHoistableRoot;\n                        } else {\n                            recursivelyAccumulateSuspenseyCommit(fiber);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var isHidden = fiber.memoizedState !== null;\n                        if (isHidden) ;\n                        else {\n                            var current = fiber.alternate;\n                            var wasHidden = current !== null && current.memoizedState !== null;\n                            if (wasHidden) {\n                                // This tree is being revealed. Visit all newly visible suspensey\n                                // instances, even if they're in the current tree.\n                                var prevFlags = suspenseyCommitFlag;\n                                suspenseyCommitFlag = MaySuspendCommit;\n                                recursivelyAccumulateSuspenseyCommit(fiber);\n                                suspenseyCommitFlag = prevFlags;\n                            } else {\n                                recursivelyAccumulateSuspenseyCommit(fiber);\n                            }\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyAccumulateSuspenseyCommit(fiber);\n                    }\n            }\n        }\n        function detachAlternateSiblings(parentFiber) {\n            // A fiber was deleted from this parent fiber, but it's still part of the\n            // previous (alternate) parent fiber's list of children. Because children\n            // are a linked list, an earlier sibling that's still alive will be\n            // connected to the deleted fiber via its `alternate`:\n            //\n            //   live fiber --alternate--> previous live fiber --sibling--> deleted\n            //   fiber\n            //\n            // We can't disconnect `alternate` on nodes that haven't been deleted yet,\n            // but we can disconnect the `sibling` and `child` pointers.\n            var previousFiber = parentFiber.alternate;\n            if (previousFiber !== null) {\n                var detachedChild = previousFiber.child;\n                if (detachedChild !== null) {\n                    previousFiber.child = null;\n                    do {\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        var detachedSibling = detachedChild.sibling; // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        detachedChild.sibling = null;\n                        detachedChild = detachedSibling;\n                    }while (detachedChild !== null);\n                }\n            }\n        }\n        function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n            if (shouldProfile(finishedWork)) {\n                startPassiveEffectTimer();\n                commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n                recordPassiveEffectDuration(finishedWork);\n            } else {\n                commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n            }\n        }\n        function recursivelyTraversePassiveUnmountEffects(parentFiber) {\n            // Deletions effects can be scheduled on any fiber type. They need to happen\n            // before the children effects have fired.\n            var deletions = parentFiber.deletions;\n            if ((parentFiber.flags & ChildDeletion) !== NoFlags$1) {\n                if (deletions !== null) {\n                    for(var i = 0; i < deletions.length; i++){\n                        var childToDelete = deletions[i]; // TODO: Convert this to use recursion\n                        nextEffect = childToDelete;\n                        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n                    }\n                }\n                detachAlternateSiblings(parentFiber);\n            }\n            var prevDebugFiber = getCurrentFiber(); // TODO: Split PassiveMask into separate masks for mount and unmount?\n            if (parentFiber.subtreeFlags & PassiveMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    commitPassiveUnmountOnFiber(child);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function commitPassiveUnmountOnFiber(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraversePassiveUnmountEffects(finishedWork);\n                        if (finishedWork.flags & Passive$1) {\n                            commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        var nextState = finishedWork.memoizedState;\n                        var isHidden = nextState !== null;\n                        if (isHidden && instance._visibility & OffscreenPassiveEffectsConnected && // the future we may change this to unmount after a delay.\n                        (finishedWork.return === null || finishedWork.return.tag !== SuspenseComponent)) {\n                            // The effects are currently connected. Disconnect them.\n                            // TODO: Add option or heuristic to delay before disconnecting the\n                            // effects. Then if the tree reappears before the delay has elapsed, we\n                            // can skip toggling the effects entirely.\n                            instance._visibility &= ~OffscreenPassiveEffectsConnected;\n                            recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        } else {\n                            recursivelyTraversePassiveUnmountEffects(finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraversePassiveUnmountEffects(finishedWork);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n            // Deletions effects can be scheduled on any fiber type. They need to happen\n            // before the children effects have fired.\n            var deletions = parentFiber.deletions;\n            if ((parentFiber.flags & ChildDeletion) !== NoFlags$1) {\n                if (deletions !== null) {\n                    for(var i = 0; i < deletions.length; i++){\n                        var childToDelete = deletions[i]; // TODO: Convert this to use recursion\n                        nextEffect = childToDelete;\n                        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n                    }\n                }\n                detachAlternateSiblings(parentFiber);\n            }\n            var prevDebugFiber = getCurrentFiber(); // TODO: Check PassiveStatic flag\n            var child = parentFiber.child;\n            while(child !== null){\n                setCurrentDebugFiberInDEV(child);\n                disconnectPassiveEffect(child);\n                child = child.sibling;\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function disconnectPassiveEffect(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        // TODO: Check PassiveStatic flag\n                        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive); // When disconnecting passive effects, we fire the effects in the same\n                        // order as during a deletiong: parent before child\n                        recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        if (instance._visibility & OffscreenPassiveEffectsConnected) {\n                            instance._visibility &= ~OffscreenPassiveEffectsConnected;\n                            recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        break;\n                    }\n            }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // Deletion effects fire in parent -> child order\n                // TODO: Check if fiber has a PassiveStatic flag\n                setCurrentDebugFiberInDEV(fiber);\n                commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n                resetCurrentDebugFiberInDEV();\n                var child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag.\n                if (child !== null) {\n                    child.return = fiber;\n                    nextEffect = child;\n                } else {\n                    commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n                }\n            }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var sibling = fiber.sibling;\n                var returnFiber = fiber.return; // Recursively traverse the entire deleted tree and clean up fiber fields.\n                // This is more aggressive than ideal, and the long term goal is to only\n                // have to detach the deleted tree at the root.\n                detachFiberAfterEffects(fiber);\n                if (fiber === deletedSubtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                if (sibling !== null) {\n                    sibling.return = returnFiber;\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = returnFiber;\n            }\n        }\n        function commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {\n            switch(current.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);\n                        break;\n                    }\n                // TODO: run passive unmount effects when unmounting a root.\n                // Because passive unmount effects are not currently run,\n                // the cache instance owned by the root will never be freed.\n                // When effects are run, the cache should be freed here:\n                // case HostRoot: {\n                //   if (enableCache) {\n                //     const cache = current.memoizedState.cache;\n                //     releaseCache(cache);\n                //   }\n                //   break;\n                // }\n                case LegacyHiddenComponent:\n                case OffscreenComponent:\n                    {\n                        {\n                            if (current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n                                var cache = current.memoizedState.cachePool.pool; // Retain/release the cache used for pending (suspended) nodes.\n                                // Note that this is only reached in the non-suspended/visible case:\n                                // when the content is suspended/hidden, the retain/release occurs\n                                // via the parent Suspense component (see case above).\n                                if (cache != null) {\n                                    retainCache(cache);\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            var _cache = current.memoizedState.cache;\n                            releaseCache(_cache);\n                        }\n                        break;\n                    }\n            }\n        }\n        function getCacheForType(resourceType) {\n            var cache = readContext(CacheContext);\n            var cacheForType = cache.data.get(resourceType);\n            if (cacheForType === undefined) {\n                cacheForType = resourceType();\n                cache.data.set(resourceType, cacheForType);\n            }\n            return cacheForType;\n        }\n        var DefaultAsyncDispatcher = {\n            getCacheForType: getCacheForType\n        };\n        {\n            DefaultAsyncDispatcher.getOwner = function() {\n                return current;\n            };\n        }\n        var COMPONENT_TYPE = 0;\n        var HAS_PSEUDO_CLASS_TYPE = 1;\n        var ROLE_TYPE = 2;\n        var TEST_NAME_TYPE = 3;\n        var TEXT_TYPE = 4;\n        if (typeof Symbol === 'function' && Symbol.for) {\n            var symbolFor = Symbol.for;\n            COMPONENT_TYPE = symbolFor('selector.component');\n            HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class');\n            ROLE_TYPE = symbolFor('selector.role');\n            TEST_NAME_TYPE = symbolFor('selector.test_id');\n            TEXT_TYPE = symbolFor('selector.text');\n        }\n        function createComponentSelector(component) {\n            return {\n                $$typeof: COMPONENT_TYPE,\n                value: component\n            };\n        }\n        function createHasPseudoClassSelector(selectors) {\n            return {\n                $$typeof: HAS_PSEUDO_CLASS_TYPE,\n                value: selectors\n            };\n        }\n        function createRoleSelector(role) {\n            return {\n                $$typeof: ROLE_TYPE,\n                value: role\n            };\n        }\n        function createTextSelector(text) {\n            return {\n                $$typeof: TEXT_TYPE,\n                value: text\n            };\n        }\n        function createTestNameSelector(id) {\n            return {\n                $$typeof: TEST_NAME_TYPE,\n                value: id\n            };\n        }\n        function findFiberRootForHostRoot(hostRoot) {\n            var maybeFiber = getInstanceFromNode(hostRoot);\n            if (maybeFiber != null) {\n                if (typeof maybeFiber.memoizedProps['data-testname'] !== 'string') {\n                    throw new Error('Invalid host root specified. Should be either a React container or a node with a testname attribute.');\n                }\n                return maybeFiber;\n            } else {\n                var fiberRoot = findFiberRoot(hostRoot);\n                if (fiberRoot === null) {\n                    throw new Error('Could not find React container within specified host subtree.');\n                } // The Flow type for FiberRoot is a little funky.\n                // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\n                return fiberRoot.stateNode.current;\n            }\n        }\n        function matchSelector(fiber, selector) {\n            var tag = fiber.tag;\n            switch(selector.$$typeof){\n                case COMPONENT_TYPE:\n                    if (fiber.type === selector.value) {\n                        return true;\n                    }\n                    break;\n                case HAS_PSEUDO_CLASS_TYPE:\n                    return hasMatchingPaths(fiber, selector.value);\n                case ROLE_TYPE:\n                    if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                        var node = fiber.stateNode;\n                        if (matchAccessibilityRole(node, selector.value)) {\n                            return true;\n                        }\n                    }\n                    break;\n                case TEXT_TYPE:\n                    if (tag === HostComponent || tag === HostText || tag === HostHoistable || tag === HostSingleton) {\n                        var textContent = getTextContent(fiber);\n                        if (textContent !== null && textContent.indexOf(selector.value) >= 0) {\n                            return true;\n                        }\n                    }\n                    break;\n                case TEST_NAME_TYPE:\n                    if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                        var dataTestID = fiber.memoizedProps['data-testname'];\n                        if (typeof dataTestID === 'string' && dataTestID.toLowerCase() === selector.value.toLowerCase()) {\n                            return true;\n                        }\n                    }\n                    break;\n                default:\n                    throw new Error('Invalid selector type specified.');\n            }\n            return false;\n        }\n        function selectorToString(selector) {\n            switch(selector.$$typeof){\n                case COMPONENT_TYPE:\n                    var displayName = getComponentNameFromType(selector.value) || 'Unknown';\n                    return \"<\" + displayName + \">\";\n                case HAS_PSEUDO_CLASS_TYPE:\n                    return \":has(\" + (selectorToString(selector) || '') + \")\";\n                case ROLE_TYPE:\n                    return \"[role=\\\"\" + selector.value + \"\\\"]\";\n                case TEXT_TYPE:\n                    return \"\\\"\" + selector.value + \"\\\"\";\n                case TEST_NAME_TYPE:\n                    return \"[data-testname=\\\"\" + selector.value + \"\\\"]\";\n                default:\n                    throw new Error('Invalid selector type specified.');\n            }\n        }\n        function findPaths(root, selectors) {\n            var matchingFibers = [];\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && isHiddenSubtree(fiber)) {\n                    continue;\n                } else {\n                    while(selector != null && matchSelector(fiber, selector)){\n                        selectorIndex++;\n                        selector = selectors[selectorIndex];\n                    }\n                }\n                if (selectorIndex === selectors.length) {\n                    matchingFibers.push(fiber);\n                } else {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return matchingFibers;\n        } // Same as findPaths but with eager bailout on first match\n        function hasMatchingPaths(root, selectors) {\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && isHiddenSubtree(fiber)) {\n                    continue;\n                } else {\n                    while(selector != null && matchSelector(fiber, selector)){\n                        selectorIndex++;\n                        selector = selectors[selectorIndex];\n                    }\n                }\n                if (selectorIndex === selectors.length) {\n                    return true;\n                } else {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return false;\n        }\n        function findAllNodes(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var matchingFibers = findPaths(root, selectors);\n            var instanceRoots = [];\n            var stack = Array.from(matchingFibers);\n            var index = 0;\n            while(index < stack.length){\n                var node = stack[index++];\n                var tag = node.tag;\n                if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                    if (isHiddenSubtree(node)) {\n                        continue;\n                    }\n                    instanceRoots.push(node.stateNode);\n                } else {\n                    var child = node.child;\n                    while(child !== null){\n                        stack.push(child);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return instanceRoots;\n        }\n        function getFindAllNodesFailureDescription(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var maxSelectorIndex = 0;\n            var matchedNames = []; // The logic of this loop should be kept in sync with findPaths()\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && isHiddenSubtree(fiber)) {\n                    continue;\n                } else if (matchSelector(fiber, selector)) {\n                    matchedNames.push(selectorToString(selector));\n                    selectorIndex++;\n                    if (selectorIndex > maxSelectorIndex) {\n                        maxSelectorIndex = selectorIndex;\n                    }\n                }\n                if (selectorIndex < selectors.length) {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            if (maxSelectorIndex < selectors.length) {\n                var unmatchedNames = [];\n                for(var i = maxSelectorIndex; i < selectors.length; i++){\n                    unmatchedNames.push(selectorToString(selectors[i]));\n                }\n                return 'findAllNodes was able to match part of the selector:\\n' + (\"  \" + matchedNames.join(' > ') + \"\\n\\n\") + 'No matching component was found for:\\n' + (\"  \" + unmatchedNames.join(' > '));\n            }\n            return null;\n        }\n        function findBoundingRects(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var instanceRoots = findAllNodes(hostRoot, selectors);\n            var boundingRects = [];\n            for(var i = 0; i < instanceRoots.length; i++){\n                boundingRects.push(getBoundingRect(instanceRoots[i]));\n            }\n            for(var _i = boundingRects.length - 1; _i > 0; _i--){\n                var targetRect = boundingRects[_i];\n                var targetLeft = targetRect.x;\n                var targetRight = targetLeft + targetRect.width;\n                var targetTop = targetRect.y;\n                var targetBottom = targetTop + targetRect.height;\n                for(var j = _i - 1; j >= 0; j--){\n                    if (_i !== j) {\n                        var otherRect = boundingRects[j];\n                        var otherLeft = otherRect.x;\n                        var otherRight = otherLeft + otherRect.width;\n                        var otherTop = otherRect.y;\n                        var otherBottom = otherTop + otherRect.height; // Merging all rects to the minimums set would be complicated,\n                        // but we can handle the most common cases:\n                        // 1. completely overlapping rects\n                        // 2. adjacent rects that are the same width or height (e.g. items in a list)\n                        //\n                        // Even given the above constraints,\n                        // we still won't end up with the fewest possible rects without doing multiple passes,\n                        // but it's good enough for this purpose.\n                        if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n                            // Complete overlapping rects; remove the inner one.\n                            boundingRects.splice(_i, 1);\n                            break;\n                        } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {\n                            // Adjacent vertical rects; merge them.\n                            if (otherTop > targetTop) {\n                                otherRect.height += otherTop - targetTop;\n                                otherRect.y = targetTop;\n                            }\n                            if (otherBottom < targetBottom) {\n                                otherRect.height = targetBottom - otherTop;\n                            }\n                            boundingRects.splice(_i, 1);\n                            break;\n                        } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {\n                            // Adjacent horizontal rects; merge them.\n                            if (otherLeft > targetLeft) {\n                                otherRect.width += otherLeft - targetLeft;\n                                otherRect.x = targetLeft;\n                            }\n                            if (otherRight < targetRight) {\n                                otherRect.width = targetRight - otherLeft;\n                            }\n                            boundingRects.splice(_i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            return boundingRects;\n        }\n        function focusWithin(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var matchingFibers = findPaths(root, selectors);\n            var stack = Array.from(matchingFibers);\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                if (isHiddenSubtree(fiber)) {\n                    continue;\n                }\n                if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                    var node = fiber.stateNode;\n                    if (setFocusIfFocusable(node)) {\n                        return true;\n                    }\n                }\n                var child = fiber.child;\n                while(child !== null){\n                    stack.push(child);\n                    child = child.sibling;\n                }\n            }\n            return false;\n        }\n        var commitHooks = [];\n        function onCommitRoot() {\n            if (supportsTestSelectors) {\n                commitHooks.forEach(function(commitHook) {\n                    return commitHook();\n                });\n            }\n        }\n        function observeVisibleRects(hostRoot, selectors, callback, options) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var instanceRoots = findAllNodes(hostRoot, selectors);\n            var _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options), disconnect = _setupIntersectionObs.disconnect, observe = _setupIntersectionObs.observe, unobserve = _setupIntersectionObs.unobserve; // When React mutates the host environment, we may need to change what we're listening to.\n            var commitHook = function() {\n                var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n                instanceRoots.forEach(function(target) {\n                    if (nextInstanceRoots.indexOf(target) < 0) {\n                        unobserve(target);\n                    }\n                });\n                nextInstanceRoots.forEach(function(target) {\n                    if (instanceRoots.indexOf(target) < 0) {\n                        observe(target);\n                    }\n                });\n            };\n            commitHooks.push(commitHook);\n            return {\n                disconnect: function() {\n                    // Stop listening for React mutations:\n                    var index = commitHooks.indexOf(commitHook);\n                    if (index >= 0) {\n                        commitHooks.splice(index, 1);\n                    } // Disconnect the host observer:\n                    disconnect();\n                }\n            };\n        }\n        function isConcurrentActEnvironment() {\n            {\n                var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined;\n                if (!isReactActEnvironmentGlobal && ReactSharedInternals.actQueue !== null) {\n                    // TODO: Include link to relevant documentation page.\n                    error('The current testing environment is not configured to support ' + 'act(...)');\n                }\n                return isReactActEnvironmentGlobal;\n            }\n        }\n        var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n        var NoContext = /*             */ 0;\n        var BatchedContext = /*               */ 1;\n        var RenderContext = /*         */ 2;\n        var CommitContext = /*         */ 4;\n        var RootInProgress = 0;\n        var RootFatalErrored = 1;\n        var RootErrored = 2;\n        var RootSuspended = 3;\n        var RootSuspendedWithDelay = 4;\n        var RootCompleted = 5;\n        var RootDidNotComplete = 6; // Describes where we are in the React execution stack\n        var executionContext = NoContext; // The root we're working on\n        var workInProgressRoot = null; // The fiber we're working on\n        var workInProgress = null; // The lanes we're rendering\n        var workInProgressRootRenderLanes = NoLanes;\n        var NotSuspended = 0;\n        var SuspendedOnError = 1;\n        var SuspendedOnData = 2;\n        var SuspendedOnImmediate = 3;\n        var SuspendedOnInstance = 4;\n        var SuspendedOnInstanceAndReadyToContinue = 5;\n        var SuspendedOnDeprecatedThrowPromise = 6;\n        var SuspendedAndReadyToContinue = 7;\n        var SuspendedOnHydration = 8; // When this is true, the work-in-progress fiber just suspended (or errored) and\n        // we've yet to unwind the stack. In some cases, we may yield to the main thread\n        // after this happens. If the fiber is pinged before we resume, we can retry\n        // immediately instead of unwinding the stack.\n        var workInProgressSuspendedReason = NotSuspended;\n        var workInProgressThrownValue = null; // Whether a ping listener was attached during this render. This is slightly\n        // different that whether something suspended, because we don't add multiple\n        // listeners to a promise we've already seen (per root and lane).\n        var workInProgressRootDidAttachPingListener = false; // A contextual version of workInProgressRootRenderLanes. It is a superset of\n        // the lanes that we started working on at the root. When we enter a subtree\n        // that is currently hidden, we add the lanes that would have committed if\n        // the hidden tree hadn't been deferred. This is modified by the\n        // HiddenContext module.\n        //\n        // Most things in the work loop should deal with workInProgressRootRenderLanes.\n        // Most things in begin/complete phases should deal with entangledRenderLanes.\n        var entangledRenderLanes = NoLanes; // Whether to root completed, errored, suspended, etc.\n        var workInProgressRootExitStatus = RootInProgress; // The work left over by components that were visited during this render. Only\n        // includes unprocessed updates, not work in bailed out children.\n        var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\n        var workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).\n        var workInProgressRootPingedLanes = NoLanes; // If this lane scheduled deferred work, this is the lane of the deferred task.\n        var workInProgressDeferredLane = NoLane; // Errors that are thrown during the render phase.\n        var workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.\n        // We will log them once the tree commits.\n        var workInProgressRootRecoverableErrors = null; // Tracks when an update occurs during the render phase.\n        var workInProgressRootDidIncludeRecursiveRenderUpdate = false; // Thacks when an update occurs during the commit phase. It's a separate\n        // variable from the one for renders because the commit phase may run\n        // concurrently to a render phase.\n        var didIncludeCommitPhaseUpdate = false; // The most recent time we either committed a fallback, or when a fallback was\n        // filled in with the resolved UI. This lets us throttle the appearance of new\n        // content as it streams in, to minimize jank.\n        // TODO: Think of a better name for this variable?\n        var globalMostRecentFallbackTime = 0;\n        var FALLBACK_THROTTLE_MS = 300; // The absolute time for when we should start giving up on rendering\n        // more and prefer CPU suspense heuristics instead.\n        var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\n        // suspense heuristics and opt out of rendering more content.\n        var RENDER_TIMEOUT_MS = 500;\n        var workInProgressTransitions = null;\n        function resetRenderTimer() {\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n        }\n        function getRenderTargetTime() {\n            return workInProgressRootRenderTargetTime;\n        }\n        var legacyErrorBoundariesThatAlreadyFailed = null;\n        var rootDoesHavePassiveEffects = false;\n        var rootWithPendingPassiveEffects = null;\n        var pendingPassiveEffectsLanes = NoLanes;\n        var pendingPassiveProfilerEffects = [];\n        var pendingPassiveEffectsRemainingLanes = NoLanes;\n        var pendingPassiveTransitions = null; // Use these to prevent an infinite loop of nested updates\n        var NESTED_UPDATE_LIMIT = 50;\n        var nestedUpdateCount = 0;\n        var rootWithNestedUpdates = null;\n        var isFlushingPassiveEffects = false;\n        var didScheduleUpdateDuringPassiveEffects = false;\n        var NESTED_PASSIVE_UPDATE_LIMIT = 50;\n        var nestedPassiveUpdateCount = 0;\n        var rootWithPassiveNestedUpdates = null;\n        var isRunningInsertionEffect = false;\n        function getWorkInProgressRoot() {\n            return workInProgressRoot;\n        }\n        function getWorkInProgressRootRenderLanes() {\n            return workInProgressRootRenderLanes;\n        }\n        function isWorkLoopSuspendedOnData() {\n            return workInProgressSuspendedReason === SuspendedOnData;\n        }\n        function requestUpdateLane(fiber) {\n            if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n                // This is a render phase update. These are not officially supported. The\n                // old behavior is to give this the same \"thread\" (lanes) as\n                // whatever is currently rendering. So if you call `setState` on a component\n                // that happens later in the same render, it will flush. Ideally, we want to\n                // remove the special case and treat them as if they came from an\n                // interleaved event. Regardless, this pattern is not officially supported.\n                // This behavior is only a fallback. The flag only exists until we can roll\n                // out the setState warning, since existing code might accidentally rely on\n                // the current behavior.\n                return pickArbitraryLane(workInProgressRootRenderLanes);\n            }\n            var transition = requestCurrentTransition();\n            if (transition !== null) {\n                {\n                    if (!transition._updatedFibers) {\n                        transition._updatedFibers = new Set();\n                    }\n                    transition._updatedFibers.add(fiber);\n                }\n                var actionScopeLane = peekEntangledActionLane();\n                return actionScopeLane !== NoLane ? actionScopeLane : // is the first update in that scope. Either way, we need to get a\n                // fresh transition lane.\n                requestTransitionLane();\n            }\n            return eventPriorityToLane(resolveUpdatePriority());\n        }\n        function requestRetryLane(fiber) {\n            return claimNextRetryLane();\n        }\n        function requestDeferredLane() {\n            if (workInProgressDeferredLane === NoLane) {\n                // If there are multiple useDeferredValue hooks in the same render, the\n                // tasks that they spawn should all be batched together, so they should all\n                // receive the same lane.\n                // Check the priority of the current render to decide the priority of the\n                // deferred task.\n                // OffscreenLane is used for prerendering, but we also use OffscreenLane\n                // for incremental hydration. It's given the lowest priority because the\n                // initial HTML is the same as the final UI. But useDeferredValue during\n                // hydration is an exception — we need to upgrade the UI to the final\n                // value. So if we're currently hydrating, we treat it like a transition.\n                var isPrerendering = includesSomeLane(workInProgressRootRenderLanes, OffscreenLane) && !getIsHydrating();\n                if (isPrerendering) {\n                    // There's only one OffscreenLane, so if it contains deferred work, we\n                    // should just reschedule using the same lane.\n                    workInProgressDeferredLane = OffscreenLane;\n                } else {\n                    // Everything else is spawned as a transition.\n                    workInProgressDeferredLane = claimNextTransitionLane();\n                }\n            } // Mark the parent Suspense boundary so it knows to spawn the deferred lane.\n            var suspenseHandler = getSuspenseHandler();\n            if (suspenseHandler !== null) {\n                // TODO: As an optimization, we shouldn't entangle the lanes at the root; we\n                // can entangle them using the baseLanes of the Suspense boundary instead.\n                // We only need to do something special if there's no Suspense boundary.\n                suspenseHandler.flags |= DidDefer;\n            }\n            return workInProgressDeferredLane;\n        }\n        function peekDeferredLane() {\n            return workInProgressDeferredLane;\n        }\n        function scheduleUpdateOnFiber(root, fiber, lane) {\n            {\n                if (isRunningInsertionEffect) {\n                    error('useInsertionEffect must not schedule updates.');\n                }\n            }\n            {\n                if (isFlushingPassiveEffects) {\n                    didScheduleUpdateDuringPassiveEffects = true;\n                }\n            }\n            // finish loading.\n            if (root === workInProgressRoot && workInProgressSuspendedReason === SuspendedOnData || // Suspended commit phase\n            root.cancelPendingCommit !== null) {\n                // The incoming update might unblock the current render. Interrupt the\n                // current attempt and restart from the top.\n                prepareFreshStack(root, NoLanes);\n                markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane);\n            } // Mark that the root has a pending update.\n            markRootUpdated(root, lane);\n            if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {\n                // This update was dispatched during the render phase. This is a mistake\n                // if the update originates from user space (with the exception of local\n                // hook updates, which are handled differently and don't reach this\n                // function), but there are some internal React features that use this as\n                // an implementation detail, like selective hydration.\n                warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase\n            } else {\n                // This is a normal update, scheduled from outside the render phase. For\n                // example, during an input event.\n                {\n                    if (isDevToolsPresent) {\n                        addFiberToLanesMap(root, fiber, lane);\n                    }\n                }\n                warnIfUpdatesNotWrappedWithActDEV(fiber);\n                if (root === workInProgressRoot) {\n                    // Received an update to a tree that's in the middle of rendering. Mark\n                    // that there was an interleaved update work on this root.\n                    if ((executionContext & RenderContext) === NoContext) {\n                        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n                    }\n                    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n                        // The root already suspended with a delay, which means this render\n                        // definitely won't finish. Since we have a new update, let's mark it as\n                        // suspended now, right before marking the incoming update. This has the\n                        // effect of interrupting the current render and switching to the update.\n                        // TODO: Make sure this doesn't override pings that happen while we've\n                        // already started rendering.\n                        markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane);\n                    }\n                }\n                ensureRootIsScheduled(root);\n                if (lane === SyncLane && executionContext === NoContext && !disableLegacyMode && (fiber.mode & ConcurrentMode) === NoMode) {\n                    if (ReactSharedInternals.isBatchingLegacy) ;\n                    else {\n                        // Flush the synchronous work now, unless we're already working or inside\n                        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n                        // scheduleCallbackForFiber to preserve the ability to schedule a callback\n                        // without immediately flushing it. We only do this for user-initiated\n                        // updates, to preserve historical behavior of legacy mode.\n                        resetRenderTimer();\n                    }\n                }\n            }\n        }\n        function scheduleInitialHydrationOnRoot(root, lane) {\n            // This is a special fork of scheduleUpdateOnFiber that is only used to\n            // schedule the initial hydration of a root that has just been created. Most\n            // of the stuff in scheduleUpdateOnFiber can be skipped.\n            //\n            // The main reason for this separate path, though, is to distinguish the\n            // initial children from subsequent updates. In fully client-rendered roots\n            // (createRoot instead of hydrateRoot), all top-level renders are modeled as\n            // updates, but hydration roots are special because the initial render must\n            // match what was rendered on the server.\n            var current = root.current;\n            current.lanes = lane;\n            markRootUpdated(root, lane);\n            ensureRootIsScheduled(root);\n        }\n        function isUnsafeClassRenderPhaseUpdate(fiber) {\n            // Check if this is a render phase update. Only called by class components,\n            // which special (deprecated) behavior for UNSAFE_componentWillReceive props.\n            return (executionContext & RenderContext) !== NoContext;\n        } // This is the entry point for every concurrent task, i.e. anything that\n        // goes through Scheduler.\n        function performConcurrentWorkOnRoot(root, didTimeout) {\n            {\n                resetNestedUpdateFlag();\n            }\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Should not already be working.');\n            } // Flush any pending passive effects before deciding which lanes to work on,\n            // in case they schedule additional work.\n            var originalCallbackNode = root.callbackNode;\n            var didFlushPassiveEffects = flushPassiveEffects();\n            if (didFlushPassiveEffects) {\n                // Something in the passive effect phase may have canceled the current task.\n                // Check if the task node for this root was changed.\n                if (root.callbackNode !== originalCallbackNode) {\n                    // The current task was canceled. Exit. We don't need to call\n                    // `ensureRootIsScheduled` because the check above implies either that\n                    // there's a new task, or that there's no remaining work on this root.\n                    return null;\n                }\n            } // Determine the next lanes to work on, using the fields stored\n            // on the root.\n            // TODO: This was already computed in the caller. Pass it as an argument.\n            var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n            if (lanes === NoLanes) {\n                // Defensive coding. This is never expected to happen.\n                return null;\n            } // We disable time-slicing in some cases: if the work has been CPU-bound\n            // for too long (\"expired\" work, to prevent starvation), or we're in\n            // sync-updates-by-default mode.\n            // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n            // bug we're still investigating. Once the bug in Scheduler is fixed,\n            // we can remove this, since we track expiration ourselves.\n            var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && !didTimeout;\n            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);\n            if (exitStatus !== RootInProgress) {\n                var renderWasConcurrent = shouldTimeSlice;\n                do {\n                    if (exitStatus === RootDidNotComplete) {\n                        // The render unwound without completing the tree. This happens in special\n                        // cases where need to exit the current render without producing a\n                        // consistent tree or committing.\n                        markRootSuspended(root, lanes, NoLane);\n                    } else {\n                        // The render completed.\n                        // Check if this render may have yielded to a concurrent event, and if so,\n                        // confirm that any newly rendered stores are consistent.\n                        // TODO: It's possible that even a concurrent render may never have yielded\n                        // to the main thread, if it was fast enough, or if it expired. We could\n                        // skip the consistency check in that case, too.\n                        var finishedWork = root.current.alternate;\n                        if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n                            // A store was mutated in an interleaved event. Render again,\n                            // synchronously, to block further mutations.\n                            exitStatus = renderRootSync(root, lanes); // We assume the tree is now consistent because we didn't yield to any\n                            // concurrent events.\n                            renderWasConcurrent = false; // Need to check the exit status again.\n                            continue;\n                        } // Check if something threw\n                        if (exitStatus === RootErrored) {\n                            var lanesThatJustErrored = lanes;\n                            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root, lanesThatJustErrored);\n                            if (errorRetryLanes !== NoLanes) {\n                                lanes = errorRetryLanes;\n                                exitStatus = recoverFromConcurrentError(root, lanesThatJustErrored, errorRetryLanes);\n                                renderWasConcurrent = false; // Need to check the exit status again.\n                                if (exitStatus !== RootErrored) {\n                                    continue;\n                                }\n                            }\n                        }\n                        if (exitStatus === RootFatalErrored) {\n                            prepareFreshStack(root, NoLanes);\n                            markRootSuspended(root, lanes, NoLane);\n                            break;\n                        } // We now have a consistent tree. The next step is either to commit it,\n                        // or, if something suspended, wait to commit it after a timeout.\n                        root.finishedWork = finishedWork;\n                        root.finishedLanes = lanes;\n                        finishConcurrentRender(root, exitStatus, finishedWork, lanes);\n                    }\n                    break;\n                }while (true);\n            }\n            ensureRootIsScheduled(root);\n            return getContinuationForRoot(root, originalCallbackNode);\n        }\n        function recoverFromConcurrentError(root, originallyAttemptedLanes, errorRetryLanes) {\n            // If an error occurred during hydration, discard server response and fall\n            // back to client side render.\n            // Before rendering again, save the errors from the previous attempt.\n            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n            var wasRootDehydrated = supportsHydration && isRootDehydrated(root);\n            if (wasRootDehydrated) {\n                // The shell failed to hydrate. Set a flag to force a client rendering\n                // during the next attempt. To do this, we call prepareFreshStack now\n                // to create the root work-in-progress fiber. This is a bit weird in terms\n                // of factoring, because it relies on renderRootSync not calling\n                // prepareFreshStack again in the call below, which happens because the\n                // root and lanes haven't changed.\n                //\n                // TODO: I think what we should do is set ForceClientRender inside\n                // throwException, like we do for nested Suspense boundaries. The reason\n                // it's here instead is so we can switch to the synchronous work loop, too.\n                // Something to consider for a future refactor.\n                var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\n                rootWorkInProgress.flags |= ForceClientRender;\n            }\n            var exitStatus = renderRootSync(root, errorRetryLanes);\n            if (exitStatus !== RootErrored) {\n                // Successfully finished rendering on retry\n                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {\n                    // During the synchronous render, we attached additional ping listeners.\n                    // This is highly suggestive of an uncached promise (though it's not the\n                    // only reason this would happen). If it was an uncached promise, then\n                    // it may have masked a downstream error from ocurring without actually\n                    // fixing it. Example:\n                    //\n                    //    use(Promise.resolve('uncached'))\n                    //    throw new Error('Oops!')\n                    //\n                    // When this happens, there's a conflict between blocking potential\n                    // concurrent data races and unwrapping uncached promise values. We\n                    // have to choose one or the other. Because the data race recovery is\n                    // a last ditch effort, we'll disable it.\n                    root.errorRecoveryDisabledLanes = mergeLanes(root.errorRecoveryDisabledLanes, originallyAttemptedLanes); // Mark the current render as suspended and force it to restart. Once\n                    // these lanes finish successfully, we'll re-enable the error recovery\n                    // mechanism for subsequent updates.\n                    workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes;\n                    return RootSuspendedWithDelay;\n                } // The errors from the failed first attempt have been recovered. Add\n                // them to the collection of recoverable errors. We'll log them in the\n                // commit phase.\n                var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n                workInProgressRootRecoverableErrors = errorsFromFirstAttempt; // The errors from the second attempt should be queued after the errors\n                // from the first attempt, to preserve the causal sequence.\n                if (errorsFromSecondAttempt !== null) {\n                    queueRecoverableErrors(errorsFromSecondAttempt);\n                }\n            }\n            return exitStatus;\n        }\n        function queueRecoverableErrors(errors) {\n            if (workInProgressRootRecoverableErrors === null) {\n                workInProgressRootRecoverableErrors = errors;\n            } else {\n                // $FlowFixMe[method-unbinding]\n                workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n            }\n        }\n        function finishConcurrentRender(root, exitStatus, finishedWork, lanes) {\n            // TODO: The fact that most of these branches are identical suggests that some\n            // of the exit statuses are not best modeled as exit statuses and should be\n            // tracked orthogonally.\n            switch(exitStatus){\n                case RootInProgress:\n                case RootFatalErrored:\n                    {\n                        throw new Error('Root did not complete. This is a bug in React.');\n                    }\n                case RootSuspendedWithDelay:\n                    {\n                        if (includesOnlyTransitions(lanes)) {\n                            // This is a transition, so we should exit without committing a\n                            // placeholder and without scheduling a timeout. Delay indefinitely\n                            // until we receive more data.\n                            markRootSuspended(root, lanes, workInProgressDeferredLane);\n                            return;\n                        } // Commit the placeholder.\n                        break;\n                    }\n                case RootErrored:\n                    {\n                        // This render errored. Ignore any recoverable errors because we weren't actually\n                        // able to recover. Instead, whatever the final errors were is the ones we log.\n                        // This ensures that we only log the actual client side error if it's just a plain\n                        // error thrown from a component on the server and the client.\n                        workInProgressRootRecoverableErrors = null;\n                        break;\n                    }\n                case RootSuspended:\n                case RootCompleted:\n                    {\n                        break;\n                    }\n                default:\n                    {\n                        throw new Error('Unknown root exit status.');\n                    }\n            }\n            if (shouldForceFlushFallbacksInDEV()) {\n                // We're inside an `act` scope. Commit immediately.\n                commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane);\n            } else {\n                if (includesOnlyRetries(lanes) && alwaysThrottleRetries) {\n                    // This render only included retries, no updates. Throttle committing\n                    // retries so that we don't show too many loading states too quickly.\n                    var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(); // Don't bother with a very short suspense time.\n                    if (msUntilTimeout > 10) {\n                        markRootSuspended(root, lanes, workInProgressDeferredLane);\n                        var nextLanes = getNextLanes(root, NoLanes);\n                        if (nextLanes !== NoLanes) {\n                            // There's additional work we can do on this root. We might as well\n                            // attempt to work on that while we're suspended.\n                            return;\n                        } // The render is suspended, it hasn't timed out, and there's no\n                        // lower priority work to do. Instead of committing the fallback\n                        // immediately, wait for more data to arrive.\n                        // TODO: Combine retry throttling with Suspensey commits. Right now they\n                        // run one after the other.\n                        root.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, root, finishedWork, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane), msUntilTimeout);\n                        return;\n                    }\n                }\n                commitRootWhenReady(root, finishedWork, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane);\n            }\n        }\n        function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane) {\n            // TODO: Combine retry throttling with Suspensey commits. Right now they run\n            // one after the other.\n            var BothVisibilityAndMaySuspendCommit = Visibility | MaySuspendCommit;\n            var subtreeFlags = finishedWork.subtreeFlags;\n            if (subtreeFlags & ShouldSuspendCommit || (subtreeFlags & BothVisibilityAndMaySuspendCommit) === BothVisibilityAndMaySuspendCommit) {\n                // Before committing, ask the renderer whether the host tree is ready.\n                // If it's not, we'll wait until it notifies us.\n                startSuspendingCommit(); // This will walk the completed fiber tree and attach listeners to all\n                // the suspensey resources. The renderer is responsible for accumulating\n                // all the load events. This all happens in a single synchronous\n                // transaction, so it track state in its own module scope.\n                accumulateSuspenseyCommit(finishedWork); // At the end, ask the renderer if it's ready to commit, or if we should\n                // suspend. If it's not ready, it will return a callback to subscribe to\n                // a ready event.\n                var schedulePendingCommit = waitForCommitToBeReady();\n                if (schedulePendingCommit !== null) {\n                    // NOTE: waitForCommitToBeReady returns a subscribe function so that we\n                    // only allocate a function if the commit isn't ready yet. The other\n                    // pattern would be to always pass a callback to waitForCommitToBeReady.\n                    // Not yet ready to commit. Delay the commit until the renderer notifies\n                    // us that it's ready. This will be canceled if we start work on the\n                    // root again.\n                    root.cancelPendingCommit = schedulePendingCommit(commitRoot.bind(null, root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate));\n                    markRootSuspended(root, lanes, spawnedLane);\n                    return;\n                }\n            } // Otherwise, commit immediately.\n            commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane);\n        }\n        function isRenderConsistentWithExternalStores(finishedWork) {\n            // Search the rendered tree for external store reads, and check whether the\n            // stores were mutated in a concurrent event. Intentionally using an iterative\n            // loop instead of recursion so we can exit early.\n            var node = finishedWork;\n            while(true){\n                if (node.flags & StoreConsistency) {\n                    var updateQueue = node.updateQueue;\n                    if (updateQueue !== null) {\n                        var checks = updateQueue.stores;\n                        if (checks !== null) {\n                            for(var i = 0; i < checks.length; i++){\n                                var check = checks[i];\n                                var getSnapshot = check.getSnapshot;\n                                var renderedValue = check.value;\n                                try {\n                                    if (!objectIs(getSnapshot(), renderedValue)) {\n                                        // Found an inconsistent store.\n                                        return false;\n                                    }\n                                } catch (error) {\n                                    // If `getSnapshot` throws, return `false`. This will schedule\n                                    // a re-render, and the error will be rethrown during render.\n                                    return false;\n                                }\n                            }\n                        }\n                    }\n                }\n                var child = node.child;\n                if (node.subtreeFlags & StoreConsistency && child !== null) {\n                    child.return = node;\n                    node = child;\n                    continue;\n                }\n                if (node === finishedWork) {\n                    return true;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === finishedWork) {\n                        return true;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            } // Flow doesn't know this is unreachable, but eslint does\n            // eslint-disable-next-line no-unreachable\n            return true;\n        } // The extra indirections around markRootUpdated and markRootSuspended is\n        // needed to avoid a circular dependency between this module and\n        // ReactFiberLane. There's probably a better way to split up these modules and\n        // avoid this problem. Perhaps all the root-marking functions should move into\n        // the work loop.\n        function markRootUpdated(root, updatedLanes) {\n            markRootUpdated$1(root, updatedLanes);\n            {\n                // Check for recursive updates\n                if (executionContext & RenderContext) {\n                    workInProgressRootDidIncludeRecursiveRenderUpdate = true;\n                } else if (executionContext & CommitContext) {\n                    didIncludeCommitPhaseUpdate = true;\n                }\n                throwIfInfiniteUpdateLoopDetected();\n            }\n        }\n        function markRootPinged(root, pingedLanes) {\n            markRootPinged$1(root, pingedLanes);\n            {\n                // Check for recursive pings. Pings are conceptually different from updates in\n                // other contexts but we call it an \"update\" in this context because\n                // repeatedly pinging a suspended render can cause a recursive render loop.\n                // The relevant property is that it can result in a new render attempt\n                // being scheduled.\n                if (executionContext & RenderContext) {\n                    workInProgressRootDidIncludeRecursiveRenderUpdate = true;\n                } else if (executionContext & CommitContext) {\n                    didIncludeCommitPhaseUpdate = true;\n                }\n                throwIfInfiniteUpdateLoopDetected();\n            }\n        }\n        function markRootSuspended(root, suspendedLanes, spawnedLane) {\n            // When suspending, we should always exclude lanes that were pinged or (more\n            // rarely, since we try to avoid it) updated during the render phase.\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n            markRootSuspended$1(root, suspendedLanes, spawnedLane);\n        } // This is the entry point for synchronous tasks that don't go\n        // through Scheduler\n        function performSyncWorkOnRoot(root, lanes) {\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Should not already be working.');\n            }\n            var didFlushPassiveEffects = flushPassiveEffects();\n            if (didFlushPassiveEffects) {\n                // If passive effects were flushed, exit to the outer work loop in the root\n                // scheduler, so we can recompute the priority.\n                // TODO: We don't actually need this `ensureRootIsScheduled` call because\n                // this path is only reachable if the root is already part of the schedule.\n                // I'm including it only for consistency with the other exit points from\n                // this function. Can address in a subsequent refactor.\n                ensureRootIsScheduled(root);\n                return null;\n            }\n            {\n                syncNestedUpdateFlag();\n            }\n            var exitStatus = renderRootSync(root, lanes);\n            if (exitStatus === RootErrored) {\n                // If something threw an error, try rendering one more time. We'll render\n                // synchronously to block concurrent data mutations, and we'll includes\n                // all pending updates are included. If it still fails after the second\n                // attempt, we'll give up and commit the resulting tree.\n                var originallyAttemptedLanes = lanes;\n                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root, originallyAttemptedLanes);\n                if (errorRetryLanes !== NoLanes) {\n                    lanes = errorRetryLanes;\n                    exitStatus = recoverFromConcurrentError(root, originallyAttemptedLanes, errorRetryLanes);\n                }\n            }\n            if (exitStatus === RootFatalErrored) {\n                prepareFreshStack(root, NoLanes);\n                markRootSuspended(root, lanes, NoLane);\n                ensureRootIsScheduled(root);\n                return null;\n            }\n            if (exitStatus === RootDidNotComplete) {\n                // The render unwound without completing the tree. This happens in special\n                // cases where need to exit the current render without producing a\n                // consistent tree or committing.\n                markRootSuspended(root, lanes, workInProgressDeferredLane);\n                ensureRootIsScheduled(root);\n                return null;\n            } // We now have a consistent tree. Because this is a sync render, we\n            // will commit it even if something suspended.\n            var finishedWork = root.current.alternate;\n            root.finishedWork = finishedWork;\n            root.finishedLanes = lanes;\n            commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane); // Before exiting, make sure there's a callback scheduled for the next\n            // pending level.\n            ensureRootIsScheduled(root);\n            return null;\n        }\n        function flushRoot(root, lanes) {\n            if (lanes !== NoLanes) {\n                upgradePendingLanesToSync(root, lanes);\n                ensureRootIsScheduled(root);\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    resetRenderTimer(); // TODO: For historical reasons this flushes all sync work across all\n                    // roots. It shouldn't really matter either way, but we could change this\n                    // to only flush the given root.\n                    flushSyncWorkOnAllRoots();\n                }\n            }\n        }\n        function getExecutionContext() {\n            return executionContext;\n        }\n        function deferredUpdates(fn) {\n            var prevTransition = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DefaultEventPriority);\n                ReactSharedInternals.T = null;\n                return fn();\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n            }\n        }\n        function batchedUpdates(fn, a) {\n            {\n                // batchedUpdates is a no-op now, but there's still some internal react-dom\n                // code calling it, that we can't remove until we remove legacy mode.\n                return fn(a);\n            }\n        }\n        function discreteUpdates(fn, a, b, c, d) {\n            var prevTransition = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                ReactSharedInternals.T = null;\n                return fn(a, b, c, d);\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n                if (executionContext === NoContext) {\n                    resetRenderTimer();\n                }\n            }\n        } // Overload the definition to the two valid signatures.\n        // Warning, this opts-out of checking the function body.\n        // eslint-disable-next-line no-unused-vars\n        // eslint-disable-next-line no-redeclare\n        // eslint-disable-next-line no-redeclare\n        function flushSyncFromReconciler(fn) {\n            // In legacy mode, we flush pending passive effects at the beginning of the\n            // next event, not at the end of the previous one.\n            if (rootWithPendingPassiveEffects !== null && !disableLegacyMode && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n                flushPassiveEffects();\n            }\n            var prevExecutionContext = executionContext;\n            executionContext |= BatchedContext;\n            var prevTransition = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                ReactSharedInternals.T = null;\n                if (fn) {\n                    return fn();\n                } else {\n                    return undefined;\n                }\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n                executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n                // Note that this will happen even if batchedUpdates is higher up\n                // the stack.\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    flushSyncWorkOnAllRoots();\n                }\n            }\n        } // If called outside of a render or commit will flush all sync work on all roots\n        // Returns whether the the call was during a render or not\n        function flushSyncWork() {\n            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                flushSyncWorkOnAllRoots();\n                return false;\n            }\n            return true;\n        }\n        function isAlreadyRendering() {\n            // Used by the renderer to print a warning if certain APIs are called from\n            // the wrong context.\n            return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n        }\n        // hidden subtree. The stack logic is managed there because that's the only\n        // place that ever modifies it. Which module it lives in doesn't matter for\n        // performance because this function will get inlined regardless\n        function setEntangledRenderLanes(newEntangledRenderLanes) {\n            entangledRenderLanes = newEntangledRenderLanes;\n        }\n        function getEntangledRenderLanes() {\n            return entangledRenderLanes;\n        }\n        function resetWorkInProgressStack() {\n            if (workInProgress === null) return;\n            var interruptedWork;\n            if (workInProgressSuspendedReason === NotSuspended) {\n                // Normal case. Work-in-progress hasn't started yet. Unwind all\n                // its parents.\n                interruptedWork = workInProgress.return;\n            } else {\n                // Work-in-progress is in suspended state. Reset the work loop and unwind\n                // both the suspended fiber and all its parents.\n                resetSuspendedWorkLoopOnUnwind(workInProgress);\n                interruptedWork = workInProgress;\n            }\n            while(interruptedWork !== null){\n                var current = interruptedWork.alternate;\n                unwindInterruptedWork(current, interruptedWork);\n                interruptedWork = interruptedWork.return;\n            }\n            workInProgress = null;\n        }\n        function prepareFreshStack(root, lanes) {\n            root.finishedWork = null;\n            root.finishedLanes = NoLanes;\n            var timeoutHandle = root.timeoutHandle;\n            if (timeoutHandle !== noTimeout) {\n                // The root previous suspended and scheduled a timeout to commit a fallback\n                // state. Now that we have additional work, cancel the timeout.\n                root.timeoutHandle = noTimeout; // $FlowFixMe[incompatible-call] Complains noTimeout is not a TimeoutID, despite the check above\n                cancelTimeout(timeoutHandle);\n            }\n            var cancelPendingCommit = root.cancelPendingCommit;\n            if (cancelPendingCommit !== null) {\n                root.cancelPendingCommit = null;\n                cancelPendingCommit();\n            }\n            resetWorkInProgressStack();\n            workInProgressRoot = root;\n            var rootWorkInProgress = createWorkInProgress(root.current, null);\n            workInProgress = rootWorkInProgress;\n            workInProgressRootRenderLanes = lanes;\n            workInProgressSuspendedReason = NotSuspended;\n            workInProgressThrownValue = null;\n            workInProgressRootDidAttachPingListener = false;\n            workInProgressRootExitStatus = RootInProgress;\n            workInProgressRootSkippedLanes = NoLanes;\n            workInProgressRootInterleavedUpdatedLanes = NoLanes;\n            workInProgressRootPingedLanes = NoLanes;\n            workInProgressDeferredLane = NoLane;\n            workInProgressRootConcurrentErrors = null;\n            workInProgressRootRecoverableErrors = null;\n            workInProgressRootDidIncludeRecursiveRenderUpdate = false; // Get the lanes that are entangled with whatever we're about to render. We\n            // track these separately so we can distinguish the priority of the render\n            // task from the priority of the lanes it is entangled with. For example, a\n            // transition may not be allowed to finish unless it includes the Sync lane,\n            // which is currently suspended. We should be able to render the Transition\n            // and Sync lane in the same batch, but at Transition priority, because the\n            // Sync lane already suspended.\n            entangledRenderLanes = getEntangledLanes(root, lanes);\n            finishQueueingConcurrentUpdates();\n            {\n                ReactStrictModeWarnings.discardPendingWarnings();\n            }\n            return rootWorkInProgress;\n        }\n        function resetSuspendedWorkLoopOnUnwind(fiber) {\n            // Reset module-level state that was set during the render phase.\n            resetContextDependencies();\n            resetHooksOnUnwind(fiber);\n            resetChildReconcilerOnUnwind();\n        }\n        function handleThrow(root, thrownValue) {\n            // A component threw an exception. Usually this is because it suspended, but\n            // it also includes regular program errors.\n            //\n            // We're either going to unwind the stack to show a Suspense or error\n            // boundary, or we're going to replay the component again. Like after a\n            // promise resolves.\n            //\n            // Until we decide whether we're going to unwind or replay, we should preserve\n            // the current state of the work loop without resetting anything.\n            //\n            // If we do decide to unwind the stack, module-level variables will be reset\n            // in resetSuspendedWorkLoopOnUnwind.\n            // These should be reset immediately because they're only supposed to be set\n            // when React is executing user code.\n            resetHooksAfterThrow();\n            {\n                resetCurrentFiber();\n            }\n            if (thrownValue === SuspenseException) {\n                // This is a special type of exception used for Suspense. For historical\n                // reasons, the rest of the Suspense implementation expects the thrown value\n                // to be a thenable, because before `use` existed that was the (unstable)\n                // API for suspending. This implementation detail can change later, once we\n                // deprecate the old API in favor of `use`.\n                thrownValue = getSuspendedThenable();\n                workInProgressSuspendedReason = shouldRemainOnPreviousScreen() && // Check if there are other pending updates that might possibly unblock this\n                // component from suspending. This mirrors the check in\n                // renderDidSuspendDelayIfPossible. We should attempt to unify them somehow.\n                // TODO: Consider unwinding immediately, using the\n                // SuspendedOnHydration mechanism.\n                !includesNonIdleWork(workInProgressRootSkippedLanes) && !includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes) ? SuspendedOnData : // immediately resolved (i.e. in a microtask). Otherwise, trigger the\n                // nearest Suspense fallback.\n                SuspendedOnImmediate;\n            } else if (thrownValue === SuspenseyCommitException) {\n                thrownValue = getSuspendedThenable();\n                workInProgressSuspendedReason = SuspendedOnInstance;\n            } else if (thrownValue === SelectiveHydrationException) {\n                // An update flowed into a dehydrated boundary. Before we can apply the\n                // update, we need to finish hydrating. Interrupt the work-in-progress\n                // render so we can restart at the hydration lane.\n                //\n                // The ideal implementation would be able to switch contexts without\n                // unwinding the current stack.\n                //\n                // We could name this something more general but as of now it's the only\n                // case where we think this should happen.\n                workInProgressSuspendedReason = SuspendedOnHydration;\n            } else {\n                // This is a regular error.\n                var isWakeable = thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function';\n                workInProgressSuspendedReason = isWakeable ? // This has slightly different behavior than suspending with `use`.\n                SuspendedOnDeprecatedThrowPromise : // suspended, we must clear the thenable state to unblock the work loop.\n                SuspendedOnError;\n            }\n            workInProgressThrownValue = thrownValue;\n            var erroredWork = workInProgress;\n            if (erroredWork === null) {\n                // This is a fatal error\n                workInProgressRootExitStatus = RootFatalErrored;\n                logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n                return;\n            }\n            if (erroredWork.mode & ProfileMode) {\n                // Record the time spent rendering before an error was thrown. This\n                // avoids inaccurate Profiler durations in the case of a\n                // suspended render.\n                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n            }\n            {\n                markComponentRenderStopped();\n                switch(workInProgressSuspendedReason){\n                    case SuspendedOnError:\n                        {\n                            markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                            break;\n                        }\n                    case SuspendedOnData:\n                    case SuspendedOnImmediate:\n                    case SuspendedOnDeprecatedThrowPromise:\n                    case SuspendedAndReadyToContinue:\n                        {\n                            var wakeable = thrownValue;\n                            markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n                            break;\n                        }\n                }\n            }\n        }\n        function shouldRemainOnPreviousScreen() {\n            // This is asking whether it's better to suspend the transition and remain\n            // on the previous screen, versus showing a fallback as soon as possible. It\n            // takes into account both the priority of render and also whether showing a\n            // fallback would produce a desirable user experience.\n            var handler = getSuspenseHandler();\n            if (handler === null) {\n                // There's no Suspense boundary that can provide a fallback. We have no\n                // choice but to remain on the previous screen.\n                // NOTE: We do this even for sync updates, for lack of any better option. In\n                // the future, we may change how we handle this, like by putting the whole\n                // root into a \"detached\" mode.\n                return true;\n            } // TODO: Once `use` has fully replaced the `throw promise` pattern, we should\n            // be able to remove the equivalent check in finishConcurrentRender, and rely\n            // just on this one.\n            if (includesOnlyTransitions(workInProgressRootRenderLanes)) {\n                if (getShellBoundary() === null) {\n                    // We're rendering inside the \"shell\" of the app. Activating the nearest\n                    // fallback would cause visible content to disappear. It's better to\n                    // suspend the transition and remain on the previous screen.\n                    return true;\n                } else {\n                    // We're rendering content that wasn't part of the previous screen.\n                    // Rather than block the transition, it's better to show a fallback as\n                    // soon as possible. The appearance of any nested fallbacks will be\n                    // throttled to avoid jank.\n                    return false;\n                }\n            }\n            if (includesOnlyRetries(workInProgressRootRenderLanes) || // In this context, an OffscreenLane counts as a Retry\n            // TODO: It's become increasingly clear that Retries and Offscreen are\n            // deeply connected. They probably can be unified further.\n            includesSomeLane(workInProgressRootRenderLanes, OffscreenLane)) {\n                // During a retry, we can suspend rendering if the nearest Suspense boundary\n                // is the boundary of the \"shell\", because we're guaranteed not to block\n                // any new content from appearing.\n                //\n                // The reason we must check if this is a retry is because it guarantees\n                // that suspending the work loop won't block an actual update, because\n                // retries don't \"update\" anything; they fill in fallbacks that were left\n                // behind by a previous transition.\n                return handler === getShellBoundary();\n            } // For all other Lanes besides Transitions and Retries, we should not wait\n            // for the data to load.\n            return false;\n        }\n        function pushDispatcher(container) {\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = ContextOnlyDispatcher;\n            if (prevDispatcher === null) {\n                // The React isomorphic package does not include a default dispatcher.\n                // Instead the first renderer will lazily attach one, in order to give\n                // nicer error messages.\n                return ContextOnlyDispatcher;\n            } else {\n                return prevDispatcher;\n            }\n        }\n        function popDispatcher(prevDispatcher) {\n            ReactSharedInternals.H = prevDispatcher;\n        }\n        function pushAsyncDispatcher() {\n            {\n                var prevAsyncDispatcher = ReactSharedInternals.A;\n                ReactSharedInternals.A = DefaultAsyncDispatcher;\n                return prevAsyncDispatcher;\n            }\n        }\n        function popAsyncDispatcher(prevAsyncDispatcher) {\n            {\n                ReactSharedInternals.A = prevAsyncDispatcher;\n            }\n        }\n        function markCommitTimeOfFallback() {\n            globalMostRecentFallbackTime = now$1();\n        }\n        function markSkippedUpdateLanes(lane) {\n            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n        }\n        function renderDidSuspend() {\n            if (workInProgressRootExitStatus === RootInProgress) {\n                workInProgressRootExitStatus = RootSuspended;\n            }\n        }\n        function renderDidSuspendDelayIfPossible() {\n            workInProgressRootExitStatus = RootSuspendedWithDelay; // Check if there are updates that we skipped tree that might have unblocked\n            // this render.\n            if ((includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes)) && workInProgressRoot !== null) {\n                // Mark the current render as suspended so that we switch to working on\n                // the updates that were skipped. Usually we only suspend at the end of\n                // the render phase.\n                // TODO: We should probably always mark the root as suspended immediately\n                // (inside this function), since by suspending at the end of the render\n                // phase introduces a potential mistake where we suspend lanes that were\n                // pinged or updated while we were rendering.\n                // TODO: Consider unwinding immediately, using the\n                // SuspendedOnHydration mechanism.\n                markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane);\n            }\n        }\n        function renderDidError() {\n            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n                workInProgressRootExitStatus = RootErrored;\n            }\n        }\n        function queueConcurrentError(error) {\n            if (workInProgressRootConcurrentErrors === null) {\n                workInProgressRootConcurrentErrors = [\n                    error\n                ];\n            } else {\n                workInProgressRootConcurrentErrors.push(error);\n            }\n        } // Called during render to determine if anything has suspended.\n        // Returns false if we're not sure.\n        function renderHasNotSuspendedYet() {\n            // If something errored or completed, we can't really be sure,\n            // so those are false.\n            return workInProgressRootExitStatus === RootInProgress;\n        } // TODO: Over time, this function and renderRootConcurrent have become more\n        // and more similar. Not sure it makes sense to maintain forked paths. Consider\n        // unifying them again.\n        function renderRootSync(root, lanes) {\n            var prevExecutionContext = executionContext;\n            executionContext |= RenderContext;\n            var prevDispatcher = pushDispatcher();\n            var prevAsyncDispatcher = pushAsyncDispatcher(); // If the root or lanes have changed, throw out the existing stack\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n                {\n                    if (isDevToolsPresent) {\n                        var memoizedUpdaters = root.memoizedUpdaters;\n                        if (memoizedUpdaters.size > 0) {\n                            restorePendingUpdaters(root, workInProgressRootRenderLanes);\n                            memoizedUpdaters.clear();\n                        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n                        // If we bailout on this work, we'll move them back (like above).\n                        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n                        // That way we can keep the current update and future updates separate.\n                        movePendingFibersToMemoized(root, lanes);\n                    }\n                }\n                workInProgressTransitions = getTransitionsForLanes();\n                prepareFreshStack(root, lanes);\n            }\n            {\n                markRenderStarted(lanes);\n            }\n            var didSuspendInShell = false;\n            outer: do {\n                try {\n                    if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {\n                        // The work loop is suspended. During a synchronous render, we don't\n                        // yield to the main thread. Immediately unwind the stack. This will\n                        // trigger either a fallback or an error boundary.\n                        // TODO: For discrete and \"default\" updates (anything that's not\n                        // flushSync), we want to wait for the microtasks the flush before\n                        // unwinding. Will probably implement this using renderRootConcurrent,\n                        // or merge renderRootSync and renderRootConcurrent into the same\n                        // function and fork the behavior some other way.\n                        var unitOfWork = workInProgress;\n                        var thrownValue = workInProgressThrownValue;\n                        switch(workInProgressSuspendedReason){\n                            case SuspendedOnHydration:\n                                {\n                                    // Selective hydration. An update flowed into a dehydrated tree.\n                                    // Interrupt the current render so the work loop can switch to the\n                                    // hydration lane.\n                                    resetWorkInProgressStack();\n                                    workInProgressRootExitStatus = RootDidNotComplete;\n                                    break outer;\n                                }\n                            case SuspendedOnImmediate:\n                            case SuspendedOnData:\n                                {\n                                    if (!didSuspendInShell && getSuspenseHandler() === null) {\n                                        didSuspendInShell = true;\n                                    } // Intentional fallthrough\n                                }\n                            default:\n                                {\n                                    // Unwind then continue with the normal work loop.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                        }\n                    }\n                    workLoopSync();\n                    break;\n                } catch (thrownValue) {\n                    handleThrow(root, thrownValue);\n                }\n            }while (true); // Check if something suspended in the shell. We use this to detect an\n            // infinite ping loop caused by an uncached promise.\n            //\n            // Only increment this counter once per synchronous render attempt across the\n            // whole tree. Even if there are many sibling components that suspend, this\n            // counter only gets incremented once.\n            if (didSuspendInShell) {\n                root.shellSuspendCounter++;\n            }\n            resetContextDependencies();\n            executionContext = prevExecutionContext;\n            popDispatcher(prevDispatcher);\n            popAsyncDispatcher(prevAsyncDispatcher);\n            if (workInProgress !== null) {\n                // This is a sync render, so we should have finished the whole tree.\n                throw new Error('Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');\n            }\n            {\n                markRenderStopped();\n            }\n            workInProgressRoot = null;\n            workInProgressRootRenderLanes = NoLanes; // It's safe to process the queue now that the render phase is complete.\n            finishQueueingConcurrentUpdates();\n            return workInProgressRootExitStatus;\n        } // The work loop is an extremely hot path. Tell Closure not to inline it.\n        /** @noinline */ function workLoopSync() {\n            // Perform work without checking if we need to yield between fiber.\n            while(workInProgress !== null){\n                performUnitOfWork(workInProgress);\n            }\n        }\n        function renderRootConcurrent(root, lanes) {\n            var prevExecutionContext = executionContext;\n            executionContext |= RenderContext;\n            var prevDispatcher = pushDispatcher();\n            var prevAsyncDispatcher = pushAsyncDispatcher(); // If the root or lanes have changed, throw out the existing stack\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n                {\n                    if (isDevToolsPresent) {\n                        var memoizedUpdaters = root.memoizedUpdaters;\n                        if (memoizedUpdaters.size > 0) {\n                            restorePendingUpdaters(root, workInProgressRootRenderLanes);\n                            memoizedUpdaters.clear();\n                        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n                        // If we bailout on this work, we'll move them back (like above).\n                        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n                        // That way we can keep the current update and future updates separate.\n                        movePendingFibersToMemoized(root, lanes);\n                    }\n                }\n                workInProgressTransitions = getTransitionsForLanes();\n                resetRenderTimer();\n                prepareFreshStack(root, lanes);\n            }\n            {\n                markRenderStarted(lanes);\n            }\n            outer: do {\n                try {\n                    if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {\n                        // The work loop is suspended. We need to either unwind the stack or\n                        // replay the suspended component.\n                        var unitOfWork = workInProgress;\n                        var thrownValue = workInProgressThrownValue;\n                        resumeOrUnwind: switch(workInProgressSuspendedReason){\n                            case SuspendedOnError:\n                                {\n                                    // Unwind then continue with the normal work loop.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                            case SuspendedOnData:\n                                {\n                                    var thenable = thrownValue;\n                                    if (isThenableResolved(thenable)) {\n                                        // The data resolved. Try rendering the component again.\n                                        workInProgressSuspendedReason = NotSuspended;\n                                        workInProgressThrownValue = null;\n                                        replaySuspendedUnitOfWork(unitOfWork);\n                                        break;\n                                    } // The work loop is suspended on data. We should wait for it to\n                                    // resolve before continuing to render.\n                                    // TODO: Handle the case where the promise resolves synchronously.\n                                    // Usually this is handled when we instrument the promise to add a\n                                    // `status` field, but if the promise already has a status, we won't\n                                    // have added a listener until right here.\n                                    var onResolution = function() {\n                                        // Check if the root is still suspended on this promise.\n                                        if (workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root) {\n                                            // Mark the root as ready to continue rendering.\n                                            workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                                        } // Ensure the root is scheduled. We should do this even if we're\n                                        // currently working on a different root, so that we resume\n                                        // rendering later.\n                                        ensureRootIsScheduled(root);\n                                    };\n                                    thenable.then(onResolution, onResolution);\n                                    break outer;\n                                }\n                            case SuspendedOnImmediate:\n                                {\n                                    // If this fiber just suspended, it's possible the data is already\n                                    // cached. Yield to the main thread to give it a chance to ping. If\n                                    // it does, we can retry immediately without unwinding the stack.\n                                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                                    break outer;\n                                }\n                            case SuspendedOnInstance:\n                                {\n                                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;\n                                    break outer;\n                                }\n                            case SuspendedAndReadyToContinue:\n                                {\n                                    var _thenable = thrownValue;\n                                    if (isThenableResolved(_thenable)) {\n                                        // The data resolved. Try rendering the component again.\n                                        workInProgressSuspendedReason = NotSuspended;\n                                        workInProgressThrownValue = null;\n                                        replaySuspendedUnitOfWork(unitOfWork);\n                                    } else {\n                                        // Otherwise, unwind then continue with the normal work loop.\n                                        workInProgressSuspendedReason = NotSuspended;\n                                        workInProgressThrownValue = null;\n                                        throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    }\n                                    break;\n                                }\n                            case SuspendedOnInstanceAndReadyToContinue:\n                                {\n                                    var resource = null;\n                                    switch(workInProgress.tag){\n                                        case HostHoistable:\n                                            {\n                                                resource = workInProgress.memoizedState;\n                                            }\n                                        // intentional fallthrough\n                                        case HostComponent:\n                                        case HostSingleton:\n                                            {\n                                                // Before unwinding the stack, check one more time if the\n                                                // instance is ready. It may have loaded when React yielded to\n                                                // the main thread.\n                                                // Assigning this to a constant so Flow knows the binding won't\n                                                // be mutated by `preloadInstance`.\n                                                var hostFiber = workInProgress;\n                                                var type = hostFiber.type;\n                                                var props = hostFiber.pendingProps;\n                                                var isReady = resource ? preloadResource(resource) : preloadInstance(type, props);\n                                                if (isReady) {\n                                                    // The data resolved. Resume the work loop as if nothing\n                                                    // suspended. Unlike when a user component suspends, we don't\n                                                    // have to replay anything because the host fiber\n                                                    // already completed.\n                                                    workInProgressSuspendedReason = NotSuspended;\n                                                    workInProgressThrownValue = null;\n                                                    var sibling = hostFiber.sibling;\n                                                    if (sibling !== null) {\n                                                        workInProgress = sibling;\n                                                    } else {\n                                                        var returnFiber = hostFiber.return;\n                                                        if (returnFiber !== null) {\n                                                            workInProgress = returnFiber;\n                                                            completeUnitOfWork(returnFiber);\n                                                        } else {\n                                                            workInProgress = null;\n                                                        }\n                                                    }\n                                                    break resumeOrUnwind;\n                                                }\n                                                break;\n                                            }\n                                        default:\n                                            {\n                                                // This will fail gracefully but it's not correct, so log a\n                                                // warning in dev.\n                                                if (true) {\n                                                    error('Unexpected type of fiber triggered a suspensey commit. ' + 'This is a bug in React.');\n                                                }\n                                                break;\n                                            }\n                                    } // Otherwise, unwind then continue with the normal work loop.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                            case SuspendedOnDeprecatedThrowPromise:\n                                {\n                                    // Suspended by an old implementation that uses the `throw promise`\n                                    // pattern. The newer replaying behavior can cause subtle issues\n                                    // like infinite ping loops. So we maintain the old behavior and\n                                    // always unwind.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                            case SuspendedOnHydration:\n                                {\n                                    // Selective hydration. An update flowed into a dehydrated tree.\n                                    // Interrupt the current render so the work loop can switch to the\n                                    // hydration lane.\n                                    resetWorkInProgressStack();\n                                    workInProgressRootExitStatus = RootDidNotComplete;\n                                    break outer;\n                                }\n                            default:\n                                {\n                                    throw new Error('Unexpected SuspendedReason. This is a bug in React.');\n                                }\n                        }\n                    }\n                    if ( true && ReactSharedInternals.actQueue !== null) {\n                        // `act` special case: If we're inside an `act` scope, don't consult\n                        // `shouldYield`. Always keep working until the render is complete.\n                        // This is not just an optimization: in a unit test environment, we\n                        // can't trust the result of `shouldYield`, because the host I/O is\n                        // likely mocked.\n                        workLoopSync();\n                    } else {\n                        workLoopConcurrent();\n                    }\n                    break;\n                } catch (thrownValue) {\n                    handleThrow(root, thrownValue);\n                }\n            }while (true);\n            resetContextDependencies();\n            popDispatcher(prevDispatcher);\n            popAsyncDispatcher(prevAsyncDispatcher);\n            executionContext = prevExecutionContext;\n            if (workInProgress !== null) {\n                // Still work remaining.\n                {\n                    markRenderYielded();\n                }\n                return RootInProgress;\n            } else {\n                // Completed the tree.\n                {\n                    markRenderStopped();\n                }\n                workInProgressRoot = null;\n                workInProgressRootRenderLanes = NoLanes; // It's safe to process the queue now that the render phase is complete.\n                finishQueueingConcurrentUpdates(); // Return the final exit status.\n                return workInProgressRootExitStatus;\n            }\n        }\n        /** @noinline */ function workLoopConcurrent() {\n            // Perform work until Scheduler asks us to yield\n            while(workInProgress !== null && !shouldYield()){\n                // $FlowFixMe[incompatible-call] found when upgrading Flow\n                performUnitOfWork(workInProgress);\n            }\n        }\n        function performUnitOfWork(unitOfWork) {\n            // The current, flushed, state of this fiber is the alternate. Ideally\n            // nothing should rely on this, but relying on it here means that we don't\n            // need an additional field on the work in progress.\n            var current = unitOfWork.alternate;\n            setCurrentDebugFiberInDEV(unitOfWork);\n            var next;\n            if ((unitOfWork.mode & ProfileMode) !== NoMode) {\n                startProfilerTimer(unitOfWork);\n                next = beginWork(current, unitOfWork, entangledRenderLanes);\n                stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n            } else {\n                next = beginWork(current, unitOfWork, entangledRenderLanes);\n            }\n            {\n                resetCurrentFiber();\n            }\n            unitOfWork.memoizedProps = unitOfWork.pendingProps;\n            if (next === null) {\n                // If this doesn't spawn new work, complete the current work.\n                completeUnitOfWork(unitOfWork);\n            } else {\n                workInProgress = next;\n            }\n        }\n        function replaySuspendedUnitOfWork(unitOfWork) {\n            // This is a fork of performUnitOfWork specifcally for replaying a fiber that\n            // just suspended.\n            //\n            var current = unitOfWork.alternate;\n            setCurrentDebugFiberInDEV(unitOfWork);\n            var next;\n            var isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;\n            if (isProfilingMode) {\n                startProfilerTimer(unitOfWork);\n            }\n            switch(unitOfWork.tag){\n                case SimpleMemoComponent:\n                case FunctionComponent:\n                    {\n                        // Resolve `defaultProps`. This logic is copied from `beginWork`.\n                        // TODO: Consider moving this switch statement into that module. Also,\n                        // could maybe use this as an opportunity to say `use` doesn't work with\n                        // `defaultProps` :)\n                        var Component = unitOfWork.type;\n                        var unresolvedProps = unitOfWork.pendingProps;\n                        var resolvedProps = unresolvedProps;\n                        var context;\n                        next = replayFunctionComponent(current, unitOfWork, resolvedProps, Component, context, workInProgressRootRenderLanes);\n                        break;\n                    }\n                case ForwardRef:\n                    {\n                        // Resolve `defaultProps`. This logic is copied from `beginWork`.\n                        // TODO: Consider moving this switch statement into that module. Also,\n                        // could maybe use this as an opportunity to say `use` doesn't work with\n                        // `defaultProps` :)\n                        var _Component = unitOfWork.type.render;\n                        var _unresolvedProps = unitOfWork.pendingProps;\n                        var _resolvedProps = _unresolvedProps;\n                        next = replayFunctionComponent(current, unitOfWork, _resolvedProps, _Component, unitOfWork.ref, workInProgressRootRenderLanes);\n                        break;\n                    }\n                case HostComponent:\n                    {\n                        // Some host components are stateful (that's how we implement form\n                        // actions) but we don't bother to reuse the memoized state because it's\n                        // not worth the extra code. The main reason to reuse the previous hooks\n                        // is to reuse uncached promises, but we happen to know that the only\n                        // promises that a host component might suspend on are definitely cached\n                        // because they are controlled by us. So don't bother.\n                        resetHooksOnUnwind(unitOfWork); // Fallthrough to the next branch.\n                    }\n                default:\n                    {\n                        // Other types besides function components are reset completely before\n                        // being replayed. Currently this only happens when a Usable type is\n                        // reconciled — the reconciler will suspend.\n                        //\n                        // We reset the fiber back to its original state; however, this isn't\n                        // a full \"unwind\" because we're going to reuse the promises that were\n                        // reconciled previously. So it's intentional that we don't call\n                        // resetSuspendedWorkLoopOnUnwind here.\n                        unwindInterruptedWork(current, unitOfWork);\n                        unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes);\n                        next = beginWork(current, unitOfWork, entangledRenderLanes);\n                        break;\n                    }\n            }\n            if (isProfilingMode) {\n                stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n            } // The begin phase finished successfully without suspending. Return to the\n            // normal work loop.\n            {\n                resetCurrentFiber();\n            }\n            unitOfWork.memoizedProps = unitOfWork.pendingProps;\n            if (next === null) {\n                // If this doesn't spawn new work, complete the current work.\n                completeUnitOfWork(unitOfWork);\n            } else {\n                workInProgress = next;\n            }\n        }\n        function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue) {\n            // This is a fork of performUnitOfWork specifcally for unwinding a fiber\n            // that threw an exception.\n            //\n            // Return to the normal work loop. This will unwind the stack, and potentially\n            // result in showing a fallback.\n            resetSuspendedWorkLoopOnUnwind(unitOfWork);\n            var returnFiber = unitOfWork.return;\n            try {\n                // Find and mark the nearest Suspense or error boundary that can handle\n                // this \"exception\".\n                var didFatal = throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes);\n                if (didFatal) {\n                    panicOnRootError(root, thrownValue);\n                    return;\n                }\n            } catch (error) {\n                // We had trouble processing the error. An example of this happening is\n                // when accessing the `componentDidCatch` property of an error boundary\n                // throws an error. A weird edge case. There's a regression test for this.\n                // To prevent an infinite loop, bubble the error up to the next parent.\n                if (returnFiber !== null) {\n                    workInProgress = returnFiber;\n                    throw error;\n                } else {\n                    panicOnRootError(root, thrownValue);\n                    return;\n                }\n            }\n            if (unitOfWork.flags & Incomplete) {\n                // Unwind the stack until we reach the nearest boundary.\n                unwindUnitOfWork(unitOfWork);\n            } else {\n                // Although the fiber suspended, we're intentionally going to commit it in\n                // an inconsistent state. We can do this safely in cases where we know the\n                // inconsistent tree will be hidden.\n                //\n                // This currently only applies to Legacy Suspense implementation, but we may\n                // port a version of this to concurrent roots, too, when performing a\n                // synchronous render. Because that will allow us to mutate the tree as we\n                // go instead of buffering mutations until the end. Though it's unclear if\n                // this particular path is how that would be implemented.\n                completeUnitOfWork(unitOfWork);\n            }\n        }\n        function panicOnRootError(root, error) {\n            // There's no ancestor that can handle this exception. This should never\n            // happen because the root is supposed to capture all errors that weren't\n            // caught by an error boundary. This is a fatal error, or panic condition,\n            // because we've run out of ways to recover.\n            workInProgressRootExitStatus = RootFatalErrored;\n            logUncaughtError(root, createCapturedValueAtFiber(error, root.current)); // Set `workInProgress` to null. This represents advancing to the next\n            // sibling, or the parent if there are no siblings. But since the root\n            // has no siblings nor a parent, we set it to null. Usually this is\n            // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n            // intentionally not calling those, we need set it here.\n            // TODO: Consider calling `unwindWork` to pop the contexts.\n            workInProgress = null;\n        }\n        function completeUnitOfWork(unitOfWork) {\n            // Attempt to complete the current unit of work, then move to the next\n            // sibling. If there are no more siblings, return to the parent fiber.\n            var completedWork = unitOfWork;\n            do {\n                {\n                    if ((completedWork.flags & Incomplete) !== NoFlags$1) {\n                        // NOTE: If we re-enable sibling prerendering in some cases, this branch\n                        // is where we would switch to the unwinding path.\n                        error('Internal React error: Expected this fiber to be complete, but ' + \"it isn't. It should have been unwound. This is a bug in React.\");\n                    }\n                }\n                // nothing should rely on this, but relying on it here means that we don't\n                // need an additional field on the work in progress.\n                var current = completedWork.alternate;\n                var returnFiber = completedWork.return;\n                setCurrentDebugFiberInDEV(completedWork);\n                var next = void 0;\n                if ((completedWork.mode & ProfileMode) === NoMode) {\n                    next = completeWork(current, completedWork, entangledRenderLanes);\n                } else {\n                    startProfilerTimer(completedWork);\n                    next = completeWork(current, completedWork, entangledRenderLanes); // Update render duration assuming we didn't error.\n                    stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n                }\n                resetCurrentDebugFiberInDEV();\n                if (next !== null) {\n                    // Completing this fiber spawned new work. Work on that next.\n                    workInProgress = next;\n                    return;\n                }\n                var siblingFiber = completedWork.sibling;\n                if (siblingFiber !== null) {\n                    // If there is more work to do in this returnFiber, do that next.\n                    workInProgress = siblingFiber;\n                    return;\n                } // Otherwise, return to the parent\n                // $FlowFixMe[incompatible-type] we bail out when we get a null\n                completedWork = returnFiber; // Update the next thing we're working on in case something throws.\n                workInProgress = completedWork;\n            }while (completedWork !== null); // We've reached the root.\n            if (workInProgressRootExitStatus === RootInProgress) {\n                workInProgressRootExitStatus = RootCompleted;\n            }\n        }\n        function unwindUnitOfWork(unitOfWork) {\n            var incompleteWork = unitOfWork;\n            do {\n                // The current, flushed, state of this fiber is the alternate. Ideally\n                // nothing should rely on this, but relying on it here means that we don't\n                // need an additional field on the work in progress.\n                var current = incompleteWork.alternate; // This fiber did not complete because something threw. Pop values off\n                // the stack without entering the complete phase. If this is a boundary,\n                // capture values if possible.\n                var next = unwindWork(current, incompleteWork); // Because this fiber did not complete, don't reset its lanes.\n                if (next !== null) {\n                    // Found a boundary that can handle this exception. Re-renter the\n                    // begin phase. This branch will return us to the normal work loop.\n                    //\n                    // Since we're restarting, remove anything that is not a host effect\n                    // from the effect tag.\n                    next.flags &= HostEffectMask;\n                    workInProgress = next;\n                    return;\n                } // Keep unwinding until we reach either a boundary or the root.\n                if ((incompleteWork.mode & ProfileMode) !== NoMode) {\n                    // Record the render duration for the fiber that errored.\n                    stopProfilerTimerIfRunningAndRecordDelta(incompleteWork, false); // Include the time spent working on failed children before continuing.\n                    var actualDuration = incompleteWork.actualDuration;\n                    var child = incompleteWork.child;\n                    while(child !== null){\n                        // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        actualDuration += child.actualDuration;\n                        child = child.sibling;\n                    }\n                    incompleteWork.actualDuration = actualDuration;\n                } // TODO: Once we stop prerendering siblings, instead of resetting the parent\n                // of the node being unwound, we should be able to reset node itself as we\n                // unwind the stack. Saves an additional null check.\n                var returnFiber = incompleteWork.return;\n                if (returnFiber !== null) {\n                    // Mark the parent fiber as incomplete and clear its subtree flags.\n                    // TODO: Once we stop prerendering siblings, we may be able to get rid of\n                    // the Incomplete flag because unwinding to the nearest boundary will\n                    // happen synchronously.\n                    returnFiber.flags |= Incomplete;\n                    returnFiber.subtreeFlags = NoFlags$1;\n                    returnFiber.deletions = null;\n                } // NOTE: If we re-enable sibling prerendering in some cases, here we\n                // would switch to the normal completion path: check if a sibling\n                // exists, and if so, begin work on it.\n                // Otherwise, return to the parent\n                // $FlowFixMe[incompatible-type] we bail out when we get a null\n                incompleteWork = returnFiber; // Update the next thing we're working on in case something throws.\n                workInProgress = incompleteWork;\n            }while (incompleteWork !== null); // We've unwound all the way to the root.\n            workInProgressRootExitStatus = RootDidNotComplete;\n            workInProgress = null;\n        }\n        function commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane) {\n            // TODO: This no longer makes any sense. We already wrap the mutation and\n            // layout phases. Should be able to remove.\n            var prevTransition = ReactSharedInternals.T;\n            var previousUpdateLanePriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                ReactSharedInternals.T = null;\n                commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, previousUpdateLanePriority, spawnedLane);\n            } finally{\n                ReactSharedInternals.T = prevTransition;\n                setCurrentUpdatePriority(previousUpdateLanePriority);\n            }\n            return null;\n        }\n        function commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane) {\n            do {\n                // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n                // means `flushPassiveEffects` will sometimes result in additional\n                // passive effects. So we need to keep flushing in a loop until there are\n                // no more pending effects.\n                // TODO: Might be better if `flushPassiveEffects` did not automatically\n                // flush synchronous work at the end, to avoid factoring hazards like this.\n                flushPassiveEffects();\n            }while (rootWithPendingPassiveEffects !== null);\n            flushRenderPhaseStrictModeWarningsInDEV();\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Should not already be working.');\n            }\n            var finishedWork = root.finishedWork;\n            var lanes = root.finishedLanes;\n            {\n                markCommitStarted(lanes);\n            }\n            if (finishedWork === null) {\n                {\n                    markCommitStopped();\n                }\n                return null;\n            } else {\n                {\n                    if (lanes === NoLanes) {\n                        error('root.finishedLanes should not be empty during a commit. This is a ' + 'bug in React.');\n                    }\n                }\n            }\n            root.finishedWork = null;\n            root.finishedLanes = NoLanes;\n            if (finishedWork === root.current) {\n                throw new Error('Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n            } // commitRoot never returns a continuation; it always finishes synchronously.\n            // So we can clear these now to allow a new callback to be scheduled.\n            root.callbackNode = null;\n            root.callbackPriority = NoLane;\n            root.cancelPendingCommit = null; // Check which lanes no longer have any work scheduled on them, and mark\n            // those as finished.\n            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes); // Make sure to account for lanes that were updated by a concurrent event\n            // during the render phase; don't mark them as finished.\n            var concurrentlyUpdatedLanes = getConcurrentlyUpdatedLanes();\n            remainingLanes = mergeLanes(remainingLanes, concurrentlyUpdatedLanes);\n            markRootFinished(root, remainingLanes, spawnedLane); // Reset this before firing side effects so we can detect recursive updates.\n            didIncludeCommitPhaseUpdate = false;\n            if (root === workInProgressRoot) {\n                // We can reset these now that they are finished.\n                workInProgressRoot = null;\n                workInProgress = null;\n                workInProgressRootRenderLanes = NoLanes;\n            } // If there are pending passive effects, schedule a callback to process them.\n            // Do this as early as possible, so it is queued before anything else that\n            // might get scheduled in the commit phase. (See #16714.)\n            // TODO: Delete all other places that schedule the passive effect callback\n            // They're redundant.\n            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags$1 || (finishedWork.flags & PassiveMask) !== NoFlags$1) {\n                if (!rootDoesHavePassiveEffects) {\n                    rootDoesHavePassiveEffects = true;\n                    pendingPassiveEffectsRemainingLanes = remainingLanes; // workInProgressTransitions might be overwritten, so we want\n                    // to store it in pendingPassiveTransitions until they get processed\n                    // We need to pass this through as an argument to commitRoot\n                    // because workInProgressTransitions might have changed between\n                    // the previous render and commit if we throttle the commit\n                    // with setTimeout\n                    pendingPassiveTransitions = transitions;\n                    scheduleCallback(NormalPriority$1, function() {\n                        flushPassiveEffects(); // This render triggered passive effects: release the root cache pool\n                        // *after* passive effects fire to avoid freeing a cache pool that may\n                        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n                        return null;\n                    });\n                }\n            } // Check if there are any effects in the whole tree.\n            // TODO: This is left over from the effect list implementation, where we had\n            // to check for the existence of `firstEffect` to satisfy Flow. I think the\n            // only other reason this optimization exists is because it affects profiling.\n            // Reconsider whether this is necessary.\n            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags$1;\n            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags$1;\n            if (subtreeHasEffects || rootHasEffect) {\n                var prevTransition = ReactSharedInternals.T;\n                ReactSharedInternals.T = null;\n                var previousPriority = getCurrentUpdatePriority();\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                var prevExecutionContext = executionContext;\n                executionContext |= CommitContext; // The commit phase is broken into several sub-phases. We do a separate pass\n                // of the effect list for each phase: all mutation effects come before all\n                // layout effects, and so on.\n                // The first phase a \"before mutation\" phase. We use this phase to read the\n                // state of the host tree right before we mutate it. This is where\n                // getSnapshotBeforeUpdate is called.\n                commitBeforeMutationEffects(root, finishedWork);\n                {\n                    // Mark the current commit time to be shared by all Profilers in this\n                    // batch. This enables them to be grouped later.\n                    recordCommitTime();\n                }\n                commitMutationEffects(root, finishedWork, lanes);\n                resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n                // the mutation phase, so that the previous tree is still current during\n                // componentWillUnmount, but before the layout phase, so that the finished\n                // work is current during componentDidMount/Update.\n                root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n                {\n                    markLayoutEffectsStarted(lanes);\n                }\n                commitLayoutEffects(finishedWork, root, lanes);\n                {\n                    markLayoutEffectsStopped();\n                }\n                // opportunity to paint.\n                requestPaint();\n                executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n            } else {\n                // No effects.\n                root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n                // no effects.\n                // TODO: Maybe there's a better way to report this.\n                {\n                    recordCommitTime();\n                }\n            }\n            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n            if (rootDoesHavePassiveEffects) {\n                // This commit has passive effects. Stash a reference to them. But don't\n                // schedule a callback until after flushing layout work.\n                rootDoesHavePassiveEffects = false;\n                rootWithPendingPassiveEffects = root;\n                pendingPassiveEffectsLanes = lanes;\n            } else {\n                // There were no passive effects, so we can immediately release the cache\n                // pool for this render.\n                releaseRootPooledCache(root, remainingLanes);\n                {\n                    nestedPassiveUpdateCount = 0;\n                    rootWithPassiveNestedUpdates = null;\n                }\n            } // Read this again, since an effect might have updated it\n            remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\n            // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n            // is to detect whether something might have called setState inside\n            // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n            // inside `componentDidCatch` is itself flawed — that's why we recommend\n            // `getDerivedStateFromError` instead. However, it could be improved by\n            // checking if remainingLanes includes Sync work, instead of whether there's\n            // any work remaining at all (which would also include stuff like Suspense\n            // retries or transitions). It's been like this for a while, though, so fixing\n            // it probably isn't that urgent.\n            if (remainingLanes === NoLanes) {\n                // If there's no remaining work, we can clear the set of already failed\n                // error boundaries.\n                legacyErrorBoundariesThatAlreadyFailed = null;\n            }\n            {\n                if (!rootDidHavePassiveEffects) {\n                    commitDoubleInvokeEffectsInDEV(root);\n                }\n            }\n            onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);\n            {\n                if (isDevToolsPresent) {\n                    root.memoizedUpdaters.clear();\n                }\n            }\n            {\n                onCommitRoot();\n            }\n            // additional work on this root is scheduled.\n            ensureRootIsScheduled(root);\n            if (recoverableErrors !== null) {\n                // There were errors during this render, but recovered from them without\n                // needing to surface it to the UI. We log them here.\n                var onRecoverableError = root.onRecoverableError;\n                for(var i = 0; i < recoverableErrors.length; i++){\n                    var recoverableError = recoverableErrors[i];\n                    var errorInfo = makeErrorInfo(recoverableError.stack);\n                    setCurrentDebugFiberInDEV(recoverableError.source);\n                    onRecoverableError(recoverableError.value, errorInfo);\n                    resetCurrentDebugFiberInDEV();\n                }\n            } // If the passive effects are the result of a discrete render, flush them\n            // synchronously at the end of the current task so that the result is\n            // immediately observable. Otherwise, we assume that they are not\n            // order-dependent and do not need to be observed by external systems, so we\n            // can wait until after paint.\n            // TODO: We can optimize this by not scheduling the callback earlier. Since we\n            // currently schedule the callback in multiple places, will wait until those\n            // are consolidated.\n            if (includesSyncLane(pendingPassiveEffectsLanes) && disableLegacyMode) {\n                flushPassiveEffects();\n            } // Read this again, since a passive effect might have updated it\n            remainingLanes = root.pendingLanes; // Check if this render scheduled a cascading synchronous update. This is a\n            // heurstic to detect infinite update loops. We are intentionally excluding\n            // hydration lanes in this check, because render triggered by selective\n            // hydration is conceptually not an update.\n            if (// the render phase or the commit phase. We track these explicitly because\n            // we can't infer from the remaining lanes alone.\n            didIncludeRenderPhaseUpdate || didIncludeCommitPhaseUpdate || // Was the finished render the result of an update (not hydration)?\n            includesSomeLane(lanes, UpdateLanes) && // Did it schedule a sync update?\n            includesSomeLane(remainingLanes, SyncUpdateLanes)) {\n                {\n                    markNestedUpdateScheduled();\n                }\n                // finishing. If there are too many, it indicates an infinite update loop.\n                if (root === rootWithNestedUpdates) {\n                    nestedUpdateCount++;\n                } else {\n                    nestedUpdateCount = 0;\n                    rootWithNestedUpdates = root;\n                }\n            } else {\n                nestedUpdateCount = 0;\n            } // If layout work was scheduled, flush it now.\n            flushSyncWorkOnAllRoots();\n            {\n                markCommitStopped();\n            }\n            return null;\n        }\n        function makeErrorInfo(componentStack) {\n            var errorInfo = {\n                componentStack: componentStack\n            };\n            {\n                Object.defineProperty(errorInfo, 'digest', {\n                    get: function() {\n                        error('You are accessing \"digest\" from the errorInfo object passed to onRecoverableError.' + ' This property is no longer provided as part of errorInfo but can be accessed as a property' + ' of the Error instance itself.');\n                    }\n                });\n            }\n            return errorInfo;\n        }\n        function releaseRootPooledCache(root, remainingLanes) {\n            {\n                var pooledCacheLanes = root.pooledCacheLanes &= remainingLanes;\n                if (pooledCacheLanes === NoLanes) {\n                    // None of the remaining work relies on the cache pool. Clear it so\n                    // subsequent requests get a new cache\n                    var pooledCache = root.pooledCache;\n                    if (pooledCache != null) {\n                        root.pooledCache = null;\n                        releaseCache(pooledCache);\n                    }\n                }\n            }\n        }\n        function flushPassiveEffects() {\n            // Returns whether passive effects were flushed.\n            // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n            // probably just combine the two functions. I believe they were only separate\n            // in the first place because we used to wrap it with\n            // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n            // priority within React itself, so we can mutate the variable directly.\n            if (rootWithPendingPassiveEffects !== null) {\n                // Cache the root since rootWithPendingPassiveEffects is cleared in\n                // flushPassiveEffectsImpl\n                var root = rootWithPendingPassiveEffects; // Cache and clear the remaining lanes flag; it must be reset since this\n                // method can be called from various places, not always from commitRoot\n                // where the remaining lanes are known\n                var remainingLanes = pendingPassiveEffectsRemainingLanes;\n                pendingPassiveEffectsRemainingLanes = NoLanes;\n                var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n                var priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n                var prevTransition = ReactSharedInternals.T;\n                var previousPriority = getCurrentUpdatePriority();\n                try {\n                    setCurrentUpdatePriority(priority);\n                    ReactSharedInternals.T = null;\n                    return flushPassiveEffectsImpl();\n                } finally{\n                    setCurrentUpdatePriority(previousPriority);\n                    ReactSharedInternals.T = prevTransition; // Once passive effects have run for the tree - giving components a\n                    // chance to retain cache instances they use - release the pooled\n                    // cache at the root (if there is one)\n                    releaseRootPooledCache(root, remainingLanes);\n                }\n            }\n            return false;\n        }\n        function enqueuePendingPassiveProfilerEffect(fiber) {\n            {\n                pendingPassiveProfilerEffects.push(fiber);\n                if (!rootDoesHavePassiveEffects) {\n                    rootDoesHavePassiveEffects = true;\n                    scheduleCallback(NormalPriority$1, function() {\n                        flushPassiveEffects();\n                        return null;\n                    });\n                }\n            }\n        }\n        function flushPassiveEffectsImpl() {\n            if (rootWithPendingPassiveEffects === null) {\n                return false;\n            } // Cache and clear the transitions flag\n            var transitions = pendingPassiveTransitions;\n            pendingPassiveTransitions = null;\n            var root = rootWithPendingPassiveEffects;\n            var lanes = pendingPassiveEffectsLanes;\n            rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n            // Figure out why and fix it. It's not causing any known issues (probably\n            // because it's only used for profiling), but it's a refactor hazard.\n            pendingPassiveEffectsLanes = NoLanes;\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Cannot flush passive effects while already rendering.');\n            }\n            {\n                isFlushingPassiveEffects = true;\n                didScheduleUpdateDuringPassiveEffects = false;\n            }\n            {\n                markPassiveEffectsStarted(lanes);\n            }\n            var prevExecutionContext = executionContext;\n            executionContext |= CommitContext;\n            commitPassiveUnmountEffects(root.current);\n            commitPassiveMountEffects(root, root.current, lanes, transitions); // TODO: Move to commitPassiveMountEffects\n            {\n                var profilerEffects = pendingPassiveProfilerEffects;\n                pendingPassiveProfilerEffects = [];\n                for(var i = 0; i < profilerEffects.length; i++){\n                    var fiber = profilerEffects[i];\n                    commitPassiveEffectDurations(root, fiber);\n                }\n            }\n            {\n                markPassiveEffectsStopped();\n            }\n            {\n                commitDoubleInvokeEffectsInDEV(root);\n            }\n            executionContext = prevExecutionContext;\n            flushSyncWorkOnAllRoots();\n            {\n                // If additional passive effects were scheduled, increment a counter. If this\n                // exceeds the limit, we'll fire a warning.\n                if (didScheduleUpdateDuringPassiveEffects) {\n                    if (root === rootWithPassiveNestedUpdates) {\n                        nestedPassiveUpdateCount++;\n                    } else {\n                        nestedPassiveUpdateCount = 0;\n                        rootWithPassiveNestedUpdates = root;\n                    }\n                } else {\n                    nestedPassiveUpdateCount = 0;\n                }\n                isFlushingPassiveEffects = false;\n                didScheduleUpdateDuringPassiveEffects = false;\n            }\n            onPostCommitRoot(root);\n            {\n                var stateNode = root.current.stateNode;\n                stateNode.effectDuration = 0;\n                stateNode.passiveEffectDuration = 0;\n            }\n            return true;\n        }\n        function isAlreadyFailedLegacyErrorBoundary(instance) {\n            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n        }\n        function markLegacyErrorBoundaryAsFailed(instance) {\n            if (legacyErrorBoundariesThatAlreadyFailed === null) {\n                legacyErrorBoundariesThatAlreadyFailed = new Set([\n                    instance\n                ]);\n            } else {\n                legacyErrorBoundariesThatAlreadyFailed.add(instance);\n            }\n        }\n        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n            var errorInfo = createCapturedValueAtFiber(error, sourceFiber);\n            var update = createRootErrorUpdate(rootFiber.stateNode, errorInfo, SyncLane);\n            var root = enqueueUpdate(rootFiber, update, SyncLane);\n            if (root !== null) {\n                markRootUpdated(root, SyncLane);\n                ensureRootIsScheduled(root);\n            }\n        }\n        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {\n            {\n                setIsRunningInsertionEffect(false);\n            }\n            if (sourceFiber.tag === HostRoot) {\n                // Error was thrown at the root. There is no parent, so the root\n                // itself should capture it.\n                captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);\n                return;\n            }\n            var fiber = nearestMountedAncestor;\n            while(fiber !== null){\n                if (fiber.tag === HostRoot) {\n                    captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);\n                    return;\n                } else if (fiber.tag === ClassComponent) {\n                    var ctor = fiber.type;\n                    var instance = fiber.stateNode;\n                    if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n                        var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);\n                        var update = createClassErrorUpdate(SyncLane);\n                        var root = enqueueUpdate(fiber, update, SyncLane);\n                        if (root !== null) {\n                            initializeClassErrorUpdate(update, root, fiber, errorInfo);\n                            markRootUpdated(root, SyncLane);\n                            ensureRootIsScheduled(root);\n                        }\n                        return;\n                    }\n                }\n                fiber = fiber.return;\n            }\n            {\n                error('Internal React error: Attempted to capture a commit phase error ' + 'inside a detached tree. This indicates a bug in React. Potential ' + 'causes include deleting the same fiber more than once, committing an ' + 'already-finished tree, or an inconsistent return pointer.\\n\\n' + 'Error message:\\n\\n%s', error$1);\n            }\n        }\n        function attachPingListener(root, wakeable, lanes) {\n            // Attach a ping listener\n            //\n            // The data might resolve before we have a chance to commit the fallback. Or,\n            // in the case of a refresh, we'll never commit a fallback. So we need to\n            // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n            // try rendering the tree again.\n            //\n            // Only attach a listener if one does not already exist for the lanes\n            // we're currently rendering (which acts like a \"thread ID\" here).\n            //\n            // We only need to do this in concurrent mode. Legacy Suspense always\n            // commits fallbacks synchronously, so there are no pings.\n            var pingCache = root.pingCache;\n            var threadIDs;\n            if (pingCache === null) {\n                pingCache = root.pingCache = new PossiblyWeakMap();\n                threadIDs = new Set();\n                pingCache.set(wakeable, threadIDs);\n            } else {\n                threadIDs = pingCache.get(wakeable);\n                if (threadIDs === undefined) {\n                    threadIDs = new Set();\n                    pingCache.set(wakeable, threadIDs);\n                }\n            }\n            if (!threadIDs.has(lanes)) {\n                workInProgressRootDidAttachPingListener = true; // Memoize using the thread ID to prevent redundant listeners.\n                threadIDs.add(lanes);\n                var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n                {\n                    if (isDevToolsPresent) {\n                        // If we have pending work still, restore the original updaters\n                        restorePendingUpdaters(root, lanes);\n                    }\n                }\n                wakeable.then(ping, ping);\n            }\n        }\n        function pingSuspendedRoot(root, wakeable, pingedLanes) {\n            var pingCache = root.pingCache;\n            if (pingCache !== null) {\n                // The wakeable resolved, so we no longer need to memoize, because it will\n                // never be thrown again.\n                pingCache.delete(wakeable);\n            }\n            markRootPinged(root, pingedLanes);\n            warnIfSuspenseResolutionNotWrappedWithActDEV();\n            if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n                // Received a ping at the same priority level at which we're currently\n                // rendering. We might want to restart this render. This should mirror\n                // the logic of whether or not a root suspends once it completes.\n                // TODO: If we're rendering sync either due to Sync, Batched or expired,\n                // we should probably never restart.\n                // If we're suspended with delay, or if it's a retry, we'll always suspend\n                // so we can always restart.\n                if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n                    // Force a restart from the root by unwinding the stack. Unless this is\n                    // being called from the render phase, because that would cause a crash.\n                    if ((executionContext & RenderContext) === NoContext) {\n                        prepareFreshStack(root, NoLanes);\n                    }\n                } else {\n                    // Even though we can't restart right now, we might get an\n                    // opportunity later. So we mark this render as having a ping.\n                    workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n                }\n            }\n            ensureRootIsScheduled(root);\n        }\n        function retryTimedOutBoundary(boundaryFiber, retryLane) {\n            // The boundary fiber (a Suspense component or SuspenseList component)\n            // previously was rendered in its fallback state. One of the promises that\n            // suspended it has resolved, which means at least part of the tree was\n            // likely unblocked. Try rendering again, at a new lanes.\n            if (retryLane === NoLane) {\n                // TODO: Assign this to `suspenseState.retryLane`? to avoid\n                // unnecessary entanglement?\n                retryLane = requestRetryLane();\n            } // TODO: Special case idle priority?\n            var root = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n            if (root !== null) {\n                markRootUpdated(root, retryLane);\n                ensureRootIsScheduled(root);\n            }\n        }\n        function retryDehydratedSuspenseBoundary(boundaryFiber) {\n            var suspenseState = boundaryFiber.memoizedState;\n            var retryLane = NoLane;\n            if (suspenseState !== null) {\n                retryLane = suspenseState.retryLane;\n            }\n            retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function resolveRetryWakeable(boundaryFiber, wakeable) {\n            var retryLane = NoLane; // Default\n            var retryCache;\n            switch(boundaryFiber.tag){\n                case SuspenseComponent:\n                    retryCache = boundaryFiber.stateNode;\n                    var suspenseState = boundaryFiber.memoizedState;\n                    if (suspenseState !== null) {\n                        retryLane = suspenseState.retryLane;\n                    }\n                    break;\n                case SuspenseListComponent:\n                    retryCache = boundaryFiber.stateNode;\n                    break;\n                case OffscreenComponent:\n                    {\n                        var instance = boundaryFiber.stateNode;\n                        retryCache = instance._retryCache;\n                        break;\n                    }\n                default:\n                    throw new Error('Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');\n            }\n            if (retryCache !== null) {\n                // The wakeable resolved, so we no longer need to memoize, because it will\n                // never be thrown again.\n                retryCache.delete(wakeable);\n            }\n            retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function throwIfInfiniteUpdateLoopDetected() {\n            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n                nestedUpdateCount = 0;\n                nestedPassiveUpdateCount = 0;\n                rootWithNestedUpdates = null;\n                rootWithPassiveNestedUpdates = null;\n                {\n                    if (executionContext & RenderContext && workInProgressRoot !== null) {\n                        // We're in the render phase. Disable the concurrent error recovery\n                        // mechanism to ensure that the error we're about to throw gets handled.\n                        // We need it to trigger the nearest error boundary so that the infinite\n                        // update loop is broken.\n                        workInProgressRoot.errorRecoveryDisabledLanes = mergeLanes(workInProgressRoot.errorRecoveryDisabledLanes, workInProgressRootRenderLanes);\n                    }\n                }\n                throw new Error('Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');\n            }\n            {\n                if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n                    nestedPassiveUpdateCount = 0;\n                    rootWithPassiveNestedUpdates = null;\n                    error('Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\n                }\n            }\n        }\n        function flushRenderPhaseStrictModeWarningsInDEV() {\n            {\n                ReactStrictModeWarnings.flushLegacyContextWarning();\n                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n            }\n        }\n        function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, parentFiber, isInStrictMode) {\n            if ((parentFiber.subtreeFlags & (PlacementDEV | Visibility)) === NoFlags$1) {\n                // Parent's descendants have already had effects double invoked.\n                // Early exit to avoid unnecessary tree traversal.\n                return;\n            }\n            var child = parentFiber.child;\n            while(child !== null){\n                doubleInvokeEffectsInDEVIfNecessary(root, child, isInStrictMode);\n                child = child.sibling;\n            }\n        } // Unconditionally disconnects and connects passive and layout effects.\n        function doubleInvokeEffectsOnFiber(root, fiber) {\n            var shouldDoubleInvokePassiveEffects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n            setIsStrictModeForDevtools(true);\n            disappearLayoutEffects(fiber);\n            if (shouldDoubleInvokePassiveEffects) {\n                disconnectPassiveEffect(fiber);\n            }\n            reappearLayoutEffects(root, fiber.alternate, fiber, false);\n            if (shouldDoubleInvokePassiveEffects) {\n                reconnectPassiveEffects(root, fiber, NoLanes, null, false);\n            }\n            setIsStrictModeForDevtools(false);\n        }\n        function doubleInvokeEffectsInDEVIfNecessary(root, fiber, parentIsInStrictMode) {\n            var isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;\n            var isInStrictMode = parentIsInStrictMode || isStrictModeFiber; // First case: the fiber **is not** of type OffscreenComponent. No\n            // special rules apply to double invoking effects.\n            if (fiber.tag !== OffscreenComponent) {\n                if (fiber.flags & PlacementDEV) {\n                    setCurrentDebugFiberInDEV(fiber);\n                    if (isInStrictMode) {\n                        doubleInvokeEffectsOnFiber(root, fiber, (fiber.mode & NoStrictPassiveEffectsMode) === NoMode);\n                    }\n                    resetCurrentDebugFiberInDEV();\n                } else {\n                    recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isInStrictMode);\n                }\n                return;\n            } // Second case: the fiber **is** of type OffscreenComponent.\n            // This branch contains cases specific to Offscreen.\n            if (fiber.memoizedState === null) {\n                // Only consider Offscreen that is visible.\n                // TODO (Offscreen) Handle manual mode.\n                setCurrentDebugFiberInDEV(fiber);\n                if (isInStrictMode && fiber.flags & Visibility) {\n                    // Double invoke effects on Offscreen's subtree only\n                    // if it is visible and its visibility has changed.\n                    doubleInvokeEffectsOnFiber(root, fiber);\n                } else if (fiber.subtreeFlags & PlacementDEV) {\n                    // Something in the subtree could have been suspended.\n                    // We need to continue traversal and find newly inserted fibers.\n                    recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isInStrictMode);\n                }\n                resetCurrentDebugFiberInDEV();\n            }\n        }\n        function commitDoubleInvokeEffectsInDEV(root, hasPassiveEffects) {\n            {\n                {\n                    var doubleInvokeEffects = true;\n                    if (!(root.current.mode & (StrictLegacyMode | StrictEffectsMode))) {\n                        doubleInvokeEffects = false;\n                    }\n                    recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);\n                }\n            }\n        }\n        var didWarnStateUpdateForNotYetMountedComponent = null;\n        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n            {\n                if ((executionContext & RenderContext) !== NoContext) {\n                    // We let the other warning about render phase updates deal with this one.\n                    return;\n                }\n                var tag = fiber.tag;\n                if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n                    // Only warn for user-defined components, not internal ones like Suspense.\n                    return;\n                } // We show the whole stack but dedupe on the top component's name because\n                // the problematic code almost always lies inside that component.\n                var componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';\n                if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n                } else {\n                    didWarnStateUpdateForNotYetMountedComponent = new Set([\n                        componentName\n                    ]);\n                }\n                var previousFiber = current;\n                try {\n                    setCurrentDebugFiberInDEV(fiber);\n                    error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');\n                } finally{\n                    if (previousFiber) {\n                        setCurrentDebugFiberInDEV(fiber);\n                    } else {\n                        resetCurrentDebugFiberInDEV();\n                    }\n                }\n            }\n        }\n        var didWarnAboutUpdateInRender = false;\n        var didWarnAboutUpdateInRenderForAnotherComponent;\n        {\n            didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n        }\n        function warnAboutRenderPhaseUpdatesInDEV(fiber) {\n            {\n                if (isRendering) {\n                    switch(fiber.tag){\n                        case FunctionComponent:\n                        case ForwardRef:\n                        case SimpleMemoComponent:\n                            {\n                                var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.\n                                var dedupeKey = renderingComponentName;\n                                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n                                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n                                    var setStateComponentName = getComponentNameFromFiber(fiber) || 'Unknown';\n                                    error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://react.dev/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);\n                                }\n                                break;\n                            }\n                        case ClassComponent:\n                            {\n                                if (!didWarnAboutUpdateInRender) {\n                                    error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');\n                                    didWarnAboutUpdateInRender = true;\n                                }\n                                break;\n                            }\n                    }\n                }\n            }\n        }\n        function restorePendingUpdaters(root, lanes) {\n            {\n                if (isDevToolsPresent) {\n                    var memoizedUpdaters = root.memoizedUpdaters;\n                    memoizedUpdaters.forEach(function(schedulingFiber) {\n                        addFiberToLanesMap(root, schedulingFiber, lanes);\n                    }); // This function intentionally does not clear memoized updaters.\n                // Those may still be relevant to the current commit\n                // and a future one (e.g. Suspense).\n                }\n            }\n        }\n        var fakeActCallbackNode = {}; // $FlowFixMe[missing-local-annot]\n        function scheduleCallback(priorityLevel, callback) {\n            {\n                // If we're currently inside an `act` scope, bypass Scheduler and push to\n                // the `act` queue instead.\n                var actQueue = ReactSharedInternals.actQueue;\n                if (actQueue !== null) {\n                    actQueue.push(callback);\n                    return fakeActCallbackNode;\n                } else {\n                    return scheduleCallback$3(priorityLevel, callback);\n                }\n            }\n        }\n        function shouldForceFlushFallbacksInDEV() {\n            // Never force flush in production. This function should get stripped out.\n            return ReactSharedInternals.actQueue !== null;\n        }\n        function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n            {\n                {\n                    if (!isConcurrentActEnvironment()) {\n                        // Not in an act environment. No need to warn.\n                        return;\n                    }\n                }\n                if (ReactSharedInternals.actQueue === null) {\n                    var previousFiber = current;\n                    try {\n                        setCurrentDebugFiberInDEV(fiber);\n                        error('An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://react.dev/link/wrap-tests-with-act', getComponentNameFromFiber(fiber));\n                    } finally{\n                        if (previousFiber) {\n                            setCurrentDebugFiberInDEV(fiber);\n                        } else {\n                            resetCurrentDebugFiberInDEV();\n                        }\n                    }\n                }\n            }\n        }\n        function warnIfSuspenseResolutionNotWrappedWithActDEV(root) {\n            {\n                if (isConcurrentActEnvironment() && ReactSharedInternals.actQueue === null) {\n                    error('A suspended resource finished loading inside a test, but the event ' + 'was not wrapped in act(...).\\n\\n' + 'When testing, code that resolves suspended data should be wrapped ' + 'into act(...):\\n\\n' + 'act(() => {\\n' + '  /* finish loading suspended data */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://react.dev/link/wrap-tests-with-act');\n                }\n            }\n        }\n        function setIsRunningInsertionEffect(isRunning) {\n            {\n                isRunningInsertionEffect = isRunning;\n            }\n        }\n        /* eslint-disable react-internal/prod-error-codes */ // Used by React Refresh runtime through DevTools Global Hook.\n        var resolveFamily = null;\n        var failedBoundaries = null;\n        var setRefreshHandler = function(handler) {\n            {\n                resolveFamily = handler;\n            }\n        };\n        function resolveFunctionForHotReloading(type) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return type;\n                }\n                var family = resolveFamily(type);\n                if (family === undefined) {\n                    return type;\n                } // Use the latest known implementation.\n                return family.current;\n            }\n        }\n        function resolveClassForHotReloading(type) {\n            // No implementation differences.\n            return resolveFunctionForHotReloading(type);\n        }\n        function resolveForwardRefForHotReloading(type) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return type;\n                }\n                var family = resolveFamily(type);\n                if (family === undefined) {\n                    // Check if we're dealing with a real forwardRef. Don't want to crash early.\n                    if (type !== null && type !== undefined && typeof type.render === 'function') {\n                        // ForwardRef is special because its resolved .type is an object,\n                        // but it's possible that we only have its inner render function in the map.\n                        // If that inner render function is different, we'll build a new forwardRef type.\n                        var currentRender = resolveFunctionForHotReloading(type.render);\n                        if (type.render !== currentRender) {\n                            var syntheticType = {\n                                $$typeof: REACT_FORWARD_REF_TYPE,\n                                render: currentRender\n                            };\n                            if (type.displayName !== undefined) {\n                                syntheticType.displayName = type.displayName;\n                            }\n                            return syntheticType;\n                        }\n                    }\n                    return type;\n                } // Use the latest known implementation.\n                return family.current;\n            }\n        }\n        function isCompatibleFamilyForHotReloading(fiber, element) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return false;\n                }\n                var prevType = fiber.elementType;\n                var nextType = element.type; // If we got here, we know types aren't === equal.\n                var needsCompareFamilies = false;\n                var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;\n                switch(fiber.tag){\n                    case ClassComponent:\n                        {\n                            if (typeof nextType === 'function') {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case FunctionComponent:\n                        {\n                            if (typeof nextType === 'function') {\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                // We don't know the inner type yet.\n                                // We're going to assume that the lazy inner type is stable,\n                                // and so it is sufficient to avoid reconciling it away.\n                                // We're not going to unwrap or actually use the new lazy type.\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case ForwardRef:\n                        {\n                            if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case MemoComponent:\n                    case SimpleMemoComponent:\n                        {\n                            if ($$typeofNextType === REACT_MEMO_TYPE) {\n                                // TODO: if it was but can no longer be simple,\n                                // we shouldn't set this.\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    default:\n                        return false;\n                } // Check if both types have a family and it's the same one.\n                if (needsCompareFamilies) {\n                    // Note: memo() and forwardRef() we'll compare outer rather than inner type.\n                    // This means both of them need to be registered to preserve state.\n                    // If we unwrapped and compared the inner types for wrappers instead,\n                    // then we would risk falsely saying two separate memo(Foo)\n                    // calls are equivalent because they wrap the same Foo function.\n                    var prevFamily = resolveFamily(prevType); // $FlowFixMe[not-a-function] found when upgrading Flow\n                    if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n        function markFailedErrorBoundaryForHotReloading(fiber) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return;\n                }\n                if (typeof WeakSet !== 'function') {\n                    return;\n                }\n                if (failedBoundaries === null) {\n                    failedBoundaries = new WeakSet();\n                }\n                failedBoundaries.add(fiber);\n            }\n        }\n        var scheduleRefresh = function(root, update) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return;\n                }\n                var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;\n                flushPassiveEffects();\n                scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);\n                flushSyncWork();\n            }\n        };\n        var scheduleRoot = function(root, element) {\n            {\n                if (root.context !== emptyContextObject) {\n                    // Super edge case: root has a legacy _renderSubtree context\n                    // but we don't know the parentComponent so we can't pass it.\n                    // Just ignore. We'll delete this with _renderSubtree code path later.\n                    return;\n                }\n                updateContainerSync(element, root, null, null);\n                flushSyncWork();\n            }\n        };\n        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n            {\n                var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n                var candidateType = null;\n                switch(tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                    case ClassComponent:\n                        candidateType = type;\n                        break;\n                    case ForwardRef:\n                        candidateType = type.render;\n                        break;\n                }\n                if (resolveFamily === null) {\n                    throw new Error('Expected resolveFamily to be set during hot reload.');\n                }\n                var needsRender = false;\n                var needsRemount = false;\n                if (candidateType !== null) {\n                    var family = resolveFamily(candidateType);\n                    if (family !== undefined) {\n                        if (staleFamilies.has(family)) {\n                            needsRemount = true;\n                        } else if (updatedFamilies.has(family)) {\n                            if (tag === ClassComponent) {\n                                needsRemount = true;\n                            } else {\n                                needsRender = true;\n                            }\n                        }\n                    }\n                }\n                if (failedBoundaries !== null) {\n                    if (failedBoundaries.has(fiber) || // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    alternate !== null && failedBoundaries.has(alternate)) {\n                        needsRemount = true;\n                    }\n                }\n                if (needsRemount) {\n                    fiber._debugNeedsRemount = true;\n                }\n                if (needsRemount || needsRender) {\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n                if (child !== null && !needsRemount) {\n                    scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n                }\n                if (sibling !== null) {\n                    scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n                }\n            }\n        }\n        var findHostInstancesForRefresh = function(root, families) {\n            {\n                var hostInstances = new Set();\n                var types = new Set(families.map(function(family) {\n                    return family.current;\n                }));\n                findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);\n                return hostInstances;\n            }\n        };\n        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n            {\n                var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n                var candidateType = null;\n                switch(tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                    case ClassComponent:\n                        candidateType = type;\n                        break;\n                    case ForwardRef:\n                        candidateType = type.render;\n                        break;\n                }\n                var didMatch = false;\n                if (candidateType !== null) {\n                    if (types.has(candidateType)) {\n                        didMatch = true;\n                    }\n                }\n                if (didMatch) {\n                    // We have a match. This only drills down to the closest host components.\n                    // There's no need to search deeper because for the purpose of giving\n                    // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n                    findHostInstancesForFiberShallowly(fiber, hostInstances);\n                } else {\n                    // If there's no match, maybe there will be one further down in the child tree.\n                    if (child !== null) {\n                        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n                    }\n                }\n                if (sibling !== null) {\n                    findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n                }\n            }\n        }\n        function findHostInstancesForFiberShallowly(fiber, hostInstances) {\n            {\n                var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n                if (foundHostInstances) {\n                    return;\n                } // If we didn't find any host children, fallback to closest host parent.\n                var node = fiber;\n                while(true){\n                    switch(node.tag){\n                        case HostSingleton:\n                        case HostComponent:\n                            hostInstances.add(node.stateNode);\n                            return;\n                        case HostPortal:\n                            hostInstances.add(node.stateNode.containerInfo);\n                            return;\n                        case HostRoot:\n                            hostInstances.add(node.stateNode.containerInfo);\n                            return;\n                    }\n                    if (node.return === null) {\n                        throw new Error('Expected to reach root first.');\n                    }\n                    node = node.return;\n                }\n            }\n        }\n        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n            {\n                var node = fiber;\n                var foundHostInstances = false;\n                while(true){\n                    if (node.tag === HostComponent || node.tag === HostHoistable || (supportsSingletons ? node.tag === HostSingleton : false)) {\n                        // We got a match.\n                        foundHostInstances = true;\n                        hostInstances.add(node.stateNode); // There may still be more, so keep searching.\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === fiber) {\n                        return foundHostInstances;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === fiber) {\n                            return foundHostInstances;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n            return false;\n        }\n        var hasBadMapPolyfill;\n        {\n            hasBadMapPolyfill = false;\n            try {\n                var nonExtensibleObject = Object.preventExtensions({});\n                /* eslint-disable no-new */ new Map([\n                    [\n                        nonExtensibleObject,\n                        null\n                    ]\n                ]);\n                new Set([\n                    nonExtensibleObject\n                ]);\n            /* eslint-enable no-new */ } catch (e) {\n                // TODO: Consider warning about bad polyfills\n                hasBadMapPolyfill = true;\n            }\n        }\n        function FiberNode(tag, pendingProps, key, mode) {\n            // Instance\n            this.tag = tag;\n            this.key = key;\n            this.elementType = null;\n            this.type = null;\n            this.stateNode = null; // Fiber\n            this.return = null;\n            this.child = null;\n            this.sibling = null;\n            this.index = 0;\n            this.ref = null;\n            this.refCleanup = null;\n            this.pendingProps = pendingProps;\n            this.memoizedProps = null;\n            this.updateQueue = null;\n            this.memoizedState = null;\n            this.dependencies = null;\n            this.mode = mode; // Effects\n            this.flags = NoFlags$1;\n            this.subtreeFlags = NoFlags$1;\n            this.deletions = null;\n            this.lanes = NoLanes;\n            this.childLanes = NoLanes;\n            this.alternate = null;\n            {\n                // Note: The following is done to avoid a v8 performance cliff.\n                //\n                // Initializing the fields below to smis and later updating them with\n                // double values will cause Fibers to end up having separate shapes.\n                // This behavior/bug has something to do with Object.preventExtension().\n                // Fortunately this only impacts DEV builds.\n                // Unfortunately it makes React unusably slow for some applications.\n                // To work around this, initialize the fields below with doubles.\n                //\n                // Learn more about this here:\n                // https://github.com/facebook/react/issues/14365\n                // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n                this.actualDuration = Number.NaN;\n                this.actualStartTime = Number.NaN;\n                this.selfBaseDuration = Number.NaN;\n                this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.\n                // This won't trigger the performance cliff mentioned above,\n                // and it simplifies other profiler code (including DevTools).\n                this.actualDuration = 0;\n                this.actualStartTime = -1;\n                this.selfBaseDuration = 0;\n                this.treeBaseDuration = 0;\n            }\n            {\n                // This isn't directly used but is handy for debugging internals:\n                this._debugInfo = null;\n                this._debugOwner = null;\n                this._debugNeedsRemount = false;\n                this._debugHookTypes = null;\n                if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n                    Object.preventExtensions(this);\n                }\n            }\n        } // This is a constructor function, rather than a POJO constructor, still\n        // please ensure we do the following:\n        // 1) Nobody should add any instance methods on this. Instance methods can be\n        //    more difficult to predict when they get optimized and they are almost\n        //    never inlined properly in static compilers.\n        // 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n        //    always know when it is a fiber.\n        // 3) We might want to experiment with using numeric keys since they are easier\n        //    to optimize in a non-JIT environment.\n        // 4) We can easily go from a constructor to a createFiber object literal if that\n        //    is faster.\n        // 5) It should be easy to port this to a C struct and keep a C implementation\n        //    compatible.\n        function createFiber(tag, pendingProps, key, mode) {\n            // $FlowFixMe[invalid-constructor]: the shapes are exact here but Flow doesn't like constructors\n            return new FiberNode(tag, pendingProps, key, mode);\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function isSimpleFunctionComponent(type) {\n            return typeof type === 'function' && !shouldConstruct(type) && type.defaultProps === undefined;\n        }\n        function isFunctionClassComponent(type) {\n            return shouldConstruct(type);\n        } // This is used to create an alternate fiber to do work on.\n        function createWorkInProgress(current, pendingProps) {\n            var workInProgress = current.alternate;\n            if (workInProgress === null) {\n                // We use a double buffering pooling technique because we know that we'll\n                // only ever need at most two versions of a tree. We pool the \"other\" unused\n                // node that we're free to reuse. This is lazily created to avoid allocating\n                // extra objects for things that are never updated. It also allow us to\n                // reclaim the extra memory if needed.\n                workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n                workInProgress.elementType = current.elementType;\n                workInProgress.type = current.type;\n                workInProgress.stateNode = current.stateNode;\n                {\n                    // DEV-only fields\n                    workInProgress._debugOwner = current._debugOwner;\n                    workInProgress._debugHookTypes = current._debugHookTypes;\n                }\n                workInProgress.alternate = current;\n                current.alternate = workInProgress;\n            } else {\n                workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.\n                workInProgress.type = current.type; // We already have an alternate.\n                // Reset the effect tag.\n                workInProgress.flags = NoFlags$1; // The effects are no longer valid.\n                workInProgress.subtreeFlags = NoFlags$1;\n                workInProgress.deletions = null;\n                {\n                    // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n                    // This prevents time from endlessly accumulating in new commits.\n                    // This has the downside of resetting values for different priority renders,\n                    // But works for yielding (the common case) and should support resuming.\n                    workInProgress.actualDuration = 0;\n                    workInProgress.actualStartTime = -1;\n                }\n            } // Reset all effects except static ones.\n            // Static effects are not specific to a render.\n            workInProgress.flags = current.flags & StaticMask;\n            workInProgress.childLanes = current.childLanes;\n            workInProgress.lanes = current.lanes;\n            workInProgress.child = current.child;\n            workInProgress.memoizedProps = current.memoizedProps;\n            workInProgress.memoizedState = current.memoizedState;\n            workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so\n            // it cannot be shared with the current fiber.\n            var currentDependencies = current.dependencies;\n            workInProgress.dependencies = currentDependencies === null ? null : {\n                lanes: currentDependencies.lanes,\n                firstContext: currentDependencies.firstContext\n            }; // These will be overridden during the parent's reconciliation\n            workInProgress.sibling = current.sibling;\n            workInProgress.index = current.index;\n            workInProgress.ref = current.ref;\n            workInProgress.refCleanup = current.refCleanup;\n            {\n                workInProgress.selfBaseDuration = current.selfBaseDuration;\n                workInProgress.treeBaseDuration = current.treeBaseDuration;\n            }\n            {\n                workInProgress._debugInfo = current._debugInfo;\n                workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n                switch(workInProgress.tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                        workInProgress.type = resolveFunctionForHotReloading(current.type);\n                        break;\n                    case ClassComponent:\n                        workInProgress.type = resolveClassForHotReloading(current.type);\n                        break;\n                    case ForwardRef:\n                        workInProgress.type = resolveForwardRefForHotReloading(current.type);\n                        break;\n                }\n            }\n            return workInProgress;\n        } // Used to reuse a Fiber for a second pass.\n        function resetWorkInProgress(workInProgress, renderLanes) {\n            // This resets the Fiber to what createFiber or createWorkInProgress would\n            // have set the values to before during the first pass. Ideally this wouldn't\n            // be necessary but unfortunately many code paths reads from the workInProgress\n            // when they should be reading from current and writing to workInProgress.\n            // We assume pendingProps, index, key, ref, return are still untouched to\n            // avoid doing another reconciliation.\n            // Reset the effect flags but keep any Placement tags, since that's something\n            // that child fiber is setting, not the reconciliation.\n            workInProgress.flags &= StaticMask | Placement; // The effects are no longer valid.\n            var current = workInProgress.alternate;\n            if (current === null) {\n                // Reset to createFiber's initial values.\n                workInProgress.childLanes = NoLanes;\n                workInProgress.lanes = renderLanes;\n                workInProgress.child = null;\n                workInProgress.subtreeFlags = NoFlags$1;\n                workInProgress.memoizedProps = null;\n                workInProgress.memoizedState = null;\n                workInProgress.updateQueue = null;\n                workInProgress.dependencies = null;\n                workInProgress.stateNode = null;\n                {\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\n                    // actual time across multiple render passes.\n                    workInProgress.selfBaseDuration = 0;\n                    workInProgress.treeBaseDuration = 0;\n                }\n            } else {\n                // Reset to the cloned values that createWorkInProgress would've.\n                workInProgress.childLanes = current.childLanes;\n                workInProgress.lanes = current.lanes;\n                workInProgress.child = current.child;\n                workInProgress.subtreeFlags = NoFlags$1;\n                workInProgress.deletions = null;\n                workInProgress.memoizedProps = current.memoizedProps;\n                workInProgress.memoizedState = current.memoizedState;\n                workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.\n                workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so\n                // it cannot be shared with the current fiber.\n                var currentDependencies = current.dependencies;\n                workInProgress.dependencies = currentDependencies === null ? null : {\n                    lanes: currentDependencies.lanes,\n                    firstContext: currentDependencies.firstContext\n                };\n                {\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\n                    // actual time across multiple render passes.\n                    workInProgress.selfBaseDuration = current.selfBaseDuration;\n                    workInProgress.treeBaseDuration = current.treeBaseDuration;\n                }\n            }\n            return workInProgress;\n        }\n        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {\n            var mode;\n            {\n                mode = ConcurrentMode;\n                if (isStrictMode === true) {\n                    mode |= StrictLegacyMode | StrictEffectsMode;\n                }\n            }\n            if (isDevToolsPresent) {\n                // Always collect profile timings when DevTools are present.\n                // This enables DevTools to start capturing timing at any point–\n                // Without some nodes in the tree having empty base times.\n                mode |= ProfileMode;\n            }\n            return createFiber(HostRoot, null, null, mode);\n        }\n        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n            var fiberTag = FunctionComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n            var resolvedType = type;\n            if (typeof type === 'function') {\n                if (shouldConstruct(type)) {\n                    fiberTag = ClassComponent;\n                    {\n                        resolvedType = resolveClassForHotReloading(resolvedType);\n                    }\n                } else {\n                    {\n                        resolvedType = resolveFunctionForHotReloading(resolvedType);\n                    }\n                }\n            } else if (typeof type === 'string') {\n                if (supportsResources && supportsSingletons) {\n                    var hostContext = getHostContext();\n                    fiberTag = isHostHoistableType(type, pendingProps, hostContext) ? HostHoistable : isHostSingletonType(type) ? HostSingleton : HostComponent;\n                } else if (supportsResources) {\n                    var _hostContext = getHostContext();\n                    fiberTag = isHostHoistableType(type, pendingProps, _hostContext) ? HostHoistable : HostComponent;\n                } else if (supportsSingletons) {\n                    fiberTag = isHostSingletonType(type) ? HostSingleton : HostComponent;\n                } else {\n                    fiberTag = HostComponent;\n                }\n            } else {\n                getTag: switch(type){\n                    case REACT_FRAGMENT_TYPE:\n                        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n                    case REACT_STRICT_MODE_TYPE:\n                        fiberTag = Mode;\n                        mode |= StrictLegacyMode;\n                        {\n                            // Strict effects should never run on legacy roots\n                            mode |= StrictEffectsMode;\n                        }\n                        break;\n                    case REACT_PROFILER_TYPE:\n                        return createFiberFromProfiler(pendingProps, mode, lanes, key);\n                    case REACT_SUSPENSE_TYPE:\n                        return createFiberFromSuspense(pendingProps, mode, lanes, key);\n                    case REACT_SUSPENSE_LIST_TYPE:\n                        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n                    case REACT_OFFSCREEN_TYPE:\n                        return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n                    case REACT_LEGACY_HIDDEN_TYPE:\n                    // Fall through\n                    case REACT_SCOPE_TYPE:\n                    // Fall through\n                    case REACT_TRACING_MARKER_TYPE:\n                    // Fall through\n                    case REACT_DEBUG_TRACING_MODE_TYPE:\n                    // Fall through\n                    default:\n                        {\n                            if (typeof type === 'object' && type !== null) {\n                                switch(type.$$typeof){\n                                    case REACT_PROVIDER_TYPE:\n                                    // Fall through\n                                    case REACT_CONTEXT_TYPE:\n                                        {\n                                            fiberTag = ContextProvider;\n                                            break getTag;\n                                        }\n                                    case REACT_CONSUMER_TYPE:\n                                        {\n                                            fiberTag = ContextConsumer;\n                                            break getTag;\n                                        }\n                                    // Fall through\n                                    case REACT_FORWARD_REF_TYPE:\n                                        fiberTag = ForwardRef;\n                                        {\n                                            resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                                        }\n                                        break getTag;\n                                    case REACT_MEMO_TYPE:\n                                        fiberTag = MemoComponent;\n                                        break getTag;\n                                    case REACT_LAZY_TYPE:\n                                        fiberTag = LazyComponent;\n                                        resolvedType = null;\n                                        break getTag;\n                                }\n                            }\n                            var info = '';\n                            var typeString;\n                            {\n                                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n                                    info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n                                }\n                                if (type === null) {\n                                    typeString = 'null';\n                                } else if (isArray(type)) {\n                                    typeString = 'array';\n                                } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                                    typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n                                    info = ' Did you accidentally export a JSX literal instead of a component?';\n                                } else {\n                                    typeString = typeof type;\n                                }\n                                var ownerName = owner ? getComponentNameFromOwner(owner) : null;\n                                if (ownerName) {\n                                    info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n                                }\n                            }\n                            throw new Error('Element type is invalid: expected a string (for built-in ' + 'components) or a class/function (for composite components) ' + (\"but got: \" + typeString + \".\" + info));\n                        }\n                }\n            }\n            var fiber = createFiber(fiberTag, pendingProps, key, mode);\n            fiber.elementType = type;\n            fiber.type = resolvedType;\n            fiber.lanes = lanes;\n            {\n                fiber._debugOwner = owner;\n            }\n            return fiber;\n        }\n        function createFiberFromElement(element, mode, lanes) {\n            var owner = null;\n            {\n                owner = element._owner;\n            }\n            var type = element.type;\n            var key = element.key;\n            var pendingProps = element.props;\n            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n            {\n                fiber._debugOwner = element._owner;\n            }\n            return fiber;\n        }\n        function createFiberFromFragment(elements, mode, lanes, key) {\n            var fiber = createFiber(Fragment, elements, key, mode);\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromProfiler(pendingProps, mode, lanes, key) {\n            {\n                if (typeof pendingProps.id !== 'string') {\n                    error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);\n                }\n            }\n            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n            fiber.elementType = REACT_PROFILER_TYPE;\n            fiber.lanes = lanes;\n            {\n                fiber.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                };\n            }\n            return fiber;\n        }\n        function createFiberFromSuspense(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_SUSPENSE_TYPE;\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_OFFSCREEN_TYPE;\n            fiber.lanes = lanes;\n            var primaryChildInstance = {\n                _visibility: OffscreenVisible,\n                _pendingVisibility: OffscreenVisible,\n                _pendingMarkers: null,\n                _retryCache: null,\n                _transitions: null,\n                _current: null,\n                detach: function() {\n                    return detachOffscreenInstance(primaryChildInstance);\n                },\n                attach: function() {\n                    return attachOffscreenInstance(primaryChildInstance);\n                }\n            };\n            fiber.stateNode = primaryChildInstance;\n            return fiber;\n        }\n        function createFiberFromText(content, mode, lanes) {\n            var fiber = createFiber(HostText, content, null, mode);\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromDehydratedFragment(dehydratedNode) {\n            var fiber = createFiber(DehydratedFragment, null, null, NoMode);\n            fiber.stateNode = dehydratedNode;\n            return fiber;\n        }\n        function createFiberFromPortal(portal, mode, lanes) {\n            var pendingProps = portal.children !== null ? portal.children : [];\n            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n            fiber.lanes = lanes;\n            fiber.stateNode = {\n                containerInfo: portal.containerInfo,\n                pendingChildren: null,\n                // Used by persistent updates\n                implementation: portal.implementation\n            };\n            return fiber;\n        }\n        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {\n            this.tag = ConcurrentRoot;\n            this.containerInfo = containerInfo;\n            this.pendingChildren = null;\n            this.current = null;\n            this.pingCache = null;\n            this.finishedWork = null;\n            this.timeoutHandle = noTimeout;\n            this.cancelPendingCommit = null;\n            this.context = null;\n            this.pendingContext = null;\n            this.next = null;\n            this.callbackNode = null;\n            this.callbackPriority = NoLane;\n            this.expirationTimes = createLaneMap(NoTimestamp);\n            this.pendingLanes = NoLanes;\n            this.suspendedLanes = NoLanes;\n            this.pingedLanes = NoLanes;\n            this.expiredLanes = NoLanes;\n            this.finishedLanes = NoLanes;\n            this.errorRecoveryDisabledLanes = NoLanes;\n            this.shellSuspendCounter = 0;\n            this.entangledLanes = NoLanes;\n            this.entanglements = createLaneMap(NoLanes);\n            this.hiddenUpdates = createLaneMap(null);\n            this.identifierPrefix = identifierPrefix;\n            this.onUncaughtError = onUncaughtError;\n            this.onCaughtError = onCaughtError;\n            this.onRecoverableError = onRecoverableError;\n            {\n                this.pooledCache = null;\n                this.pooledCacheLanes = NoLanes;\n            }\n            this.formState = formState;\n            this.incompleteTransitions = new Map();\n            {\n                this.effectDuration = 0;\n                this.passiveEffectDuration = 0;\n            }\n            {\n                this.memoizedUpdaters = new Set();\n                var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n                for(var _i = 0; _i < TotalLanes; _i++){\n                    pendingUpdatersLaneMap.push(new Set());\n                }\n            }\n            {\n                {\n                    // TODO: This varies by each renderer.\n                    this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';\n                }\n            }\n        }\n        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // host config, but because they are passed in at runtime, we have to thread\n        // them through the root constructor. Perhaps we should put them all into a\n        // single type, like a DynamicHostConfig that is defined by the renderer.\n        identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);\n            // stateNode is any.\n            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);\n            root.current = uninitializedFiber;\n            uninitializedFiber.stateNode = root;\n            {\n                var initialCache = createCache();\n                retainCache(initialCache); // The pooledCache is a fresh cache instance that is used temporarily\n                // for newly mounted boundaries during a render. In general, the\n                // pooledCache is always cleared from the root at the end of a render:\n                // it is either released when render commits, or moved to an Offscreen\n                // component if rendering suspends. Because the lifetime of the pooled\n                // cache is distinct from the main memoizedState.cache, it must be\n                // retained separately.\n                root.pooledCache = initialCache;\n                retainCache(initialCache);\n                var initialState = {\n                    element: initialChildren,\n                    isDehydrated: hydrate,\n                    cache: initialCache\n                };\n                uninitializedFiber.memoizedState = initialState;\n            }\n            initializeUpdateQueue(uninitializedFiber);\n            return root;\n        }\n        var ReactVersion = '19.0.0-rc-935180c7e0-20240524';\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return '' + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function createPortal(children, containerInfo, implementation) {\n            var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n            {\n                checkKeyStringCoercion(key);\n            }\n            return {\n                // This tag allow us to uniquely identify this as a React Portal\n                $$typeof: REACT_PORTAL_TYPE,\n                key: key == null ? null : '' + key,\n                children: children,\n                containerInfo: containerInfo,\n                implementation: implementation\n            };\n        }\n        // Might add PROFILE later.\n        var didWarnAboutNestedUpdates;\n        var didWarnAboutFindNodeInStrictMode;\n        {\n            didWarnAboutNestedUpdates = false;\n            didWarnAboutFindNodeInStrictMode = {};\n        }\n        function getContextForSubtree(parentComponent) {\n            if (!parentComponent) {\n                return emptyContextObject;\n            }\n            var fiber = get(parentComponent);\n            var parentContext = findCurrentUnmaskedContext();\n            if (fiber.tag === ClassComponent) {\n                var Component = fiber.type;\n                if (isContextProvider()) {\n                    return processChildContext(fiber, Component, parentContext);\n                }\n            }\n            return parentContext;\n        }\n        function findHostInstance(component) {\n            var fiber = get(component);\n            if (fiber === undefined) {\n                if (typeof component.render === 'function') {\n                    throw new Error('Unable to find node on an unmounted component.');\n                } else {\n                    var keys = Object.keys(component).join(',');\n                    throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n                }\n            }\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return getPublicInstance(hostFiber.stateNode);\n        }\n        function findHostInstanceWithWarning(component, methodName) {\n            {\n                var fiber = get(component);\n                if (fiber === undefined) {\n                    if (typeof component.render === 'function') {\n                        throw new Error('Unable to find node on an unmounted component.');\n                    } else {\n                        var keys = Object.keys(component).join(',');\n                        throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n                    }\n                }\n                var hostFiber = findCurrentHostFiber(fiber);\n                if (hostFiber === null) {\n                    return null;\n                }\n                if (hostFiber.mode & StrictLegacyMode) {\n                    var componentName = getComponentNameFromFiber(fiber) || 'Component';\n                    if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n                        didWarnAboutFindNodeInStrictMode[componentName] = true;\n                        var previousFiber = current;\n                        try {\n                            setCurrentDebugFiberInDEV(hostFiber);\n                            if (fiber.mode & StrictLegacyMode) {\n                                error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://react.dev/link/strict-mode-find-node', methodName, methodName, componentName);\n                            } else {\n                                error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://react.dev/link/strict-mode-find-node', methodName, methodName, componentName);\n                            }\n                        } finally{\n                            // Ideally this should reset to previous but this shouldn't be called in\n                            // render and there's another warning for that anyway.\n                            if (previousFiber) {\n                                setCurrentDebugFiberInDEV(previousFiber);\n                            } else {\n                                resetCurrentDebugFiberInDEV();\n                            }\n                        }\n                    }\n                }\n                return getPublicInstance(hostFiber.stateNode);\n            }\n        }\n        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks) {\n            var hydrate = false;\n            var initialChildren = null;\n            return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);\n        }\n        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n            var hydrate = true;\n            var root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState); // TODO: Move this to FiberRoot constructor\n            root.context = getContextForSubtree(null); // Schedule the initial render. In a hydration root, this is different from\n            // a regular update because the initial render must match was was rendered\n            // on the server.\n            // NOTE: This update intentionally doesn't have a payload. We're only using\n            // the update to schedule work on the root fiber (and, for legacy roots, to\n            // enqueue the callback if one is provided).\n            var current = root.current;\n            var lane = requestUpdateLane(current);\n            var update = createUpdate(lane);\n            update.callback = callback !== undefined && callback !== null ? callback : null;\n            enqueueUpdate(current, update, lane);\n            scheduleInitialHydrationOnRoot(root, lane);\n            return root;\n        }\n        function updateContainer(element, container, parentComponent, callback) {\n            var current = container.current;\n            var lane = requestUpdateLane(current);\n            updateContainerImpl(current, lane, element, container, parentComponent, callback);\n            return lane;\n        }\n        function updateContainerSync(element, container, parentComponent, callback) {\n            if (container.tag === LegacyRoot) {\n                flushPassiveEffects();\n            }\n            var current = container.current;\n            updateContainerImpl(current, SyncLane, element, container, parentComponent, callback);\n            return SyncLane;\n        }\n        function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {\n            {\n                onScheduleRoot(container, element);\n            }\n            {\n                markRenderScheduled(lane);\n            }\n            var context = getContextForSubtree(parentComponent);\n            if (container.context === null) {\n                container.context = context;\n            } else {\n                container.pendingContext = context;\n            }\n            {\n                if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\n                    didWarnAboutNestedUpdates = true;\n                    error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentNameFromFiber(current) || 'Unknown');\n                }\n            }\n            var update = createUpdate(lane); // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            update.payload = {\n                element: element\n            };\n            callback = callback === undefined ? null : callback;\n            if (callback !== null) {\n                {\n                    if (typeof callback !== 'function') {\n                        error('Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n                    }\n                }\n                update.callback = callback;\n            }\n            var root = enqueueUpdate(rootFiber, update, lane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, rootFiber, lane);\n                entangleTransitions(root, rootFiber, lane);\n            }\n        }\n        function getPublicRootInstance(container) {\n            var containerFiber = container.current;\n            if (!containerFiber.child) {\n                return null;\n            }\n            switch(containerFiber.child.tag){\n                case HostSingleton:\n                case HostComponent:\n                    return getPublicInstance(containerFiber.child.stateNode);\n                default:\n                    return containerFiber.child.stateNode;\n            }\n        }\n        function attemptSynchronousHydration(fiber) {\n            switch(fiber.tag){\n                case HostRoot:\n                    {\n                        var root = fiber.stateNode;\n                        if (isRootDehydrated(root)) {\n                            // Flush the first scheduled \"update\".\n                            var lanes = getHighestPriorityPendingLanes(root);\n                            flushRoot(root, lanes);\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                        if (_root !== null) {\n                            scheduleUpdateOnFiber(_root, fiber, SyncLane);\n                        }\n                        flushSyncWork(); // If we're still blocked after this, we need to increase\n                        // the priority of any promises resolving within this\n                        // boundary so that they next attempt also has higher pri.\n                        var retryLane = SyncLane;\n                        markRetryLaneIfNotHydrated(fiber, retryLane);\n                        break;\n                    }\n            }\n        }\n        function markRetryLaneImpl(fiber, retryLane) {\n            var suspenseState = fiber.memoizedState;\n            if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n            }\n        } // Increases the priority of thenables when they resolve within this boundary.\n        function markRetryLaneIfNotHydrated(fiber, retryLane) {\n            markRetryLaneImpl(fiber, retryLane);\n            var alternate = fiber.alternate;\n            if (alternate) {\n                markRetryLaneImpl(alternate, retryLane);\n            }\n        }\n        function attemptContinuousHydration(fiber) {\n            if (fiber.tag !== SuspenseComponent) {\n                // We ignore HostRoots here because we can't increase\n                // their priority and they should not suspend on I/O,\n                // since you have to wrap anything that might suspend in\n                // Suspense.\n                return;\n            }\n            var lane = SelectiveHydrationLane;\n            var root = enqueueConcurrentRenderForLane(fiber, lane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, fiber, lane);\n            }\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function attemptHydrationAtCurrentPriority(fiber) {\n            if (fiber.tag !== SuspenseComponent) {\n                // We ignore HostRoots here because we can't increase\n                // their priority other than synchronously flush it.\n                return;\n            }\n            var lane = requestUpdateLane(fiber);\n            var root = enqueueConcurrentRenderForLane(fiber, lane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, fiber, lane);\n            }\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function findHostInstanceWithNoPortals(fiber) {\n            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return getPublicInstance(hostFiber.stateNode);\n        }\n        var shouldErrorImpl = function(fiber) {\n            return null;\n        };\n        function shouldError(fiber) {\n            return shouldErrorImpl(fiber);\n        }\n        var shouldSuspendImpl = function(fiber) {\n            return false;\n        };\n        function shouldSuspend(fiber) {\n            return shouldSuspendImpl(fiber);\n        }\n        var overrideHookState = null;\n        var overrideHookStateDeletePath = null;\n        var overrideHookStateRenamePath = null;\n        var overrideProps = null;\n        var overridePropsDeletePath = null;\n        var overridePropsRenamePath = null;\n        var scheduleUpdate = null;\n        var setErrorHandler = null;\n        var setSuspenseHandler = null;\n        {\n            var copyWithDeleteImpl = function(obj, path, index) {\n                var key = path[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n                if (index + 1 === path.length) {\n                    if (isArray(updated)) {\n                        updated.splice(key, 1);\n                    } else {\n                        delete updated[key];\n                    }\n                    return updated;\n                } // $FlowFixMe[incompatible-use] number or string is fine here\n                updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n                return updated;\n            };\n            var copyWithDelete = function(obj, path) {\n                return copyWithDeleteImpl(obj, path, 0);\n            };\n            var copyWithRenameImpl = function(obj, oldPath, newPath, index) {\n                var oldKey = oldPath[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n                if (index + 1 === oldPath.length) {\n                    var newKey = newPath[index]; // $FlowFixMe[incompatible-use] number or string is fine here\n                    updated[newKey] = updated[oldKey];\n                    if (isArray(updated)) {\n                        updated.splice(oldKey, 1);\n                    } else {\n                        delete updated[oldKey];\n                    }\n                } else {\n                    // $FlowFixMe[incompatible-use] number or string is fine here\n                    updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n                }\n                return updated;\n            };\n            var copyWithRename = function(obj, oldPath, newPath) {\n                if (oldPath.length !== newPath.length) {\n                    warn('copyWithRename() expects paths of the same length');\n                    return;\n                } else {\n                    for(var i = 0; i < newPath.length - 1; i++){\n                        if (oldPath[i] !== newPath[i]) {\n                            warn('copyWithRename() expects paths to be the same except for the deepest key');\n                            return;\n                        }\n                    }\n                }\n                return copyWithRenameImpl(obj, oldPath, newPath, 0);\n            };\n            var copyWithSetImpl = function(obj, path, index, value) {\n                if (index >= path.length) {\n                    return value;\n                }\n                var key = path[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj); // $FlowFixMe[incompatible-use] number or string is fine here\n                updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n                return updated;\n            };\n            var copyWithSet = function(obj, path, value) {\n                return copyWithSetImpl(obj, path, 0, value);\n            };\n            var findHook = function(fiber, id) {\n                // For now, the \"id\" of stateful hooks is just the stateful hook index.\n                // This may change in the future with e.g. nested hooks.\n                var currentHook = fiber.memoizedState;\n                while(currentHook !== null && id > 0){\n                    currentHook = currentHook.next;\n                    id--;\n                }\n                return currentHook;\n            }; // Support DevTools editable values for useState and useReducer.\n            overrideHookState = function(fiber, id, path, value) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithSet(hook.memoizedState, path, value);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n            };\n            overrideHookStateDeletePath = function(fiber, id, path) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithDelete(hook.memoizedState, path);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n            };\n            overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n            }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n            overrideProps = function(fiber, path, value) {\n                fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            overridePropsDeletePath = function(fiber, path) {\n                fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            overridePropsRenamePath = function(fiber, oldPath, newPath) {\n                fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            scheduleUpdate = function(fiber) {\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            setErrorHandler = function(newShouldErrorImpl) {\n                shouldErrorImpl = newShouldErrorImpl;\n            };\n            setSuspenseHandler = function(newShouldSuspendImpl) {\n                shouldSuspendImpl = newShouldSuspendImpl;\n            };\n        }\n        function findHostInstanceByFiber(fiber) {\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return hostFiber.stateNode;\n        }\n        function emptyFindFiberByHostInstance(instance) {\n            return null;\n        }\n        function getCurrentFiberForDevTools() {\n            return current;\n        }\n        function injectIntoDevTools(devToolsConfig) {\n            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n            return injectInternals({\n                bundleType: devToolsConfig.bundleType,\n                version: devToolsConfig.version,\n                rendererPackageName: devToolsConfig.rendererPackageName,\n                rendererConfig: devToolsConfig.rendererConfig,\n                overrideHookState: overrideHookState,\n                overrideHookStateDeletePath: overrideHookStateDeletePath,\n                overrideHookStateRenamePath: overrideHookStateRenamePath,\n                overrideProps: overrideProps,\n                overridePropsDeletePath: overridePropsDeletePath,\n                overridePropsRenamePath: overridePropsRenamePath,\n                setErrorHandler: setErrorHandler,\n                setSuspenseHandler: setSuspenseHandler,\n                scheduleUpdate: scheduleUpdate,\n                currentDispatcherRef: ReactSharedInternals,\n                findHostInstanceByFiber: findHostInstanceByFiber,\n                findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n                // React Refresh\n                findHostInstancesForRefresh: findHostInstancesForRefresh,\n                scheduleRefresh: scheduleRefresh,\n                scheduleRoot: scheduleRoot,\n                setRefreshHandler: setRefreshHandler,\n                // Enables DevTools to append owner stacks to error messages in DEV mode.\n                getCurrentFiber: getCurrentFiberForDevTools,\n                // Enables DevTools to detect reconciler version rather than renderer version\n                // which may not match for third party renderers.\n                reconcilerVersion: ReactVersion\n            });\n        }\n        exports.attemptContinuousHydration = attemptContinuousHydration;\n        exports.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority;\n        exports.attemptSynchronousHydration = attemptSynchronousHydration;\n        exports.batchedUpdates = batchedUpdates;\n        exports.createComponentSelector = createComponentSelector;\n        exports.createContainer = createContainer;\n        exports.createHasPseudoClassSelector = createHasPseudoClassSelector;\n        exports.createHydrationContainer = createHydrationContainer;\n        exports.createPortal = createPortal;\n        exports.createRoleSelector = createRoleSelector;\n        exports.createTestNameSelector = createTestNameSelector;\n        exports.createTextSelector = createTextSelector;\n        exports.defaultOnCaughtError = defaultOnCaughtError;\n        exports.defaultOnRecoverableError = defaultOnRecoverableError;\n        exports.defaultOnUncaughtError = defaultOnUncaughtError;\n        exports.deferredUpdates = deferredUpdates;\n        exports.discreteUpdates = discreteUpdates;\n        exports.findAllNodes = findAllNodes;\n        exports.findBoundingRects = findBoundingRects;\n        exports.findHostInstance = findHostInstance;\n        exports.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;\n        exports.findHostInstanceWithWarning = findHostInstanceWithWarning;\n        exports.flushPassiveEffects = flushPassiveEffects;\n        exports.flushSyncFromReconciler = flushSyncFromReconciler;\n        exports.flushSyncWork = flushSyncWork;\n        exports.focusWithin = focusWithin;\n        exports.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription;\n        exports.getPublicRootInstance = getPublicRootInstance;\n        exports.injectIntoDevTools = injectIntoDevTools;\n        exports.isAlreadyRendering = isAlreadyRendering;\n        exports.observeVisibleRects = observeVisibleRects;\n        exports.shouldError = shouldError;\n        exports.shouldSuspend = shouldSuspend;\n        exports.startHostTransition = startHostTransition;\n        exports.updateContainer = updateContainer;\n        exports.updateContainerSync = updateContainerSync;\n        return exports;\n    };\n    module.exports[\"default\"] = module.exports;\n    Object.defineProperty(module.exports, \"__esModule\", ({\n        value: true\n    }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVZO0FBRWIsSUFBSUEsSUFBcUMsRUFBRTtJQUN6Q0MsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLGNBQWNDLFNBQVM7UUFDL0MsSUFBSUYsVUFBVSxDQUFDO1FBQ25CO1FBRUEsSUFBSUcsUUFBUUMsbUJBQU9BLENBQUMsaUdBQU87UUFDM0IsSUFBSUMsWUFBWUQsbUJBQU9BLENBQUMsd0ZBQVc7UUFFbkMsSUFBSUUsdUJBQXVCSCxNQUFNSSwrREFBK0Q7UUFFaEcsSUFBSUMsa0JBQWtCO1FBQ3RCLFNBQVNDLG1CQUFtQkMsa0JBQWtCO1lBQzVDO2dCQUNFRixrQkFBa0JFO1lBQ3BCO1FBQ0YsRUFBRSwrREFBK0Q7UUFDakUsK0NBQStDO1FBQy9DLEVBQUU7UUFDRiw4REFBOEQ7UUFDOUQscUNBQXFDO1FBRXJDLFNBQVNDLEtBQUtDLE1BQU07WUFDbEI7Z0JBQ0UsSUFBSSxDQUFDSixpQkFBaUI7b0JBQ3BCLElBQUssSUFBSUssT0FBT0MsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1KLE9BQU8sSUFBSUEsT0FBTyxJQUFJLElBQUlLLE9BQU8sR0FBR0EsT0FBT0wsTUFBTUssT0FBUTt3QkFDMUdGLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztvQkFDbEM7b0JBRUFDLGFBQWEsUUFBUVAsUUFBUUk7Z0JBQy9CO1lBQ0Y7UUFDRjtRQUNBLFNBQVNJLE1BQU1SLE1BQU07WUFDbkI7Z0JBQ0UsSUFBSSxDQUFDSixpQkFBaUI7b0JBQ3BCLElBQUssSUFBSWEsUUFBUVAsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1JLFFBQVEsSUFBSUEsUUFBUSxJQUFJLElBQUlDLFFBQVEsR0FBR0EsUUFBUUQsT0FBT0MsUUFBUzt3QkFDakhO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cHJvamVjdHMvZm9yZ2V0YWkvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gJCQkcmVjb25jaWxlcigkJCRjb25maWcpIHtcbiAgICB2YXIgZXhwb3J0cyA9IHt9O1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFNjaGVkdWxlciA9IHJlcXVpcmUoJ3NjaGVkdWxlcicpO1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREU7XG5cbnZhciBzdXBwcmVzc1dhcm5pbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldFN1cHByZXNzV2FybmluZyhuZXdTdXBwcmVzc1dhcm5pbmcpIHtcbiAge1xuICAgIHN1cHByZXNzV2FybmluZyA9IG5ld1N1cHByZXNzV2FybmluZztcbiAgfVxufSAvLyBJbiBERVYsIGNhbGxzIHRvIGNvbnNvbGUud2FybiBhbmQgY29uc29sZS5lcnJvciBnZXQgcmVwbGFjZWRcbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGlmICghc3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBpZiAoIXN1cHByZXNzV2FybmluZykge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBpc0Vycm9yTG9nZ2VyID0gZm9ybWF0ID09PSAnJXNcXG5cXG4lc1xcbicgfHwgZm9ybWF0ID09PSAnJW9cXG5cXG4lc1xcblxcbiVzXFxuJztcblxuICAgIGlmIChSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2spIHtcbiAgICAgIHZhciBzdGFjayA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjaygpO1xuXG4gICAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRXJyb3JMb2dnZXIpIHtcbiAgICAgIC8vIERvbid0IHByZWZpeCBvdXIgZGVmYXVsdCBsb2dnaW5nIGZvcm1hdHRpbmcgaW4gUmVhY3RGaWJlckVycm9yTG9nZ2dlci5cbiAgICAgIC8vIERvbid0IHRvU3RyaW5nIHRoZSBhcmd1bWVudHMuXG4gICAgICBhcmdzLnVuc2hpZnQoZm9ybWF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgcHJlZml4IGFuZCBzdG9wIHRvU3RyaW5naW5nIGluIHRoZSB3cmFwcGVyIGFuZFxuICAgICAgLy8gaW5zdGVhZCBkbyBpdCBhdCBlYWNoIGNhbGxzaXRlIGFzIG5lZWRlZC5cbiAgICAgIC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgICAgfSk7XG4gICAgICBhcmdzLnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpO1xuICAgIH0gLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJncyk7XG4gIH1cbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbnZhciBMZWdhY3lSb290ID0gMDtcbnZhciBDb25jdXJyZW50Um9vdCA9IDE7XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFscztcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbHMgPSB2YWx1ZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEtpbGxzd2l0Y2hcbi8vXG4vLyBGbGFncyB0aGF0IGV4aXN0IHNvbGVseSB0byB0dXJuIG9mZiBhIGNoYW5nZSBpbiBjYXNlIGl0IGNhdXNlcyBhIHJlZ3Jlc3Npb25cbi8vIHdoZW4gaXQgcm9sbHMgb3V0IHRvIHByb2QuIFdlIHNob3VsZCByZW1vdmUgdGhlc2UgYXMgc29vbiBhcyBwb3NzaWJsZS5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGFuZCBvciByZW1vdmUgKG1vZGVyYXRlIGVmZm9ydClcbi8vXG4vLyBGbGFncyB0aGF0IGNhbiBiZSBwcm9iYWJseSBkZWxldGVkIG9yIGxhbmRlZCwgYnV0IG1pZ2h0IHJlcXVpcmUgZXh0cmEgZWZmb3J0XG4vLyBsaWtlIG1pZ3JhdGluZyBpbnRlcm5hbCBjYWxsZXJzIG9yIHBlcmZvcm1hbmNlIHRlc3RpbmcuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVE9ETzogRmluaXNoIHJvbGxpbmcgb3V0IGluIHd3d1xuXG52YXIgZmF2b3JTYWZldHlPdmVySHlkcmF0aW9uUGVyZiA9IHRydWU7XG52YXIgZW5hYmxlQXN5bmNBY3Rpb25zID0gdHJ1ZTsgLy8gTmVlZCB0byByZW1vdmUgZGlkVGltZW91dCBhcmd1bWVudCBmcm9tIFNjaGVkdWxlciBiZWZvcmUgbGFuZGluZ1xuXG52YXIgZGlzYWJsZURlZmF1bHRQcm9wc0V4Y2VwdEZvckNsYXNzZXMgPSB0cnVlOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2xhdGVkIGZvciByZW1vdmFsIGluIHRoZSBmdXR1cmUgKHNpZ25pZmljYW50IGVmZm9ydClcbi8vXG4vLyBUaGVzZSBhcmUgZXhwZXJpbWVudHMgdGhhdCBkaWRuJ3Qgd29yayBvdXQsIGFuZCBuZXZlciBzaGlwcGVkLCBidXQgd2UgY2FuJ3Rcbi8vIGRlbGV0ZSBmcm9tIHRoZSBjb2RlYmFzZSB1bnRpbCB3ZSBtaWdyYXRlIGludGVybmFsIGNhbGxlcnMuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQWRkIGEgY2FsbGJhY2sgcHJvcGVydHkgdG8gc3VzcGVuc2UgdG8gbm90aWZ5IHdoaWNoIHByb21pc2VzIGFyZSBjdXJyZW50bHlcbi8vIGluIHRoZSB1cGRhdGUgcXVldWUuIFRoaXMgYWxsb3dzIHJlcG9ydGluZyBhbmQgdHJhY2luZyBvZiB3aGF0IGlzIGNhdXNpbmdcbi8vIHRoZSB1c2VyIHRvIHNlZSBhIGxvYWRpbmcgc3RhdGUuXG4vL1xuLy8gQWxzbyBhbGxvd3MgaHlkcmF0aW9uIGNhbGxiYWNrcyB0byBmaXJlIHdoZW4gYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IGdldHNcbi8vIGh5ZHJhdGVkIG9yIGRlbGV0ZWQuXG4vL1xuLy8gVGhpcyB3aWxsIGV2ZW50dWFsbHkgYmUgcmVwbGFjZWQgYnkgdGhlIFRyYW5zaXRpb24gVHJhY2luZyBwcm9wb3NhbC5cblxudmFyIGVuYWJsZVN1c3BlbnNlQ2FsbGJhY2sgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIFNjb3BlIHN1cHBvcnQuXG52YXIgZW5hYmxlQXN5bmNJdGVyYWJsZUNoaWxkcmVuID0gZmFsc2U7XG5cbnZhciBlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uID0gZmFsc2U7IC8vIEZCLW9ubHkgdXNhZ2UuIFRoZSBuZXcgQVBJIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzLlxuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxudmFyIGFsd2F5c1Rocm90dGxlUmV0cmllcyA9IHRydWU7XG52YXIgcGFzc0NoaWxkcmVuV2hlbkNsb25pbmdQZXJzaXN0ZWROb2RlcyA9IGZhbHNlO1xudmFyIHN5bmNMYW5lRXhwaXJhdGlvbk1zID0gMjUwO1xudmFyIHRyYW5zaXRpb25MYW5lRXhwaXJhdGlvbk1zID0gNTAwMDsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRoaXMgYWxsb3dzIHVzIHRvIGxhbmQgYnJlYWtpbmcgY2hhbmdlcyB0byByZW1vdmUgbGVnYWN5IG1vZGUgQVBJcyBpbiBleHBlcmltZW50YWwgYnVpbGRzXG4vLyBiZWZvcmUgcmVtb3ZpbmcgdGhlbSBpbiBzdGFibGUgaW4gdGhlIG5leHQgTWFqb3JcblxudmFyIGRpc2FibGVMZWdhY3lNb2RlID0gdHJ1ZTtcbi8vIERlYnVnZ2luZyBhbmQgRGV2VG9vbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBZGRzIHVzZXIgdGltaW5nIG1hcmtzIGZvciBlLmcuIHN0YXRlIHVwZGF0ZXMsIHN1c3BlbnNlLCBhbmQgd29yayBsb29wIHN0dWZmLFxuLy8gZm9yIGFuIGV4cGVyaW1lbnRhbCB0aW1lbGluZSB0b29sLlxuXG52YXIgZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyID0gdHJ1ZTsgLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIHJlbmRlci1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlXG5cbnZhciBlbmFibGVQcm9maWxlclRpbWVyID0gdHJ1ZTsgLy8gUmVjb3JkIGR1cmF0aW9ucyBmb3IgY29tbWl0IGFuZCBwYXNzaXZlIGVmZmVjdHMgcGhhc2VzLlxuXG52YXIgZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcyA9IHRydWU7IC8vIFBoYXNlIHBhcmFtIHBhc3NlZCB0byBvblJlbmRlciBjYWxsYmFjayBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFuIFwidXBkYXRlXCIgYW5kIGEgXCJjYXNjYWRpbmctdXBkYXRlXCIuXG5cbnZhciBlbmFibGVQcm9maWxlck5lc3RlZFVwZGF0ZVBoYXNlID0gdHJ1ZTsgLy8gQWRkcyB2ZXJib3NlIGNvbnNvbGUgbG9nZ2luZyBmb3IgZS5nLiBzdGF0ZSB1cGRhdGVzLCBzdXNwZW5zZSwgYW5kIHdvcmsgbG9vcFxuXG52YXIgRnVuY3Rpb25Db21wb25lbnQgPSAwO1xudmFyIENsYXNzQ29tcG9uZW50ID0gMTtcbnZhciBIb3N0Um9vdCA9IDM7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxuXG52YXIgSG9zdFBvcnRhbCA9IDQ7IC8vIEEgc3VidHJlZS4gQ291bGQgYmUgYW4gZW50cnkgcG9pbnQgdG8gYSBkaWZmZXJlbnQgcmVuZGVyZXIuXG5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgRnJhZ21lbnQgPSA3O1xudmFyIE1vZGUgPSA4O1xudmFyIENvbnRleHRDb25zdW1lciA9IDk7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gMTA7XG52YXIgRm9yd2FyZFJlZiA9IDExO1xudmFyIFByb2ZpbGVyID0gMTI7XG52YXIgU3VzcGVuc2VDb21wb25lbnQgPSAxMztcbnZhciBNZW1vQ29tcG9uZW50ID0gMTQ7XG52YXIgU2ltcGxlTWVtb0NvbXBvbmVudCA9IDE1O1xudmFyIExhenlDb21wb25lbnQgPSAxNjtcbnZhciBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQgPSAxNztcbnZhciBEZWh5ZHJhdGVkRnJhZ21lbnQgPSAxODtcbnZhciBTdXNwZW5zZUxpc3RDb21wb25lbnQgPSAxOTtcbnZhciBTY29wZUNvbXBvbmVudCA9IDIxO1xudmFyIE9mZnNjcmVlbkNvbXBvbmVudCA9IDIyO1xudmFyIExlZ2FjeUhpZGRlbkNvbXBvbmVudCA9IDIzO1xudmFyIENhY2hlQ29tcG9uZW50ID0gMjQ7XG52YXIgVHJhY2luZ01hcmtlckNvbXBvbmVudCA9IDI1O1xudmFyIEhvc3RIb2lzdGFibGUgPSAyNjtcbnZhciBIb3N0U2luZ2xldG9uID0gMjc7XG52YXIgSW5jb21wbGV0ZUZ1bmN0aW9uQ29tcG9uZW50ID0gMjg7XG5cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxuXG52YXIgUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudCcpIDtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpOyAvLyBUT0RPOiBEZWxldGUgd2l0aCBlbmFibGVSZW5kZXJhYmxlQ29udGV4dFxuXG52YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnN1bWVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xudmFyIFJFQUNUX1RSQUNJTkdfTUFSS0VSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC50cmFjaW5nX21hcmtlcicpO1xudmFyIFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUwgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lJDEob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSQxKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTsgLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUkMShjb250ZXh0KSArICcuUHJvdmlkZXInO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjb25zdW1lciA9IHR5cGU7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lJDEoY29uc3VtZXIuX2NvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUkMSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCBzaGFyZWQvZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tT3duZXIob3duZXIpIHtcbiAgaWYgKHR5cGVvZiBvd25lci50YWcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXIpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvd25lci5uYW1lID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBvd25lci5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB7XG4gIHZhciB0YWcgPSBmaWJlci50YWcsXG4gICAgICB0eXBlID0gZmliZXIudHlwZTtcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICByZXR1cm4gJ0NhY2hlJztcblxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAge1xuICAgICAgICB2YXIgY29uc3VtZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29uc3VtZXIuX2NvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICB9XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9jb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKF9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuICAgICAgfVxuXG4gICAgY2FzZSBEZWh5ZHJhdGVkRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0RlaHlkcmF0ZWRGcmFnbWVudCc7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIC8vIEhvc3QgY29tcG9uZW50IHR5cGUgaXMgdGhlIGRpc3BsYXkgbmFtZSAoZS5nLiBcImRpdlwiLCBcIlZpZXdcIilcbiAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHJldHVybiAnUm9vdCc7XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgcmV0dXJuICdUZXh0JztcblxuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIC8vIE5hbWUgY29tZXMgZnJvbSB0aGUgdHlwZSBpbiB0aGlzIGNhc2U7IHdlIGRvbid0IGhhdmUgYSB0YWcuXG4gICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgY2FzZSBNb2RlOlxuICAgICAgaWYgKHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUpIHtcbiAgICAgICAgLy8gRG9uJ3QgYmUgbGVzcyBzcGVjaWZpYyB0aGFuIHNoYXJlZC9nZXRDb21wb25lbnROYW1lRnJvbVR5cGVcbiAgICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdNb2RlJztcblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdPZmZzY3JlZW4nO1xuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnU2NvcGUnO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBjYXNlIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6XG4gICAgICByZXR1cm4gJ1RyYWNpbmdNYXJrZXInO1xuICAgIC8vIFRoZSBkaXNwbGF5IG5hbWUgZm9yIHRoZXNlIHRhZ3MgY29tZSBmcm9tIHRoZSB1c2VyLXByb3ZpZGVkIHR5cGU6XG5cbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICBjYXNlIEluY29tcGxldGVGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAvLyBGYWxsdGhyb3VnaFxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIE5vRmxhZ3MkMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuMDtcbnZhciBQZXJmb3JtZWRXb3JrID1cbi8qICAgICAgICAgICAgICAgICovXG4xO1xudmFyIFBsYWNlbWVudCA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgRGlkQ2FwdHVyZSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuMTI4O1xudmFyIEh5ZHJhdGluZyA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjQwOTY7IC8vIFlvdSBjYW4gY2hhbmdlIHRoZSByZXN0IChhbmQgYWRkIG1vcmUpLlxuXG52YXIgVXBkYXRlID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDtcbi8qIFNraXBwZWQgdmFsdWU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwOyAqL1xuXG52YXIgQ2hpbGREZWxldGlvbiA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTY7XG52YXIgQ29udGVudFJlc2V0ID1cbi8qICAgICAgICAgICAgICAgICAqL1xuMzI7XG52YXIgQ2FsbGJhY2sgPVxuLyogICAgICAgICAgICAgICAgICAgICAqL1xuNjQ7XG4vKiBVc2VkIGJ5IERpZENhcHR1cmU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDsgKi9cblxudmFyIEZvcmNlQ2xpZW50UmVuZGVyID1cbi8qICAgICAgICAgICAgKi9cbjI1NjtcbnZhciBSZWYgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICovXG41MTI7XG52YXIgU25hcHNob3QgPVxuLyogICAgICAgICAgICAgICAgICAgICAqL1xuMTAyNDtcbnZhciBQYXNzaXZlJDEgPVxuLyogICAgICAgICAgICAgICAgICAgICAgKi9cbjIwNDg7XG4vKiBVc2VkIGJ5IEh5ZHJhdGluZzogICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBiMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDsgKi9cblxudmFyIFZpc2liaWxpdHkgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjgxOTI7XG52YXIgU3RvcmVDb25zaXN0ZW5jeSA9XG4vKiAgICAgICAgICAgICAqL1xuMTYzODQ7IC8vIEl0J3MgT0sgdG8gcmV1c2UgdGhlc2UgYml0cyBiZWNhdXNlIHRoZXNlIGZsYWdzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgZm9yXG4vLyBkaWZmZXJlbnQgZmliZXIgdHlwZXMuIFdlIHNob3VsZCByZWFsbHkgYmUgZG9pbmcgdGhpcyBmb3IgYXMgbWFueSBmbGFncyBhc1xuLy8gcG9zc2libGUsIGJlY2F1c2Ugd2UncmUgYWJvdXQgdG8gcnVuIG91dCBvZiBiaXRzLlxuXG52YXIgU2NoZWR1bGVSZXRyeSA9IFN0b3JlQ29uc2lzdGVuY3k7XG52YXIgU2hvdWxkU3VzcGVuZENvbW1pdCA9IFZpc2liaWxpdHk7XG52YXIgRGlkRGVmZXIgPSBDb250ZW50UmVzZXQ7XG52YXIgRm9ybVJlc2V0ID0gU25hcHNob3Q7XG5cbnZhciBIb3N0RWZmZWN0TWFzayA9XG4vKiAgICAgICAgICAgICAgICovXG4zMjc2NzsgLy8gVGhlc2UgYXJlIG5vdCByZWFsbHkgc2lkZSBlZmZlY3RzLCBidXQgd2Ugc3RpbGwgcmV1c2UgdGhpcyBmaWVsZC5cblxudmFyIEluY29tcGxldGUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjMyNzY4O1xudmFyIFNob3VsZENhcHR1cmUgPVxuLyogICAgICAgICAgICAgICAgKi9cbjY1NTM2O1xudmFyIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UgPVxuLyogKi9cbjEzMTA3MjtcbnZhciBGb3JrZWQgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG4xMDQ4NTc2OyAvLyBTdGF0aWMgdGFncyBkZXNjcmliZSBhc3BlY3RzIG9mIGEgZmliZXIgdGhhdCBhcmUgbm90IHNwZWNpZmljIHRvIGEgcmVuZGVyLFxuLy8gZS5nLiBhIGZpYmVyIHVzZXMgYSBwYXNzaXZlIGVmZmVjdCAoZXZlbiBpZiB0aGVyZSBhcmUgbm8gdXBkYXRlcyBvbiB0aGlzIHBhcnRpY3VsYXIgcmVuZGVyKS5cbi8vIFRoaXMgZW5hYmxlcyB1cyB0byBkZWZlciBtb3JlIHdvcmsgaW4gdGhlIHVubW91bnQgY2FzZSxcbi8vIHNpbmNlIHdlIGNhbiBkZWZlciB0cmF2ZXJzaW5nIHRoZSB0cmVlIGR1cmluZyBsYXlvdXQgdG8gbG9vayBmb3IgUGFzc2l2ZSBlZmZlY3RzLFxuLy8gYW5kIGluc3RlYWQgcmVseSBvbiB0aGUgc3RhdGljIGZsYWcgYXMgYSBzaWduYWwgdGhhdCB0aGVyZSBtYXkgYmUgY2xlYW51cCB3b3JrLlxuXG52YXIgUmVmU3RhdGljID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjA5NzE1MjtcbnZhciBMYXlvdXRTdGF0aWMgPVxuLyogICAgICAgICAgICAgICAgICovXG40MTk0MzA0O1xudmFyIFBhc3NpdmVTdGF0aWMgPVxuLyogICAgICAgICAgICAgICAgKi9cbjgzODg2MDg7XG52YXIgTWF5U3VzcGVuZENvbW1pdCA9XG4vKiAgICAgICAgICAgICAqL1xuMTY3NzcyMTY7IC8vIEZsYWcgdXNlZCB0byBpZGVudGlmeSBuZXdseSBpbnNlcnRlZCBmaWJlcnMuIEl0IGlzbid0IHJlc2V0IGFmdGVyIGNvbW1pdCB1bmxpa2UgYFBsYWNlbWVudGAuXG5cbnZhciBQbGFjZW1lbnRERVYgPVxuLyogICAgICAgICAgICAgICAgICovXG4zMzU1NDQzMjtcbnZhciBNb3VudExheW91dERldiA9XG4vKiAgICAgICAgICAgICAgICovXG42NzEwODg2NDtcbnZhciBNb3VudFBhc3NpdmVEZXYgPVxuLyogICAgICAgICAgICAgICovXG4xMzQyMTc3Mjg7IC8vIEdyb3VwcyBvZiBmbGFncyB0aGF0IGFyZSB1c2VkIGluIHRoZSBjb21taXQgcGhhc2UgdG8gc2tpcCBvdmVyIHRyZWVzIHRoYXRcbi8vIGRvbid0IGNvbnRhaW4gZWZmZWN0cywgYnkgY2hlY2tpbmcgc3VidHJlZUZsYWdzLlxuXG52YXIgQmVmb3JlTXV0YXRpb25NYXNrID0gLy8gVE9ETzogUmVtb3ZlIFVwZGF0ZSBmbGFnIGZyb20gYmVmb3JlIG11dGF0aW9uIHBoYXNlIGJ5IHJlLWxhbmRpbmcgVmlzaWJpbGl0eVxuLy8gZmxhZyBsb2dpYyAoc2VlICMyMDA0MylcblVwZGF0ZSB8IFNuYXBzaG90IHwgKDApO1xudmFyIE11dGF0aW9uTWFzayA9IFBsYWNlbWVudCB8IFVwZGF0ZSB8IENoaWxkRGVsZXRpb24gfCBDb250ZW50UmVzZXQgfCBSZWYgfCBIeWRyYXRpbmcgfCBWaXNpYmlsaXR5IHwgRm9ybVJlc2V0O1xudmFyIExheW91dE1hc2sgPSBVcGRhdGUgfCBDYWxsYmFjayB8IFJlZiB8IFZpc2liaWxpdHk7IC8vIFRPRE86IFNwbGl0IGludG8gUGFzc2l2ZU1vdW50TWFzayBhbmQgUGFzc2l2ZVVubW91bnRNYXNrXG5cbnZhciBQYXNzaXZlTWFzayA9IFBhc3NpdmUkMSB8IFZpc2liaWxpdHkgfCBDaGlsZERlbGV0aW9uOyAvLyBVbmlvbiBvZiB0YWdzIHRoYXQgZG9uJ3QgZ2V0IHJlc2V0IG9uIGNsb25lcy5cbi8vIFRoaXMgYWxsb3dzIGNlcnRhaW4gY29uY2VwdHMgdG8gcGVyc2lzdCB3aXRob3V0IHJlY2FsY3VsYXRpbmcgdGhlbSxcbi8vIGUuZy4gd2hldGhlciBhIHN1YnRyZWUgY29udGFpbnMgcGFzc2l2ZSBlZmZlY3RzIG9yIHBvcnRhbHMuXG5cbnZhciBTdGF0aWNNYXNrID0gTGF5b3V0U3RhdGljIHwgUGFzc2l2ZVN0YXRpYyB8IFJlZlN0YXRpYyB8IE1heVN1c3BlbmRDb21taXQ7XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRGVidWdJbmZvRnJhbWUobmFtZSwgZW52KSB7XG4gIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lICsgKGVudiA/ICcgKCcgKyBlbnYgKyAnKScgOiAnJykpO1xufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAkMSA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAkMSgpO1xufVxuLyoqXG4gKiBMZXZlcmFnZXMgbmF0aXZlIGJyb3dzZXIvVk0gc3RhY2sgZnJhbWVzIHRvIGdldCBwcm9wZXIgZGV0YWlscyAoZS5nLlxuICogZmlsZW5hbWUsIGxpbmUgKyBjb2wgbnVtYmVyKSBmb3IgYSBzaW5nbGUgY29tcG9uZW50IGluIGEgY29tcG9uZW50IHN0YWNrLiBXZVxuICogZG8gdGhpcyBieTpcbiAqICAgKDEpIHRocm93aW5nIGFuZCBjYXRjaGluZyBhbiBlcnJvciBpbiB0aGUgZnVuY3Rpb24gLSB0aGlzIHdpbGwgYmUgb3VyXG4gKiAgICAgICBjb250cm9sIGVycm9yLlxuICogICAoMikgY2FsbGluZyB0aGUgY29tcG9uZW50IHdoaWNoIHdpbGwgZXZlbnR1YWxseSB0aHJvdyBhbiBlcnJvciB0aGF0IHdlJ2xsXG4gKiAgICAgICBjYXRjaCAtIHRoaXMgd2lsbCBiZSBvdXIgc2FtcGxlIGVycm9yLlxuICogICAoMykgZGlmZmluZyB0aGUgY29udHJvbCBhbmQgc2FtcGxlIGVycm9yIHN0YWNrcyB0byBmaW5kIHRoZSBzdGFjayBmcmFtZVxuICogICAgICAgd2hpY2ggcmVwcmVzZW50cyBvdXIgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuICAvKipcbiAgICogRmluZGluZyBhIGNvbW1vbiBzdGFjayBmcmFtZSBiZXR3ZWVuIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgY2FuIGJlXG4gICAqIHRyaWNreSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzIGFuZCBsZXZlbHMgb2Ygc3RhY2sgdHJhY2UgdHJ1bmNhdGlvbiBmcm9tXG4gICAqIGRpZmZlcmVudCBKUyBWTXMuIFNvIGluc3RlYWQgd2UnbGwgYXR0ZW1wdCB0byBjb250cm9sIHdoYXQgdGhhdCBjb21tb25cbiAgICogZnJhbWUgc2hvdWxkIGJlIHRocm91Z2ggdGhpcyBvYmplY3QgbWV0aG9kOlxuICAgKiBIYXZpbmcgYm90aCB0aGUgc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBiZSBpbiB0aGUgZnVuY3Rpb24gdW5kZXIgdGhlXG4gICAqIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgcHJvcGVydHksICsgc2V0dGluZyB0aGUgYG5hbWVgIGFuZFxuICAgKiBgZGlzcGxheU5hbWVgIHByb3BlcnRpZXMgb2YgdGhlIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBhIHN0YWNrXG4gICAqIGZyYW1lIGV4aXN0cyB0aGF0IGhhcyB0aGUgbWV0aG9kIG5hbWUgYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBpblxuICAgKiBpdCBmb3IgYm90aCBjb250cm9sIGFuZCBzYW1wbGUgc3RhY2tzLlxuICAgKi9cblxuXG4gIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb250cm9sO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICB9IC8vIFRPRE8obHVuYSk6IFRoaXMgd2lsbCBjdXJyZW50bHkgb25seSB0aHJvdyBpZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAgICAgLy8gaW4gc2ltcGxlIGNvbXBvbmVudHMgdG9vXG5cblxuICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSBmbigpOyAvLyBJZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHJldHVybnMgYSBwcm9taXNlLCBpdCdzIGxpa2VseSBhbiBhc3luY1xuICAgICAgICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggd2UgZG9uJ3QgeWV0IHN1cHBvcnQuIEF0dGFjaCBhIG5vb3AgY2F0Y2ggaGFuZGxlciB0b1xuICAgICAgICAgIC8vIHNpbGVuY2UgdGhlIGVycm9yLlxuICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBjb21wb25lbnQgc3RhY2tzIGZvciBhc3luYyBjbGllbnQgY29tcG9uZW50cz9cblxuICAgICAgICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICB9XG4gIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnO1xuICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsICduYW1lJyk7IC8vIEJlZm9yZSBFUzYsIHRoZSBgbmFtZWAgcHJvcGVydHkgd2FzIG5vdCBjb25maWd1cmFibGUuXG5cbiAgaWYgKG5hbWVQcm9wRGVzY3JpcHRvciAmJiBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgLy8gVjggdXRpbGl6ZXMgYSBmdW5jdGlvbidzIGBuYW1lYCBwcm9wZXJ0eSB3aGVuIGdlbmVyYXRpbmcgYSBzdGFjayB0cmFjZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAvLyBDb25maWd1cmFibGUgcHJvcGVydGllcyBjYW4gYmUgdXBkYXRlZCBldmVuIGlmIGl0cyB3cml0YWJsZSBkZXNjcmlwdG9yXG4gICAgLy8gaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG4gICAgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCdcbiAgICB9KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuXG4gICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IDA7XG4gICAgICB2YXIgYyA9IDA7XG5cbiAgICAgIHdoaWxlIChzIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmICFzYW1wbGVMaW5lc1tzXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgcysrO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoYyA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiYgIWNvbnRyb2xMaW5lc1tjXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgYysrO1xuICAgICAgfSAvLyBXZSBjb3VsZG4ndCBmaW5kIG91ciBpbnRlbnRpb25hbGx5IGluamVjdGVkIGNvbW1vbiByb290IGZyYW1lLCBhdHRlbXB0XG4gICAgICAvLyB0byBmaW5kIGFub3RoZXIgY29tbW9uIHJvb3QgZnJhbWUgYnkgc2VhcmNoIGZyb20gdGhlIGJvdHRvbSBvZiB0aGVcbiAgICAgIC8vIGNvbnRyb2wgc3RhY2suLi5cblxuXG4gICAgICBpZiAocyA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8IGMgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICAgIGMtLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKGN0b3IpIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGN0b3IsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO1xuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdMYXp5Jyk7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuXG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmaWJlci50eXBlLnJlbmRlcik7XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHdvcmtJblByb2dyZXNzKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuXG4gICAgZG8ge1xuICAgICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuXG4gICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAvLyBBZGQgYW55IFNlcnZlciBDb21wb25lbnQgc3RhY2sgZnJhbWVzIGluIHJldmVyc2Ugb3JkZXIuXG4gICAgICAgIHZhciBkZWJ1Z0luZm8gPSBub2RlLl9kZWJ1Z0luZm87XG5cbiAgICAgICAgaWYgKGRlYnVnSW5mbykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBkZWJ1Z0luZm8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IGRlYnVnSW5mb1tpXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeS5uYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlRGVidWdJbmZvRnJhbWUoZW50cnkubmFtZSwgZW50cnkuZW52KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH0gd2hpbGUgKG5vZGUpO1xuXG4gICAgcmV0dXJuIGluZm87XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXR1cm4gJ1xcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6ICcgKyB4Lm1lc3NhZ2UgKyAnXFxuJyArIHguc3RhY2s7XG4gIH1cbn1cblxudmFyIGN1cnJlbnQgPSBudWxsO1xudmFyIGlzUmVuZGVyaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKSB7XG4gIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4gICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cblxuXG4gICAgcmV0dXJuIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChjdXJyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKSB7XG4gIHtcbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpYmVyKSB7XG4gIHtcbiAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICB9XG59XG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAge1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gICAgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIGN1cnJlbnQgPSBudWxsO1xufVxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIHtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBmaWJlciA9PT0gbnVsbCA/IG51bGwgOiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2O1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cblxuICBjdXJyZW50ID0gZmliZXI7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXIoKSB7XG4gIHtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gc2V0SXNSZW5kZXJpbmcocmVuZGVyaW5nKSB7XG4gIHtcbiAgICBpc1JlbmRlcmluZyA9IHJlbmRlcmluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXI7XG4gIHZhciBuZWFyZXN0TW91bnRlZCA9IGZpYmVyO1xuXG4gIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgIC8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxuICAgIHZhciBuZXh0Tm9kZSA9IG5vZGU7XG5cbiAgICBkbyB7XG4gICAgICBub2RlID0gbmV4dE5vZGU7XG5cbiAgICAgIGlmICgobm9kZS5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uIG9yIGluLXByb2dyZXNzIGh5ZHJhdGlvbi4gVGhlIG5lYXJlc3QgcG9zc2libGVcbiAgICAgICAgLy8gbW91bnRlZCBmaWJlciBpcyB0aGUgcGFyZW50IGJ1dCB3ZSBuZWVkIHRvIGNvbnRpbnVlIHRvIGZpZ3VyZSBvdXRcbiAgICAgICAgLy8gaWYgdGhhdCBvbmUgaXMgc3RpbGwgbW91bnRlZC5cbiAgICAgICAgbmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybjtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgICAgbmV4dE5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChuZXh0Tm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGUucmV0dXJuKSB7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgcmV0dXJuIG5lYXJlc3RNb3VudGVkO1xuICB9IC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cblxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gY3VycmVudDtcblxuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBpc1JlbmRlcmluZyAmJiBvd25lci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICghaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyKSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyRmliZXIpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuXG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgPT09IGZpYmVyO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgaWYgKGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpICE9PSBmaWJlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik7XG5cbiAgICBpZiAobmVhcmVzdE1vdW50ZWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCAhPT0gZmliZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmaWJlcjtcbiAgfSAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuXG5cbiAgdmFyIGEgPSBmaWJlcjtcbiAgdmFyIGIgPSBhbHRlcm5hdGU7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGEucmV0dXJuO1xuXG4gICAgaWYgKHBhcmVudEEgPT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBLmFsdGVybmF0ZTtcblxuICAgIGlmIChwYXJlbnRCID09PSBudWxsKSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBhbHRlcm5hdGUuIFRoaXMgaXMgYW4gdW51c3VhbCBjYXNlLiBDdXJyZW50bHksIGl0IG9ubHlcbiAgICAgIC8vIGhhcHBlbnMgd2hlbiBhIFN1c3BlbnNlIGNvbXBvbmVudCBpcyBoaWRkZW4uIEFuIGV4dHJhIGZyYWdtZW50IGZpYmVyXG4gICAgICAvLyBpcyBpbnNlcnRlZCBpbiBiZXR3ZWVuIHRoZSBTdXNwZW5zZSBmaWJlciBhbmQgaXRzIGNoaWxkcmVuLiBTa2lwXG4gICAgICAvLyBvdmVyIHRoaXMgZXh0cmEgZnJhZ21lbnQgZmliZXIgYW5kIHByb2NlZWQgdG8gdGhlIG5leHQgcGFyZW50LlxuICAgICAgdmFyIG5leHRQYXJlbnQgPSBwYXJlbnRBLnJldHVybjtcblxuICAgICAgaWYgKG5leHRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgYSA9IGIgPSBuZXh0UGFyZW50O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlJ3JlIGF0IHRoZSByb290LlxuXG5cbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuXG5cbiAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50QS5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfSAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgX2NoaWxkID0gcGFyZW50Qi5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnICcgKyAnaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGEuYWx0ZXJuYXRlICE9PSBiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnMnIGFsdGVybmF0ZXMuIFwiICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9IC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cblxuXG4gIGlmIChhLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgfVxuXG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfSAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG5cblxuICByZXR1cm4gYWx0ZXJuYXRlO1xufVxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXIocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgcmV0dXJuIGN1cnJlbnRQYXJlbnQgIT09IG51bGwgPyBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwoY3VycmVudFBhcmVudCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwobm9kZSkge1xuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgdGFnID0gbm9kZS50YWc7XG5cbiAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RIb2lzdGFibGUgfHwgdGFnID09PSBIb3N0U2luZ2xldG9uIHx8IHRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgdmFyIG1hdGNoID0gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKGNoaWxkKTtcblxuICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgcmV0dXJuIGN1cnJlbnRQYXJlbnQgIT09IG51bGwgPyBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKGN1cnJlbnRQYXJlbnQpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChub2RlKSB7XG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIHZhciB0YWcgPSBub2RlLnRhZztcblxuICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCB0YWcgPT09IEhvc3RTaW5nbGV0b24gfHwgdGFnID09PSBIb3N0VGV4dCkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBpZiAoY2hpbGQudGFnICE9PSBIb3N0UG9ydGFsKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKGNoaWxkKTtcblxuICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBUaGlzIGlzIGEgaG9zdCBjb25maWcgdGhhdCdzIHVzZWQgZm9yIHRoZSBgcmVhY3QtcmVjb25jaWxlcmAgcGFja2FnZSBvbiBucG0uXG4vLyBJdCBpcyBvbmx5IHVzZWQgYnkgdGhpcmQtcGFydHkgcmVuZGVyZXJzLlxuLy9cbi8vIEl0cyBBUEkgbGV0cyB5b3UgcGFzcyB0aGUgaG9zdCBjb25maWcgYXMgYW4gYXJndW1lbnQuXG4vLyBIb3dldmVyLCBpbnNpZGUgdGhlIGByZWFjdC1yZWNvbmNpbGVyYCB3ZSB0cmVhdCBob3N0IGNvbmZpZyBhcyBhIG1vZHVsZS5cbi8vIFRoaXMgZmlsZSBpcyBhIHNoaW0gYmV0d2VlbiB0d28gd29ybGRzLlxuLy9cbi8vIEl0IHdvcmtzIGJlY2F1c2UgdGhlIGByZWFjdC1yZWNvbmNpbGVyYCBidW5kbGUgaXMgd3JhcHBlZCBpbiBzb21ldGhpbmcgbGlrZTpcbi8vXG4vLyBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkJCRjb25maWcpIHtcbi8vICAgLyogcmVjb25jaWxlciBjb2RlICovXG4vLyB9XG4vL1xuLy8gU28gYCQkJGNvbmZpZ2AgbG9va3MgbGlrZSBhIGdsb2JhbCB2YXJpYWJsZSwgYnV0IGl0J3Ncbi8vIHJlYWxseSBhbiBhcmd1bWVudCB0byBhIHRvcC1sZXZlbCB3cmFwcGluZyBmdW5jdGlvbi5cbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbnZhciBnZXRQdWJsaWNJbnN0YW5jZSA9ICQkJGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZTtcbnZhciBnZXRSb290SG9zdENvbnRleHQgPSAkJCRjb25maWcuZ2V0Um9vdEhvc3RDb250ZXh0O1xudmFyIGdldENoaWxkSG9zdENvbnRleHQgPSAkJCRjb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dDtcbnZhciBwcmVwYXJlRm9yQ29tbWl0ID0gJCQkY29uZmlnLnByZXBhcmVGb3JDb21taXQ7XG52YXIgcmVzZXRBZnRlckNvbW1pdCA9ICQkJGNvbmZpZy5yZXNldEFmdGVyQ29tbWl0O1xudmFyIGNyZWF0ZUluc3RhbmNlID0gJCQkY29uZmlnLmNyZWF0ZUluc3RhbmNlO1xudmFyIGFwcGVuZEluaXRpYWxDaGlsZCA9ICQkJGNvbmZpZy5hcHBlbmRJbml0aWFsQ2hpbGQ7XG52YXIgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4gPSAkJCRjb25maWcuZmluYWxpemVJbml0aWFsQ2hpbGRyZW47XG52YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSAkJCRjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQ7XG52YXIgY3JlYXRlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmNyZWF0ZVRleHRJbnN0YW5jZTtcbnZhciBzY2hlZHVsZVRpbWVvdXQgPSAkJCRjb25maWcuc2NoZWR1bGVUaW1lb3V0O1xudmFyIGNhbmNlbFRpbWVvdXQgPSAkJCRjb25maWcuY2FuY2VsVGltZW91dDtcbnZhciBub1RpbWVvdXQgPSAkJCRjb25maWcubm9UaW1lb3V0O1xudmFyIGlzUHJpbWFyeVJlbmRlcmVyID0gJCQkY29uZmlnLmlzUHJpbWFyeVJlbmRlcmVyO1xuJCQkY29uZmlnLndhcm5zSWZOb3RBY3Rpbmc7XG52YXIgc3VwcG9ydHNNdXRhdGlvbiA9ICQkJGNvbmZpZy5zdXBwb3J0c011dGF0aW9uO1xudmFyIHN1cHBvcnRzUGVyc2lzdGVuY2UgPSAkJCRjb25maWcuc3VwcG9ydHNQZXJzaXN0ZW5jZTtcbnZhciBzdXBwb3J0c0h5ZHJhdGlvbiA9ICQkJGNvbmZpZy5zdXBwb3J0c0h5ZHJhdGlvbjtcbnZhciBnZXRJbnN0YW5jZUZyb21Ob2RlID0gJCQkY29uZmlnLmdldEluc3RhbmNlRnJvbU5vZGU7XG4kJCRjb25maWcuYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyO1xuJCQkY29uZmlnLmFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyO1xudmFyIHByZXBhcmVQb3J0YWxNb3VudCA9ICQkJGNvbmZpZy5wcmVwYXJlUG9ydGFsTW91bnQ7XG4kJCRjb25maWcucHJlcGFyZVNjb3BlVXBkYXRlO1xuJCQkY29uZmlnLmdldEluc3RhbmNlRnJvbVNjb3BlO1xudmFyIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSA9ICQkJGNvbmZpZy5zZXRDdXJyZW50VXBkYXRlUHJpb3JpdHk7XG52YXIgZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5ID0gJCQkY29uZmlnLmdldEN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbnZhciByZXNvbHZlVXBkYXRlUHJpb3JpdHkgPSAkJCRjb25maWcucmVzb2x2ZVVwZGF0ZVByaW9yaXR5O1xudmFyIHNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24gPSAkJCRjb25maWcuc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbjtcbnZhciBkZXRhY2hEZWxldGVkSW5zdGFuY2UgPSAkJCRjb25maWcuZGV0YWNoRGVsZXRlZEluc3RhbmNlO1xuJCQkY29uZmlnLnJlcXVlc3RQb3N0UGFpbnRDYWxsYmFjaztcbnZhciBtYXlTdXNwZW5kQ29tbWl0ID0gJCQkY29uZmlnLm1heVN1c3BlbmRDb21taXQ7XG52YXIgcHJlbG9hZEluc3RhbmNlID0gJCQkY29uZmlnLnByZWxvYWRJbnN0YW5jZTtcbnZhciBzdGFydFN1c3BlbmRpbmdDb21taXQgPSAkJCRjb25maWcuc3RhcnRTdXNwZW5kaW5nQ29tbWl0O1xudmFyIHN1c3BlbmRJbnN0YW5jZSA9ICQkJGNvbmZpZy5zdXNwZW5kSW5zdGFuY2U7XG52YXIgd2FpdEZvckNvbW1pdFRvQmVSZWFkeSA9ICQkJGNvbmZpZy53YWl0Rm9yQ29tbWl0VG9CZVJlYWR5O1xudmFyIE5vdFBlbmRpbmdUcmFuc2l0aW9uID0gJCQkY29uZmlnLk5vdFBlbmRpbmdUcmFuc2l0aW9uO1xudmFyIHJlc2V0Rm9ybUluc3RhbmNlID0gJCQkY29uZmlnLnJlc2V0Rm9ybUluc3RhbmNlOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgIE1pY3JvdGFza3Ncbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBzdXBwb3J0c01pY3JvdGFza3MgPSAkJCRjb25maWcuc3VwcG9ydHNNaWNyb3Rhc2tzO1xudmFyIHNjaGVkdWxlTWljcm90YXNrID0gJCQkY29uZmlnLnNjaGVkdWxlTWljcm90YXNrOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgIFRlc3Qgc2VsZWN0b3JzXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgc3VwcG9ydHNUZXN0U2VsZWN0b3JzID0gJCQkY29uZmlnLnN1cHBvcnRzVGVzdFNlbGVjdG9ycztcbnZhciBmaW5kRmliZXJSb290ID0gJCQkY29uZmlnLmZpbmRGaWJlclJvb3Q7XG52YXIgZ2V0Qm91bmRpbmdSZWN0ID0gJCQkY29uZmlnLmdldEJvdW5kaW5nUmVjdDtcbnZhciBnZXRUZXh0Q29udGVudCA9ICQkJGNvbmZpZy5nZXRUZXh0Q29udGVudDtcbnZhciBpc0hpZGRlblN1YnRyZWUgPSAkJCRjb25maWcuaXNIaWRkZW5TdWJ0cmVlO1xudmFyIG1hdGNoQWNjZXNzaWJpbGl0eVJvbGUgPSAkJCRjb25maWcubWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZTtcbnZhciBzZXRGb2N1c0lmRm9jdXNhYmxlID0gJCQkY29uZmlnLnNldEZvY3VzSWZGb2N1c2FibGU7XG52YXIgc2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlciA9ICQkJGNvbmZpZy5zZXR1cEludGVyc2VjdGlvbk9ic2VydmVyOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgIE11dGF0aW9uXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgYXBwZW5kQ2hpbGQgPSAkJCRjb25maWcuYXBwZW5kQ2hpbGQ7XG52YXIgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9ICQkJGNvbmZpZy5hcHBlbmRDaGlsZFRvQ29udGFpbmVyO1xudmFyIGNvbW1pdFRleHRVcGRhdGUgPSAkJCRjb25maWcuY29tbWl0VGV4dFVwZGF0ZTtcbnZhciBjb21taXRNb3VudCA9ICQkJGNvbmZpZy5jb21taXRNb3VudDtcbnZhciBjb21taXRVcGRhdGUgPSAkJCRjb25maWcuY29tbWl0VXBkYXRlO1xudmFyIGluc2VydEJlZm9yZSA9ICQkJGNvbmZpZy5pbnNlcnRCZWZvcmU7XG52YXIgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUgPSAkJCRjb25maWcuaW5zZXJ0SW5Db250YWluZXJCZWZvcmU7XG52YXIgcmVtb3ZlQ2hpbGQgPSAkJCRjb25maWcucmVtb3ZlQ2hpbGQ7XG52YXIgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyID0gJCQkY29uZmlnLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtcbnZhciByZXNldFRleHRDb250ZW50ID0gJCQkY29uZmlnLnJlc2V0VGV4dENvbnRlbnQ7XG52YXIgaGlkZUluc3RhbmNlID0gJCQkY29uZmlnLmhpZGVJbnN0YW5jZTtcbnZhciBoaWRlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmhpZGVUZXh0SW5zdGFuY2U7XG52YXIgdW5oaWRlSW5zdGFuY2UgPSAkJCRjb25maWcudW5oaWRlSW5zdGFuY2U7XG52YXIgdW5oaWRlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLnVuaGlkZVRleHRJbnN0YW5jZTtcbnZhciBjbGVhckNvbnRhaW5lciA9ICQkJGNvbmZpZy5jbGVhckNvbnRhaW5lcjsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgIFBlcnNpc3RlbmNlXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgY2xvbmVJbnN0YW5jZSA9ICQkJGNvbmZpZy5jbG9uZUluc3RhbmNlO1xudmFyIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gJCQkY29uZmlnLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0O1xudmFyIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCA9ICQkJGNvbmZpZy5hcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQ7XG52YXIgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9ICQkJGNvbmZpZy5maW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuO1xudmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9ICQkJGNvbmZpZy5yZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW47XG52YXIgY2xvbmVIaWRkZW5JbnN0YW5jZSA9ICQkJGNvbmZpZy5jbG9uZUhpZGRlbkluc3RhbmNlO1xudmFyIGNsb25lSGlkZGVuVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmNsb25lSGlkZGVuVGV4dEluc3RhbmNlOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgSHlkcmF0aW9uXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyA9ICQkJGNvbmZpZy5pc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nO1xudmFyIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrID0gJCQkY29uZmlnLmlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrO1xudmFyIGdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyA9ICQkJGNvbmZpZy5nZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHM7XG52YXIgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkgPSAkJCRjb25maWcucmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnk7XG52YXIgY2FuSHlkcmF0ZUZvcm1TdGF0ZU1hcmtlciA9ICQkJGNvbmZpZy5jYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyO1xudmFyIGlzRm9ybVN0YXRlTWFya2VyTWF0Y2hpbmcgPSAkJCRjb25maWcuaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZztcbnZhciBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcgPSAkJCRjb25maWcuZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nO1xudmFyIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkID0gJCQkY29uZmlnLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkO1xudmFyIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyID0gJCQkY29uZmlnLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyO1xudmFyIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGNvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2U7XG52YXIgY2FuSHlkcmF0ZUluc3RhbmNlID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVJbnN0YW5jZTtcbnZhciBjYW5IeWRyYXRlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2U7XG52YXIgY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UgPSAkJCRjb25maWcuY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2U7XG52YXIgaHlkcmF0ZUluc3RhbmNlID0gJCQkY29uZmlnLmh5ZHJhdGVJbnN0YW5jZTtcbnZhciBoeWRyYXRlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmh5ZHJhdGVUZXh0SW5zdGFuY2U7XG52YXIgaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UgPSAkJCRjb25maWcuaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2U7XG52YXIgZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGNvbmZpZy5nZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlO1xudmFyIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyID0gJCQkY29uZmlnLmNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyO1xudmFyIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGNvbmZpZy5jb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2U7XG52YXIgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5ID0gJCQkY29uZmlnLmNsZWFyU3VzcGVuc2VCb3VuZGFyeTtcbnZhciBjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyID0gJCQkY29uZmlnLmNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXI7XG52YXIgc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMgPSAkJCRjb25maWcuc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXM7XG52YXIgZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncyA9ICQkJGNvbmZpZy5kaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzO1xudmFyIGRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyA9ICQkJGNvbmZpZy5kaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3M7XG52YXIgZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyA9ICQkJGNvbmZpZy5kZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzO1xudmFyIHZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlID0gJCQkY29uZmlnLnZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlO1xudmFyIHZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy52YWxpZGF0ZUh5ZHJhdGFibGVUZXh0SW5zdGFuY2U7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICBSZXNvdXJjZXNcbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbnZhciBzdXBwb3J0c1Jlc291cmNlcyA9ICQkJGNvbmZpZy5zdXBwb3J0c1Jlc291cmNlcztcbnZhciBpc0hvc3RIb2lzdGFibGVUeXBlID0gJCQkY29uZmlnLmlzSG9zdEhvaXN0YWJsZVR5cGU7XG52YXIgZ2V0SG9pc3RhYmxlUm9vdCA9ICQkJGNvbmZpZy5nZXRIb2lzdGFibGVSb290O1xudmFyIGdldFJlc291cmNlID0gJCQkY29uZmlnLmdldFJlc291cmNlO1xudmFyIGFjcXVpcmVSZXNvdXJjZSA9ICQkJGNvbmZpZy5hY3F1aXJlUmVzb3VyY2U7XG52YXIgcmVsZWFzZVJlc291cmNlID0gJCQkY29uZmlnLnJlbGVhc2VSZXNvdXJjZTtcbnZhciBoeWRyYXRlSG9pc3RhYmxlID0gJCQkY29uZmlnLmh5ZHJhdGVIb2lzdGFibGU7XG52YXIgbW91bnRIb2lzdGFibGUgPSAkJCRjb25maWcubW91bnRIb2lzdGFibGU7XG52YXIgdW5tb3VudEhvaXN0YWJsZSA9ICQkJGNvbmZpZy51bm1vdW50SG9pc3RhYmxlO1xudmFyIGNyZWF0ZUhvaXN0YWJsZUluc3RhbmNlID0gJCQkY29uZmlnLmNyZWF0ZUhvaXN0YWJsZUluc3RhbmNlO1xudmFyIHByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMgPSAkJCRjb25maWcucHJlcGFyZVRvQ29tbWl0SG9pc3RhYmxlcztcbnZhciBtYXlSZXNvdXJjZVN1c3BlbmRDb21taXQgPSAkJCRjb25maWcubWF5UmVzb3VyY2VTdXNwZW5kQ29tbWl0O1xudmFyIHByZWxvYWRSZXNvdXJjZSA9ICQkJGNvbmZpZy5wcmVsb2FkUmVzb3VyY2U7XG52YXIgc3VzcGVuZFJlc291cmNlID0gJCQkY29uZmlnLnN1c3BlbmRSZXNvdXJjZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgIFNpbmdsZXRvbnNcbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBzdXBwb3J0c1NpbmdsZXRvbnMgPSAkJCRjb25maWcuc3VwcG9ydHNTaW5nbGV0b25zO1xudmFyIHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZSA9ICQkJGNvbmZpZy5yZXNvbHZlU2luZ2xldG9uSW5zdGFuY2U7XG52YXIgY2xlYXJTaW5nbGV0b24gPSAkJCRjb25maWcuY2xlYXJTaW5nbGV0b247XG52YXIgYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlID0gJCQkY29uZmlnLmFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZTtcbnZhciByZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UgPSAkJCRjb25maWcucmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlO1xudmFyIGlzSG9zdFNpbmdsZXRvblR5cGUgPSAkJCRjb25maWcuaXNIb3N0U2luZ2xldG9uVHlwZTtcblxudmFyIHZhbHVlU3RhY2sgPSBbXTtcbnZhciBmaWJlclN0YWNrO1xuXG57XG4gIGZpYmVyU3RhY2sgPSBbXTtcbn1cblxudmFyIGluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBkZWZhdWx0VmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleF07XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IGZpYmVyO1xuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbn1cblxudmFyIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbn0gLy8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cblxuZnVuY3Rpb24gaGFzQ29udGV4dENoYW5nZWQoKSB7XG4gIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIodHlwZSkge1xuICB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHR5cGUsIHBhcmVudENvbnRleHQpIHtcbiAge1xuICAgIHJldHVybiBwYXJlbnRDb250ZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIHtcbiAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG59XG5cbi8vIFdlIHVzZSB0aGUgZXhpc3RlbmNlIG9mIHRoZSBzdGF0ZSBvYmplY3QgYXMgYW4gaW5kaWNhdG9yIHRoYXQgdGhlIGNvbXBvbmVudFxuLy8gaXMgaGlkZGVuLlxudmFyIE9mZnNjcmVlblZpc2libGUgPVxuLyogICAgICAgICAgICAgICAgICAgICAqL1xuMTtcbnZhciBPZmZzY3JlZW5EZXRhY2hlZCA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgT2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQgPVxuLyogICAgICovXG40O1xuZnVuY3Rpb24gaXNPZmZzY3JlZW5NYW51YWwob2Zmc2NyZWVuRmliZXIpIHtcbiAgcmV0dXJuIG9mZnNjcmVlbkZpYmVyLm1lbW9pemVkUHJvcHMgIT09IG51bGwgJiYgb2Zmc2NyZWVuRmliZXIubWVtb2l6ZWRQcm9wcy5tb2RlID09PSAnbWFudWFsJztcbn1cblxudmFyIE5vTW9kZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMDsgLy8gVE9ETzogUmVtb3ZlIENvbmN1cnJlbnRNb2RlIGJ5IHJlYWRpbmcgZnJvbSB0aGUgcm9vdCB0YWcgaW5zdGVhZFxuXG52YXIgQ29uY3VycmVudE1vZGUgPVxuLyogICAgICAgICAgICAgICAgICovXG4xO1xudmFyIFByb2ZpbGVNb2RlID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBTdHJpY3RMZWdhY3lNb2RlID1cbi8qICAgICAgICAgICAgICAgKi9cbjg7XG52YXIgU3RyaWN0RWZmZWN0c01vZGUgPVxuLyogICAgICAgICAgICAgICovXG4xNjtcbnZhciBOb1N0cmljdFBhc3NpdmVFZmZlY3RzTW9kZSA9XG4vKiAgICAgKi9cbjY0O1xuXG4vLyBUT0RPOiBUaGlzIGlzIHByZXR0eSB3ZWxsIHN1cHBvcnRlZCBieSBicm93c2Vycy4gTWF5YmUgd2UgY2FuIGRyb3AgaXQuXG52YXIgY2x6MzIgPSBNYXRoLmNsejMyID8gTWF0aC5jbHozMiA6IGNsejMyRmFsbGJhY2s7IC8vIENvdW50IGxlYWRpbmcgemVyb3MuXG4vLyBCYXNlZCBvbjpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY2x6MzJcblxudmFyIGxvZyQxID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG5cbmZ1bmN0aW9uIGNsejMyRmFsbGJhY2soeCkge1xuICB2YXIgYXNVaW50ID0geCA+Pj4gMDtcblxuICBpZiAoYXNVaW50ID09PSAwKSB7XG4gICAgcmV0dXJuIDMyO1xuICB9XG5cbiAgcmV0dXJuIDMxIC0gKGxvZyQxKGFzVWludCkgLyBMTjIgfCAwKSB8IDA7XG59XG5cbi8vIElmIHRob3NlIHZhbHVlcyBhcmUgY2hhbmdlZCB0aGF0IHBhY2thZ2Ugc2hvdWxkIGJlIHJlYnVpbHQgYW5kIHJlZGVwbG95ZWQuXG5cbnZhciBUb3RhbExhbmVzID0gMzE7XG52YXIgTm9MYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xudmFyIE5vTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgU3luY0h5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgICAgICAqL1xuMTtcbnZhciBTeW5jTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIFN5bmNMYW5lSW5kZXggPSAxO1xudmFyIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmUgPVxuLyogICAgKi9cbjQ7XG52YXIgSW5wdXRDb250aW51b3VzTGFuZSA9XG4vKiAgICAgICAgICAgICAqL1xuODtcbnZhciBEZWZhdWx0SHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICovXG4xNjtcbnZhciBEZWZhdWx0TGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG4zMjtcbnZhciBTeW5jVXBkYXRlTGFuZXMgPSBTeW5jTGFuZSB8IElucHV0Q29udGludW91c0xhbmUgfCBEZWZhdWx0TGFuZSA7XG52YXIgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgICAgICAgKi9cbjY0O1xudmFyIFRyYW5zaXRpb25MYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQxOTQxNzY7XG52YXIgVHJhbnNpdGlvbkxhbmUxID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjEyODtcbnZhciBUcmFuc2l0aW9uTGFuZTIgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjU2O1xudmFyIFRyYW5zaXRpb25MYW5lMyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG41MTI7XG52YXIgVHJhbnNpdGlvbkxhbmU0ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjEwMjQ7XG52YXIgVHJhbnNpdGlvbkxhbmU1ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjIwNDg7XG52YXIgVHJhbnNpdGlvbkxhbmU2ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQwOTY7XG52YXIgVHJhbnNpdGlvbkxhbmU3ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjgxOTI7XG52YXIgVHJhbnNpdGlvbkxhbmU4ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjE2Mzg0O1xudmFyIFRyYW5zaXRpb25MYW5lOSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4zMjc2ODtcbnZhciBUcmFuc2l0aW9uTGFuZTEwID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNjU1MzY7XG52YXIgVHJhbnNpdGlvbkxhbmUxMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjEzMTA3MjtcbnZhciBUcmFuc2l0aW9uTGFuZTEyID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjYyMTQ0O1xudmFyIFRyYW5zaXRpb25MYW5lMTMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG41MjQyODg7XG52YXIgVHJhbnNpdGlvbkxhbmUxNCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjEwNDg1NzY7XG52YXIgVHJhbnNpdGlvbkxhbmUxNSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjIwOTcxNTI7XG52YXIgUmV0cnlMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNjI5MTQ1NjA7XG52YXIgUmV0cnlMYW5lMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQxOTQzMDQ7XG52YXIgUmV0cnlMYW5lMiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjgzODg2MDg7XG52YXIgUmV0cnlMYW5lMyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjE2Nzc3MjE2O1xudmFyIFJldHJ5TGFuZTQgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4zMzU1NDQzMjtcbnZhciBTb21lUmV0cnlMYW5lID0gUmV0cnlMYW5lMTtcbnZhciBTZWxlY3RpdmVIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICovXG42NzEwODg2NDtcbnZhciBOb25JZGxlTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICovXG4xMzQyMTc3Mjc7XG52YXIgSWRsZUh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgICAgICAqL1xuMTM0MjE3NzI4O1xudmFyIElkbGVMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjI2ODQzNTQ1NjtcbnZhciBPZmZzY3JlZW5MYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICovXG41MzY4NzA5MTI7XG52YXIgRGVmZXJyZWRMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMTA3Mzc0MTgyNDsgLy8gQW55IGxhbmUgdGhhdCBtaWdodCBzY2hlZHVsZSBhbiB1cGRhdGUuIFRoaXMgaXMgdXNlZCB0byBkZXRlY3QgaW5maW5pdGVcbi8vIHVwZGF0ZSBsb29wcywgc28gaXQgZG9lc24ndCBpbmNsdWRlIGh5ZHJhdGlvbiBsYW5lcyBvciByZXRyaWVzLlxuXG52YXIgVXBkYXRlTGFuZXMgPSBTeW5jTGFuZSB8IElucHV0Q29udGludW91c0xhbmUgfCBEZWZhdWx0TGFuZSB8IFRyYW5zaXRpb25MYW5lczsgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGZvciB0aGUgZXhwZXJpbWVudGFsIHRpbWVsaW5lIChyZWFjdC1kZXZ0b29scy10aW1lbGluZSlcbi8vIEl0IHNob3VsZCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgTGFuZXMgdmFsdWVzIGFib3ZlLlxuXG5mdW5jdGlvbiBnZXRMYWJlbEZvckxhbmUobGFuZSkge1xuICB7XG4gICAgaWYgKGxhbmUgJiBTeW5jSHlkcmF0aW9uTGFuZSkge1xuICAgICAgcmV0dXJuICdTeW5jSHlkcmF0aW9uTGFuZSc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBTeW5jTGFuZSkge1xuICAgICAgcmV0dXJuICdTeW5jJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnSW5wdXRDb250aW51b3VzSHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIElucHV0Q29udGludW91c0xhbmUpIHtcbiAgICAgIHJldHVybiAnSW5wdXRDb250aW51b3VzJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIERlZmF1bHRIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ0RlZmF1bHRIeWRyYXRpb24nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgRGVmYXVsdExhbmUpIHtcbiAgICAgIHJldHVybiAnRGVmYXVsdCc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZSkge1xuICAgICAgcmV0dXJuICdUcmFuc2l0aW9uSHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIFRyYW5zaXRpb25MYW5lcykge1xuICAgICAgcmV0dXJuICdUcmFuc2l0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIFJldHJ5TGFuZXMpIHtcbiAgICAgIHJldHVybiAnUmV0cnknO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSkge1xuICAgICAgcmV0dXJuICdTZWxlY3RpdmVIeWRyYXRpb24nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgSWRsZUh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnSWRsZUh5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJZGxlTGFuZSkge1xuICAgICAgcmV0dXJuICdJZGxlJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIE9mZnNjcmVlbkxhbmUpIHtcbiAgICAgIHJldHVybiAnT2Zmc2NyZWVuJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIERlZmVycmVkTGFuZSkge1xuICAgICAgcmV0dXJuICdEZWZlcnJlZCc7XG4gICAgfVxuICB9XG59XG52YXIgTm9UaW1lc3RhbXAgPSAtMTtcbnZhciBuZXh0VHJhbnNpdGlvbkxhbmUgPSBUcmFuc2l0aW9uTGFuZTE7XG52YXIgbmV4dFJldHJ5TGFuZSA9IFJldHJ5TGFuZTE7XG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gIHtcbiAgICB2YXIgcGVuZGluZ1N5bmNMYW5lcyA9IGxhbmVzICYgU3luY1VwZGF0ZUxhbmVzO1xuXG4gICAgaWYgKHBlbmRpbmdTeW5jTGFuZXMgIT09IDApIHtcbiAgICAgIHJldHVybiBwZW5kaW5nU3luY0xhbmVzO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAoZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcykpIHtcbiAgICBjYXNlIFN5bmNIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIFN5bmNIeWRyYXRpb25MYW5lO1xuXG4gICAgY2FzZSBTeW5jTGFuZTpcbiAgICAgIHJldHVybiBTeW5jTGFuZTtcblxuICAgIGNhc2UgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZTpcbiAgICAgIHJldHVybiBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lO1xuXG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNMYW5lOlxuICAgICAgcmV0dXJuIElucHV0Q29udGludW91c0xhbmU7XG5cbiAgICBjYXNlIERlZmF1bHRIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIERlZmF1bHRIeWRyYXRpb25MYW5lO1xuXG4gICAgY2FzZSBEZWZhdWx0TGFuZTpcbiAgICAgIHJldHVybiBEZWZhdWx0TGFuZTtcblxuICAgIGNhc2UgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmU6XG4gICAgICByZXR1cm4gVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lODpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lOTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTA6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTExOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTM6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNTpcbiAgICAgIHJldHVybiBsYW5lcyAmIFRyYW5zaXRpb25MYW5lcztcblxuICAgIGNhc2UgUmV0cnlMYW5lMTpcbiAgICBjYXNlIFJldHJ5TGFuZTI6XG4gICAgY2FzZSBSZXRyeUxhbmUzOlxuICAgIGNhc2UgUmV0cnlMYW5lNDpcbiAgICAgIHJldHVybiBsYW5lcyAmIFJldHJ5TGFuZXM7XG5cbiAgICBjYXNlIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU6XG4gICAgICByZXR1cm4gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtcblxuICAgIGNhc2UgSWRsZUh5ZHJhdGlvbkxhbmU6XG4gICAgICByZXR1cm4gSWRsZUh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIElkbGVMYW5lOlxuICAgICAgcmV0dXJuIElkbGVMYW5lO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5MYW5lOlxuICAgICAgcmV0dXJuIE9mZnNjcmVlbkxhbmU7XG5cbiAgICBjYXNlIERlZmVycmVkTGFuZTpcbiAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGJlIHJlYWNoYWJsZSBiZWNhdXNlIGRlZmVycmVkIHdvcmsgaXMgYWx3YXlzIGVudGFuZ2xlZFxuICAgICAgLy8gd2l0aCBzb21ldGhpbmcgZWxzZS5cbiAgICAgIHJldHVybiBOb0xhbmVzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgZXJyb3IoJ1Nob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfSAvLyBUaGlzIHNob3VsZG4ndCBiZSByZWFjaGFibGUsIGJ1dCBhcyBhIGZhbGxiYWNrLCByZXR1cm4gdGhlIGVudGlyZSBiaXRtYXNrLlxuXG5cbiAgICAgIHJldHVybiBsYW5lcztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCwgd2lwTGFuZXMpIHtcbiAgLy8gRWFybHkgYmFpbG91dCBpZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yayBsZWZ0LlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG5cbiAgaWYgKHBlbmRpbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIHJldHVybiBOb0xhbmVzO1xuICB9XG5cbiAgdmFyIG5leHRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG4gIHZhciBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7IC8vIERvIG5vdCB3b3JrIG9uIGFueSBpZGxlIHdvcmsgdW50aWwgYWxsIHRoZSBub24taWRsZSB3b3JrIGhhcyBmaW5pc2hlZCxcbiAgLy8gZXZlbiBpZiB0aGUgd29yayBpcyBzdXNwZW5kZWQuXG5cbiAgdmFyIG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiBOb25JZGxlTGFuZXM7XG5cbiAgaWYgKG5vbklkbGVQZW5kaW5nTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICB2YXIgbm9uSWRsZVVuYmxvY2tlZExhbmVzID0gbm9uSWRsZVBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcztcblxuICAgIGlmIChub25JZGxlVW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVVbmJsb2NrZWRMYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub25JZGxlUGluZ2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgcGluZ2VkTGFuZXM7XG5cbiAgICAgIGlmIChub25JZGxlUGluZ2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVBpbmdlZExhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIG9ubHkgcmVtYWluaW5nIHdvcmsgaXMgSWRsZS5cbiAgICB2YXIgdW5ibG9ja2VkTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXM7XG5cbiAgICBpZiAodW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHVuYmxvY2tlZExhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBpbmdlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobmV4dExhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgb25seSBiZSByZWFjaGFibGUgaWYgd2UncmUgc3VzcGVuZGVkXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBpbiB0aGlzIHBhdGggaWYgYSBmYWxsYmFjayB0aW1lciBpcyBub3Qgc2NoZWR1bGVkLlxuICAgIHJldHVybiBOb0xhbmVzO1xuICB9IC8vIElmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciwgc3dpdGNoaW5nIGxhbmVzIHdpbGwgaW50ZXJydXB0XG4gIC8vIGl0IGFuZCB3ZSdsbCBsb3NlIG91ciBwcm9ncmVzcy4gV2Ugc2hvdWxkIG9ubHkgZG8gdGhpcyBpZiB0aGUgbmV3IGxhbmVzIGFyZVxuICAvLyBoaWdoZXIgcHJpb3JpdHkuXG5cblxuICBpZiAod2lwTGFuZXMgIT09IE5vTGFuZXMgJiYgd2lwTGFuZXMgIT09IG5leHRMYW5lcyAmJiAvLyBJZiB3ZSBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHRoZW4gaW50ZXJydXB0aW5nIGlzIGZpbmUuIERvbid0XG4gIC8vIGJvdGhlciB3YWl0aW5nIHVudGlsIHRoZSByb290IGlzIGNvbXBsZXRlLlxuICAod2lwTGFuZXMgJiBzdXNwZW5kZWRMYW5lcykgPT09IE5vTGFuZXMpIHtcbiAgICB2YXIgbmV4dExhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKG5leHRMYW5lcyk7XG4gICAgdmFyIHdpcExhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKHdpcExhbmVzKTtcblxuICAgIGlmICggLy8gVGVzdHMgd2hldGhlciB0aGUgbmV4dCBsYW5lIGlzIGVxdWFsIG9yIGxvd2VyIHByaW9yaXR5IHRoYW4gdGhlIHdpcFxuICAgIC8vIG9uZS4gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXRzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxuICAgIG5leHRMYW5lID49IHdpcExhbmUgfHwgLy8gRGVmYXVsdCBwcmlvcml0eSB1cGRhdGVzIHNob3VsZCBub3QgaW50ZXJydXB0IHRyYW5zaXRpb24gdXBkYXRlcy4gVGhlXG4gICAgLy8gb25seSBkaWZmZXJlbmNlIGJldHdlZW4gZGVmYXVsdCB1cGRhdGVzIGFuZCB0cmFuc2l0aW9uIHVwZGF0ZXMgaXMgdGhhdFxuICAgIC8vIGRlZmF1bHQgdXBkYXRlcyBkbyBub3Qgc3VwcG9ydCByZWZyZXNoIHRyYW5zaXRpb25zLlxuICAgIG5leHRMYW5lID09PSBEZWZhdWx0TGFuZSAmJiAod2lwTGFuZSAmIFRyYW5zaXRpb25MYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICAgIC8vIEtlZXAgd29ya2luZyBvbiB0aGUgZXhpc3RpbmcgaW4tcHJvZ3Jlc3MgdHJlZS4gRG8gbm90IGludGVycnVwdC5cbiAgICAgIHJldHVybiB3aXBMYW5lcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dExhbmVzO1xufVxuZnVuY3Rpb24gZ2V0RW50YW5nbGVkTGFuZXMocm9vdCwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGVudGFuZ2xlZExhbmVzID0gcmVuZGVyTGFuZXM7XG5cbiAgaWYgKChlbnRhbmdsZWRMYW5lcyAmIElucHV0Q29udGludW91c0xhbmUpICE9PSBOb0xhbmVzKSB7XG4gICAgLy8gV2hlbiB1cGRhdGVzIGFyZSBzeW5jIGJ5IGRlZmF1bHQsIHdlIGVudGFuZ2xlIGNvbnRpbnVvdXMgcHJpb3JpdHkgdXBkYXRlc1xuICAgIC8vIGFuZCBkZWZhdWx0IHVwZGF0ZXMsIHNvIHRoZXkgcmVuZGVyIGluIHRoZSBzYW1lIGJhdGNoLiBUaGUgb25seSByZWFzb25cbiAgICAvLyB0aGV5IHVzZSBzZXBhcmF0ZSBsYW5lcyBpcyBiZWNhdXNlIGNvbnRpbnVvdXMgdXBkYXRlcyBzaG91bGQgaW50ZXJydXB0XG4gICAgLy8gdHJhbnNpdGlvbnMsIGJ1dCBkZWZhdWx0IHVwZGF0ZXMgc2hvdWxkIG5vdC5cbiAgICBlbnRhbmdsZWRMYW5lcyB8PSBlbnRhbmdsZWRMYW5lcyAmIERlZmF1bHRMYW5lO1xuICB9IC8vIENoZWNrIGZvciBlbnRhbmdsZWQgbGFuZXMgYW5kIGFkZCB0aGVtIHRvIHRoZSBiYXRjaC5cbiAgLy9cbiAgLy8gQSBsYW5lIGlzIHNhaWQgdG8gYmUgZW50YW5nbGVkIHdpdGggYW5vdGhlciB3aGVuIGl0J3Mgbm90IGFsbG93ZWQgdG8gcmVuZGVyXG4gIC8vIGluIGEgYmF0Y2ggdGhhdCBkb2VzIG5vdCBhbHNvIGluY2x1ZGUgdGhlIG90aGVyIGxhbmUuIFR5cGljYWxseSB3ZSBkbyB0aGlzXG4gIC8vIHdoZW4gbXVsdGlwbGUgdXBkYXRlcyBoYXZlIHRoZSBzYW1lIHNvdXJjZSwgYW5kIHdlIG9ubHkgd2FudCB0byByZXNwb25kIHRvXG4gIC8vIHRoZSBtb3N0IHJlY2VudCBldmVudCBmcm9tIHRoYXQgc291cmNlLlxuICAvL1xuICAvLyBOb3RlIHRoYXQgd2UgYXBwbHkgZW50YW5nbGVtZW50cyAqYWZ0ZXIqIGNoZWNraW5nIGZvciBwYXJ0aWFsIHdvcmsgYWJvdmUuXG4gIC8vIFRoaXMgbWVhbnMgdGhhdCBpZiBhIGxhbmUgaXMgZW50YW5nbGVkIGR1cmluZyBhbiBpbnRlcmxlYXZlZCBldmVudCB3aGlsZVxuICAvLyBpdCdzIGFscmVhZHkgcmVuZGVyaW5nLCB3ZSB3b24ndCBpbnRlcnJ1cHQgaXQuIFRoaXMgaXMgaW50ZW50aW9uYWwsIHNpbmNlXG4gIC8vIGVudGFuZ2xlbWVudCBpcyB1c3VhbGx5IFwiYmVzdCBlZmZvcnRcIjogd2UnbGwgdHJ5IG91ciBiZXN0IHRvIHJlbmRlciB0aGVcbiAgLy8gbGFuZXMgaW4gdGhlIHNhbWUgYmF0Y2gsIGJ1dCBpdCdzIG5vdCB3b3J0aCB0aHJvd2luZyBvdXQgcGFydGlhbGx5XG4gIC8vIGNvbXBsZXRlZCB3b3JrIGluIG9yZGVyIHRvIGRvIGl0LlxuICAvLyBUT0RPOiBSZWNvbnNpZGVyIHRoaXMuIFRoZSBjb3VudGVyLWFyZ3VtZW50IGlzIHRoYXQgdGhlIHBhcnRpYWwgd29ya1xuICAvLyByZXByZXNlbnRzIGFuIGludGVybWVkaWF0ZSBzdGF0ZSwgd2hpY2ggd2UgZG9uJ3Qgd2FudCB0byBzaG93IHRvIHRoZSB1c2VyLlxuICAvLyBBbmQgYnkgc3BlbmRpbmcgZXh0cmEgdGltZSBmaW5pc2hpbmcgaXQsIHdlJ3JlIGluY3JlYXNpbmcgdGhlIGFtb3VudCBvZlxuICAvLyB0aW1lIGl0IHRha2VzIHRvIHNob3cgdGhlIGZpbmFsIHN0YXRlLCB3aGljaCBpcyB3aGF0IHRoZXkgYXJlIGFjdHVhbGx5XG4gIC8vIHdhaXRpbmcgZm9yLlxuICAvL1xuICAvLyBGb3IgdGhvc2UgZXhjZXB0aW9ucyB3aGVyZSBlbnRhbmdsZW1lbnQgaXMgc2VtYW50aWNhbGx5IGltcG9ydGFudCxcbiAgLy8gd2Ugc2hvdWxkIGVuc3VyZSB0aGF0IHRoZXJlIGlzIG5vIHBhcnRpYWwgd29yayBhdCB0aGVcbiAgLy8gdGltZSB3ZSBhcHBseSB0aGUgZW50YW5nbGVtZW50LlxuXG5cbiAgdmFyIGFsbEVudGFuZ2xlZExhbmVzID0gcm9vdC5lbnRhbmdsZWRMYW5lcztcblxuICBpZiAoYWxsRW50YW5nbGVkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgICB2YXIgbGFuZXMgPSBlbnRhbmdsZWRMYW5lcyAmIGFsbEVudGFuZ2xlZExhbmVzO1xuXG4gICAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICBlbnRhbmdsZWRMYW5lcyB8PSBlbnRhbmdsZW1lbnRzW2luZGV4XTtcbiAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbnRhbmdsZWRMYW5lcztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKSB7XG4gIHN3aXRjaCAobGFuZSkge1xuICAgIGNhc2UgU3luY0h5ZHJhdGlvbkxhbmU6XG4gICAgY2FzZSBTeW5jTGFuZTpcbiAgICBjYXNlIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU6XG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNMYW5lOlxuICAgICAgLy8gVXNlciBpbnRlcmFjdGlvbnMgc2hvdWxkIGV4cGlyZSBzbGlnaHRseSBtb3JlIHF1aWNrbHkuXG4gICAgICAvL1xuICAgICAgLy8gTk9URTogVGhpcyBpcyBzZXQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY29uc3RhbnQgYXMgaW4gU2NoZWR1bGVyLmpzLlxuICAgICAgLy8gV2hlbiB3ZSBtYWRlIGl0IGxhcmdlciwgYSBwcm9kdWN0IG1ldHJpYyBpbiB3d3cgcmVncmVzc2VkLCBzdWdnZXN0aW5nXG4gICAgICAvLyB0aGVyZSdzIGEgdXNlciBpbnRlcmFjdGlvbiB0aGF0J3MgYmVpbmcgc3RhcnZlZCBieSBhIHNlcmllcyBvZlxuICAgICAgLy8gc3luY2hyb25vdXMgdXBkYXRlcy4gSWYgdGhhdCB0aGVvcnkgaXMgY29ycmVjdCwgdGhlIHByb3BlciBzb2x1dGlvbiBpc1xuICAgICAgLy8gdG8gZml4IHRoZSBzdGFydmF0aW9uLiBIb3dldmVyLCB0aGlzIHNjZW5hcmlvIHN1cHBvcnRzIHRoZSBpZGVhIHRoYXRcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZXMgYXJlIGFuIGltcG9ydGFudCBzYWZlZ3VhcmQgd2hlbiBzdGFydmF0aW9uXG4gICAgICAvLyBkb2VzIGhhcHBlbi5cbiAgICAgIHJldHVybiBjdXJyZW50VGltZSArIHN5bmNMYW5lRXhwaXJhdGlvbk1zO1xuXG4gICAgY2FzZSBEZWZhdWx0SHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIERlZmF1bHRMYW5lOlxuICAgIGNhc2UgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmU6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTI6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTM6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTQ6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTU6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTY6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTc6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTg6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTk6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEwOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTI6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEzOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTU6XG4gICAgICByZXR1cm4gY3VycmVudFRpbWUgKyB0cmFuc2l0aW9uTGFuZUV4cGlyYXRpb25NcztcblxuICAgIGNhc2UgUmV0cnlMYW5lMTpcbiAgICBjYXNlIFJldHJ5TGFuZTI6XG4gICAgY2FzZSBSZXRyeUxhbmUzOlxuICAgIGNhc2UgUmV0cnlMYW5lNDpcbiAgICAgIC8vIFRPRE86IFJldHJpZXMgc2hvdWxkIGJlIGFsbG93ZWQgdG8gZXhwaXJlIGlmIHRoZXkgYXJlIENQVSBib3VuZCBmb3JcbiAgICAgIC8vIHRvbyBsb25nLCBidXQgd2hlbiBJIG1hZGUgdGhpcyBjaGFuZ2UgaXQgY2F1c2VkIGEgc3Bpa2UgaW4gYnJvd3NlclxuICAgICAgLy8gY3Jhc2hlcy4gVGhlcmUgbXVzdCBiZSBzb21lIG90aGVyIHVuZGVybHlpbmcgYnVnOyBub3Qgc3VwZXIgdXJnZW50IGJ1dFxuICAgICAgLy8gaWRlYWxseSBzaG91bGQgZmlndXJlIG91dCB3aHkgYW5kIGZpeCBpdC4gVW5mb3J0dW5hdGVseSB3ZSBkb24ndCBoYXZlXG4gICAgICAvLyBhIHJlcHJvIGZvciB0aGUgY3Jhc2hlcywgb25seSBkZXRlY3RlZCB2aWEgcHJvZHVjdGlvbiBtZXRyaWNzLlxuICAgICAgcmV0dXJuIE5vVGltZXN0YW1wO1xuXG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgSWRsZUh5ZHJhdGlvbkxhbmU6XG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICBjYXNlIE9mZnNjcmVlbkxhbmU6XG4gICAgY2FzZSBEZWZlcnJlZExhbmU6XG4gICAgICAvLyBBbnl0aGluZyBpZGxlIHByaW9yaXR5IG9yIGxvd2VyIHNob3VsZCBuZXZlciBleHBpcmUuXG4gICAgICByZXR1cm4gTm9UaW1lc3RhbXA7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBlcnJvcignU2hvdWxkIGhhdmUgZm91bmQgbWF0Y2hpbmcgbGFuZXMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBOb1RpbWVzdGFtcDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIC8vIFRPRE86IFRoaXMgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB3ZSB5aWVsZC4gV2UgY2FuIG9wdGltaXplIGJ5IHN0b3JpbmdcbiAgLy8gdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZSBvbiB0aGUgcm9vdC4gVGhlbiB1c2UgdGhhdCB0byBxdWlja2x5IGJhaWwgb3V0XG4gIC8vIG9mIHRoaXMgZnVuY3Rpb24uXG4gIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcbiAgdmFyIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcztcbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzOyAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHBlbmRpbmcgbGFuZXMgYW5kIGNoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlaXJcbiAgLy8gZXhwaXJhdGlvbiB0aW1lLiBJZiBzbywgd2UnbGwgYXNzdW1lIHRoZSB1cGRhdGUgaXMgYmVpbmcgc3RhcnZlZCBhbmQgbWFya1xuICAvLyBpdCBhcyBleHBpcmVkIHRvIGZvcmNlIGl0IHRvIGZpbmlzaC5cbiAgLy8gVE9ETzogV2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVwbGFjZSB0aGlzIHdpdGggdXBncmFkZVBlbmRpbmdMYW5lc1RvU3luY1xuICAvL1xuICAvLyBXZSBleGNsdWRlIHJldHJ5IGxhbmVzIGJlY2F1c2UgdGhvc2UgbXVzdCBhbHdheXMgYmUgdGltZSBzbGljZWQsIGluIG9yZGVyXG4gIC8vIHRvIHVud3JhcCB1bmNhY2hlZCBwcm9taXNlcy5cbiAgLy8gVE9ETzogV3JpdGUgYSB0ZXN0IGZvciB0aGlzXG5cbiAgdmFyIGxhbmVzID0gcGVuZGluZ0xhbmVzICYgflJldHJ5TGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBOb1RpbWVzdGFtcCkge1xuICAgICAgLy8gRm91bmQgYSBwZW5kaW5nIGxhbmUgd2l0aCBubyBleHBpcmF0aW9uIHRpbWUuIElmIGl0J3Mgbm90IHN1c3BlbmRlZCwgb3JcbiAgICAgIC8vIGlmIGl0J3MgcGluZ2VkLCBhc3N1bWUgaXQncyBDUFUtYm91bmQuIENvbXB1dGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lXG4gICAgICAvLyB1c2luZyB0aGUgY3VycmVudCB0aW1lLlxuICAgICAgaWYgKChsYW5lICYgc3VzcGVuZGVkTGFuZXMpID09PSBOb0xhbmVzIHx8IChsYW5lICYgcGluZ2VkTGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIC8vIEFzc3VtZXMgdGltZXN0YW1wcyBhcmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuICAgICAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBUaGlzIGxhbmUgZXhwaXJlZFxuICAgICAgcm9vdC5leHBpcmVkTGFuZXMgfD0gbGFuZTtcbiAgICB9XG5cbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufSAvLyBUaGlzIHJldHVybnMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgcGVuZGluZyBsYW5lcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleVxuLy8gYXJlIHN1c3BlbmRlZC5cblxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5UGVuZGluZ0xhbmVzKHJvb3QpIHtcbiAgcmV0dXJuIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHJvb3QucGVuZGluZ0xhbmVzKTtcbn1cbmZ1bmN0aW9uIGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QsIG9yaWdpbmFsbHlBdHRlbXB0ZWRMYW5lcykge1xuICBpZiAocm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyAmIG9yaWdpbmFsbHlBdHRlbXB0ZWRMYW5lcykge1xuICAgIC8vIFRoZSBlcnJvciByZWNvdmVyeSBtZWNoYW5pc20gaXMgZGlzYWJsZWQgdW50aWwgdGhlc2UgbGFuZXMgYXJlIGNsZWFyZWQuXG4gICAgcmV0dXJuIE5vTGFuZXM7XG4gIH1cblxuICB2YXIgZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiA9IHJvb3QucGVuZGluZ0xhbmVzICYgfk9mZnNjcmVlbkxhbmU7XG5cbiAgaWYgKGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm4gZXZlcnl0aGluZ0J1dE9mZnNjcmVlbjtcbiAgfVxuXG4gIGlmIChldmVyeXRoaW5nQnV0T2Zmc2NyZWVuICYgT2Zmc2NyZWVuTGFuZSkge1xuICAgIHJldHVybiBPZmZzY3JlZW5MYW5lO1xuICB9XG5cbiAgcmV0dXJuIE5vTGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc1N5bmNMYW5lKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiAoU3luY0xhbmUgfCBTeW5jSHlkcmF0aW9uTGFuZSkpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNOb25JZGxlV29yayhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgTm9uSWRsZUxhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIFJldHJ5TGFuZXMpID09PSBsYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seU5vblVyZ2VudExhbmVzKGxhbmVzKSB7XG4gIC8vIFRPRE86IFNob3VsZCBoeWRyYXRpb24gbGFuZXMgYmUgaW5jbHVkZWQgaGVyZT8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5XG4gIC8vIHVzZWQgaW4gYHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsYC5cbiAgdmFyIFVyZ2VudExhbmVzID0gU3luY0xhbmUgfCBJbnB1dENvbnRpbnVvdXNMYW5lIHwgRGVmYXVsdExhbmU7XG4gIHJldHVybiAobGFuZXMgJiBVcmdlbnRMYW5lcykgPT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgVHJhbnNpdGlvbkxhbmVzKSA9PT0gbGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc0Jsb2NraW5nTGFuZShyb290LCBsYW5lcykge1xuXG4gIHZhciBTeW5jRGVmYXVsdExhbmVzID0gSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSB8IElucHV0Q29udGludW91c0xhbmUgfCBEZWZhdWx0SHlkcmF0aW9uTGFuZSB8IERlZmF1bHRMYW5lO1xuICByZXR1cm4gKGxhbmVzICYgU3luY0RlZmF1bHRMYW5lcykgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc0V4cGlyZWRMYW5lKHJvb3QsIGxhbmVzKSB7XG4gIC8vIFRoaXMgaXMgYSBzZXBhcmF0ZSBjaGVjayBmcm9tIGluY2x1ZGVzQmxvY2tpbmdMYW5lIGJlY2F1c2UgYSBsYW5lIGNhblxuICAvLyBleHBpcmUgYWZ0ZXIgYSByZW5kZXIgaGFzIGFscmVhZHkgc3RhcnRlZC5cbiAgcmV0dXJuIChsYW5lcyAmIHJvb3QuZXhwaXJlZExhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGlzVHJhbnNpdGlvbkxhbmUobGFuZSkge1xuICByZXR1cm4gKGxhbmUgJiBUcmFuc2l0aW9uTGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKSB7XG4gIC8vIEN5Y2xlIHRocm91Z2ggdGhlIGxhbmVzLCBhc3NpZ25pbmcgZWFjaCBuZXcgdHJhbnNpdGlvbiB0byB0aGUgbmV4dCBsYW5lLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIG1lYW5zIGV2ZXJ5IHRyYW5zaXRpb24gZ2V0cyBpdHMgb3duIGxhbmUsIHVudGlsIHdlXG4gIC8vIHJ1biBvdXQgb2YgbGFuZXMgYW5kIGN5Y2xlIGJhY2sgdG8gdGhlIGJlZ2lubmluZy5cbiAgdmFyIGxhbmUgPSBuZXh0VHJhbnNpdGlvbkxhbmU7XG4gIG5leHRUcmFuc2l0aW9uTGFuZSA8PD0gMTtcblxuICBpZiAoKG5leHRUcmFuc2l0aW9uTGFuZSAmIFRyYW5zaXRpb25MYW5lcykgPT09IE5vTGFuZXMpIHtcbiAgICBuZXh0VHJhbnNpdGlvbkxhbmUgPSBUcmFuc2l0aW9uTGFuZTE7XG4gIH1cblxuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGNsYWltTmV4dFJldHJ5TGFuZSgpIHtcbiAgdmFyIGxhbmUgPSBuZXh0UmV0cnlMYW5lO1xuICBuZXh0UmV0cnlMYW5lIDw8PSAxO1xuXG4gIGlmICgobmV4dFJldHJ5TGFuZSAmIFJldHJ5TGFuZXMpID09PSBOb0xhbmVzKSB7XG4gICAgbmV4dFJldHJ5TGFuZSA9IFJldHJ5TGFuZTE7XG4gIH1cblxuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpIHtcbiAgcmV0dXJuIGxhbmVzICYgLWxhbmVzO1xufVxuZnVuY3Rpb24gcGlja0FyYml0cmFyeUxhbmUobGFuZXMpIHtcbiAgLy8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGdldHMgaW5saW5lZC4gT25seSBleGlzdHMgc28gdG8gY29tbXVuaWNhdGUgdGhhdCBpdFxuICAvLyBkb2Vzbid0IG1hdHRlciB3aGljaCBiaXQgaXMgc2VsZWN0ZWQ7IHlvdSBjYW4gcGljayBhbnkgYml0IHdpdGhvdXRcbiAgLy8gYWZmZWN0aW5nIHRoZSBhbGdvcml0aG1zIHdoZXJlIGl0cyB1c2VkLiBIZXJlIEknbSB1c2luZ1xuICAvLyBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lIGJlY2F1c2UgaXQgcmVxdWlyZXMgdGhlIGZld2VzdCBvcGVyYXRpb25zLlxuICByZXR1cm4gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpIHtcbiAgcmV0dXJuIDMxIC0gY2x6MzIobGFuZXMpO1xufVxuXG5mdW5jdGlvbiBsYW5lVG9JbmRleChsYW5lKSB7XG4gIHJldHVybiBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmUpO1xufVxuXG5mdW5jdGlvbiBpbmNsdWRlc1NvbWVMYW5lKGEsIGIpIHtcbiAgcmV0dXJuIChhICYgYikgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBpc1N1YnNldE9mTGFuZXMoc2V0LCBzdWJzZXQpIHtcbiAgcmV0dXJuIChzZXQgJiBzdWJzZXQpID09PSBzdWJzZXQ7XG59XG5mdW5jdGlvbiBtZXJnZUxhbmVzKGEsIGIpIHtcbiAgcmV0dXJuIGEgfCBiO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGFuZXMoc2V0LCBzdWJzZXQpIHtcbiAgcmV0dXJuIHNldCAmIH5zdWJzZXQ7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RMYW5lcyhhLCBiKSB7XG4gIHJldHVybiBhICYgYjtcbn0gLy8gU2VlbXMgcmVkdW5kYW50LCBidXQgaXQgY2hhbmdlcyB0aGUgdHlwZSBmcm9tIGEgc2luZ2xlIGxhbmUgKHVzZWQgZm9yXG4vLyB1cGRhdGVzKSB0byBhIGdyb3VwIG9mIGxhbmVzICh1c2VkIGZvciBmbHVzaGluZyB3b3JrKS5cblxuZnVuY3Rpb24gbGFuZVRvTGFuZXMobGFuZSkge1xuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGhpZ2hlclByaW9yaXR5TGFuZShhLCBiKSB7XG4gIC8vIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgYml0IHJhbmdlcyBkZWNyZWFzZSBpbiBwcmlvcml0eSBhcyB5b3UgZ28gbGVmdC5cbiAgcmV0dXJuIGEgIT09IE5vTGFuZSAmJiBhIDwgYiA/IGEgOiBiO1xufVxuZnVuY3Rpb24gY3JlYXRlTGFuZU1hcChpbml0aWFsKSB7XG4gIC8vIEludGVudGlvbmFsbHkgcHVzaGluZyBvbmUgYnkgb25lLlxuICAvLyBodHRwczovL3Y4LmRldi9ibG9nL2VsZW1lbnRzLWtpbmRzI2F2b2lkLWNyZWF0aW5nLWhvbGVzXG4gIHZhciBsYW5lTWFwID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBUb3RhbExhbmVzOyBpKyspIHtcbiAgICBsYW5lTWFwLnB1c2goaW5pdGlhbCk7XG4gIH1cblxuICByZXR1cm4gbGFuZU1hcDtcbn1cbmZ1bmN0aW9uIG1hcmtSb290VXBkYXRlZCQxKHJvb3QsIHVwZGF0ZUxhbmUpIHtcbiAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gdXBkYXRlTGFuZTsgLy8gSWYgdGhlcmUgYXJlIGFueSBzdXNwZW5kZWQgdHJhbnNpdGlvbnMsIGl0J3MgcG9zc2libGUgdGhpcyBuZXcgdXBkYXRlXG4gIC8vIGNvdWxkIHVuYmxvY2sgdGhlbS4gQ2xlYXIgdGhlIHN1c3BlbmRlZCBsYW5lcyBzbyB0aGF0IHdlIGNhbiB0cnkgcmVuZGVyaW5nXG4gIC8vIHRoZW0gYWdhaW4uXG4gIC8vXG4gIC8vIFRPRE86IFdlIHJlYWxseSBvbmx5IG5lZWQgdG8gdW5zdXNwZW5kIG9ubHkgbGFuZXMgdGhhdCBhcmUgaW4gdGhlXG4gIC8vIGBzdWJ0cmVlTGFuZXNgIG9mIHRoZSB1cGRhdGVkIGZpYmVyLCBvciB0aGUgdXBkYXRlIGxhbmVzIG9mIHRoZSByZXR1cm5cbiAgLy8gcGF0aC4gVGhpcyB3b3VsZCBleGNsdWRlIHN1c3BlbmRlZCB1cGRhdGVzIGluIGFuIHVucmVsYXRlZCBzaWJsaW5nIHRyZWUsXG4gIC8vIHNpbmNlIHRoZXJlJ3Mgbm8gd2F5IGZvciB0aGlzIHVwZGF0ZSB0byB1bmJsb2NrIGl0LlxuICAvL1xuICAvLyBXZSBkb24ndCBkbyB0aGlzIGlmIHRoZSBpbmNvbWluZyB1cGRhdGUgaXMgaWRsZSwgYmVjYXVzZSB3ZSBuZXZlciBwcm9jZXNzXG4gIC8vIGlkbGUgdXBkYXRlcyB1bnRpbCBhZnRlciBhbGwgdGhlIHJlZ3VsYXIgdXBkYXRlcyBoYXZlIGZpbmlzaGVkOyB0aGVyZSdzIG5vXG4gIC8vIHdheSBpdCBjb3VsZCB1bmJsb2NrIGEgdHJhbnNpdGlvbi5cblxuICBpZiAodXBkYXRlTGFuZSAhPT0gSWRsZUxhbmUpIHtcbiAgICByb290LnN1c3BlbmRlZExhbmVzID0gTm9MYW5lcztcbiAgICByb290LnBpbmdlZExhbmVzID0gTm9MYW5lcztcbiAgfVxufVxuZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBzdXNwZW5kZWRMYW5lcywgc3Bhd25lZExhbmUpIHtcbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyB8PSBzdXNwZW5kZWRMYW5lcztcbiAgcm9vdC5waW5nZWRMYW5lcyAmPSB+c3VzcGVuZGVkTGFuZXM7IC8vIFRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBDUFUtYm91bmQuIENsZWFyIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzO1xuICB2YXIgbGFuZXMgPSBzdXNwZW5kZWRMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxuXG4gIGlmIChzcGF3bmVkTGFuZSAhPT0gTm9MYW5lKSB7XG4gICAgbWFya1NwYXduZWREZWZlcnJlZExhbmUocm9vdCwgc3Bhd25lZExhbmUsIHN1c3BlbmRlZExhbmVzKTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1Jvb3RQaW5nZWQkMShyb290LCBwaW5nZWRMYW5lcykge1xuICByb290LnBpbmdlZExhbmVzIHw9IHJvb3Quc3VzcGVuZGVkTGFuZXMgJiBwaW5nZWRMYW5lcztcbn1cbmZ1bmN0aW9uIG1hcmtSb290RmluaXNoZWQocm9vdCwgcmVtYWluaW5nTGFuZXMsIHNwYXduZWRMYW5lKSB7XG4gIHZhciBub0xvbmdlclBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzICYgfnJlbWFpbmluZ0xhbmVzO1xuICByb290LnBlbmRpbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzOyAvLyBMZXQncyB0cnkgZXZlcnl0aGluZyBhZ2FpblxuXG4gIHJvb3Quc3VzcGVuZGVkTGFuZXMgPSBOb0xhbmVzO1xuICByb290LnBpbmdlZExhbmVzID0gTm9MYW5lcztcbiAgcm9vdC5leHBpcmVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3QuZW50YW5nbGVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlciA9IDA7XG4gIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzO1xuICB2YXIgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXM7XG4gIHZhciBoaWRkZW5VcGRhdGVzID0gcm9vdC5oaWRkZW5VcGRhdGVzOyAvLyBDbGVhciB0aGUgbGFuZXMgdGhhdCBubyBsb25nZXIgaGF2ZSBwZW5kaW5nIHdvcmtcblxuICB2YXIgbGFuZXMgPSBub0xvbmdlclBlbmRpbmdMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdID0gTm9MYW5lcztcbiAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gTm9UaW1lc3RhbXA7XG4gICAgdmFyIGhpZGRlblVwZGF0ZXNGb3JMYW5lID0gaGlkZGVuVXBkYXRlc1tpbmRleF07XG5cbiAgICBpZiAoaGlkZGVuVXBkYXRlc0ZvckxhbmUgIT09IG51bGwpIHtcbiAgICAgIGhpZGRlblVwZGF0ZXNbaW5kZXhdID0gbnVsbDsgLy8gXCJIaWRkZW5cIiB1cGRhdGVzIGFyZSB1cGRhdGVzIHRoYXQgd2VyZSBtYWRlIHRvIGEgaGlkZGVuIGNvbXBvbmVudC4gVGhleVxuICAgICAgLy8gaGF2ZSBzcGVjaWFsIGxvZ2ljIGFzc29jaWF0ZWQgd2l0aCB0aGVtIGJlY2F1c2UgdGhleSBtYXkgYmUgZW50YW5nbGVkXG4gICAgICAvLyB3aXRoIHVwZGF0ZXMgdGhhdCBvY2N1ciBvdXRzaWRlIHRoYXQgdHJlZS4gQnV0IG9uY2UgdGhlIG91dGVyIHRyZWVcbiAgICAgIC8vIGNvbW1pdHMsIHRoZXkgYmVoYXZlIGxpa2UgcmVndWxhciB1cGRhdGVzLlxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlblVwZGF0ZXNGb3JMYW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB1cGRhdGUgPSBoaWRkZW5VcGRhdGVzRm9yTGFuZVtpXTtcblxuICAgICAgICBpZiAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgdXBkYXRlLmxhbmUgJj0gfk9mZnNjcmVlbkxhbmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxuXG4gIGlmIChzcGF3bmVkTGFuZSAhPT0gTm9MYW5lKSB7XG4gICAgbWFya1NwYXduZWREZWZlcnJlZExhbmUocm9vdCwgc3Bhd25lZExhbmUsIC8vIFRoaXMgcmVuZGVyIGZpbmlzaGVkIHN1Y2Nlc3NmdWxseSB3aXRob3V0IHN1c3BlbmRpbmcsIHNvIHdlIGRvbid0IG5lZWRcbiAgICAvLyB0byBlbnRhbmdsZSB0aGUgc3Bhd25lZCB0YXNrIHdpdGggdGhlIHBhcmVudCB0YXNrLlxuICAgIE5vTGFuZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lKHJvb3QsIHNwYXduZWRMYW5lLCBlbnRhbmdsZWRMYW5lcykge1xuICAvLyBUaGlzIHJlbmRlciBzcGF3bmVkIGEgZGVmZXJyZWQgdGFzay4gTWFyayBpdCBhcyBwZW5kaW5nLlxuICByb290LnBlbmRpbmdMYW5lcyB8PSBzcGF3bmVkTGFuZTtcbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyAmPSB+c3Bhd25lZExhbmU7IC8vIEVudGFuZ2xlIHRoZSBzcGF3bmVkIGxhbmUgd2l0aCB0aGUgRGVmZXJyZWRMYW5lIGJpdCBzbyB0aGF0IHdlIGtub3cgaXRcbiAgLy8gd2FzIHRoZSByZXN1bHQgb2YgYW5vdGhlciByZW5kZXIuIFRoaXMgbGV0cyB1cyBhdm9pZCBhIHVzZURlZmVycmVkVmFsdWVcbiAgLy8gd2F0ZXJmYWxsIOKAlCBvbmx5IHRoZSBmaXJzdCBsZXZlbCB3aWxsIGRlZmVyLlxuXG4gIHZhciBzcGF3bmVkTGFuZUluZGV4ID0gbGFuZVRvSW5kZXgoc3Bhd25lZExhbmUpO1xuICByb290LmVudGFuZ2xlZExhbmVzIHw9IHNwYXduZWRMYW5lO1xuICByb290LmVudGFuZ2xlbWVudHNbc3Bhd25lZExhbmVJbmRleF0gfD0gRGVmZXJyZWRMYW5lIHwgLy8gSWYgdGhlIHBhcmVudCByZW5kZXIgdGFzayBzdXNwZW5kZWQsIHdlIG11c3QgYWxzbyBlbnRhbmdsZSB0aG9zZSBsYW5lc1xuICAvLyB3aXRoIHRoZSBzcGF3bmVkIHRhc2ssIHNvIHRoYXQgdGhlIGRlZmVycmVkIHRhc2sgaW5jbHVkZXMgYWxsIHRoZSBzYW1lXG4gIC8vIHVwZGF0ZXMgdGhhdCB0aGUgcGFyZW50IHRhc2sgZGlkLiBXZSBjYW4gZXhjbHVkZSBhbnkgbGFuZSB0aGF0IGlzIG5vdFxuICAvLyB1c2VkIGZvciB1cGRhdGVzIChlLmcuIE9mZnNjcmVlbikuXG4gIGVudGFuZ2xlZExhbmVzICYgVXBkYXRlTGFuZXM7XG59XG5cbmZ1bmN0aW9uIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGVudGFuZ2xlZExhbmVzKSB7XG4gIC8vIEluIGFkZGl0aW9uIHRvIGVudGFuZ2xpbmcgZWFjaCBvZiB0aGUgZ2l2ZW4gbGFuZXMgd2l0aCBlYWNoIG90aGVyLCB3ZSBhbHNvXG4gIC8vIGhhdmUgdG8gY29uc2lkZXIgX3RyYW5zaXRpdmVfIGVudGFuZ2xlbWVudHMuIEZvciBlYWNoIGxhbmUgdGhhdCBpcyBhbHJlYWR5XG4gIC8vIGVudGFuZ2xlZCB3aXRoICphbnkqIG9mIHRoZSBnaXZlbiBsYW5lcywgdGhhdCBsYW5lIGlzIG5vdyB0cmFuc2l0aXZlbHlcbiAgLy8gZW50YW5nbGVkIHdpdGggKmFsbCogdGhlIGdpdmVuIGxhbmVzLlxuICAvL1xuICAvLyBUcmFuc2xhdGVkOiBJZiBDIGlzIGVudGFuZ2xlZCB3aXRoIEEsIHRoZW4gZW50YW5nbGluZyBBIHdpdGggQiBhbHNvXG4gIC8vIGVudGFuZ2xlcyBDIHdpdGggQi5cbiAgLy9cbiAgLy8gSWYgdGhpcyBpcyBoYXJkIHRvIGdyYXNwLCBpdCBtaWdodCBoZWxwIHRvIGludGVudGlvbmFsbHkgYnJlYWsgdGhpc1xuICAvLyBmdW5jdGlvbiBhbmQgbG9vayBhdCB0aGUgdGVzdHMgdGhhdCBmYWlsIGluIFJlYWN0VHJhbnNpdGlvbi10ZXN0LmpzLiBUcnlcbiAgLy8gY29tbWVudGluZyBvdXQgb25lIG9mIHRoZSBjb25kaXRpb25zIGJlbG93LlxuICB2YXIgcm9vdEVudGFuZ2xlZExhbmVzID0gcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBlbnRhbmdsZWRMYW5lcztcbiAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gIHZhciBsYW5lcyA9IHJvb3RFbnRhbmdsZWRMYW5lcztcblxuICB3aGlsZSAobGFuZXMpIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG5cbiAgICBpZiAoIC8vIElzIHRoaXMgb25lIG9mIHRoZSBuZXdseSBlbnRhbmdsZWQgbGFuZXM/XG4gICAgbGFuZSAmIGVudGFuZ2xlZExhbmVzIHwgLy8gSXMgdGhpcyBsYW5lIHRyYW5zaXRpdmVseSBlbnRhbmdsZWQgd2l0aCB0aGUgbmV3bHkgZW50YW5nbGVkIGxhbmVzP1xuICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdICYgZW50YW5nbGVkTGFuZXMpIHtcbiAgICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdIHw9IGVudGFuZ2xlZExhbmVzO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiB1cGdyYWRlUGVuZGluZ0xhbmVUb1N5bmMocm9vdCwgbGFuZSkge1xuICAvLyBTaW5jZSB3ZSdyZSB1cGdyYWRpbmcgdGhlIHByaW9yaXR5IG9mIHRoZSBnaXZlbiBsYW5lLCB0aGVyZSBpcyBub3cgcGVuZGluZ1xuICAvLyBzeW5jIHdvcmsuXG4gIHJvb3QucGVuZGluZ0xhbmVzIHw9IFN5bmNMYW5lOyAvLyBFbnRhbmdsZSB0aGUgc3luYyBsYW5lIHdpdGggdGhlIGxhbmUgd2UncmUgdXBncmFkaW5nLiBUaGlzIG1lYW5zIFN5bmNMYW5lXG4gIC8vIHdpbGwgbm90IGJlIGFsbG93ZWQgdG8gZmluaXNoIHdpdGhvdXQgYWxzbyBmaW5pc2hpbmcgdGhlIGdpdmVuIGxhbmUuXG5cbiAgcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBTeW5jTGFuZTtcbiAgcm9vdC5lbnRhbmdsZW1lbnRzW1N5bmNMYW5lSW5kZXhdIHw9IGxhbmU7XG59XG5mdW5jdGlvbiB1cGdyYWRlUGVuZGluZ0xhbmVzVG9TeW5jKHJvb3QsIGxhbmVzVG9VcGdyYWRlKSB7XG4gIC8vIFNhbWUgYXMgdXBncmFkZVBlbmRpbmdMYW5lVG9TeW5jIGJ1dCBhY2NlcHRzIG11bHRpcGxlIGxhbmVzLCBzbyBpdCdzIGFcbiAgLy8gYml0IHNsb3dlci5cbiAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gU3luY0xhbmU7XG4gIHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gU3luY0xhbmU7XG4gIHZhciBsYW5lcyA9IGxhbmVzVG9VcGdyYWRlO1xuXG4gIHdoaWxlIChsYW5lcykge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICByb290LmVudGFuZ2xlbWVudHNbU3luY0xhbmVJbmRleF0gfD0gbGFuZTtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya0hpZGRlblVwZGF0ZShyb290LCB1cGRhdGUsIGxhbmUpIHtcbiAgdmFyIGluZGV4ID0gbGFuZVRvSW5kZXgobGFuZSk7XG4gIHZhciBoaWRkZW5VcGRhdGVzID0gcm9vdC5oaWRkZW5VcGRhdGVzO1xuICB2YXIgaGlkZGVuVXBkYXRlc0ZvckxhbmUgPSBoaWRkZW5VcGRhdGVzW2luZGV4XTtcblxuICBpZiAoaGlkZGVuVXBkYXRlc0ZvckxhbmUgPT09IG51bGwpIHtcbiAgICBoaWRkZW5VcGRhdGVzW2luZGV4XSA9IFt1cGRhdGVdO1xuICB9IGVsc2Uge1xuICAgIGhpZGRlblVwZGF0ZXNGb3JMYW5lLnB1c2godXBkYXRlKTtcbiAgfVxuXG4gIHVwZGF0ZS5sYW5lID0gbGFuZSB8IE9mZnNjcmVlbkxhbmU7XG59XG5mdW5jdGlvbiBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKHJvb3QsIHJlbmRlckxhbmVzKSB7XG4gIHZhciByZW5kZXJMYW5lID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShyZW5kZXJMYW5lcyk7XG4gIHZhciBsYW5lO1xuXG4gIGlmICgocmVuZGVyTGFuZSAmIFN5bmNVcGRhdGVMYW5lcykgIT09IE5vTGFuZSkge1xuICAgIGxhbmUgPSBTeW5jSHlkcmF0aW9uTGFuZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHJlbmRlckxhbmUpIHtcbiAgICAgIGNhc2UgU3luY0xhbmU6XG4gICAgICAgIGxhbmUgPSBTeW5jSHlkcmF0aW9uTGFuZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgSW5wdXRDb250aW51b3VzTGFuZTpcbiAgICAgICAgbGFuZSA9IElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIERlZmF1bHRMYW5lOlxuICAgICAgICBsYW5lID0gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUyOlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTM6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lNDpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU1OlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTY6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lNzpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU4OlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTk6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTA6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTE6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTI6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTM6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTQ6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTU6XG4gICAgICBjYXNlIFJldHJ5TGFuZTE6XG4gICAgICBjYXNlIFJldHJ5TGFuZTI6XG4gICAgICBjYXNlIFJldHJ5TGFuZTM6XG4gICAgICBjYXNlIFJldHJ5TGFuZTQ6XG4gICAgICAgIGxhbmUgPSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgSWRsZUxhbmU6XG4gICAgICAgIGxhbmUgPSBJZGxlSHlkcmF0aW9uTGFuZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpcyBhbHJlYWR5IGVpdGhlciBhIGh5ZHJhdGlvbiBsYW5lLCBvciBzaG91bGRuJ3RcbiAgICAgICAgLy8gYmUgcmV0cmllZCBhdCBhIGh5ZHJhdGlvbiBsYW5lLlxuICAgICAgICBsYW5lID0gTm9MYW5lO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8gQ2hlY2sgaWYgdGhlIGxhbmUgd2UgY2hvc2UgaXMgc3VzcGVuZGVkLiBJZiBzbywgdGhhdCBpbmRpY2F0ZXMgdGhhdCB3ZVxuICAvLyBhbHJlYWR5IGF0dGVtcHRlZCBhbmQgZmFpbGVkIHRvIGh5ZHJhdGUgYXQgdGhhdCBsZXZlbC4gQWxzbyBjaGVjayBpZiB3ZSdyZVxuICAvLyBhbHJlYWR5IHJlbmRlcmluZyB0aGF0IGxhbmUsIHdoaWNoIGlzIHJhcmUgYnV0IGNvdWxkIGhhcHBlbi5cblxuXG4gIGlmICgobGFuZSAmIChyb290LnN1c3BlbmRlZExhbmVzIHwgcmVuZGVyTGFuZXMpKSAhPT0gTm9MYW5lKSB7XG4gICAgLy8gR2l2ZSB1cCB0cnlpbmcgdG8gaHlkcmF0ZSBhbmQgZmFsbCBiYWNrIHRvIGNsaWVudCByZW5kZXIuXG4gICAgcmV0dXJuIE5vTGFuZTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIGZpYmVyLCBsYW5lcykge1xuXG4gIGlmICghaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcDtcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gbGFuZVRvSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICB2YXIgdXBkYXRlcnMgPSBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwW2luZGV4XTtcbiAgICB1cGRhdGVycy5hZGQoZmliZXIpO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpIHtcblxuICBpZiAoIWlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSByb290LnBlbmRpbmdVcGRhdGVyc0xhbmVNYXA7XG4gIHZhciBtZW1vaXplZFVwZGF0ZXJzID0gcm9vdC5tZW1vaXplZFVwZGF0ZXJzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBsYW5lVG9JbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIHZhciB1cGRhdGVycyA9IHBlbmRpbmdVcGRhdGVyc0xhbmVNYXBbaW5kZXhdO1xuXG4gICAgaWYgKHVwZGF0ZXJzLnNpemUgPiAwKSB7XG4gICAgICB1cGRhdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICAgIGlmIChhbHRlcm5hdGUgPT09IG51bGwgfHwgIW1lbW9pemVkVXBkYXRlcnMuaGFzKGFsdGVybmF0ZSkpIHtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmFkZChmaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdXBkYXRlcnMuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbnNGb3JMYW5lcyhyb290LCBsYW5lcykge1xuICB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxudmFyIERpc2NyZXRlRXZlbnRQcmlvcml0eSA9IFN5bmNMYW5lO1xudmFyIENvbnRpbnVvdXNFdmVudFByaW9yaXR5ID0gSW5wdXRDb250aW51b3VzTGFuZTtcbnZhciBEZWZhdWx0RXZlbnRQcmlvcml0eSA9IERlZmF1bHRMYW5lO1xudmFyIElkbGVFdmVudFByaW9yaXR5ID0gSWRsZUxhbmU7XG5mdW5jdGlvbiBoaWdoZXJFdmVudFByaW9yaXR5KGEsIGIpIHtcbiAgcmV0dXJuIGEgIT09IDAgJiYgYSA8IGIgPyBhIDogYjtcbn1cbmZ1bmN0aW9uIGxvd2VyRXZlbnRQcmlvcml0eShhLCBiKSB7XG4gIHJldHVybiBhID09PSAwIHx8IGEgPiBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiBpc0hpZ2hlckV2ZW50UHJpb3JpdHkoYSwgYikge1xuICByZXR1cm4gYSAhPT0gMCAmJiBhIDwgYjtcbn1cbmZ1bmN0aW9uIGV2ZW50UHJpb3JpdHlUb0xhbmUodXBkYXRlUHJpb3JpdHkpIHtcbiAgcmV0dXJuIHVwZGF0ZVByaW9yaXR5O1xufVxuZnVuY3Rpb24gbGFuZXNUb0V2ZW50UHJpb3JpdHkobGFuZXMpIHtcbiAgdmFyIGxhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKTtcblxuICBpZiAoIWlzSGlnaGVyRXZlbnRQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHksIGxhbmUpKSB7XG4gICAgcmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtcbiAgfVxuXG4gIGlmICghaXNIaWdoZXJFdmVudFByaW9yaXR5KENvbnRpbnVvdXNFdmVudFByaW9yaXR5LCBsYW5lKSkge1xuICAgIHJldHVybiBDb250aW51b3VzRXZlbnRQcmlvcml0eTtcbiAgfVxuXG4gIGlmIChpbmNsdWRlc05vbklkbGVXb3JrKGxhbmUpKSB7XG4gICAgcmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O1xuICB9XG5cbiAgcmV0dXJuIElkbGVFdmVudFByaW9yaXR5O1xufVxuXG4vLyBUaGlzIG1vZHVsZSBvbmx5IGV4aXN0cyBhcyBhbiBFU00gd3JhcHBlciBhcm91bmQgdGhlIGV4dGVybmFsIENvbW1vbkpTXG52YXIgc2NoZWR1bGVDYWxsYmFjayQzID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s7XG52YXIgY2FuY2VsQ2FsbGJhY2skMSA9IFNjaGVkdWxlci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjaztcbnZhciBzaG91bGRZaWVsZCA9IFNjaGVkdWxlci51bnN0YWJsZV9zaG91bGRZaWVsZDtcbnZhciByZXF1ZXN0UGFpbnQgPSBTY2hlZHVsZXIudW5zdGFibGVfcmVxdWVzdFBhaW50O1xudmFyIG5vdyQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdztcbnZhciBJbW1lZGlhdGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eTtcbnZhciBOb3JtYWxQcmlvcml0eSQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5O1xudmFyIElkbGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JZGxlUHJpb3JpdHk7IC8vIHRoaXMgZG9lc24ndCBhY3R1YWxseSBleGlzdCBvbiB0aGUgc2NoZWR1bGVyLCBidXQgaXQgKmRvZXMqXG4vLyBvbiBzY2hlZHVsZXIvdW5zdGFibGVfbW9jaywgd2hpY2ggd2UnbGwgbmVlZCBmb3IgaW50ZXJuYWwgdGVzdGluZ1xuXG52YXIgbG9nID0gU2NoZWR1bGVyLmxvZztcbnZhciB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSA9IFNjaGVkdWxlci51bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZTtcblxudmFyIHJlbmRlcmVySUQgPSBudWxsO1xudmFyIGluamVjdGVkSG9vayA9IG51bGw7XG52YXIgaW5qZWN0ZWRQcm9maWxpbmdIb29rcyA9IG51bGw7XG52YXIgaGFzTG9nZ2VkRXJyb3IgPSBmYWxzZTtcbnZhciBpc0RldlRvb2xzUHJlc2VudCA9IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnO1xuZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscykge1xuICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBObyBEZXZUb29sc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBob29rID0gX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4gIGlmIChob29rLmlzRGlzYWJsZWQpIHtcbiAgICAvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxuICAgIC8vIG9mIERldlRvb2xzIGludGVncmF0aW9uIGFuZCBhc3NvY2lhdGVkIHdhcm5pbmdzIGFuZCBsb2dzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzg3N1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCFob29rLnN1cHBvcnRzRmliZXIpIHtcbiAgICB7XG4gICAgICBlcnJvcignVGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIFJlYWN0IERldlRvb2xzIGlzIHRvbyBvbGQgYW5kIHdpbGwgbm90IHdvcmsgJyArICd3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuICcgKyAnaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9yZWFjdC1kZXZ0b29scycpO1xuICAgIH0gLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG5cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyKSB7XG4gICAgICAvLyBDb25kaXRpb25hbGx5IGluamVjdCB0aGVzZSBob29rcyBvbmx5IGlmIFRpbWVsaW5lIHByb2ZpbGVyIGlzIHN1cHBvcnRlZCBieSB0aGlzIGJ1aWxkLlxuICAgICAgLy8gVGhpcyBnaXZlcyBEZXZUb29scyBhIHdheSB0byBmZWF0dXJlIGRldGVjdCB0aGF0IGlzbid0IHRpZWQgdG8gdmVyc2lvbiBudW1iZXJcbiAgICAgIC8vIChzaW5jZSBwcm9maWxpbmcgYW5kIHRpbWVsaW5lIGFyZSBjb250cm9sbGVkIGJ5IGRpZmZlcmVudCBmZWF0dXJlIGZsYWdzKS5cbiAgICAgIGludGVybmFscyA9IGFzc2lnbih7fSwgaW50ZXJuYWxzLCB7XG4gICAgICAgIGdldExhbmVMYWJlbE1hcDogZ2V0TGFuZUxhYmVsTWFwLFxuICAgICAgICBpbmplY3RQcm9maWxpbmdIb29rczogaW5qZWN0UHJvZmlsaW5nSG9va3NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlcmVySUQgPSBob29rLmluamVjdChpbnRlcm5hbHMpOyAvLyBXZSBoYXZlIHN1Y2Nlc3NmdWxseSBpbmplY3RlZCwgc28gbm93IGl0IGlzIHNhZmUgdG8gc2V0IHVwIGhvb2tzLlxuXG4gICAgaW5qZWN0ZWRIb29rID0gaG9vaztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gQ2F0Y2ggYWxsIGVycm9ycyBiZWNhdXNlIGl0IGlzIHVuc2FmZSB0byB0aHJvdyBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG4gICAge1xuICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJywgZXJyKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaG9vay5jaGVja0RDRSkge1xuICAgIC8vIFRoaXMgaXMgdGhlIHJlYWwgRGV2VG9vbHMuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBsaWtlbHkgYSBob29rIGluc3RhbGxlZCBieSBGYXN0IFJlZnJlc2ggcnVudGltZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uU2NoZWR1bGVSb290KHJvb3QsIGNoaWxkcmVuKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRIb29rICYmIHR5cGVvZiBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCwgY2hpbGRyZW4pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdCQxKHJvb3QsIGV2ZW50UHJpb3JpdHkpIHtcbiAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBkaWRFcnJvciA9IChyb290LmN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gRGlkQ2FwdHVyZTtcblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgdmFyIHNjaGVkdWxlclByaW9yaXR5O1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnRQcmlvcml0eSkge1xuICAgICAgICAgIGNhc2UgRGlzY3JldGVFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgSWRsZUV2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IElkbGVQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHkkMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QsIHNjaGVkdWxlclByaW9yaXR5LCBkaWRFcnJvcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9uUG9zdENvbW1pdFJvb3Qocm9vdCkge1xuICBpZiAoaW5qZWN0ZWRIb29rICYmIHR5cGVvZiBpbmplY3RlZEhvb2sub25Qb3N0Q29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAoaW5qZWN0ZWRIb29rICYmIHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsIGZpYmVyKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMobmV3SXNTdHJpY3RNb2RlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gV2UncmUgaW4gYSB0ZXN0IGJlY2F1c2UgU2NoZWR1bGVyLmxvZyBvbmx5IGV4aXN0c1xuICAgICAgLy8gaW4gU2NoZWR1bGVyTW9jay4gVG8gcmVkdWNlIHRoZSBub2lzZSBpbiBzdHJpY3QgbW9kZSB0ZXN0cyxcbiAgICAgIC8vIHN1cHByZXNzIHdhcm5pbmdzIGFuZCBkaXNhYmxlIHNjaGVkdWxlciB5aWVsZGluZyBkdXJpbmcgdGhlIGRvdWJsZSByZW5kZXJcbiAgICAgIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlKG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICBzZXRTdXBwcmVzc1dhcm5pbmcobmV3SXNTdHJpY3RNb2RlKTtcbiAgICB9XG5cbiAgICBpZiAoaW5qZWN0ZWRIb29rICYmIHR5cGVvZiBpbmplY3RlZEhvb2suc2V0U3RyaWN0TW9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUocmVuZGVyZXJJRCwgbmV3SXNTdHJpY3RNb2RlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59IC8vIFByb2ZpbGVyIEFQSSBob29rc1xuXG5mdW5jdGlvbiBpbmplY3RQcm9maWxpbmdIb29rcyhwcm9maWxpbmdIb29rcykge1xuICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzID0gcHJvZmlsaW5nSG9va3M7XG59XG5cbmZ1bmN0aW9uIGdldExhbmVMYWJlbE1hcCgpIHtcbiAge1xuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgdmFyIGxhbmUgPSAxO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IFRvdGFsTGFuZXM7IGluZGV4KyspIHtcbiAgICAgIHZhciBsYWJlbCA9IGdldExhYmVsRm9yTGFuZShsYW5lKTtcbiAgICAgIG1hcC5zZXQobGFuZSwgbGFiZWwpO1xuICAgICAgbGFuZSAqPSAyO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya0NvbW1pdFN0YXJ0ZWQobGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdGFydGVkKGxhbmVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21taXRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZChmaWJlcikge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcikge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZChmaWJlcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudEVycm9yZWQoZmliZXIsIHRocm93blZhbHVlLCBsYW5lcykge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudEVycm9yZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudEVycm9yZWQoZmliZXIsIHRocm93blZhbHVlLCBsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50U3VzcGVuZGVkKGZpYmVyLCB3YWtlYWJsZSwgbGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFN1c3BlbmRlZChmaWJlciwgd2FrZWFibGUsIGxhbmVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChsYW5lcykge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSZW5kZXJZaWVsZGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlcllpZWxkZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlcllpZWxkZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSZW5kZXJTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSZW5kZXJTY2hlZHVsZWQobGFuZSkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG50eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbi8vIFRoaXMgaXMgaW1wb3J0ZWQgYnkgdGhlIGV2ZW50IHJlcGxheWluZyBpbXBsZW1lbnRhdGlvbiBpbiBSZWFjdCBET00uIEl0J3Ncbi8vIGluIGEgc2VwYXJhdGUgZmlsZSB0byBicmVhayBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGUgcmVuZGVyZXIgYW5kXG4vLyB0aGUgcmVjb25jaWxlci5cbmZ1bmN0aW9uIGlzUm9vdERlaHlkcmF0ZWQocm9vdCkge1xuICB2YXIgY3VycmVudFN0YXRlID0gcm9vdC5jdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHJldHVybiBjdXJyZW50U3RhdGUuaXNEZWh5ZHJhdGVkO1xufVxuXG52YXIgQ2FwdHVyZWRTdGFja3MgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZSkge1xuICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IsIGNhbGwgdGhpcyBmdW5jdGlvbiBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyB0aHJvd25cbiAgLy8gc28gdGhlIHN0YWNrIGlzIGFjY3VyYXRlLlxuICB2YXIgc3RhY2s7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICB2YXIgY2FwdHVyZWRTdGFjayA9IENhcHR1cmVkU3RhY2tzLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAodHlwZW9mIGNhcHR1cmVkU3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzdGFjayA9IGNhcHR1cmVkU3RhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrID0gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSk7XG4gICAgICBDYXB0dXJlZFN0YWNrcy5zZXQodmFsdWUsIHN0YWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RhY2sgPSBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHNvdXJjZTogc291cmNlLFxuICAgIHN0YWNrOiBzdGFja1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZUZyb21FcnJvcih2YWx1ZSwgc3RhY2spIHtcbiAgaWYgKHR5cGVvZiBzdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICBDYXB0dXJlZFN0YWNrcy5zZXQodmFsdWUsIHN0YWNrKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHNvdXJjZTogbnVsbCxcbiAgICBzdGFjazogc3RhY2tcbiAgfTtcbn1cblxuLy8gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgaXQgeWV0IHRvIGRlcmlzayB0aGUgaW5pdGlhbCBpbXBsZW1lbnRhdGlvbiwgYmVjYXVzZVxuLy8gdGhlIHdheSB3ZSBwdXNoL3BvcCB0aGVzZSB2YWx1ZXMgaXMgYSBiaXQgdW51c3VhbC4gSWYgdGhlcmUncyBhIG1pc3Rha2UsIEknZFxuLy8gcmF0aGVyIHRoZSBpZHMgYmUgd3JvbmcgdGhhbiBjcmFzaCB0aGUgd2hvbGUgcmVjb25jaWxlci5cblxudmFyIGZvcmtTdGFjayA9IFtdO1xudmFyIGZvcmtTdGFja0luZGV4ID0gMDtcbnZhciB0cmVlRm9ya1Byb3ZpZGVyID0gbnVsbDtcbnZhciB0cmVlRm9ya0NvdW50ID0gMDtcbnZhciBpZFN0YWNrID0gW107XG52YXIgaWRTdGFja0luZGV4ID0gMDtcbnZhciB0cmVlQ29udGV4dFByb3ZpZGVyID0gbnVsbDtcbnZhciB0cmVlQ29udGV4dElkID0gMTtcbnZhciB0cmVlQ29udGV4dE92ZXJmbG93ID0gJyc7XG5mdW5jdGlvbiBpc0ZvcmtlZENoaWxkKHdvcmtJblByb2dyZXNzKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9ya2VkKSAhPT0gTm9GbGFncyQxO1xufVxuZnVuY3Rpb24gZ2V0Rm9ya3NBdExldmVsKHdvcmtJblByb2dyZXNzKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICByZXR1cm4gdHJlZUZvcmtDb3VudDtcbn1cbmZ1bmN0aW9uIGdldFRyZWVJZCgpIHtcbiAgdmFyIG92ZXJmbG93ID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgdmFyIGlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICB2YXIgaWQgPSBpZFdpdGhMZWFkaW5nQml0ICYgfmdldExlYWRpbmdCaXQoaWRXaXRoTGVhZGluZ0JpdCk7XG4gIHJldHVybiBpZC50b1N0cmluZygzMikgKyBvdmVyZmxvdztcbn1cbmZ1bmN0aW9uIHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbikge1xuICAvLyBUaGlzIGlzIGNhbGxlZCByaWdodCBhZnRlciB3ZSByZWNvbmNpbGUgYW4gYXJyYXkgKG9yIGl0ZXJhdG9yKSBvZiBjaGlsZFxuICAvLyBmaWJlcnMsIGJlY2F1c2UgdGhhdCdzIHRoZSBvbmx5IHBsYWNlIHdoZXJlIHdlIGtub3cgaG93IG1hbnkgY2hpbGRyZW4gaW5cbiAgLy8gdGhlIHdob2xlIHNldCB3aXRob3V0IGRvaW5nIGV4dHJhIHdvcmsgbGF0ZXIsIG9yIHN0b3JpbmcgYWRkdGlvbmFsXG4gIC8vIGluZm9ybWF0aW9uIG9uIHRoZSBmaWJlci5cbiAgLy9cbiAgLy8gVGhhdCdzIHdoeSB0aGlzIGZ1bmN0aW9uIGlzIHNlcGFyYXRlIGZyb20gcHVzaFRyZWVJZCDigJQgaXQncyBjYWxsZWQgZHVyaW5nXG4gIC8vIHRoZSByZW5kZXIgcGhhc2Ugb2YgdGhlIGZvcmsgcGFyZW50LCBub3QgdGhlIGNoaWxkLCB3aGljaCBpcyB3aGVyZSB3ZSBwdXNoXG4gIC8vIHRoZSBvdGhlciBjb250ZXh0IHZhbHVlcy5cbiAgLy9cbiAgLy8gSW4gdGhlIEZpenogaW1wbGVtZW50YXRpb24gdGhpcyBpcyBtdWNoIHNpbXBsZXIgYmVjYXVzZSB0aGUgY2hpbGQgaXNcbiAgLy8gcmVuZGVyZWQgaW4gdGhlIHNhbWUgY2FsbHN0YWNrIGFzIHRoZSBwYXJlbnQuXG4gIC8vXG4gIC8vIEl0IG1pZ2h0IGJlIGJldHRlciB0byBqdXN0IGFkZCBhIGBmb3Jrc2AgZmllbGQgdG8gdGhlIEZpYmVyIHR5cGUuIEl0IHdvdWxkXG4gIC8vIG1ha2UgdGhpcyBtb2R1bGUgc2ltcGxlci5cbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrQ291bnQ7XG4gIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrUHJvdmlkZXI7XG4gIHRyZWVGb3JrUHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgdHJlZUZvcmtDb3VudCA9IHRvdGFsQ2hpbGRyZW47XG59XG5mdW5jdGlvbiBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkO1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlcjtcbiAgdHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICB2YXIgYmFzZU92ZXJmbG93ID0gdHJlZUNvbnRleHRPdmVyZmxvdzsgLy8gVGhlIGxlZnRtb3N0IDEgbWFya3MgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIG5vbi1pbmNsdXNpdmUuIEl0J3Mgbm90IHBhcnRcbiAgLy8gb2YgdGhlIGlkOyB3ZSB1c2UgaXQgdG8gYWNjb3VudCBmb3IgbGVhZGluZyAwcy5cblxuICB2YXIgYmFzZUxlbmd0aCA9IGdldEJpdExlbmd0aChiYXNlSWRXaXRoTGVhZGluZ0JpdCkgLSAxO1xuICB2YXIgYmFzZUlkID0gYmFzZUlkV2l0aExlYWRpbmdCaXQgJiB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gIHZhciBzbG90ID0gaW5kZXggKyAxO1xuICB2YXIgbGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aDsgLy8gMzAgaXMgdGhlIG1heCBsZW5ndGggd2UgY2FuIHN0b3JlIHdpdGhvdXQgb3ZlcmZsb3dpbmcsIHRha2luZyBpbnRvXG4gIC8vIGNvbnNpZGVyYXRpb24gdGhlIGxlYWRpbmcgMSB3ZSB1c2UgdG8gbWFyayB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cblxuICBpZiAobGVuZ3RoID4gMzApIHtcbiAgICAvLyBXZSBvdmVyZmxvd2VkIHRoZSBiaXR3aXNlLXNhZmUgcmFuZ2UuIEZhbGwgYmFjayB0byBzbG93ZXIgYWxnb3JpdGhtLlxuICAgIC8vIFRoaXMgYnJhbmNoIGFzc3VtZXMgdGhlIGxlbmd0aCBvZiB0aGUgYmFzZSBpZCBpcyBncmVhdGVyIHRoYW4gNTsgaXQgd29uJ3RcbiAgICAvLyB3b3JrIGZvciBzbWFsbGVyIGlkcywgYmVjYXVzZSB5b3UgbmVlZCA1IGJpdHMgcGVyIGNoYXJhY3Rlci5cbiAgICAvL1xuICAgIC8vIFdlIGVuY29kZSB0aGUgaWQgaW4gbXVsdGlwbGUgc3RlcHM6IGZpcnN0IHRoZSBiYXNlIGlkLCB0aGVuIHRoZVxuICAgIC8vIHJlbWFpbmluZyBkaWdpdHMuXG4gICAgLy9cbiAgICAvLyBFYWNoIDUgYml0IHNlcXVlbmNlIGNvcnJlc3BvbmRzIHRvIGEgc2luZ2xlIGJhc2UgMzIgY2hhcmFjdGVyLiBTbyBmb3JcbiAgICAvLyBleGFtcGxlLCBpZiB0aGUgY3VycmVudCBpZCBpcyAyMyBiaXRzIGxvbmcsIHdlIGNhbiBjb252ZXJ0IDIwIG9mIHRob3NlXG4gICAgLy8gYml0cyBpbnRvIGEgc3RyaW5nIG9mIDQgY2hhcmFjdGVycywgd2l0aCAzIGJpdHMgbGVmdCBvdmVyLlxuICAgIC8vXG4gICAgLy8gRmlyc3QgY2FsY3VsYXRlIGhvdyBtYW55IGJpdHMgaW4gdGhlIGJhc2UgaWQgcmVwcmVzZW50IGEgY29tcGxldGVcbiAgICAvLyBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzLlxuICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSBiYXNlTGVuZ3RoICUgNTsgLy8gVGhlbiBjcmVhdGUgYSBiaXRtYXNrIHRoYXQgc2VsZWN0cyBvbmx5IHRob3NlIGJpdHMuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3dCaXRzID0gKDEgPDwgbnVtYmVyT2ZPdmVyZmxvd0JpdHMpIC0gMTsgLy8gU2VsZWN0IHRoZSBiaXRzLCBhbmQgY29udmVydCB0aGVtIHRvIGEgYmFzZSAzMiBzdHJpbmcuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3cgPSAoYmFzZUlkICYgbmV3T3ZlcmZsb3dCaXRzKS50b1N0cmluZygzMik7IC8vIE5vdyB3ZSBjYW4gcmVtb3ZlIHRob3NlIGJpdHMgZnJvbSB0aGUgYmFzZSBpZC5cblxuICAgIHZhciByZXN0T2ZCYXNlSWQgPSBiYXNlSWQgPj4gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgdmFyIHJlc3RPZkJhc2VMZW5ndGggPSBiYXNlTGVuZ3RoIC0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7IC8vIEZpbmFsbHksIGVuY29kZSB0aGUgcmVzdCBvZiB0aGUgYml0cyB1c2luZyB0aGUgbm9ybWFsIGFsZ29yaXRobS4gQmVjYXVzZVxuICAgIC8vIHdlIG1hZGUgbW9yZSByb29tLCB0aGlzIHRpbWUgaXQgd29uJ3Qgb3ZlcmZsb3cuXG5cbiAgICB2YXIgcmVzdE9mTGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgcmVzdE9mTmV3Qml0cyA9IHNsb3QgPDwgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgaWQgPSByZXN0T2ZOZXdCaXRzIHwgcmVzdE9mQmFzZUlkO1xuICAgIHZhciBvdmVyZmxvdyA9IG5ld092ZXJmbG93ICsgYmFzZU92ZXJmbG93O1xuICAgIHRyZWVDb250ZXh0SWQgPSAxIDw8IHJlc3RPZkxlbmd0aCB8IGlkO1xuICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3JtYWwgcGF0aFxuICAgIHZhciBuZXdCaXRzID0gc2xvdCA8PCBiYXNlTGVuZ3RoO1xuXG4gICAgdmFyIF9pZCA9IG5ld0JpdHMgfCBiYXNlSWQ7XG5cbiAgICB2YXIgX292ZXJmbG93ID0gYmFzZU92ZXJmbG93O1xuICAgIHRyZWVDb250ZXh0SWQgPSAxIDw8IGxlbmd0aCB8IF9pZDtcbiAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gX292ZXJmbG93O1xuICB9XG59XG5mdW5jdGlvbiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpOyAvLyBUaGlzIGNvbXBvbmVudCBtYXRlcmlhbGl6ZWQgYW4gaWQuIFRoaXMgd2lsbCBhZmZlY3QgYW55IGlkcyB0aGF0IGFwcGVhclxuICAvLyBpbiBpdHMgY2hpbGRyZW4uXG5cbiAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBudW1iZXJPZkZvcmtzID0gMTtcbiAgICB2YXIgc2xvdEluZGV4ID0gMDtcbiAgICBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIG51bWJlck9mRm9ya3MpO1xuICAgIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIG51bWJlck9mRm9ya3MsIHNsb3RJbmRleCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Qml0TGVuZ3RoKG51bWJlcikge1xuICByZXR1cm4gMzIgLSBjbHozMihudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWFkaW5nQml0KGlkKSB7XG4gIHJldHVybiAxIDw8IGdldEJpdExlbmd0aChpZCkgLSAxO1xufVxuXG5mdW5jdGlvbiBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyB2YWx1ZXMuXG4gIC8vIFRoaXMgaXMgYSBiaXQgbW9yZSBjb21wbGljYXRlZCB0aGFuIG90aGVyIGNvbnRleHQtbGlrZSBtb2R1bGVzIGluIEZpYmVyXG4gIC8vIGJlY2F1c2UgdGhlIHNhbWUgRmliZXIgbWF5IGFwcGVhciBvbiB0aGUgc3RhY2sgbXVsdGlwbGUgdGltZXMgYW5kIGZvclxuICAvLyBkaWZmZXJlbnQgcmVhc29ucy4gV2UgaGF2ZSB0byBrZWVwIHBvcHBpbmcgdW50aWwgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaXNcbiAgLy8gbm8gbG9uZ2VyIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrLlxuICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgPT09IHRyZWVGb3JrUHJvdmlkZXIpIHtcbiAgICB0cmVlRm9ya1Byb3ZpZGVyID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdO1xuICAgIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsO1xuICAgIHRyZWVGb3JrQ291bnQgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF07XG4gICAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGw7XG4gIH1cblxuICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgPT09IHRyZWVDb250ZXh0UHJvdmlkZXIpIHtcbiAgICB0cmVlQ29udGV4dFByb3ZpZGVyID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgICB0cmVlQ29udGV4dElkID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVHJlZUNvbnRleHQoKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuXG4gIGlmICh0cmVlQ29udGV4dFByb3ZpZGVyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0cmVlQ29udGV4dElkLFxuICAgICAgb3ZlcmZsb3c6IHRyZWVDb250ZXh0T3ZlcmZsb3dcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlU3VzcGVuZGVkVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbmRlZENvbnRleHQpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZDtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXI7XG4gIHRyZWVDb250ZXh0SWQgPSBzdXNwZW5kZWRDb250ZXh0LmlkO1xuICB0cmVlQ29udGV4dE92ZXJmbG93ID0gc3VzcGVuZGVkQ29udGV4dC5vdmVyZmxvdztcbiAgdHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZOb3RIeWRyYXRpbmcoKSB7XG4gIHtcbiAgICBpZiAoIWdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0byBiZSBoeWRyYXRpbmcuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlICcgKyAnYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7IC8vIFJlcHJlc2VudHMgdGhlIG5lYXJlc3QgaG9zdCB0cmFuc2l0aW9uIHByb3ZpZGVyIChpbiBSZWFjdCBET00sIGEgPGZvcm0gLz4pXG4vLyBOT1RFOiBTaW5jZSBmb3JtcyBjYW5ub3QgYmUgbmVzdGVkLCBhbmQgdGhpcyBmZWF0dXJlIGlzIG9ubHkgaW1wbGVtZW50ZWQgYnlcbi8vIFJlYWN0IERPTSwgd2UgZG9uJ3QgdGVjaG5pY2FsbHkgbmVlZCB0aGlzIHRvIGJlIGEgc3RhY2suIEl0IGNvdWxkIGJlIGEgc2luZ2xlXG4vLyBtb2R1bGUgdmFyaWFibGUgaW5zdGVhZC5cblxudmFyIGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7IC8vIFRPRE86IFRoaXMgc2hvdWxkIGluaXRpYWxpemUgdG8gTm90UGVuZGluZ1RyYW5zaXRpb24sIGEgY29uc3RhbnRcbi8vIGltcG9ydGVkIGZyb20gdGhlIGZpYmVyIGNvbmZpZy4gSG93ZXZlciwgYmVjYXVzZSBvZiBhIGN5Y2xlIGluIHRoZSBtb2R1bGVcbi8vIGdyYXBoLCB0aGF0IHZhbHVlIGlzbid0IGRlZmluZWQgZHVyaW5nIHRoaXMgbW9kdWxlJ3MgaW5pdGlhbGl6YXRpb24uIEkgY2FuJ3Rcbi8vIHRoaW5rIG9mIGEgd2F5IHRvIHdvcmsgYXJvdW5kIHRoaXMgd2l0aG91dCBtb3ZpbmcgdGhhdCB2YWx1ZSBvdXQgb2YgdGhlXG4vLyBmaWJlciBjb25maWcuIEZvciBub3csIHRoZSBcIm5vIHByb3ZpZGVyXCIgY2FzZSBpcyBoYW5kbGVkIHdoZW4gcmVhZGluZyxcbi8vIGluc2lkZSB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cy5cblxudmFyIEhvc3RUcmFuc2l0aW9uQ29udGV4dCA9IHtcbiAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgUHJvdmlkZXI6IG51bGwsXG4gIENvbnN1bWVyOiBudWxsLFxuICBfY3VycmVudFZhbHVlOiBudWxsLFxuICBfY3VycmVudFZhbHVlMjogbnVsbCxcbiAgX3RocmVhZENvdW50OiAwXG59O1xuXG5mdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICB7XG4gICAgaWYgKGMgPT09IG51bGwpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyAnICsgJ2luIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHJldHVybiByb290SW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7IC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7IC8vIEZpbmFsbHksIHdlIG5lZWQgdG8gcHVzaCB0aGUgaG9zdCBjb250ZXh0IHRvIHRoZSBzdGFjay5cbiAgLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2VcbiAgLy8gd2UnZCBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZiBlbnRyaWVzIG9uIHRoZSBzdGFjayBkZXBlbmRpbmcgb25cbiAgLy8gd2hldGhlciBnZXRSb290SG9zdENvbnRleHQoKSB0aHJvd3Mgc29tZXdoZXJlIGluIHJlbmRlcmVyIGNvZGUgb3Igbm90LlxuICAvLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG51bGwsIGZpYmVyKTtcbiAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTsgLy8gTm93IHRoYXQgd2Uga25vdyB0aGlzIGZ1bmN0aW9uIGRvZXNuJ3QgdGhyb3csIHJlcGxhY2UgaXQuXG5cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RDb250ZXh0KCkge1xuICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAge1xuICAgIHZhciBzdGF0ZUhvb2sgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHN0YXRlSG9vayAhPT0gbnVsbCkge1xuICAgICAgLy8gT25seSBwcm92aWRlIGNvbnRleHQgaWYgdGhpcyBmaWJlciBoYXMgYmVlbiB1cGdyYWRlZCBieSBhIGhvc3RcbiAgICAgIC8vIHRyYW5zaXRpb24uIFdlIHVzZSB0aGUgc2FtZSBvcHRpbWl6YXRpb24gZm9yIHJlZ3VsYXIgaG9zdCBjb250ZXh0IGJlbG93LlxuICAgICAgcHVzaChob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlKTsgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG5cbiAgaWYgKGNvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIGlmIChjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ID09PSBmaWJlcikge1xuICAgIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAvLyBwdXNoSG9zdENvbnRleHQoKSBvbmx5IHB1c2hlcyBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cblxuICB7XG4gICAgaWYgKGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IuY3VycmVudCA9PT0gZmliZXIpIHtcbiAgICAgIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC4gVGhpcyBpcyBtb3N0bHlcbiAgICAgIC8vIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBidXQgY29udmVuaWVudGx5IGl0IGFsc28gcHJldmVudHMgYSBwb3RlbnRpYWxcbiAgICAgIC8vIGRhdGEgcmFjZSB3aGVyZSBhIGhvc3QgcHJvdmlkZXIgaXMgdXBncmFkZWQgKGkuZS4gbWVtb2l6ZWRTdGF0ZSBiZWNvbWVzXG4gICAgICAvLyBub24tbnVsbCkgZHVyaW5nIGEgY29uY3VycmVudCBldmVudC4gVGhpcyBpcyBhIGJpdCBvZiBhIGZsYXcgaW4gdGhlIHdheVxuICAgICAgLy8gd2UgdXBncmFkZSBob3N0IGNvbXBvbmVudHMsIGJ1dCBiZWNhdXNlIHdlJ3JlIGFjY291bnRpbmcgZm9yIGl0IGhlcmUsIGl0XG4gICAgICAvLyBzaG91bGQgYmUgZmluZS5cbiAgICAgIHBvcChob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLCBmaWJlcik7IC8vIFdoZW4gcG9wcGluZyB0aGUgdHJhbnNpdGlvbiBwcm92aWRlciwgd2UgcmVzZXQgdGhlIGNvbnRleHQgdmFsdWUgYmFja1xuICAgICAgLy8gdG8gYG51bGxgLiBXZSBjYW4gZG8gdGhpcyBiZWNhdXNlIHlvdSdyZSBub3QgYWxsb3dkIHRvIG5lc3QgZm9ybXMuIElmXG4gICAgICAvLyB3ZSBhbGxvd2VkIGZvciBtdWx0aXBsZSBuZXN0ZWQgaG9zdCB0cmFuc2l0aW9uIHByb3ZpZGVycywgdGhlbiB3ZSdkXG4gICAgICAvLyBuZWVkIHRvIHJlc2V0IHRoaXMgdG8gdGhlIHBhcmVudCBwcm92aWRlcidzIHN0YXR1cy5cblxuICAgICAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgICAgIEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlMiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBtYXhSb3dMZW5ndGggPSAxMjA7XG52YXIgaWRlYWxEZXB0aCA9IDE1O1xuXG5mdW5jdGlvbiBmaW5kTm90YWJsZU5vZGUobm9kZSwgaW5kZW50KSB7XG4gIGlmIChub2RlLnNlcnZlclByb3BzID09PSB1bmRlZmluZWQgJiYgbm9kZS5zZXJ2ZXJUYWlsLmxlbmd0aCA9PT0gMCAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBub2RlLmRpc3RhbmNlRnJvbUxlYWYgPiAzICYmIG5vZGUuZGlzdGFuY2VGcm9tTGVhZiA+IGlkZWFsRGVwdGggLSBpbmRlbnQpIHtcbiAgICAvLyBUaGlzIGlzIG5vdCBhbiBpbnRlcmVzdGluZyBub2RlIGZvciBjb250ZXh0dWFsIHB1cnBvc2VzIHNvIHdlIGNhbiBza2lwIGl0LlxuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgcmV0dXJuIGZpbmROb3RhYmxlTm9kZShjaGlsZCwgaW5kZW50KTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBpbmRlbnRhdGlvbihpbmRlbnQpIHtcbiAgcmV0dXJuICcgICcgKyAnICAnLnJlcGVhdChpbmRlbnQpO1xufVxuXG5mdW5jdGlvbiBhZGRlZChpbmRlbnQpIHtcbiAgcmV0dXJuICcrICcgKyAnICAnLnJlcGVhdChpbmRlbnQpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVkKGluZGVudCkge1xuICByZXR1cm4gJy0gJyArICcgICcucmVwZWF0KGluZGVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXJUeXBlKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZmliZXIudHlwZTtcblxuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnTGF6eSc7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgdmFyIGZuID0gZmliZXIudHlwZTtcbiAgICAgIHJldHVybiBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIHx8IG51bGw7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICB2YXIgcmVuZGVyID0gZmliZXIudHlwZS5yZW5kZXI7XG4gICAgICByZXR1cm4gcmVuZGVyLmRpc3BsYXlOYW1lIHx8IHJlbmRlci5uYW1lIHx8IG51bGw7XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgdmFyIGN0ciA9IGZpYmVyLnR5cGU7XG4gICAgICByZXR1cm4gY3RyLmRpc3BsYXlOYW1lIHx8IGN0ci5uYW1lIHx8IG51bGw7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gU2tpcFxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxudmFyIG5lZWRzRXNjYXBpbmcgPSAvW1wiJyY8PlxcblxcdF0vO1xuXG5mdW5jdGlvbiBkZXNjcmliZVRleHROb2RlKGNvbnRlbnQsIG1heExlbmd0aCkge1xuICBpZiAobmVlZHNFc2NhcGluZy50ZXN0KGNvbnRlbnQpKSB7XG4gICAgdmFyIGVuY29kZWQgPSBKU09OLnN0cmluZ2lmeShjb250ZW50KTtcblxuICAgIGlmIChlbmNvZGVkLmxlbmd0aCA+IG1heExlbmd0aCAtIDIpIHtcbiAgICAgIGlmIChtYXhMZW5ndGggPCA4KSB7XG4gICAgICAgIHJldHVybiAne1wiLi4uXCJ9JztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICd7JyArIGVuY29kZWQuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gNykgKyAnLi4uXCJ9JztcbiAgICB9XG5cbiAgICByZXR1cm4gJ3snICsgZW5jb2RlZCArICd9JztcbiAgfSBlbHNlIHtcbiAgICBpZiAoY29udGVudC5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgIGlmIChtYXhMZW5ndGggPCA1KSB7XG4gICAgICAgIHJldHVybiAne1wiLi4uXCJ9JztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gMykgKyAnLi4uJztcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZVRleHREaWZmKGNsaWVudFRleHQsIHNlcnZlclByb3BzLCBpbmRlbnQpIHtcbiAgdmFyIG1heExlbmd0aCA9IG1heFJvd0xlbmd0aCAtIGluZGVudCAqIDI7XG5cbiAgaWYgKHNlcnZlclByb3BzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGFkZGVkKGluZGVudCkgKyBkZXNjcmliZVRleHROb2RlKGNsaWVudFRleHQsIG1heExlbmd0aCkgKyAnXFxuJztcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2VydmVyUHJvcHMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlcnZlclRleHQgPSBzZXJ2ZXJQcm9wcztcbiAgICB2YXIgZmlyc3REaWZmID0gMDtcblxuICAgIGZvciAoOyBmaXJzdERpZmYgPCBzZXJ2ZXJUZXh0Lmxlbmd0aCAmJiBmaXJzdERpZmYgPCBjbGllbnRUZXh0Lmxlbmd0aDsgZmlyc3REaWZmKyspIHtcbiAgICAgIGlmIChzZXJ2ZXJUZXh0LmNoYXJDb2RlQXQoZmlyc3REaWZmKSAhPT0gY2xpZW50VGV4dC5jaGFyQ29kZUF0KGZpcnN0RGlmZikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RGlmZiA+IG1heExlbmd0aCAtIDggJiYgZmlyc3REaWZmID4gMTApIHtcbiAgICAgIC8vIFRoZSBmaXJzdCBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHR3byBzdHJpbmdzIHdvdWxkIGJlIGN1dCBvZmYsIHNvIGN1dCBvZmYgaW5cbiAgICAgIC8vIHRoZSBiZWdpbm5pbmcgaW5zdGVhZC5cbiAgICAgIGNsaWVudFRleHQgPSAnLi4uJyArIGNsaWVudFRleHQuc2xpY2UoZmlyc3REaWZmIC0gOCk7XG4gICAgICBzZXJ2ZXJUZXh0ID0gJy4uLicgKyBzZXJ2ZXJUZXh0LnNsaWNlKGZpcnN0RGlmZiAtIDgpO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRlZChpbmRlbnQpICsgZGVzY3JpYmVUZXh0Tm9kZShjbGllbnRUZXh0LCBtYXhMZW5ndGgpICsgJ1xcbicgKyByZW1vdmVkKGluZGVudCkgKyBkZXNjcmliZVRleHROb2RlKHNlcnZlclRleHQsIG1heExlbmd0aCkgKyAnXFxuJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW5kZW50YXRpb24oaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUoY2xpZW50VGV4dCwgbWF4TGVuZ3RoKSArICdcXG4nO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9iamVjdE5hbWUob2JqZWN0KSB7XG4gIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgdmFyIG5hbWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KTtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXlxcW29iamVjdCAoLiopXFxdJC8sIGZ1bmN0aW9uIChtLCBwMCkge1xuICAgIHJldHVybiBwMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVmFsdWUodmFsdWUsIG1heExlbmd0aCkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICB7XG4gICAgICAgIHZhciBlbmNvZGVkID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXG4gICAgICAgIGlmIChlbmNvZGVkLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICAgIGlmIChtYXhMZW5ndGggPCA1KSB7XG4gICAgICAgICAgICByZXR1cm4gJ1wiLi4uXCInO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBlbmNvZGVkLnNsaWNlKDAsIG1heExlbmd0aCAtIDQpICsgJy4uLlwiJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbmNvZGVkO1xuICAgICAgfVxuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiAnWy4uLl0nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh2YWx1ZS50eXBlKTtcbiAgICAgICAgICByZXR1cm4gdHlwZSA/ICc8JyArIHR5cGUgKyAnPicgOiAnPC4uLj4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWUgPSBvYmplY3ROYW1lKHZhbHVlKTtcblxuICAgICAgICBpZiAobmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9ICcnO1xuICAgICAgICAgIG1heExlbmd0aCAtPSAyO1xuXG4gICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIganNvblByb3BOYW1lID0gSlNPTi5zdHJpbmdpZnkocHJvcE5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoanNvblByb3BOYW1lICE9PSAnXCInICsgcHJvcE5hbWUgKyAnXCInKSB7XG4gICAgICAgICAgICAgIHByb3BOYW1lID0ganNvblByb3BOYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXhMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBkZXNjcmliZVZhbHVlKHZhbHVlW3Byb3BOYW1lXSwgbWF4TGVuZ3RoIDwgMTUgPyBtYXhMZW5ndGggOiAxNSk7XG4gICAgICAgICAgICBtYXhMZW5ndGggLT0gcHJvcFZhbHVlLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKG1heExlbmd0aCA8IDApIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllcyArPSBwcm9wZXJ0aWVzID09PSAnJyA/ICcuLi4nIDogJywgLi4uJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3BlcnRpZXMgKz0gKHByb3BlcnRpZXMgPT09ICcnID8gJycgOiAnLCcpICsgcHJvcE5hbWUgKyAnOicgKyBwcm9wVmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICd7JyArIHByb3BlcnRpZXMgKyAnfSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9uYW1lID0gdmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubmFtZTtcblxuICAgICAgICByZXR1cm4gX25hbWUgPyAnZnVuY3Rpb24gJyArIF9uYW1lIDogJ2Z1bmN0aW9uJztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlUHJvcFZhbHVlKHZhbHVlLCBtYXhMZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIW5lZWRzRXNjYXBpbmcudGVzdCh2YWx1ZSkpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID4gbWF4TGVuZ3RoIC0gMikge1xuICAgICAgaWYgKG1heExlbmd0aCA8IDUpIHtcbiAgICAgICAgcmV0dXJuICdcIi4uLlwiJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdcIicgKyB2YWx1ZS5zbGljZSgwLCBtYXhMZW5ndGggLSA1KSArICcuLi5cIic7XG4gICAgfVxuXG4gICAgcmV0dXJuICdcIicgKyB2YWx1ZSArICdcIic7XG4gIH1cblxuICByZXR1cm4gJ3snICsgZGVzY3JpYmVWYWx1ZSh2YWx1ZSwgbWF4TGVuZ3RoIC0gMikgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlQ29sbGFwc2VkRWxlbWVudCh0eXBlLCBwcm9wcywgaW5kZW50KSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gZml0IHRoZSBwcm9wcyBpbnRvIGEgc2luZ2xlIGxpbmUgZm9yIG5vbi1lc3NlbnRpYWwgZWxlbWVudHMuXG4gIC8vIFdlIGFsc28gaWdub3JlIGNoaWxkcmVuIGJlY2F1c2Ugd2UncmUgbm90IGdvaW5nIGRlZXBlci5cbiAgdmFyIG1heExlbmd0aCA9IG1heFJvd0xlbmd0aCAtIGluZGVudCAqIDIgLSB0eXBlLmxlbmd0aCAtIDI7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BOYW1lID09PSAnY2hpbGRyZW4nKSB7XG4gICAgICAvLyBJZ25vcmVkLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BWYWx1ZSA9IGRlc2NyaWJlUHJvcFZhbHVlKHByb3BzW3Byb3BOYW1lXSwgMTUpO1xuICAgIG1heExlbmd0aCAtPSBwcm9wTmFtZS5sZW5ndGggKyBwcm9wVmFsdWUubGVuZ3RoICsgMjtcblxuICAgIGlmIChtYXhMZW5ndGggPCAwKSB7XG4gICAgICBjb250ZW50ICs9ICcgLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnRlbnQgKz0gJyAnICsgcHJvcE5hbWUgKyAnPScgKyBwcm9wVmFsdWU7XG4gIH1cblxuICByZXR1cm4gaW5kZW50YXRpb24oaW5kZW50KSArICc8JyArIHR5cGUgKyBjb250ZW50ICsgJz5cXG4nO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUV4cGFuZGVkRWxlbWVudCh0eXBlLCBwcm9wcywgcm93UHJlZml4KSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gZml0IHRoZSBwcm9wcyBpbnRvIGEgc2luZ2xlIGxpbmUgZm9yIG5vbi1lc3NlbnRpYWwgZWxlbWVudHMuXG4gIC8vIFdlIGFsc28gaWdub3JlIGNoaWxkcmVuIGJlY2F1c2Ugd2UncmUgbm90IGdvaW5nIGRlZXBlci5cbiAgdmFyIHJlbWFpbmluZ1Jvd0xlbmd0aCA9IG1heFJvd0xlbmd0aCAtIHJvd1ByZWZpeC5sZW5ndGggLSB0eXBlLmxlbmd0aDsgLy8gV2UgYWRkIHRoZSBwcm9wZXJ0aWVzIHRvIGEgc2V0IHNvIHdlIGNhbiBjaG9vc2UgbGF0ZXIgd2hldGhlciB3ZSdsbCBwdXQgaXQgb24gb25lXG4gIC8vIGxpbmUgb3IgbXVsdGlwbGUgbGluZXMuXG5cbiAgdmFyIHByb3BlcnRpZXMgPSBbXTtcblxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcE5hbWUgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgIC8vIElnbm9yZWQuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbWF4TGVuZ3RoID0gbWF4Um93TGVuZ3RoIC0gcm93UHJlZml4Lmxlbmd0aCAtIHByb3BOYW1lLmxlbmd0aCAtIDE7XG4gICAgdmFyIHByb3BWYWx1ZSA9IGRlc2NyaWJlUHJvcFZhbHVlKHByb3BzW3Byb3BOYW1lXSwgbWF4TGVuZ3RoKTtcbiAgICByZW1haW5pbmdSb3dMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoICsgcHJvcFZhbHVlLmxlbmd0aCArIDI7XG4gICAgcHJvcGVydGllcy5wdXNoKHByb3BOYW1lICsgJz0nICsgcHJvcFZhbHVlKTtcbiAgfVxuXG4gIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiByb3dQcmVmaXggKyAnPCcgKyB0eXBlICsgJz5cXG4nO1xuICB9IGVsc2UgaWYgKHJlbWFpbmluZ1Jvd0xlbmd0aCA+IDApIHtcbiAgICAvLyBXZSBjYW4gZml0IGFsbCBvbiBvbmUgcm93LlxuICAgIHJldHVybiByb3dQcmVmaXggKyAnPCcgKyB0eXBlICsgJyAnICsgcHJvcGVydGllcy5qb2luKCcgJykgKyAnPlxcbic7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3BsaXQgaW50byBvbmUgcm93IHBlciBwcm9wZXJ0eTpcbiAgICByZXR1cm4gcm93UHJlZml4ICsgJzwnICsgdHlwZSArICdcXG4nICsgcm93UHJlZml4ICsgJyAgJyArIHByb3BlcnRpZXMuam9pbignXFxuJyArIHJvd1ByZWZpeCArICcgICcpICsgJ1xcbicgKyByb3dQcmVmaXggKyAnPlxcbic7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVQcm9wZXJ0aWVzRGlmZihjbGllbnRPYmplY3QsIHNlcnZlck9iamVjdCwgaW5kZW50KSB7XG4gIHZhciBwcm9wZXJ0aWVzID0gJyc7XG4gIHZhciByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzID0gYXNzaWduKHt9LCBzZXJ2ZXJPYmplY3QpO1xuXG4gIGZvciAodmFyIHByb3BOYW1lIGluIGNsaWVudE9iamVjdCkge1xuICAgIGlmICghY2xpZW50T2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZGVsZXRlIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgIHZhciBtYXhMZW5ndGggPSBtYXhSb3dMZW5ndGggLSBpbmRlbnQgKiAyIC0gcHJvcE5hbWUubGVuZ3RoIC0gMjtcbiAgICB2YXIgY2xpZW50VmFsdWUgPSBjbGllbnRPYmplY3RbcHJvcE5hbWVdO1xuICAgIHZhciBjbGllbnRQcm9wVmFsdWUgPSBkZXNjcmliZVZhbHVlKGNsaWVudFZhbHVlLCBtYXhMZW5ndGgpO1xuXG4gICAgaWYgKHNlcnZlck9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIHZhciBzZXJ2ZXJWYWx1ZSA9IHNlcnZlck9iamVjdFtwcm9wTmFtZV07XG4gICAgICB2YXIgc2VydmVyUHJvcFZhbHVlID0gZGVzY3JpYmVWYWx1ZShzZXJ2ZXJWYWx1ZSwgbWF4TGVuZ3RoKTtcbiAgICAgIHByb3BlcnRpZXMgKz0gYWRkZWQoaW5kZW50KSArIHByb3BOYW1lICsgJzogJyArIGNsaWVudFByb3BWYWx1ZSArICdcXG4nO1xuICAgICAgcHJvcGVydGllcyArPSByZW1vdmVkKGluZGVudCkgKyBwcm9wTmFtZSArICc6ICcgKyBzZXJ2ZXJQcm9wVmFsdWUgKyAnXFxuJztcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcGVydGllcyArPSBhZGRlZChpbmRlbnQpICsgcHJvcE5hbWUgKyAnOiAnICsgY2xpZW50UHJvcFZhbHVlICsgJ1xcbic7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3Byb3BOYW1lIGluIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMpIHtcbiAgICBpZiAoIXJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIF9tYXhMZW5ndGggPSBtYXhSb3dMZW5ndGggLSBpbmRlbnQgKiAyIC0gX3Byb3BOYW1lLmxlbmd0aCAtIDI7XG5cbiAgICB2YXIgX3NlcnZlclZhbHVlID0gcmVtYWluaW5nU2VydmVyUHJvcGVydGllc1tfcHJvcE5hbWVdO1xuXG4gICAgdmFyIF9zZXJ2ZXJQcm9wVmFsdWUgPSBkZXNjcmliZVZhbHVlKF9zZXJ2ZXJWYWx1ZSwgX21heExlbmd0aCk7XG5cbiAgICBwcm9wZXJ0aWVzICs9IHJlbW92ZWQoaW5kZW50KSArIF9wcm9wTmFtZSArICc6ICcgKyBfc2VydmVyUHJvcFZhbHVlICsgJ1xcbic7XG4gIH1cblxuICByZXR1cm4gcHJvcGVydGllcztcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVFbGVtZW50RGlmZih0eXBlLCBjbGllbnRQcm9wcywgc2VydmVyUHJvcHMsIGluZGVudCkge1xuICB2YXIgY29udGVudCA9ICcnOyAvLyBNYXBzIGFueSBwcmV2aW91c2x5IHVubWF0Y2hlZCBsb3dlciBjYXNlIHNlcnZlciBwcm9wIG5hbWUgdG8gaXRzIGZ1bGwgcHJvcCBuYW1lXG5cbiAgdmFyIHNlcnZlclByb3BOYW1lcyA9IG5ldyBNYXAoKTtcblxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBzZXJ2ZXJQcm9wcykge1xuICAgIGlmICghc2VydmVyUHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzZXJ2ZXJQcm9wTmFtZXMuc2V0KHByb3BOYW1lLnRvTG93ZXJDYXNlKCksIHByb3BOYW1lKTtcbiAgfVxuXG4gIGlmIChzZXJ2ZXJQcm9wTmFtZXMuc2l6ZSA9PT0gMSAmJiBzZXJ2ZXJQcm9wTmFtZXMuaGFzKCdjaGlsZHJlbicpKSB7XG4gICAgY29udGVudCArPSBkZXNjcmliZUV4cGFuZGVkRWxlbWVudCh0eXBlLCBjbGllbnRQcm9wcywgaW5kZW50YXRpb24oaW5kZW50KSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgX3Byb3BOYW1lMiBpbiBjbGllbnRQcm9wcykge1xuICAgICAgaWYgKCFjbGllbnRQcm9wcy5oYXNPd25Qcm9wZXJ0eShfcHJvcE5hbWUyKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9wcm9wTmFtZTIgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgICAgLy8gSGFuZGxlZCBiZWxvdy5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhMZW5ndGggPSBtYXhSb3dMZW5ndGggLSAoaW5kZW50ICsgMSkgKiAyIC0gX3Byb3BOYW1lMi5sZW5ndGggLSAxO1xuICAgICAgdmFyIHNlcnZlclByb3BOYW1lID0gc2VydmVyUHJvcE5hbWVzLmdldChfcHJvcE5hbWUyLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICBpZiAoc2VydmVyUHJvcE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMuZGVsZXRlKF9wcm9wTmFtZTIudG9Mb3dlckNhc2UoKSk7IC8vIFRoZXJlJ3MgYSBkaWZmIGhlcmUuXG5cbiAgICAgICAgdmFyIGNsaWVudFZhbHVlID0gY2xpZW50UHJvcHNbX3Byb3BOYW1lMl07XG4gICAgICAgIHZhciBzZXJ2ZXJWYWx1ZSA9IHNlcnZlclByb3BzW3NlcnZlclByb3BOYW1lXTtcbiAgICAgICAgdmFyIGNsaWVudFByb3BWYWx1ZSA9IGRlc2NyaWJlUHJvcFZhbHVlKGNsaWVudFZhbHVlLCBtYXhMZW5ndGgpO1xuICAgICAgICB2YXIgc2VydmVyUHJvcFZhbHVlID0gZGVzY3JpYmVQcm9wVmFsdWUoc2VydmVyVmFsdWUsIG1heExlbmd0aCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjbGllbnRWYWx1ZSA9PT0gJ29iamVjdCcgJiYgY2xpZW50VmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHNlcnZlclZhbHVlID09PSAnb2JqZWN0JyAmJiBzZXJ2ZXJWYWx1ZSAhPT0gbnVsbCAmJiBvYmplY3ROYW1lKGNsaWVudFZhbHVlKSA9PT0gJ09iamVjdCcgJiYgb2JqZWN0TmFtZShzZXJ2ZXJWYWx1ZSkgPT09ICdPYmplY3QnICYmICggLy8gT25seSBkbyB0aGUgZGlmZiBpZiB0aGUgb2JqZWN0IGhhcyBhIGxvdCBvZiBrZXlzIG9yIHdhcyBzaG9ydGVuZWQuXG4gICAgICAgIE9iamVjdC5rZXlzKGNsaWVudFZhbHVlKS5sZW5ndGggPiAyIHx8IE9iamVjdC5rZXlzKHNlcnZlclZhbHVlKS5sZW5ndGggPiAyIHx8IGNsaWVudFByb3BWYWx1ZS5pbmRleE9mKCcuLi4nKSA+IC0xIHx8IHNlcnZlclByb3BWYWx1ZS5pbmRleE9mKCcuLi4nKSA+IC0xKSkge1xuICAgICAgICAgIC8vIFdlJ3JlIGNvbXBhcmluZyB0d28gcGxhaW4gb2JqZWN0cy4gV2UgY2FuIGRpZmYgdGhlIG5lc3RlZCBvYmplY3RzIGluc3RlYWQuXG4gICAgICAgICAgY29udGVudCArPSBpbmRlbnRhdGlvbihpbmRlbnQgKyAxKSArIF9wcm9wTmFtZTIgKyAnPXt7XFxuJyArIGRlc2NyaWJlUHJvcGVydGllc0RpZmYoY2xpZW50VmFsdWUsIHNlcnZlclZhbHVlLCBpbmRlbnQgKyAyKSArIGluZGVudGF0aW9uKGluZGVudCArIDEpICsgJ319XFxuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50ICs9IGFkZGVkKGluZGVudCArIDEpICsgX3Byb3BOYW1lMiArICc9JyArIGNsaWVudFByb3BWYWx1ZSArICdcXG4nO1xuICAgICAgICAgIGNvbnRlbnQgKz0gcmVtb3ZlZChpbmRlbnQgKyAxKSArIF9wcm9wTmFtZTIgKyAnPScgKyBzZXJ2ZXJQcm9wVmFsdWUgKyAnXFxuJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29uc2lkZXJlZCBlcXVhbC5cbiAgICAgICAgY29udGVudCArPSBpbmRlbnRhdGlvbihpbmRlbnQgKyAxKSArIF9wcm9wTmFtZTIgKyAnPScgKyBkZXNjcmliZVByb3BWYWx1ZShjbGllbnRQcm9wc1tfcHJvcE5hbWUyXSwgbWF4TGVuZ3RoKSArICdcXG4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlcnZlclByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAnY2hpbGRyZW4nKSB7XG4gICAgICAgIC8vIEhhbmRsZWQgYmVsb3cuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heExlbmd0aCA9IG1heFJvd0xlbmd0aCAtIChpbmRlbnQgKyAxKSAqIDIgLSBwcm9wTmFtZS5sZW5ndGggLSAxO1xuICAgICAgY29udGVudCArPSByZW1vdmVkKGluZGVudCArIDEpICsgcHJvcE5hbWUgKyAnPScgKyBkZXNjcmliZVByb3BWYWx1ZShzZXJ2ZXJQcm9wc1twcm9wTmFtZV0sIG1heExlbmd0aCkgKyAnXFxuJztcbiAgICB9KTtcblxuICAgIGlmIChjb250ZW50ID09PSAnJykge1xuICAgICAgLy8gTm8gcHJvcGVydGllc1xuICAgICAgY29udGVudCA9IGluZGVudGF0aW9uKGluZGVudCkgKyAnPCcgKyB0eXBlICsgJz5cXG4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIYWQgcHJvcGVydGllc1xuICAgICAgY29udGVudCA9IGluZGVudGF0aW9uKGluZGVudCkgKyAnPCcgKyB0eXBlICsgJ1xcbicgKyBjb250ZW50ICsgaW5kZW50YXRpb24oaW5kZW50KSArICc+XFxuJztcbiAgICB9XG4gIH1cblxuICB2YXIgc2VydmVyQ2hpbGRyZW4gPSBzZXJ2ZXJQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGNsaWVudENoaWxkcmVuID0gY2xpZW50UHJvcHMuY2hpbGRyZW47XG5cbiAgaWYgKHR5cGVvZiBzZXJ2ZXJDaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHNlcnZlckNoaWxkcmVuID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygc2VydmVyQ2hpbGRyZW4gPT09ICdiaWdpbnQnKSB7XG4gICAgLy8gVGhlcmUncyBhIGRpZmYgb2YgdGhlIGNoaWxkcmVuLlxuICAgIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXVxuICAgIHZhciBzZXJ2ZXJUZXh0ID0gJycgKyBzZXJ2ZXJDaGlsZHJlbjtcbiAgICB2YXIgY2xpZW50VGV4dCA9ICcnO1xuXG4gICAgaWYgKHR5cGVvZiBjbGllbnRDaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNsaWVudENoaWxkcmVuID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgY2xpZW50Q2hpbGRyZW4gPT09ICdiaWdpbnQnKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl1cbiAgICAgIGNsaWVudFRleHQgPSAnJyArIGNsaWVudENoaWxkcmVuO1xuICAgIH1cblxuICAgIGNvbnRlbnQgKz0gZGVzY3JpYmVUZXh0RGlmZihjbGllbnRUZXh0LCBzZXJ2ZXJUZXh0LCBpbmRlbnQgKyAxKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2xpZW50Q2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjbGllbnRDaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGNsaWVudENoaWxkcmVuID09PSAnYmlnaW50Jykge1xuICAgIC8vIFRoZSBjbGllbnQgaGFzIGNoaWxkcmVuIGJ1dCBpdCdzIG5vdCBjb25zaWRlcmVkIGEgZGlmZmVyZW5jZSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dXG4gICAgY29udGVudCArPSBkZXNjcmliZVRleHREaWZmKCcnICsgY2xpZW50Q2hpbGRyZW4sIHVuZGVmaW5lZCwgaW5kZW50ICsgMSk7XG4gIH1cblxuICByZXR1cm4gY29udGVudDtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVTaWJsaW5nRmliZXIoZmliZXIsIGluZGVudCkge1xuICB2YXIgdHlwZSA9IGRlc2NyaWJlRmliZXJUeXBlKGZpYmVyKTtcblxuICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgIC8vIFNraXAgdGhpcyB0eXBlIG9mIGZpYmVyLiBXZSBjdXJyZW50bHkgdHJlYXQgdGhpcyBhcyBhIGZyYWdtZW50XG4gICAgLy8gc28gaXQncyBqdXN0IHBhcnQgb2YgdGhlIHBhcmVudCdzIGNoaWxkcmVuLlxuICAgIHZhciBmbGF0Q29udGVudCA9ICcnO1xuICAgIHZhciBjaGlsZEZpYmVyID0gZmliZXIuY2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGRGaWJlcikge1xuICAgICAgZmxhdENvbnRlbnQgKz0gZGVzY3JpYmVTaWJsaW5nRmliZXIoY2hpbGRGaWJlciwgaW5kZW50KTtcbiAgICAgIGNoaWxkRmliZXIgPSBjaGlsZEZpYmVyLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsYXRDb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGluZGVudGF0aW9uKGluZGVudCkgKyAnPCcgKyB0eXBlICsgJz4nICsgJ1xcbic7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTm9kZShub2RlLCBpbmRlbnQpIHtcbiAgdmFyIHNraXBUb05vZGUgPSBmaW5kTm90YWJsZU5vZGUobm9kZSwgaW5kZW50KTtcblxuICBpZiAoc2tpcFRvTm9kZSAhPT0gbm9kZSAmJiAobm9kZS5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgbm9kZS5jaGlsZHJlblswXSAhPT0gc2tpcFRvTm9kZSkpIHtcbiAgICByZXR1cm4gaW5kZW50YXRpb24oaW5kZW50KSArICcuLi5cXG4nICsgZGVzY3JpYmVOb2RlKHNraXBUb05vZGUsIGluZGVudCArIDEpO1xuICB9IC8vIFByZWZpeCB3aXRoIGFueSBzZXJ2ZXIgY29tcG9uZW50cyBmb3IgY29udGV4dFxuXG5cbiAgdmFyIHBhcmVudENvbnRlbnQgPSAnJztcbiAgdmFyIGRlYnVnSW5mbyA9IG5vZGUuZmliZXIuX2RlYnVnSW5mbztcblxuICBpZiAoZGVidWdJbmZvKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWJ1Z0luZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZXJ2ZXJDb21wb25lbnROYW1lID0gZGVidWdJbmZvW2ldLm5hbWU7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VydmVyQ29tcG9uZW50TmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFyZW50Q29udGVudCArPSBpbmRlbnRhdGlvbihpbmRlbnQpICsgJzwnICsgc2VydmVyQ29tcG9uZW50TmFtZSArICc+JyArICdcXG4nO1xuICAgICAgICBpbmRlbnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gU2VsZlxuXG5cbiAgdmFyIHNlbGZDb250ZW50ID0gJyc7IC8vIFdlIHVzZSB0aGUgcGVuZGluZyBwcm9wcyBzaW5jZSB3ZSBtaWdodCBiZSBnZW5lcmF0aW5nIGEgZGlmZiBiZWZvcmUgdGhlIGNvbXBsZXRlIHBoYXNlXG4gIC8vIHdoZW4gc29tZXRoaW5nIHRocm93cy5cblxuICB2YXIgY2xpZW50UHJvcHMgPSBub2RlLmZpYmVyLnBlbmRpbmdQcm9wcztcblxuICBpZiAobm9kZS5maWJlci50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gVGV4dCBOb2RlXG4gICAgc2VsZkNvbnRlbnQgPSBkZXNjcmliZVRleHREaWZmKGNsaWVudFByb3BzLCBub2RlLnNlcnZlclByb3BzLCBpbmRlbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gZGVzY3JpYmVGaWJlclR5cGUobm9kZS5maWJlcik7XG5cbiAgICBpZiAodHlwZSAhPT0gbnVsbCkge1xuICAgICAgLy8gRWxlbWVudCBOb2RlXG4gICAgICBpZiAobm9kZS5zZXJ2ZXJQcm9wcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEp1c3QgYSByZWZlcmVuY2Ugbm9kZSBmb3IgY29udGV4dC5cbiAgICAgICAgc2VsZkNvbnRlbnQgPSBkZXNjcmliZUNvbGxhcHNlZEVsZW1lbnQodHlwZSwgY2xpZW50UHJvcHMsIGluZGVudCk7XG4gICAgICAgIGluZGVudCsrO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnNlcnZlclByb3BzID09PSBudWxsKSB7XG4gICAgICAgIHNlbGZDb250ZW50ID0gZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQodHlwZSwgY2xpZW50UHJvcHMsIGFkZGVkKGluZGVudCkpOyAvLyBJZiB0aGlzIHdhcyBhbiBpbnNlcnRpb24gd2Ugd29uJ3Qgc3RlcCBkb3duIGZ1cnRoZXIuIEFueSB0YWlsXG4gICAgICAgIC8vIGFyZSBjb25zaWRlcmVkIHNpYmxpbmdzIHNvIHdlIGRvbid0IGluZGVudC5cbiAgICAgICAgLy8gVE9ETzogTW9kZWwgdGhpcyBhIGxpdHRsZSBiZXR0ZXIuXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlLnNlcnZlclByb3BzID09PSAnc3RyaW5nJykge1xuICAgICAgICB7XG4gICAgICAgICAgZXJyb3IoJ1Nob3VsZCBub3QgaGF2ZSBtYXRjaGVkIGEgbm9uIEhvc3RUZXh0IGZpYmVyIHRvIGEgVGV4dCBub2RlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmQ29udGVudCA9IGRlc2NyaWJlRWxlbWVudERpZmYodHlwZSwgY2xpZW50UHJvcHMsIG5vZGUuc2VydmVyUHJvcHMsIGluZGVudCk7XG4gICAgICAgIGluZGVudCsrO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDb21wdXRlIGNoaWxkcmVuXG5cblxuICB2YXIgY2hpbGRDb250ZW50ID0gJyc7XG4gIHZhciBjaGlsZEZpYmVyID0gbm9kZS5maWJlci5jaGlsZDtcbiAgdmFyIGRpZmZJZHggPSAwO1xuXG4gIHdoaWxlIChjaGlsZEZpYmVyICYmIGRpZmZJZHggPCBub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSBub2RlLmNoaWxkcmVuW2RpZmZJZHhdO1xuXG4gICAgaWYgKGNoaWxkTm9kZS5maWJlciA9PT0gY2hpbGRGaWJlcikge1xuICAgICAgLy8gVGhpcyB3YXMgYSBtYXRjaCBpbiB0aGUgZGlmZi5cbiAgICAgIGNoaWxkQ29udGVudCArPSBkZXNjcmliZU5vZGUoY2hpbGROb2RlLCBpbmRlbnQpO1xuICAgICAgZGlmZklkeCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIHVucmVsYXRlZCBwcmV2aW91cyBzaWJsaW5nLlxuICAgICAgY2hpbGRDb250ZW50ICs9IGRlc2NyaWJlU2libGluZ0ZpYmVyKGNoaWxkRmliZXIsIGluZGVudCk7XG4gICAgfVxuXG4gICAgY2hpbGRGaWJlciA9IGNoaWxkRmliZXIuc2libGluZztcbiAgfVxuXG4gIGlmIChjaGlsZEZpYmVyICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgIC8vIElmIHdlIGhhZCBhbnkgZnVydGhlciBzaWJsaW5ncyBhZnRlciB0aGUgbGFzdCBtaXNtYXRjaCwgd2UgY2FuJ3QgYmUgc3VyZSBpZiBpdCdzXG4gICAgLy8gYWN0dWFsbHkgYSB2YWxpZCBtYXRjaCBzaW5jZSBpdCBtaWdodCBub3QgaGF2ZSBmb3VuZCBhIG1hdGNoLiBTbyB3ZSBleGNsdWRlIG5leHRcbiAgICAvLyBzaWJsaW5ncyB0byBhdm9pZCBjb25mdXNpb24uXG4gICAgY2hpbGRDb250ZW50ICs9IGluZGVudGF0aW9uKGluZGVudCkgKyAnLi4uJyArICdcXG4nO1xuICB9IC8vIERlbGV0ZWQgdGFpbCBub2Rlc1xuXG5cbiAgdmFyIHNlcnZlclRhaWwgPSBub2RlLnNlcnZlclRhaWw7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHNlcnZlclRhaWwubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIHRhaWxOb2RlID0gc2VydmVyVGFpbFtfaV07XG5cbiAgICBpZiAodHlwZW9mIHRhaWxOb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gUmVtb3ZlZCB0ZXh0IG5vZGVcbiAgICAgIGNoaWxkQ29udGVudCArPSByZW1vdmVkKGluZGVudCkgKyBkZXNjcmliZVRleHROb2RlKHRhaWxOb2RlLCBtYXhSb3dMZW5ndGggLSBpbmRlbnQgKiAyKSArICdcXG4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmVkIGVsZW1lbnRcbiAgICAgIGNoaWxkQ29udGVudCArPSBkZXNjcmliZUV4cGFuZGVkRWxlbWVudCh0YWlsTm9kZS50eXBlLCB0YWlsTm9kZS5wcm9wcywgcmVtb3ZlZChpbmRlbnQpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyZW50Q29udGVudCArIHNlbGZDb250ZW50ICsgY2hpbGRDb250ZW50O1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZURpZmYocm9vdE5vZGUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJ1xcblxcbicgKyBkZXNjcmliZU5vZGUocm9vdE5vZGUsIDApO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbi8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cbnZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG52YXIgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTsgLy8gVGhpcyBmbGFnIGFsbG93cyBmb3Igd2FybmluZyBzdXByZXNzaW9uIHdoZW4gd2UgZXhwZWN0IHRoZXJlIHRvIGJlIG1pc21hdGNoZXNcbi8vIGR1ZSB0byBlYXJsaWVyIG1pc21hdGNoZXMgb3IgYSBzdXNwZW5kZWQgZmliZXIuXG5cbnZhciBkaWRTdXNwZW5kT3JFcnJvckRFViA9IGZhbHNlOyAvLyBIeWRyYXRpb24gZGlmZmVyZW5jZXMgZm91bmQgdGhhdCBoYXZlbid0IHlldCBiZWVuIGxvZ2dlZC5cblxudmFyIGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbDsgLy8gSHlkcmF0aW9uIGVycm9ycyB0aGF0IHdlcmUgdGhyb3duIGluc2lkZSB0aGlzIGJvdW5kYXJ5XG5cbnZhciBoeWRyYXRpb25FcnJvcnMgPSBudWxsO1xudmFyIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSBmYWxzZTsgLy8gQnVpbGRzIGEgY29tbW9uIGFuY2VzdG9yIHRyZWUgZnJvbSB0aGUgcm9vdCBkb3duIGZvciBjb2xsZWN0aW5nIGRpZmZzLlxuXG5mdW5jdGlvbiBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLCBkaXN0YW5jZUZyb21MZWFmKSB7XG4gIGlmIChmaWJlci5yZXR1cm4gPT09IG51bGwpIHtcbiAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICBpZiAoaHlkcmF0aW9uRGlmZlJvb3RERVYgPT09IG51bGwpIHtcbiAgICAgIGh5ZHJhdGlvbkRpZmZSb290REVWID0ge1xuICAgICAgICBmaWJlcjogZmliZXIsXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgc2VydmVyUHJvcHM6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VydmVyVGFpbDogW10sXG4gICAgICAgIGRpc3RhbmNlRnJvbUxlYWY6IGRpc3RhbmNlRnJvbUxlYWZcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChoeWRyYXRpb25EaWZmUm9vdERFVi5maWJlciAhPT0gZmliZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2F3IG11bHRpcGxlIGh5ZHJhdGlvbiBkaWZmIHJvb3RzIGluIGEgcGFzcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9IGVsc2UgaWYgKGh5ZHJhdGlvbkRpZmZSb290REVWLmRpc3RhbmNlRnJvbUxlYWYgPiBkaXN0YW5jZUZyb21MZWFmKSB7XG4gICAgICBoeWRyYXRpb25EaWZmUm9vdERFVi5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZjtcbiAgICB9XG5cbiAgICByZXR1cm4gaHlkcmF0aW9uRGlmZlJvb3RERVY7XG4gIH1cblxuICB2YXIgc2libGluZ3MgPSBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLnJldHVybiwgZGlzdGFuY2VGcm9tTGVhZiArIDEpLmNoaWxkcmVuOyAvLyBUaGUgc2FtZSBub2RlIG1heSBhbHJlYWR5IGV4aXN0IGluIHRoZSBwYXJlbnQuIFNpbmNlIHdlIGN1cnJlbnRseSBhbHdheXMgcmVuZGVyIGRlcHRoIGZpcnN0XG4gIC8vIGFuZCByZXJlbmRlciBpZiB3ZSBzdXNwZW5kIG9yIHRlcm1pbmF0ZSBlYXJseSwgaWYgYSBzaGFyZWQgYW5jZXN0b3Igd2FzIGFkZGVkIHdlIHNob3VsZCBzdGlsbFxuICAvLyBiZSBpbnNpZGUgb2YgdGhhdCBzaGFyZWQgYW5jZXN0b3Igd2hpY2ggbWVhbnMgaXQgd2FzIHRoZSBsYXN0IG9uZSB0byBiZSBhZGRlZC4gSWYgdGhpcyBjaGFuZ2VzXG4gIC8vIHdlIG1heSBoYXZlIHRvIHNjYW4gdGhlIHdob2xlIHNldC5cblxuICBpZiAoc2libGluZ3MubGVuZ3RoID4gMCAmJiBzaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGggLSAxXS5maWJlciA9PT0gZmliZXIpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBzaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChleGlzdGluZy5kaXN0YW5jZUZyb21MZWFmID4gZGlzdGFuY2VGcm9tTGVhZikge1xuICAgICAgZXhpc3RpbmcuZGlzdGFuY2VGcm9tTGVhZiA9IGRpc3RhbmNlRnJvbUxlYWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4aXN0aW5nO1xuICB9XG5cbiAgdmFyIG5ld05vZGUgPSB7XG4gICAgZmliZXI6IGZpYmVyLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBzZXJ2ZXJQcm9wczogdW5kZWZpbmVkLFxuICAgIHNlcnZlclRhaWw6IFtdLFxuICAgIGRpc3RhbmNlRnJvbUxlYWY6IGRpc3RhbmNlRnJvbUxlYWZcbiAgfTtcbiAgc2libGluZ3MucHVzaChuZXdOb2RlKTtcbiAgcmV0dXJuIG5ld05vZGU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZkh5ZHJhdGluZygpIHtcbiAge1xuICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgZXJyb3IoJ1dlIHNob3VsZCBub3QgYmUgaHlkcmF0aW5nIGhlcmUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGEgYnVnLicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFVigpIHtcbiAge1xuICAgIGRpZFN1c3BlbmRPckVycm9yREVWID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcGFyZW50SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyKHBhcmVudEluc3RhbmNlKTtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICBoeWRyYXRpb25FcnJvcnMgPSBudWxsO1xuICBkaWRTdXNwZW5kT3JFcnJvckRFViA9IGZhbHNlO1xuICBoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGw7XG4gIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyLCBzdXNwZW5zZUluc3RhbmNlLCB0cmVlQ29udGV4dCkge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICBoeWRyYXRpb25FcnJvcnMgPSBudWxsO1xuICBkaWRTdXNwZW5kT3JFcnJvckRFViA9IGZhbHNlO1xuICBoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGw7XG4gIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSBmYWxzZTtcblxuICBpZiAodHJlZUNvbnRleHQgIT09IG51bGwpIHtcbiAgICByZXN0b3JlU3VzcGVuZGVkVHJlZUNvbnRleHQoZmliZXIsIHRyZWVDb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZShmaWJlciwgcmVqZWN0ZWRDYW5kaWRhdGUpIHtcbiAge1xuICAgIGlmIChkaWRTdXNwZW5kT3JFcnJvckRFVikge1xuICAgICAgLy8gSW5zaWRlIGEgYm91bmRhcnkgdGhhdCBhbHJlYWR5IHN1c3BlbmRlZC4gV2UncmUgY3VycmVudGx5IHJlbmRlcmluZyB0aGVcbiAgICAgIC8vIHNpYmxpbmdzIG9mIGEgc3VzcGVuZGVkIG5vZGUuIFRoZSBtaXNtYXRjaCBtYXkgYmUgZHVlIHRvIHRoZSBtaXNzaW5nXG4gICAgICAvLyBkYXRhLCBzbyBpdCdzIHByb2JhYmx5IGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBBZGQgdGhpcyBmaWJlciB0byB0aGUgZGlmZiB0cmVlLlxuXG5cbiAgICB2YXIgZGlmZk5vZGUgPSBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLCAwKTsgLy8gV2UgdXNlIG51bGwgYXMgYSBzaWduYWwgdGhhdCB0aGVyZSB3YXMgbm8gbm9kZSB0byBtYXRjaC5cblxuICAgIGRpZmZOb2RlLnNlcnZlclByb3BzID0gbnVsbDtcblxuICAgIGlmIChyZWplY3RlZENhbmRpZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRlc2NyaXB0aW9uID0gZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyhyZWplY3RlZENhbmRpZGF0ZSk7XG4gICAgICBkaWZmTm9kZS5zZXJ2ZXJUYWlsLnB1c2goZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlIeWRyYXRlSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgLy8gZmliZXIgaXMgYSBIb3N0Q29tcG9uZW50IEZpYmVyXG4gIHZhciBpbnN0YW5jZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIGZpYmVyLnR5cGUsIGZpYmVyLnBlbmRpbmdQcm9wcywgcm9vdE9yU2luZ2xldG9uQ29udGV4dCk7XG5cbiAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG5cbiAgICB7XG4gICAgICBpZiAoIWRpZFN1c3BlbmRPckVycm9yREVWKSB7XG4gICAgICAgIHZhciBkaWZmZXJlbmNlcyA9IGRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MoaW5zdGFuY2UsIGZpYmVyLnR5cGUsIGZpYmVyLnBlbmRpbmdQcm9wcywgaG9zdENvbnRleHQpO1xuXG4gICAgICAgIGlmIChkaWZmZXJlbmNlcyAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBkaWZmTm9kZSA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIDApO1xuICAgICAgICAgIGRpZmZOb2RlLnNlcnZlclByb3BzID0gZGlmZmVyZW5jZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChpbnN0YW5jZSk7XG4gICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9IGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB0cnlIeWRyYXRlVGV4dChmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gIC8vIGZpYmVyIGlzIGEgSG9zdFRleHQgRmliZXJcbiAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gIHZhciB0ZXh0SW5zdGFuY2UgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKG5leHRJbnN0YW5jZSwgdGV4dCwgcm9vdE9yU2luZ2xldG9uQ29udGV4dCk7XG5cbiAgaWYgKHRleHRJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIGZpYmVyLnN0YXRlTm9kZSA9IHRleHRJbnN0YW5jZTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyOyAvLyBUZXh0IEluc3RhbmNlcyBkb24ndCBoYXZlIGNoaWxkcmVuIHNvIHRoZXJlJ3Mgbm90aGluZyB0byBoeWRyYXRlLlxuXG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHRyeUh5ZHJhdGVTdXNwZW5zZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gIC8vIGZpYmVyIGlzIGEgU3VzcGVuc2VDb21wb25lbnQgRmliZXJcbiAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHJvb3RPclNpbmdsZXRvbkNvbnRleHQpO1xuXG4gIGlmIChzdXNwZW5zZUluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgdmFyIHN1c3BlbnNlU3RhdGUgPSB7XG4gICAgICBkZWh5ZHJhdGVkOiBzdXNwZW5zZUluc3RhbmNlLFxuICAgICAgdHJlZUNvbnRleHQ6IGdldFN1c3BlbmRlZFRyZWVDb250ZXh0KCksXG4gICAgICByZXRyeUxhbmU6IE9mZnNjcmVlbkxhbmVcbiAgICB9O1xuICAgIGZpYmVyLm1lbW9pemVkU3RhdGUgPSBzdXNwZW5zZVN0YXRlOyAvLyBTdG9yZSB0aGUgZGVoeWRyYXRlZCBmcmFnbWVudCBhcyBhIGNoaWxkIGZpYmVyLlxuICAgIC8vIFRoaXMgc2ltcGxpZmllcyB0aGUgY29kZSBmb3IgZ2V0SG9zdFNpYmxpbmcgYW5kIGRlbGV0aW5nIG5vZGVzLFxuICAgIC8vIHNpbmNlIGl0IGRvZXNuJ3QgaGF2ZSB0byBjb25zaWRlciBhbGwgU3VzcGVuc2UgYm91bmRhcmllcyBhbmRcbiAgICAvLyBjaGVjayBpZiB0aGV5J3JlIGRlaHlkcmF0ZWQgb25lcyBvciBub3QuXG5cbiAgICB2YXIgZGVoeWRyYXRlZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRGVoeWRyYXRlZEZyYWdtZW50KHN1c3BlbnNlSW5zdGFuY2UpO1xuICAgIGRlaHlkcmF0ZWRGcmFnbWVudC5yZXR1cm4gPSBmaWJlcjtcbiAgICBmaWJlci5jaGlsZCA9IGRlaHlkcmF0ZWRGcmFnbWVudDtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyOyAvLyBXaGlsZSBhIFN1c3BlbnNlIEluc3RhbmNlIGRvZXMgaGF2ZSBjaGlsZHJlbiwgd2Ugd29uJ3Qgc3RlcCBpbnRvXG4gICAgLy8gaXQgZHVyaW5nIHRoZSBmaXJzdCBwYXNzLiBJbnN0ZWFkLCB3ZSdsbCByZWVudGVyIGl0IGxhdGVyLlxuXG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiA9IG5ldyBFcnJvcignSHlkcmF0aW9uIE1pc21hdGNoIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yLCBhbmQgc2hvdWxkIG5vdCBsZWFrIGludG8gJyArIFwidXNlcnNwYWNlLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIGl0J3MgbGlrZWx5IGEgYnVnIGluIFJlYWN0LlwiKTtcblxuZnVuY3Rpb24gdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKSB7XG4gIHZhciBkaWZmID0gJyc7XG5cbiAge1xuICAgIC8vIENvbnN1bWUgdGhlIGRpZmYgcm9vdCBmb3IgdGhpcyBtaXNtYXRjaC5cbiAgICAvLyBBbnkgb3RoZXIgZXJyb3JzIHdpbGwgZ2V0IHRoZWlyIG93biBkaWZmcy5cbiAgICB2YXIgZGlmZlJvb3QgPSBoeWRyYXRpb25EaWZmUm9vdERFVjtcblxuICAgIGlmIChkaWZmUm9vdCAhPT0gbnVsbCkge1xuICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsO1xuICAgICAgZGlmZiA9IGRlc2NyaWJlRGlmZihkaWZmUm9vdCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiSHlkcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBzZXJ2ZXIgcmVuZGVyZWQgSFRNTCBkaWRuJ3QgbWF0Y2ggdGhlIGNsaWVudC4gQXMgYSByZXN1bHQgdGhpcyB0cmVlIHdpbGwgYmUgcmVnZW5lcmF0ZWQgb24gdGhlIGNsaWVudC4gVGhpcyBjYW4gaGFwcGVuIGlmIGEgU1NSLWVkIENsaWVudCBDb21wb25lbnQgdXNlZDpcXG5cIiArICdcXG4nICsgXCItIEEgc2VydmVyL2NsaWVudCBicmFuY2ggYGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylgLlxcblwiICsgXCItIFZhcmlhYmxlIGlucHV0IHN1Y2ggYXMgYERhdGUubm93KClgIG9yIGBNYXRoLnJhbmRvbSgpYCB3aGljaCBjaGFuZ2VzIGVhY2ggdGltZSBpdCdzIGNhbGxlZC5cXG5cIiArIFwiLSBEYXRlIGZvcm1hdHRpbmcgaW4gYSB1c2VyJ3MgbG9jYWxlIHdoaWNoIGRvZXNuJ3QgbWF0Y2ggdGhlIHNlcnZlci5cXG5cIiArICctIEV4dGVybmFsIGNoYW5naW5nIGRhdGEgd2l0aG91dCBzZW5kaW5nIGEgc25hcHNob3Qgb2YgaXQgYWxvbmcgd2l0aCB0aGUgSFRNTC5cXG4nICsgJy0gSW52YWxpZCBIVE1MIHRhZyBuZXN0aW5nLlxcbicgKyAnXFxuJyArICdJdCBjYW4gYWxzbyBoYXBwZW4gaWYgdGhlIGNsaWVudCBoYXMgYSBicm93c2VyIGV4dGVuc2lvbiBpbnN0YWxsZWQgd2hpY2ggbWVzc2VzIHdpdGggdGhlIEhUTUwgYmVmb3JlIFJlYWN0IGxvYWRlZC5cXG4nICsgJ1xcbicgKyAnaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9oeWRyYXRpb24tbWlzbWF0Y2gnICsgZGlmZik7XG4gIHF1ZXVlSHlkcmF0aW9uRXJyb3IoY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoZXJyb3IsIGZpYmVyKSk7XG4gIHRocm93IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uO1xufVxuXG5mdW5jdGlvbiBjbGFpbUh5ZHJhdGFibGVTaW5nbGV0b24oZmliZXIpIHtcbiAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFJvb3RDb250YWluZXIgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZSA9IHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZShmaWJlci50eXBlLCBmaWJlci5wZW5kaW5nUHJvcHMsIGN1cnJlbnRSb290Q29udGFpbmVyLCBjdXJyZW50SG9zdENvbnRleHQsIGZhbHNlKTtcblxuICAgIHtcbiAgICAgIGlmICghZGlkU3VzcGVuZE9yRXJyb3JERVYpIHtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2VzID0gZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncyhpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIucGVuZGluZ1Byb3BzLCBjdXJyZW50SG9zdENvbnRleHQpO1xuXG4gICAgICAgIGlmIChkaWZmZXJlbmNlcyAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBkaWZmTm9kZSA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIDApO1xuICAgICAgICAgIGRpZmZOb2RlLnNlcnZlclByb3BzID0gZGlmZmVyZW5jZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSB0cnVlO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChpbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgIHJldHVybjtcbiAgfSAvLyBWYWxpZGF0ZSB0aGF0IHRoaXMgaXMgb2sgdG8gcmVuZGVyIGhlcmUgYmVmb3JlIGFueSBtaXNtYXRjaGVzLlxuXG5cbiAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gIHZhciBzaG91bGRLZWVwV2FybmluZyA9IHZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLnR5cGUsIGZpYmVyLnBlbmRpbmdQcm9wcywgY3VycmVudEhvc3RDb250ZXh0KTtcbiAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgaWYgKCFuZXh0SW5zdGFuY2UgfHwgIXRyeUh5ZHJhdGVJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgaWYgKHNob3VsZEtlZXBXYXJuaW5nKSB7XG4gICAgICB3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICB9XG5cbiAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZVRleHRJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gIHZhciBzaG91bGRLZWVwV2FybmluZyA9IHRydWU7IC8vIFZhbGlkYXRlIHRoYXQgdGhpcyBpcyBvayB0byByZW5kZXIgaGVyZSBiZWZvcmUgYW55IG1pc21hdGNoZXMuXG5cbiAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gIHNob3VsZEtlZXBXYXJuaW5nID0gdmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlKHRleHQsIGN1cnJlbnRIb3N0Q29udGV4dCk7XG4gIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlVGV4dChmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgIGlmIChzaG91bGRLZWVwV2FybmluZykge1xuICAgICAgd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZVN1c3BlbnNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVGb3JtTWFya2VySW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlKSB7XG4gICAgdmFyIG1hcmtlckluc3RhbmNlID0gY2FuSHlkcmF0ZUZvcm1TdGF0ZU1hcmtlcihuZXh0SHlkcmF0YWJsZUluc3RhbmNlLCByb290T3JTaW5nbGV0b25Db250ZXh0KTtcblxuICAgIGlmIChtYXJrZXJJbnN0YW5jZSkge1xuICAgICAgLy8gRm91bmQgdGhlIG1hcmtlciBpbnN0YW5jZS5cbiAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobWFya2VySW5zdGFuY2UpOyAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGlzIG1hcmtlciBpbnN0YW5jZSBzaG91bGQgdXNlIHRoZSBzdGF0ZSBwYXNzZWRcbiAgICAgIC8vIHRvIGh5ZHJhdGVSb290LlxuICAgICAgLy8gVE9ETzogQXMgYW4gb3B0aW1pemF0aW9uLCBGaXp6IHNob3VsZCBvbmx5IGVtaXQgdGhlc2UgbWFya2VycyBpZiBmb3JtXG4gICAgICAvLyBzdGF0ZSBpcyBwYXNzZWQgYXQgdGhlIHJvb3QuXG5cbiAgICAgIHJldHVybiBpc0Zvcm1TdGF0ZU1hcmtlck1hdGNoaW5nKG1hcmtlckluc3RhbmNlKTtcbiAgICB9XG4gIH0gLy8gU2hvdWxkIGhhdmUgZm91bmQgYSBtYXJrZXIgaW5zdGFuY2UuIFRocm93IGFuIGVycm9yIHRvIHRyaWdnZXIgY2xpZW50XG4gIC8vIHJlbmRlcmluZy4gV2UgZG9uJ3QgYm90aGVyIHRvIGNoZWNrIGlmIHdlJ3JlIGluIGEgY29uY3VycmVudCByb290IGJlY2F1c2VcbiAgLy8gdXNlQWN0aW9uU3RhdGUgaXMgYSBuZXcgQVBJLCBzbyBiYWNrd2FyZHMgY29tcGF0IGlzIG5vdCBhbiBpc3N1ZS5cblxuXG4gIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgaG9zdENvbnRleHQpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgZGlkSHlkcmF0ZSA9IGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcywgaG9zdENvbnRleHQsIGZpYmVyKTtcblxuICBpZiAoIWRpZEh5ZHJhdGUgJiYgZmF2b3JTYWZldHlPdmVySHlkcmF0aW9uUGVyZikge1xuICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciB0ZXh0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciB0ZXh0Q29udGVudCA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gIHZhciBzaG91bGRXYXJuSWZNaXNtYXRjaERldiA9ICFkaWRTdXNwZW5kT3JFcnJvckRFVjtcbiAgdmFyIHBhcmVudFByb3BzID0gbnVsbDsgLy8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbiAgLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxuXG4gIHZhciByZXR1cm5GaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyO1xuXG4gIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHNob3VsZFdhcm5JZk1pc21hdGNoRGV2KSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmZXJlbmNlID0gZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIHBhcmVudFByb3BzKTtcblxuICAgICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBkaWZmTm9kZSA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIDApO1xuICAgICAgICAgICAgICAgIGRpZmZOb2RlLnNlcnZlclByb3BzID0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRXYXJuSWZNaXNtYXRjaERldikge1xuICAgICAgICAgICAgICB2YXIgX2RpZmZlcmVuY2UgPSBkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3ModGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgcGFyZW50UHJvcHMpO1xuXG4gICAgICAgICAgICAgIGlmIChfZGlmZmVyZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBfZGlmZk5vZGUgPSBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLCAwKTtcblxuICAgICAgICAgICAgICAgIF9kaWZmTm9kZS5zZXJ2ZXJQcm9wcyA9IF9kaWZmZXJlbmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IC8vIFRPRE86IFdoYXQgaWYgaXQncyBhIFN1c3BlbnNlSW5zdGFuY2U/XG5cbiAgfVxuXG4gIHZhciBkaWRIeWRyYXRlID0gaHlkcmF0ZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50LCBmaWJlciwgcGFyZW50UHJvcHMpO1xuXG4gIGlmICghZGlkSHlkcmF0ZSAmJiBmYXZvclNhZmV0eU92ZXJIeWRyYXRpb25QZXJmKSB7XG4gICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciBzdXNwZW5zZUluc3RhbmNlID0gc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCA/IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCA6IG51bGw7XG5cbiAgaWYgKCFzdXNwZW5zZUluc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIGh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciBzdXNwZW5zZUluc3RhbmNlID0gc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCA/IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCA6IG51bGw7XG5cbiAgaWYgKCFzdXNwZW5zZUluc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgIHN3aXRjaCAoaHlkcmF0aW9uUGFyZW50RmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlci5yZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSB7XG4gICAgLy8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuICAgIC8vIHRyZWUuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgIC8vIElmIHdlJ3JlIG5vdCBjdXJyZW50bHkgaHlkcmF0aW5nIGJ1dCB3ZSdyZSBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LCB0aGVuXG4gICAgLy8gd2Ugd2VyZSBhbiBpbnNlcnRpb24gYW5kIG5vdyBuZWVkIHRvIHBvcCB1cCByZWVudGVyIGh5ZHJhdGlvbiBvZiBvdXJcbiAgICAvLyBzaWJsaW5ncy5cbiAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHNob3VsZENsZWFyID0gZmFsc2U7XG5cbiAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgIC8vIFdpdGggZmxvYXQgd2UgbmV2ZXIgY2xlYXIgdGhlIFJvb3QsIG9yIFNpbmdsZXRvbiBpbnN0YW5jZXMuIFdlIGFsc28gZG8gbm90IGNsZWFyIEluc3RhbmNlc1xuICAgIC8vIHRoYXQgaGF2ZSBzaW5nbGV0b24gdGV4dCBjb250ZW50XG4gICAgaWYgKGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QgJiYgZmliZXIudGFnICE9PSBIb3N0U2luZ2xldG9uICYmICEoZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50ICYmICghc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMoZmliZXIudHlwZSkgfHwgc2hvdWxkU2V0VGV4dENvbnRlbnQoZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpKSkge1xuICAgICAgc2hvdWxkQ2xlYXIgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGFueSByZW1haW5pbmcgaHlkcmF0YWJsZSBub2Rlcywgd2UgbmVlZCB0byBkZWxldGUgdGhlbSBub3cuXG4gICAgLy8gV2Ugb25seSBkbyB0aGlzIGRlZXBlciB0aGFuIGhlYWQgYW5kIGJvZHkgc2luY2UgdGhleSB0ZW5kIHRvIGhhdmUgcmFuZG9tXG4gICAgLy8gb3RoZXIgbm9kZXMgaW4gdGhlbS4gV2UgYWxzbyBpZ25vcmUgY29tcG9uZW50cyB3aXRoIHB1cmUgdGV4dCBjb250ZW50IGluXG4gICAgLy8gc2lkZSBvZiB0aGVtLiBXZSBhbHNvIGRvbid0IGRlbGV0ZSBhbnl0aGluZyBpbnNpZGUgdGhlIHJvb3QgY29udGFpbmVyLlxuICAgIGlmIChmaWJlci50YWcgIT09IEhvc3RSb290ICYmIChmaWJlci50YWcgIT09IEhvc3RDb21wb25lbnQgfHwgc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMoZmliZXIudHlwZSkgJiYgIXNob3VsZFNldFRleHRDb250ZW50KGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSkge1xuICAgICAgc2hvdWxkQ2xlYXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzaG91bGRDbGVhcikge1xuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gICAgaWYgKG5leHRJbnN0YW5jZSkge1xuICAgICAgd2FybklmVW5oeWRyYXRlZFRhaWxOb2RlcyhmaWJlcik7XG4gICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpO1xuICAgIH1cbiAgfVxuXG4gIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpO1xuICB9IGVsc2Uge1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZVbmh5ZHJhdGVkVGFpbE5vZGVzKGZpYmVyKSB7XG4gIHtcbiAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICAgIHdoaWxlIChuZXh0SW5zdGFuY2UpIHtcbiAgICAgIHZhciBkaWZmTm9kZSA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIDApO1xuICAgICAgdmFyIGRlc2NyaXB0aW9uID0gZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyhuZXh0SW5zdGFuY2UpO1xuICAgICAgZGlmZk5vZGUuc2VydmVyVGFpbC5wdXNoKGRlc2NyaXB0aW9uKTtcblxuICAgICAgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICdTdXNwZW5zZScpIHtcbiAgICAgICAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBuZXh0SW5zdGFuY2U7XG4gICAgICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRIeWRyYXRpb25TdGF0ZSgpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gIGRpZFN1c3BlbmRPckVycm9yREVWID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCkge1xuICBpZiAoaHlkcmF0aW9uRXJyb3JzICE9PSBudWxsKSB7XG4gICAgLy8gU3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCBhIGZvcmNlZCBjbGllbnQgcmVuZGVyLiBUaGUgZXJyb3JzIHRoYXQgb2NjdXJyZWRcbiAgICAvLyBkdXJpbmcgdGhlIGh5ZHJhdGlvbiBhdHRlbXB0IGFyZSBub3cgcmVjb3ZlcmVkLiBXZSB3aWxsIGxvZyB0aGVtIGluXG4gICAgLy8gY29tbWl0IHBoYXNlLCBvbmNlIHRoZSBlbnRpcmUgdHJlZSBoYXMgZmluaXNoZWQuXG4gICAgcXVldWVSZWNvdmVyYWJsZUVycm9ycyhoeWRyYXRpb25FcnJvcnMpO1xuICAgIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SXNIeWRyYXRpbmcoKSB7XG4gIHJldHVybiBpc0h5ZHJhdGluZztcbn1cblxuZnVuY3Rpb24gcXVldWVIeWRyYXRpb25FcnJvcihlcnJvcikge1xuICBpZiAoaHlkcmF0aW9uRXJyb3JzID09PSBudWxsKSB7XG4gICAgaHlkcmF0aW9uRXJyb3JzID0gW2Vycm9yXTtcbiAgfSBlbHNlIHtcbiAgICBoeWRyYXRpb25FcnJvcnMucHVzaChlcnJvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MoKSB7XG4gIHtcbiAgICAvLyBJZiB3ZSBoYXZlbid0IHlldCB0aHJvd24gYW55IGh5ZHJhdGlvbiBlcnJvcnMgYnkgdGhlIHRpbWUgd2UgcmVhY2ggdGhlIGVuZCB3ZSd2ZSBzdWNjZXNzZnVsbHlcbiAgICAvLyBoeWRyYXRlZCwgaG93ZXZlciwgd2UgbWlnaHQgc3RpbGwgaGF2ZSBERVYtb25seSBtaXNtYXRjaGVzIHRoYXQgd2UgbG9nIG5vdy5cbiAgICB2YXIgZGlmZlJvb3QgPSBoeWRyYXRpb25EaWZmUm9vdERFVjtcblxuICAgIGlmIChkaWZmUm9vdCAhPT0gbnVsbCkge1xuICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsO1xuICAgICAgdmFyIGRpZmYgPSBkZXNjcmliZURpZmYoZGlmZlJvb3QpO1xuXG4gICAgICBlcnJvcihcIkEgdHJlZSBoeWRyYXRlZCBidXQgc29tZSBhdHRyaWJ1dGVzIG9mIHRoZSBzZXJ2ZXIgcmVuZGVyZWQgSFRNTCBkaWRuJ3QgbWF0Y2ggdGhlIGNsaWVudCBwcm9wZXJ0aWVzLiBUaGlzIHdvbid0IGJlIHBhdGNoZWQgdXAuIFwiICsgJ1RoaXMgY2FuIGhhcHBlbiBpZiBhIFNTUi1lZCBDbGllbnQgQ29tcG9uZW50IHVzZWQ6XFxuJyArICdcXG4nICsgXCItIEEgc2VydmVyL2NsaWVudCBicmFuY2ggYGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylgLlxcblwiICsgXCItIFZhcmlhYmxlIGlucHV0IHN1Y2ggYXMgYERhdGUubm93KClgIG9yIGBNYXRoLnJhbmRvbSgpYCB3aGljaCBjaGFuZ2VzIGVhY2ggdGltZSBpdCdzIGNhbGxlZC5cXG5cIiArIFwiLSBEYXRlIGZvcm1hdHRpbmcgaW4gYSB1c2VyJ3MgbG9jYWxlIHdoaWNoIGRvZXNuJ3QgbWF0Y2ggdGhlIHNlcnZlci5cXG5cIiArICctIEV4dGVybmFsIGNoYW5naW5nIGRhdGEgd2l0aG91dCBzZW5kaW5nIGEgc25hcHNob3Qgb2YgaXQgYWxvbmcgd2l0aCB0aGUgSFRNTC5cXG4nICsgJy0gSW52YWxpZCBIVE1MIHRhZyBuZXN0aW5nLlxcbicgKyAnXFxuJyArICdJdCBjYW4gYWxzbyBoYXBwZW4gaWYgdGhlIGNsaWVudCBoYXMgYSBicm93c2VyIGV4dGVuc2lvbiBpbnN0YWxsZWQgd2hpY2ggbWVzc2VzIHdpdGggdGhlIEhUTUwgYmVmb3JlIFJlYWN0IGxvYWRlZC5cXG4nICsgJ1xcbicgKyAnJXMlcycsICdodHRwczovL3JlYWN0LmRldi9saW5rL2h5ZHJhdGlvbi1taXNtYXRjaCcsIGRpZmYpO1xuICAgIH1cbiAgfVxufVxuXG4vLyB3ZSB3YWl0IHVudGlsIHRoZSBjdXJyZW50IHJlbmRlciBpcyBvdmVyIChlaXRoZXIgZmluaXNoZWQgb3IgaW50ZXJydXB0ZWQpXG4vLyBiZWZvcmUgYWRkaW5nIGl0IHRvIHRoZSBmaWJlci9ob29rIHF1ZXVlLiBQdXNoIHRvIHRoaXMgYXJyYXkgc28gd2UgY2FuXG4vLyBhY2Nlc3MgdGhlIHF1ZXVlLCBmaWJlciwgdXBkYXRlLCBldCBhbCBsYXRlci5cblxudmFyIGNvbmN1cnJlbnRRdWV1ZXMgPSBbXTtcbnZhciBjb25jdXJyZW50UXVldWVzSW5kZXggPSAwO1xudmFyIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyA9IE5vTGFuZXM7XG5mdW5jdGlvbiBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCkge1xuICB2YXIgZW5kSW5kZXggPSBjb25jdXJyZW50UXVldWVzSW5kZXg7XG4gIGNvbmN1cnJlbnRRdWV1ZXNJbmRleCA9IDA7XG4gIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGVuZEluZGV4KSB7XG4gICAgdmFyIGZpYmVyID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICBjb25jdXJyZW50UXVldWVzW2krK10gPSBudWxsO1xuICAgIHZhciBxdWV1ZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICBjb25jdXJyZW50UXVldWVzW2krK10gPSBudWxsO1xuICAgIHZhciBsYW5lID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICBjb25jdXJyZW50UXVldWVzW2krK10gPSBudWxsO1xuXG4gICAgaWYgKHF1ZXVlICE9PSBudWxsICYmIHVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuXG4gICAgICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQ7XG4gICAgICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgICAgIH1cblxuICAgICAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAobGFuZSAhPT0gTm9MYW5lKSB7XG4gICAgICBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgdXBkYXRlLCBsYW5lKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcygpIHtcbiAgcmV0dXJuIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcztcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG4gIC8vIERvbid0IHVwZGF0ZSB0aGUgYGNoaWxkTGFuZXNgIG9uIHRoZSByZXR1cm4gcGF0aCB5ZXQuIElmIHdlIGFscmVhZHkgaW5cbiAgLy8gdGhlIG1pZGRsZSBvZiByZW5kZXJpbmcsIHdhaXQgdW50aWwgYWZ0ZXIgaXQgaGFzIGNvbXBsZXRlZC5cbiAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBmaWJlcjtcbiAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBxdWV1ZTtcbiAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSB1cGRhdGU7XG4gIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gbGFuZTtcbiAgY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gbWVyZ2VMYW5lcyhjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMsIGxhbmUpOyAvLyBUaGUgZmliZXIncyBgbGFuZWAgZmllbGQgaXMgdXNlZCBpbiBzb21lIHBsYWNlcyB0byBjaGVjayBpZiBhbnkgd29yayBpc1xuICAvLyBzY2hlZHVsZWQsIHRvIHBlcmZvcm0gYW4gZWFnZXIgYmFpbG91dCwgc28gd2UgbmVlZCB0byB1cGRhdGUgaXQgaW1tZWRpYXRlbHkuXG4gIC8vIFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBtb3ZlIHRoaXMgdG8gdGhlIFwic2hhcmVkXCIgcXVldWUgaW5zdGVhZC5cblxuICBmaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoZmliZXIubGFuZXMsIGxhbmUpO1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICBhbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcywgbGFuZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG4gIHZhciBjb25jdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgdmFyIGNvbmN1cnJlbnRVcGRhdGUgPSB1cGRhdGU7XG4gIGVucXVldWVVcGRhdGUkMShmaWJlciwgY29uY3VycmVudFF1ZXVlLCBjb25jdXJyZW50VXBkYXRlLCBsYW5lKTtcbiAgcmV0dXJuIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpO1xufVxuZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlQW5kRWFnZXJseUJhaWxvdXQoZmliZXIsIHF1ZXVlLCB1cGRhdGUpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHF1ZXVlIGFuIHVwZGF0ZSB0aGF0IGRvZXNuJ3QgbmVlZCBhIHJlcmVuZGVyLiBUaGVcbiAgLy8gb25seSByZWFzb24gd2UgcXVldWUgaXQgaXMgaW4gY2FzZSB0aGVyZSdzIGEgc3Vic2VxdWVudCBoaWdoZXIgcHJpb3JpdHlcbiAgLy8gdXBkYXRlIHRoYXQgY2F1c2VzIGl0IHRvIGJlIHJlYmFzZWQuXG4gIHZhciBsYW5lID0gTm9MYW5lO1xuICB2YXIgY29uY3VycmVudFF1ZXVlID0gcXVldWU7XG4gIHZhciBjb25jdXJyZW50VXBkYXRlID0gdXBkYXRlO1xuICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIGNvbmN1cnJlbnRRdWV1ZSwgY29uY3VycmVudFVwZGF0ZSwgbGFuZSk7IC8vIFVzdWFsbHkgd2UgY2FuIHJlbHkgb24gdGhlIHVwY29taW5nIHJlbmRlciBwaGFzZSB0byBwcm9jZXNzIHRoZSBjb25jdXJyZW50XG4gIC8vIHF1ZXVlLiBIb3dldmVyLCBzaW5jZSB0aGlzIGlzIGEgYmFpbCBvdXQsIHdlJ3JlIG5vdCBzY2hlZHVsaW5nIGFueSB3b3JrXG4gIC8vIGhlcmUuIFNvIHRoZSB1cGRhdGUgd2UganVzdCBxdWV1ZWQgd2lsbCBsZWFrIHVudGlsIHNvbWV0aGluZyBlbHNlIGhhcHBlbnNcbiAgLy8gdG8gc2NoZWR1bGUgd29yayAoaWYgZXZlcikuXG4gIC8vXG4gIC8vIENoZWNrIGlmIHdlJ3JlIGN1cnJlbnRseSBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlcmluZyBhIHRyZWUsIGFuZCBpZiBub3QsXG4gIC8vIHByb2Nlc3MgdGhlIHF1ZXVlIGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgYSBsZWFrLlxuXG4gIHZhciBpc0NvbmN1cnJlbnRseVJlbmRlcmluZyA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpICE9PSBudWxsO1xuXG4gIGlmICghaXNDb25jdXJyZW50bHlSZW5kZXJpbmcpIHtcbiAgICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50Q2xhc3NVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgdmFyIGNvbmN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICB2YXIgY29uY3VycmVudFVwZGF0ZSA9IHVwZGF0ZTtcbiAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBjb25jdXJyZW50UXVldWUsIGNvbmN1cnJlbnRVcGRhdGUsIGxhbmUpO1xuICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIGxhbmUpIHtcbiAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBudWxsLCBudWxsLCBsYW5lKTtcbiAgcmV0dXJuIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpO1xufSAvLyBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gb3V0c2lkZSB0aGlzIG1vZHVsZSBzaG91bGQgb25seSBiZSBkb25lIGZvciBiYWNrd2FyZHNcbi8vIGNvbXBhdGliaWxpdHkgYW5kIHNob3VsZCBhbHdheXMgYmUgYWNjb21wYW5pZWQgYnkgYSB3YXJuaW5nLlxuXG5mdW5jdGlvbiB1bnNhZmVfbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qoc291cmNlRmliZXIsIGxhbmUpIHtcbiAgLy8gTk9URTogRm9yIEh5cnVtJ3MgTGF3IHJlYXNvbnMsIGlmIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wIGlzIGRldGVjdGVkLCBpdFxuICAvLyBzaG91bGQgdGhyb3cgYmVmb3JlIGBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdGAgaXMgY2FsbGVkLiBCdXQgdGhpcyBpc1xuICAvLyB1bmRlZmluZWQgYmVoYXZpb3IgYW5kIHdlIGNhbiBjaGFuZ2UgaXQgaWYgd2UgbmVlZCB0bzsgaXQganVzdCBzbyBoYXBwZW5zXG4gIC8vIHRoYXQsIGF0IHRoZSB0aW1lIG9mIHRoaXMgd3JpdGluZywgdGhlcmUncyBhbiBpbnRlcm5hbCBwcm9kdWN0IHRlc3QgdGhhdFxuICAvLyBoYXBwZW5zIHRvIHJlbHkgb24gdGhpcy5cbiAgdmFyIHJvb3QgPSBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKHNvdXJjZUZpYmVyKTtcbiAgbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qoc291cmNlRmliZXIsIG51bGwsIGxhbmUpO1xuICByZXR1cm4gcm9vdDtcbn1cblxuZnVuY3Rpb24gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qoc291cmNlRmliZXIsIHVwZGF0ZSwgbGFuZSkge1xuICAvLyBVcGRhdGUgdGhlIHNvdXJjZSBmaWJlcidzIGxhbmVzXG4gIHNvdXJjZUZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhzb3VyY2VGaWJlci5sYW5lcywgbGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCBsYW5lKTtcbiAgfSAvLyBXYWxrIHRoZSBwYXJlbnQgcGF0aCB0byB0aGUgcm9vdCBhbmQgdXBkYXRlIHRoZSBjaGlsZCBsYW5lcy5cblxuXG4gIHZhciBpc0hpZGRlbiA9IGZhbHNlO1xuICB2YXIgcGFyZW50ID0gc291cmNlRmliZXIucmV0dXJuO1xuICB2YXIgbm9kZSA9IHNvdXJjZUZpYmVyO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBwYXJlbnQuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMocGFyZW50LmNoaWxkTGFuZXMsIGxhbmUpO1xuICAgIGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGU7XG5cbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIGxhbmUpO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgb2Zmc2NyZWVuIGJvdW5kYXJ5IGlzIGN1cnJlbnRseSBoaWRkZW4uXG4gICAgICAvL1xuICAgICAgLy8gVGhlIGluc3RhbmNlIG1heSBiZSBudWxsIGlmIHRoZSBPZmZzY3JlZW4gcGFyZW50IHdhcyB1bm1vdW50ZWQuIFVzdWFsbHlcbiAgICAgIC8vIHRoZSBwYXJlbnQgd291bGRuJ3QgYmUgcmVhY2hhYmxlIGluIHRoYXQgY2FzZSBiZWNhdXNlIHdlIGRpc2Nvbm5lY3RcbiAgICAgIC8vIGZpYmVycyBmcm9tIHRoZSB0cmVlIHdoZW4gdGhleSBhcmUgZGVsZXRlZC4gSG93ZXZlciwgdGhlcmUncyBhIHdlaXJkXG4gICAgICAvLyBlZGdlIGNhc2Ugd2hlcmUgc2V0U3RhdGUgaXMgY2FsbGVkIG9uIGEgZmliZXIgdGhhdCB3YXMgaW50ZXJydXB0ZWRcbiAgICAgIC8vIGJlZm9yZSBpdCBldmVyIG1vdW50ZWQuIEJlY2F1c2UgaXQgbmV2ZXIgbW91bnRzLCBpdCBhbHNvIG5ldmVyIGdldHNcbiAgICAgIC8vIGRlbGV0ZWQuIEJlY2F1c2UgaXQgbmV2ZXIgZ2V0cyBkZWxldGVkLCBpdHMgcmV0dXJuIHBvaW50ZXIgbmV2ZXIgZ2V0c1xuICAgICAgLy8gZGlzY29ubmVjdGVkLiBXaGljaCBtZWFucyBpdCBtYXkgYmUgYXR0YWNoZWQgdG8gYSBkZWxldGVkIE9mZnNjcmVlblxuICAgICAgLy8gcGFyZW50IG5vZGUuIChUaGlzIGRpc2NvdmVyeSBzdWdnZXN0cyBpdCBtYXkgYmUgYmV0dGVyIGZvciBtZW1vcnkgdXNhZ2VcbiAgICAgIC8vIGlmIHdlIGRvbid0IGF0dGFjaCB0aGUgYHJldHVybmAgcG9pbnRlciB1bnRpbCB0aGUgY29tbWl0IHBoYXNlLCB0aG91Z2hcbiAgICAgIC8vIGluIG9yZGVyIHRvIGRvIHRoYXQgd2UnZCBuZWVkIHNvbWUgb3RoZXIgd2F5IHRvIHRyYWNrIHRoZSByZXR1cm5cbiAgICAgIC8vIHBvaW50ZXIgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlciwgbGlrZSBvbiB0aGUgc3RhY2suKVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgY2FzZSBpcyBhbHdheXMgYWNjb21wYW5pZWQgYnkgYSB3YXJuaW5nLCBidXQgd2Ugc3RpbGwgbmVlZCB0b1xuICAgICAgLy8gYWNjb3VudCBmb3IgaXQuIChUaGVyZSBtYXkgYmUgb3RoZXIgY2FzZXMgdGhhdCB3ZSBoYXZlbid0IGRpc2NvdmVyZWQsXG4gICAgICAvLyB0b28uKVxuICAgICAgdmFyIG9mZnNjcmVlbkluc3RhbmNlID0gcGFyZW50LnN0YXRlTm9kZTtcblxuICAgICAgaWYgKG9mZnNjcmVlbkluc3RhbmNlICE9PSBudWxsICYmICEob2Zmc2NyZWVuSW5zdGFuY2UuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5WaXNpYmxlKSkge1xuICAgICAgICBpc0hpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZSA9IHBhcmVudDtcbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG5cbiAgaWYgKGlzSGlkZGVuICYmIHVwZGF0ZSAhPT0gbnVsbCAmJiBub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICB2YXIgcm9vdCA9IG5vZGUuc3RhdGVOb2RlO1xuICAgIG1hcmtIaWRkZW5VcGRhdGUocm9vdCwgdXBkYXRlLCBsYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKHNvdXJjZUZpYmVyKSB7XG4gIC8vIFRPRE86IFdlIHdpbGwgZGV0ZWN0IGFuZCBpbmZpbml0ZSB1cGRhdGUgbG9vcCBhbmQgdGhyb3cgZXZlbiBpZiB0aGlzIGZpYmVyXG4gIC8vIGhhcyBhbHJlYWR5IHVubW91bnRlZC4gVGhpcyBpc24ndCByZWFsbHkgbmVjZXNzYXJ5IGJ1dCBpdCBoYXBwZW5zIHRvIGJlIHRoZVxuICAvLyBjdXJyZW50IGJlaGF2aW9yIHdlJ3ZlIHVzZWQgZm9yIHNldmVyYWwgcmVsZWFzZSBjeWNsZXMuIENvbnNpZGVyIG5vdFxuICAvLyBwZXJmb3JtaW5nIHRoaXMgY2hlY2sgaWYgdGhlIHVwZGF0ZWQgZmliZXIgYWxyZWFkeSB1bm1vdW50ZWQsIHNpbmNlIGl0J3NcbiAgLy8gbm90IHBvc3NpYmxlIGZvciB0aGF0IHRvIGNhdXNlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wLlxuICB0aHJvd0lmSW5maW5pdGVVcGRhdGVMb29wRGV0ZWN0ZWQoKTsgLy8gV2hlbiBhIHNldFN0YXRlIGhhcHBlbnMsIHdlIG11c3QgZW5zdXJlIHRoZSByb290IGlzIHNjaGVkdWxlZC4gQmVjYXVzZVxuICAvLyB1cGRhdGUgcXVldWVzIGRvIG5vdCBoYXZlIGEgYmFja3BvaW50ZXIgdG8gdGhlIHJvb3QsIHRoZSBvbmx5IHdheSB0byBkb1xuICAvLyB0aGlzIGN1cnJlbnRseSBpcyB0byB3YWxrIHVwIHRoZSByZXR1cm4gcGF0aC4gVGhpcyB1c2VkIHRvIG5vdCBiZSBhIGJpZ1xuICAvLyBkZWFsIGJlY2F1c2Ugd2Ugd291bGQgaGF2ZSB0byB3YWxrIHVwIHRoZSByZXR1cm4gcGF0aCB0byBzZXRcbiAgLy8gdGhlIGBjaGlsZExhbmVzYCwgYW55d2F5LCBidXQgbm93IHRob3NlIHR3byB0cmF2ZXJzYWxzIGhhcHBlbiBhdFxuICAvLyBkaWZmZXJlbnQgdGltZXMuXG4gIC8vIFRPRE86IENvbnNpZGVyIGFkZGluZyBhIGByb290YCBiYWNrcG9pbnRlciBvbiB0aGUgdXBkYXRlIHF1ZXVlLlxuXG4gIGRldGVjdFVwZGF0ZU9uVW5tb3VudGVkRmliZXIoc291cmNlRmliZXIsIHNvdXJjZUZpYmVyKTtcbiAgdmFyIG5vZGUgPSBzb3VyY2VGaWJlcjtcbiAgdmFyIHBhcmVudCA9IG5vZGUucmV0dXJuO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBkZXRlY3RVcGRhdGVPblVubW91bnRlZEZpYmVyKHNvdXJjZUZpYmVyLCBub2RlKTtcbiAgICBub2RlID0gcGFyZW50O1xuICAgIHBhcmVudCA9IG5vZGUucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG5vZGUudGFnID09PSBIb3N0Um9vdCA/IG5vZGUuc3RhdGVOb2RlIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZGV0ZWN0VXBkYXRlT25Vbm1vdW50ZWRGaWJlcihzb3VyY2VGaWJlciwgcGFyZW50KSB7XG4gIHtcbiAgICB2YXIgYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZTtcblxuICAgIGlmIChhbHRlcm5hdGUgPT09IG51bGwgJiYgKHBhcmVudC5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gdGhlcmUncyBvbmx5IGEgc2luZ2xlIHJvb3QsIGJ1dCB3ZSBkbyBzdXBwb3J0IG11bHRpIHJvb3QgYXBwcywgaGVuY2UgdGhpc1xuLy8gZXh0cmEgY29tcGxleGl0eS4gQnV0IHRoaXMgbW9kdWxlIGlzIG9wdGltaXplZCBmb3IgdGhlIHNpbmdsZSByb290IGNhc2UuXG5cbnZhciBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xudmFyIGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbDsgLy8gVXNlZCB0byBwcmV2ZW50IHJlZHVuZGFudCBtaXJjb3Rhc2tzIGZyb20gYmVpbmcgc2NoZWR1bGVkLlxuXG52YXIgZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPSBmYWxzZTsgLy8gYGFjdGAgXCJtaWNyb3Rhc2tzXCIgYXJlIHNjaGVkdWxlZCBvbiB0aGUgYGFjdGAgcXVldWUgaW5zdGVhZCBvZiBhbiBhY3R1YWxcbi8vIG1pY3JvdGFzaywgc28gd2UgaGF2ZSB0byBkZWR1cGUgdGhvc2Ugc2VwYXJhdGVseS4gVGhpcyB3b3VsZG4ndCBiZSBhbiBpc3N1ZVxuLy8gaWYgd2UgcmVxdWlyZWQgYWxsIGBhY3RgIGNhbGxzIHRvIGJlIGF3YWl0ZWQsIHdoaWNoIHdlIG1pZ2h0IGluIHRoZSBmdXR1cmUuXG5cbnZhciBkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QgPSBmYWxzZTsgLy8gVXNlZCB0byBxdWlja2x5IGJhaWwgb3V0IG9mIGZsdXNoU3luYyBpZiB0aGVyZSdzIG5vIHN5bmMgd29yayB0byBkby5cblxudmFyIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9IGZhbHNlO1xudmFyIGlzRmx1c2hpbmdXb3JrID0gZmFsc2U7XG52YXIgY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSBOb0xhbmU7XG5mdW5jdGlvbiBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuZXZlciBhIHJvb3QgcmVjZWl2ZXMgYW4gdXBkYXRlLiBJdCBkb2VzIHR3b1xuICAvLyB0aGluZ3MgMSkgaXQgZW5zdXJlcyB0aGUgcm9vdCBpcyBpbiB0aGUgcm9vdCBzY2hlZHVsZSwgYW5kIDIpIGl0IGVuc3VyZXNcbiAgLy8gdGhlcmUncyBhIHBlbmRpbmcgbWljcm90YXNrIHRvIHByb2Nlc3MgdGhlIHJvb3Qgc2NoZWR1bGUuXG4gIC8vXG4gIC8vIE1vc3Qgb2YgdGhlIGFjdHVhbCBzY2hlZHVsaW5nIGxvZ2ljIGRvZXMgbm90IGhhcHBlbiB1bnRpbFxuICAvLyBgc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFza2AgcnVucy5cbiAgLy8gQWRkIHRoZSByb290IHRvIHRoZSBzY2hlZHVsZVxuICBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QgfHwgcm9vdC5uZXh0ICE9PSBudWxsKSA7IGVsc2Uge1xuICAgIGlmIChsYXN0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0ID0gcm9vdDtcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICB9XG4gIH0gLy8gQW55IHRpbWUgYSByb290IHJlY2VpdmVkIGFuIHVwZGF0ZSwgd2Ugc2V0IHRoaXMgdG8gdHJ1ZSB1bnRpbCB0aGUgbmV4dCB0aW1lXG4gIC8vIHdlIHByb2Nlc3MgdGhlIHNjaGVkdWxlLiBJZiBpdCdzIGZhbHNlLCB0aGVuIHdlIGNhbiBxdWlja2x5IGV4aXQgZmx1c2hTeW5jXG4gIC8vIHdpdGhvdXQgY29uc3VsdGluZyB0aGUgc2NoZWR1bGUuXG5cblxuICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSB0cnVlOyAvLyBBdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGV2ZW50LCBnbyB0aHJvdWdoIGVhY2ggb2YgdGhlIHJvb3RzIGFuZCBlbnN1cmVcbiAgLy8gdGhlcmUncyBhIHRhc2sgc2NoZWR1bGVkIGZvciBlYWNoIG9uZSBhdCB0aGUgY29ycmVjdCBwcmlvcml0eS5cblxuICBpZiAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBXZSdyZSBpbnNpZGUgYW4gYGFjdGAgc2NvcGUuXG4gICAgaWYgKCFkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QpIHtcbiAgICAgIGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCA9IHRydWU7XG4gICAgICBzY2hlZHVsZUltbWVkaWF0ZVRhc2socHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFkaWRTY2hlZHVsZU1pY3JvdGFzaykge1xuICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPSB0cnVlO1xuICAgICAgc2NoZWR1bGVJbW1lZGlhdGVUYXNrKHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzayk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmbHVzaFN5bmNXb3JrT25BbGxSb290cygpIHtcbiAgLy8gVGhpcyBpcyBhbGxvd2VkIHRvIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5LCBidXQgdGhlIGNhbGxlciBzaG91bGQgY2hlY2tcbiAgLy8gdGhlIGV4ZWN1dGlvbiBjb250ZXh0IGZpcnN0LlxuICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbChmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKG9ubHlMZWdhY3kpIHtcbiAgaWYgKGlzRmx1c2hpbmdXb3JrKSB7XG4gICAgLy8gUHJldmVudCByZWVudHJhbmN5LlxuICAgIC8vIFRPRE86IElzIHRoaXMgb3Zlcmx5IGRlZmVuc2l2ZT8gVGhlIGNhbGxlcnMgbXVzdCBjaGVjayB0aGUgZXhlY3V0aW9uXG4gICAgLy8gY29udGV4dCBmaXJzdCByZWdhcmRsZXNzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrKSB7XG4gICAgLy8gRmFzdCBwYXRoLiBUaGVyZSdzIG5vIHN5bmMgd29yayB0byBkby5cbiAgICByZXR1cm47XG4gIH0gLy8gVGhlcmUgbWF5IG9yIG1heSBub3QgYmUgc3luY2hyb25vdXMgd29yayBzY2hlZHVsZWQuIExldCdzIGNoZWNrLlxuXG5cbiAgdmFyIGRpZFBlcmZvcm1Tb21lV29yaztcbiAgaXNGbHVzaGluZ1dvcmsgPSB0cnVlO1xuXG4gIGRvIHtcbiAgICBkaWRQZXJmb3JtU29tZVdvcmsgPSBmYWxzZTtcbiAgICB2YXIgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcblxuICAgIHdoaWxlIChyb290ICE9PSBudWxsKSB7XG4gICAgICBpZiAob25seUxlZ2FjeSAmJiAoZGlzYWJsZUxlZ2FjeU1vZGUgKSkgOyBlbHNlIHtcbiAgICAgICAgdmFyIHdvcmtJblByb2dyZXNzUm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuICAgICAgICB2YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcygpO1xuICAgICAgICB2YXIgbmV4dExhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCA/IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIDogTm9MYW5lcyk7XG5cbiAgICAgICAgaWYgKGluY2x1ZGVzU3luY0xhbmUobmV4dExhbmVzKSkge1xuICAgICAgICAgIC8vIFRoaXMgcm9vdCBoYXMgcGVuZGluZyBzeW5jIHdvcmsuIEZsdXNoIGl0IG5vdy5cbiAgICAgICAgICBkaWRQZXJmb3JtU29tZVdvcmsgPSB0cnVlO1xuICAgICAgICAgIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290LCBuZXh0TGFuZXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJvb3QgPSByb290Lm5leHQ7XG4gICAgfVxuICB9IHdoaWxlIChkaWRQZXJmb3JtU29tZVdvcmspO1xuXG4gIGlzRmx1c2hpbmdXb3JrID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzaygpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBhbHdheXMgY2FsbGVkIGluc2lkZSBhIG1pY3JvdGFzay4gSXQgc2hvdWxkIG5ldmVyIGJlXG4gIC8vIGNhbGxlZCBzeW5jaHJvbm91c2x5LlxuICBkaWRTY2hlZHVsZU1pY3JvdGFzayA9IGZhbHNlO1xuXG4gIHtcbiAgICBkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QgPSBmYWxzZTtcbiAgfSAvLyBXZSdsbCByZWNvbXB1dGUgdGhpcyBhcyB3ZSBpdGVyYXRlIHRocm91Z2ggYWxsIHRoZSByb290cyBhbmQgc2NoZWR1bGUgdGhlbS5cblxuXG4gIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9IGZhbHNlO1xuICB2YXIgY3VycmVudFRpbWUgPSBub3ckMSgpO1xuICB2YXIgcHJldiA9IG51bGw7XG4gIHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuXG4gIHdoaWxlIChyb290ICE9PSBudWxsKSB7XG4gICAgdmFyIG5leHQgPSByb290Lm5leHQ7XG5cbiAgICBpZiAoY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgIT09IE5vTGFuZSAmJiBzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uKCkpIHtcbiAgICAgIC8vIEEgdHJhbnNpdGlvbiB3YXMgc2NoZWR1bGVkIGR1cmluZyBhbiBldmVudCwgYnV0IHdlJ3JlIGdvaW5nIHRvIHRyeSB0b1xuICAgICAgLy8gcmVuZGVyIGl0IHN5bmNocm9ub3VzbHkgYW55d2F5LiBXZSBkbyB0aGlzIGR1cmluZyBhIHBvcHN0YXRlIGV2ZW50IHRvXG4gICAgICAvLyBwcmVzZXJ2ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBwcmV2aW91cyBwYWdlLlxuICAgICAgdXBncmFkZVBlbmRpbmdMYW5lVG9TeW5jKHJvb3QsIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dExhbmVzID0gc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayhyb290LCBjdXJyZW50VGltZSk7XG5cbiAgICBpZiAobmV4dExhbmVzID09PSBOb0xhbmUpIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBoYXMgbm8gbW9yZSBwZW5kaW5nIHdvcmsuIFJlbW92ZSBpdCBmcm9tIHRoZSBzY2hlZHVsZS4gVG9cbiAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc3VidGxlIHJlZW50cmFuY3kgYnVncywgdGhpcyBtaWNyb3Rhc2sgaXMgdGhlIG9ubHkgcGxhY2VcbiAgICAgIC8vIHdlIGRvIHRoaXMg4oCUIHlvdSBjYW4gYWRkIHJvb3RzIHRvIHRoZSBzY2hlZHVsZSB3aGVuZXZlciwgYnV0IHlvdSBjYW5cbiAgICAgIC8vIG9ubHkgcmVtb3ZlIHRoZW0gaGVyZS5cbiAgICAgIC8vIE51bGwgdGhpcyBvdXQgc28gd2Uga25vdyBpdCdzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBzY2hlZHVsZS5cbiAgICAgIHJvb3QubmV4dCA9IG51bGw7XG5cbiAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIG5ldyBoZWFkIG9mIHRoZSBsaXN0XG4gICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBuZXcgdGFpbCBvZiB0aGUgbGlzdFxuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IHByZXY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBzdGlsbCBoYXMgd29yay4gS2VlcCBpdCBpbiB0aGUgbGlzdC5cbiAgICAgIHByZXYgPSByb290O1xuXG4gICAgICBpZiAoaW5jbHVkZXNTeW5jTGFuZShuZXh0TGFuZXMpKSB7XG4gICAgICAgIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcm9vdCA9IG5leHQ7XG4gIH1cblxuICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IE5vTGFuZTsgLy8gQXQgdGhlIGVuZCBvZiB0aGUgbWljcm90YXNrLCBmbHVzaCBhbnkgcGVuZGluZyBzeW5jaHJvbm91cyB3b3JrLiBUaGlzIGhhc1xuICAvLyB0byBjb21lIGF0IHRoZSBlbmQsIGJlY2F1c2UgaXQgZG9lcyBhY3R1YWwgcmVuZGVyaW5nIHdvcmsgdGhhdCBtaWdodCB0aHJvdy5cblxuICBmbHVzaFN5bmNXb3JrT25BbGxSb290cygpO1xufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgYWx3YXlzIGNhbGxlZCBpbnNpZGUgYSBtaWNyb3Rhc2ssIG9yIGF0IHRoZSB2ZXJ5IGVuZCBvZiBhXG4gIC8vIHJlbmRlcmluZyB0YXNrIHJpZ2h0IGJlZm9yZSB3ZSB5aWVsZCB0byB0aGUgbWFpbiB0aHJlYWQuIEl0IHNob3VsZCBuZXZlciBiZVxuICAvLyBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAgLy9cbiAgLy8gVE9ETzogVW5sZXNzIGVuYWJsZURlZmVyUm9vdFNjaGVkdWxpbmdUb01pY3JvdGFzayBpcyBvZmYuIFdlIG5lZWQgdG8gbGFuZFxuICAvLyB0aGF0IEFTQVAgdG8gdW5ibG9jayBhZGRpdGlvbmFsIGZlYXR1cmVzIHdlIGhhdmUgcGxhbm5lZC5cbiAgLy9cbiAgLy8gVGhpcyBmdW5jdGlvbiBhbHNvIG5ldmVyIHBlcmZvcm1zIFJlYWN0IHdvcmsgc3luY2hyb25vdXNseTsgaXQgc2hvdWxkXG4gIC8vIG9ubHkgc2NoZWR1bGUgd29yayB0byBiZSBwZXJmb3JtZWQgbGF0ZXIsIGluIGEgc2VwYXJhdGUgdGFzayBvciBtaWNyb3Rhc2suXG4gIC8vIENoZWNrIGlmIGFueSBsYW5lcyBhcmUgYmVpbmcgc3RhcnZlZCBieSBvdGhlciB3b3JrLiBJZiBzbywgbWFyayB0aGVtIGFzXG4gIC8vIGV4cGlyZWQgc28gd2Uga25vdyB0byB3b3JrIG9uIHRob3NlIG5leHQuXG4gIG1hcmtTdGFydmVkTGFuZXNBc0V4cGlyZWQocm9vdCwgY3VycmVudFRpbWUpOyAvLyBEZXRlcm1pbmUgdGhlIG5leHQgbGFuZXMgdG8gd29yayBvbiwgYW5kIHRoZWlyIHByaW9yaXR5LlxuXG4gIHZhciB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcbiAgdmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMoKTtcbiAgdmFyIG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA6IE5vTGFuZXMpO1xuICB2YXIgZXhpc3RpbmdDYWxsYmFja05vZGUgPSByb290LmNhbGxiYWNrTm9kZTtcblxuICBpZiAoIC8vIENoZWNrIGlmIHRoZXJlJ3Mgbm90aGluZyB0byB3b3JrIG9uXG4gIG5leHRMYW5lcyA9PT0gTm9MYW5lcyB8fCAvLyBJZiB0aGlzIHJvb3QgaXMgY3VycmVudGx5IHN1c3BlbmRlZCBhbmQgd2FpdGluZyBmb3IgZGF0YSB0byByZXNvbHZlLCBkb24ndFxuICAvLyBzY2hlZHVsZSBhIHRhc2sgdG8gcmVuZGVyIGl0LiBXZSdsbCBlaXRoZXIgd2FpdCBmb3IgYSBwaW5nLCBvciB3YWl0IHRvXG4gIC8vIHJlY2VpdmUgYW4gdXBkYXRlLlxuICAvL1xuICAvLyBTdXNwZW5kZWQgcmVuZGVyIHBoYXNlXG4gIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJiBpc1dvcmtMb29wU3VzcGVuZGVkT25EYXRhKCkgfHwgLy8gU3VzcGVuZGVkIGNvbW1pdCBwaGFzZVxuICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgIT09IG51bGwpIHtcbiAgICAvLyBGYXN0IHBhdGg6IFRoZXJlJ3Mgbm90aGluZyB0byB3b3JrIG9uLlxuICAgIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQ2FsbGJhY2soZXhpc3RpbmdDYWxsYmFja05vZGUpO1xuICAgIH1cblxuICAgIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmU7XG4gICAgcmV0dXJuIE5vTGFuZTtcbiAgfSAvLyBTY2hlZHVsZSBhIG5ldyBjYWxsYmFjayBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudC5cblxuXG4gIGlmIChpbmNsdWRlc1N5bmNMYW5lKG5leHRMYW5lcykpIHtcbiAgICAvLyBTeW5jaHJvbm91cyB3b3JrIGlzIGFsd2F5cyBmbHVzaGVkIGF0IHRoZSBlbmQgb2YgdGhlIG1pY3JvdGFzaywgc28gd2VcbiAgICAvLyBkb24ndCBuZWVkIHRvIHNjaGVkdWxlIGFuIGFkZGl0aW9uYWwgdGFzay5cbiAgICBpZiAoZXhpc3RpbmdDYWxsYmFja05vZGUgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbENhbGxiYWNrKGV4aXN0aW5nQ2FsbGJhY2tOb2RlKTtcbiAgICB9XG5cbiAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBTeW5jTGFuZTtcbiAgICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgcmV0dXJuIFN5bmNMYW5lO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIHVzZSB0aGUgaGlnaGVzdCBwcmlvcml0eSBsYW5lIHRvIHJlcHJlc2VudCB0aGUgcHJpb3JpdHkgb2YgdGhlIGNhbGxiYWNrLlxuICAgIHZhciBleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgPSByb290LmNhbGxiYWNrUHJpb3JpdHk7XG4gICAgdmFyIG5ld0NhbGxiYWNrUHJpb3JpdHkgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKG5leHRMYW5lcyk7XG5cbiAgICBpZiAobmV3Q2FsbGJhY2tQcmlvcml0eSA9PT0gZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5ICYmIC8vIFNwZWNpYWwgY2FzZSByZWxhdGVkIHRvIGBhY3RgLiBJZiB0aGUgY3VycmVudGx5IHNjaGVkdWxlZCB0YXNrIGlzIGFcbiAgICAvLyBTY2hlZHVsZXIgdGFzaywgcmF0aGVyIHRoYW4gYW4gYGFjdGAgdGFzaywgY2FuY2VsIGl0IGFuZCByZS1zY2hlZHVsZVxuICAgIC8vIG9uIHRoZSBgYWN0YCBxdWV1ZS5cbiAgICAhKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICE9PSBudWxsICYmIGV4aXN0aW5nQ2FsbGJhY2tOb2RlICE9PSBmYWtlQWN0Q2FsbGJhY2tOb2RlJDEpKSB7XG4gICAgICAvLyBUaGUgcHJpb3JpdHkgaGFzbid0IGNoYW5nZWQuIFdlIGNhbiByZXVzZSB0aGUgZXhpc3RpbmcgdGFzay5cbiAgICAgIHJldHVybiBuZXdDYWxsYmFja1ByaW9yaXR5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYW5jZWwgdGhlIGV4aXN0aW5nIGNhbGxiYWNrLiBXZSdsbCBzY2hlZHVsZSBhIG5ldyBvbmUgYmVsb3cuXG4gICAgICBjYW5jZWxDYWxsYmFjayhleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIHNjaGVkdWxlclByaW9yaXR5TGV2ZWw7XG5cbiAgICBzd2l0Y2ggKGxhbmVzVG9FdmVudFByaW9yaXR5KG5leHRMYW5lcykpIHtcbiAgICAgIGNhc2UgRGlzY3JldGVFdmVudFByaW9yaXR5OlxuICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gSW1tZWRpYXRlUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENvbnRpbnVvdXNFdmVudFByaW9yaXR5OlxuICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIERlZmF1bHRFdmVudFByaW9yaXR5OlxuICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHkkMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgSWRsZUV2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHkkMTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIG5ld0NhbGxiYWNrTm9kZSA9IHNjaGVkdWxlQ2FsbGJhY2skMihzY2hlZHVsZXJQcmlvcml0eUxldmVsLCBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KSk7XG4gICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gbmV3Q2FsbGJhY2tQcmlvcml0eTtcbiAgICByb290LmNhbGxiYWNrTm9kZSA9IG5ld0NhbGxiYWNrTm9kZTtcbiAgICByZXR1cm4gbmV3Q2FsbGJhY2tQcmlvcml0eTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb250aW51YXRpb25Gb3JSb290KHJvb3QsIG9yaWdpbmFsQ2FsbGJhY2tOb2RlKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIGF0IHRoZSBlbmQgb2YgYHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdGAgdG8gZGV0ZXJtaW5lXG4gIC8vIGlmIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjb250aW51YXRpb24gdGFzay5cbiAgLy9cbiAgLy8gVXN1YWxseSBgc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFza2Agb25seSBydW5zIGluc2lkZSBhIG1pY3JvdGFzaztcbiAgLy8gaG93ZXZlciwgc2luY2UgbW9zdCBvZiB0aGUgbG9naWMgZm9yIGRldGVybWluaW5nIGlmIHdlIG5lZWQgYSBjb250aW51YXRpb25cbiAgLy8gdmVyc3VzIGEgbmV3IHRhc2sgaXMgdGhlIHNhbWUsIHdlIGNoZWF0IGEgYml0IGFuZCBjYWxsIGl0IGhlcmUuIFRoaXMgaXNcbiAgLy8gb25seSBzYWZlIHRvIGRvIGJlY2F1c2Ugd2Uga25vdyB3ZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBicm93c2VyIHRhc2suXG4gIC8vIFNvIGFsdGhvdWdoIGl0J3Mgbm90IGFuIGFjdHVhbCBtaWNyb3Rhc2ssIGl0IG1pZ2h0IGFzIHdlbGwgYmUuXG4gIHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgbm93JDEoKSk7XG5cbiAgaWYgKHJvb3QuY2FsbGJhY2tOb2RlID09PSBvcmlnaW5hbENhbGxiYWNrTm9kZSkge1xuICAgIC8vIFRoZSB0YXNrIG5vZGUgc2NoZWR1bGVkIGZvciB0aGlzIHJvb3QgaXMgdGhlIHNhbWUgb25lIHRoYXQnc1xuICAgIC8vIGN1cnJlbnRseSBleGVjdXRlZC4gTmVlZCB0byByZXR1cm4gYSBjb250aW51YXRpb24uXG4gICAgcmV0dXJuIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG52YXIgZmFrZUFjdENhbGxiYWNrTm9kZSQxID0ge307XG5cbmZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2skMihwcmlvcml0eUxldmVsLCBjYWxsYmFjaykge1xuICBpZiAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IFdlJ3JlIGluc2lkZSBhbiBgYWN0YCBzY29wZSAoYSB0ZXN0aW5nIHV0aWxpdHkpLlxuICAgIC8vIEluc3RlYWQgb2Ygc2NoZWR1bGluZyB3b3JrIGluIHRoZSBob3N0IGVudmlyb25tZW50LCBhZGQgaXQgdG8gYVxuICAgIC8vIGZha2UgaW50ZXJuYWwgcXVldWUgdGhhdCdzIG1hbmFnZWQgYnkgdGhlIGBhY3RgIGltcGxlbWVudGF0aW9uLlxuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiBmYWtlQWN0Q2FsbGJhY2tOb2RlJDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2skMyhwcmlvcml0eUxldmVsLCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKSB7XG4gIGlmIChjYWxsYmFja05vZGUgPT09IGZha2VBY3RDYWxsYmFja05vZGUkMSkgOyBlbHNlIGlmIChjYWxsYmFja05vZGUgIT09IG51bGwpIHtcbiAgICBjYW5jZWxDYWxsYmFjayQxKGNhbGxiYWNrTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVJbW1lZGlhdGVUYXNrKGNiKSB7XG4gIGlmIChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogSW5zaWRlIGFuIGBhY3RgIHNjb3BlLCB3ZSBwdXNoIG1pY3JvdGFza3MgdG8gdGhlIGZha2UgYGFjdGBcbiAgICAvLyBjYWxsYmFjayBxdWV1ZS4gVGhpcyBpcyBiZWNhdXNlIHdlIGN1cnJlbnRseSBzdXBwb3J0IGNhbGxpbmcgYGFjdGBcbiAgICAvLyB3aXRob3V0IGF3YWl0aW5nIHRoZSByZXN1bHQuIFRoZSBwbGFuIGlzIHRvIGRlcHJlY2F0ZSB0aGF0LCBhbmQgcmVxdWlyZVxuICAgIC8vIHRoYXQgeW91IGFsd2F5cyBhd2FpdCB0aGUgcmVzdWx0IHNvIHRoYXQgdGhlIG1pY3JvdGFza3MgaGF2ZSBhIGNoYW5jZSB0b1xuICAgIC8vIHJ1bi4gQnV0IGl0IGhhc24ndCBoYXBwZW5lZCB5ZXQuXG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBjYigpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gIH0gLy8gVE9ETzogQ2FuIHdlIGxhbmQgc3VwcG9ydHNNaWNyb3Rhc2tzPyBXaGljaCBlbnZpcm9ubWVudHMgZG9uJ3Qgc3VwcG9ydCBpdD9cbiAgLy8gQWx0ZXJuYXRpdmVseSwgY2FuIHdlIG1vdmUgdGhpcyBjaGVjayB0byB0aGUgaG9zdCBjb25maWc/XG5cblxuICBpZiAoc3VwcG9ydHNNaWNyb3Rhc2tzKSB7XG4gICAgc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgLy8gSW4gU2FmYXJpLCBhcHBlbmRpbmcgYW4gaWZyYW1lIGZvcmNlcyBtaWNyb3Rhc2tzIHRvIHJ1bi5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjI0NTlcbiAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgcnVubmluZyBjYWxsYmFja3MgaW4gdGhlIG1pZGRsZSBvZiByZW5kZXJcbiAgICAgIC8vIG9yIGNvbW1pdCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QgdGhhdC5cbiAgICAgIHZhciBleGVjdXRpb25Db250ZXh0ID0gZ2V0RXhlY3V0aW9uQ29udGV4dCgpO1xuXG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIHdvdWxkIHN0aWxsIHByZW1hdHVyZWx5IGZsdXNoIHRoZSBjYWxsYmFja3NcbiAgICAgICAgLy8gaWYgdGhpcyBoYXBwZW5zIG91dHNpZGUgcmVuZGVyIG9yIGNvbW1pdCBwaGFzZSAoZS5nLiBpbiBhbiBldmVudCkuXG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNpbmcgYSBtYWNyb3Rhc2sgaW5zdGVhZCBvZiBhIG1pY3JvdGFzayBoZXJlLiBUaGlzIGlzXG4gICAgICAgIC8vIHdyb25nIHNlbWFudGljYWxseSBidXQgaXQgcHJldmVudHMgYW4gaW5maW5pdGUgbG9vcC4gVGhlIGJ1ZyBpc1xuICAgICAgICAvLyBTYWZhcmkncywgbm90IG91cnMsIHNvIHdlIGp1c3QgZG8gb3VyIGJlc3QgdG8gbm90IGNyYXNoIGV2ZW4gdGhvdWdoXG4gICAgICAgIC8vIHRoZSBiZWhhdmlvciBpc24ndCBjb21wbGV0ZWx5IGNvcnJlY3QuXG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2skMyhJbW1lZGlhdGVQcmlvcml0eSwgY2IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNiKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgbWljcm90YXNrcyBhcmUgbm90IHN1cHBvcnRlZCwgdXNlIFNjaGVkdWxlci5cbiAgICBzY2hlZHVsZUNhbGxiYWNrJDMoSW1tZWRpYXRlUHJpb3JpdHksIGNiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoIC8vIFRoaXMgYXJndW1lbnQgaXNuJ3QgdXNlZCwgaXQncyBvbmx5IGhlcmUgdG8gZW5jb3VyYWdlIHRoZSBjYWxsZXIgdG9cbi8vIGNoZWNrIHRoYXQgaXQncyBpbnNpZGUgYSB0cmFuc2l0aW9uIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4vLyBUT0RPOiBNYWtlIHRoaXMgbm9uLW51bGxhYmxlLiBSZXF1aXJlcyBhIHR3ZWFrIHRvIHVzZU9wdGltaXN0aWMuXG50cmFuc2l0aW9uKSB7XG4gIC8vIFRoZSBhbGdvcml0aG0gZm9yIGFzc2lnbmluZyBhbiB1cGRhdGUgdG8gYSBsYW5lIHNob3VsZCBiZSBzdGFibGUgZm9yIGFsbFxuICAvLyB1cGRhdGVzIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGhpbiB0aGUgc2FtZSBldmVudC4gVG8gZG8gdGhpcywgdGhlXG4gIC8vIGlucHV0cyB0byB0aGUgYWxnb3JpdGhtIG11c3QgYmUgdGhlIHNhbWUuXG4gIC8vXG4gIC8vIFRoZSB0cmljayB3ZSB1c2UgaXMgdG8gY2FjaGUgdGhlIGZpcnN0IG9mIGVhY2ggb2YgdGhlc2UgaW5wdXRzIHdpdGhpbiBhblxuICAvLyBldmVudC4gVGhlbiByZXNldCB0aGUgY2FjaGVkIHZhbHVlcyBvbmNlIHdlIGNhbiBiZSBzdXJlIHRoZSBldmVudCBpc1xuICAvLyBvdmVyLiBPdXIgaGV1cmlzdGljIGZvciB0aGF0IGlzIHdoZW5ldmVyIHdlIGVudGVyIGEgY29uY3VycmVudCB3b3JrIGxvb3AuXG4gIGlmIChjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9PT0gTm9MYW5lKSB7XG4gICAgLy8gQWxsIHRyYW5zaXRpb25zIHdpdGhpbiB0aGUgc2FtZSBldmVudCBhcmUgYXNzaWduZWQgdGhlIHNhbWUgbGFuZS5cbiAgICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCk7XG4gIH1cblxuICByZXR1cm4gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmU7XG59XG5cbi8vIHRyYW5zaXRpb24gdXBkYXRlcyB0aGF0IG9jY3VyIHdoaWxlIHRoZSBhc3luYyBhY3Rpb24gaXMgc3RpbGwgaW4gcHJvZ3Jlc3Ncbi8vIGFyZSB0cmVhdGVkIGFzIHBhcnQgb2YgdGhlIGFjdGlvbi5cbi8vXG4vLyBUaGUgaWRlYWwgYmVoYXZpb3Igd291bGQgYmUgdG8gdHJlYXQgZWFjaCBhc3luYyBmdW5jdGlvbiBhcyBhbiBpbmRlcGVuZGVudFxuLy8gYWN0aW9uLiBIb3dldmVyLCB3aXRob3V0IGEgbWVjaGFuaXNtIGxpa2UgQXN5bmNDb250ZXh0LCB3ZSBjYW4ndCB0ZWxsIHdoaWNoXG4vLyBhY3Rpb24gYW4gdXBkYXRlIGNvcnJlc3BvbmRzIHRvLiBTbyBpbnN0ZWFkLCB3ZSBlbnRhbmdsZSB0aGVtIGFsbCBpbnRvIG9uZS5cbi8vIFRoZSBsaXN0ZW5lcnMgdG8gbm90aWZ5IG9uY2UgdGhlIGVudGFuZ2xlZCBzY29wZSBjb21wbGV0ZXMuXG5cbnZhciBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gbnVsbDsgLy8gVGhlIG51bWJlciBvZiBwZW5kaW5nIGFzeW5jIGFjdGlvbnMgaW4gdGhlIGVudGFuZ2xlZCBzY29wZS5cblxudmFyIGN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQgPSAwOyAvLyBUaGUgdHJhbnNpdGlvbiBsYW5lIHNoYXJlZCBieSBhbGwgdXBkYXRlcyBpbiB0aGUgZW50YW5nbGVkIHNjb3BlLlxuXG52YXIgY3VycmVudEVudGFuZ2xlZExhbmUgPSBOb0xhbmU7IC8vIEEgdGhlbmFibGUgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBlbnRhbmdsZWQgc2NvcGUgY29tcGxldGVzLiBJdCBkb2VzIG5vdFxuLy8gcmVzb2x2ZSB0byBhIHBhcnRpY3VsYXIgdmFsdWUgYmVjYXVzZSBpdCdzIG9ubHkgdXNlZCBmb3Igc3VzcGVuZGluZyB0aGUgVUlcbi8vIHVudGlsIHRoZSBhc3luYyBhY3Rpb24gc2NvcGUgaGFzIGNvbXBsZXRlZC5cblxudmFyIGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IG51bGw7XG5mdW5jdGlvbiBlbnRhbmdsZUFzeW5jQWN0aW9uKHRyYW5zaXRpb24sIHRoZW5hYmxlKSB7XG4gIC8vIGB0aGVuYWJsZWAgaXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYXN5bmMgYWN0aW9uIHNjb3BlIGZ1bmN0aW9uLiBDcmVhdGVcbiAgLy8gYSBjb21iaW5lZCB0aGVuYWJsZSB0aGF0IHJlc29sdmVzIG9uY2UgZXZlcnkgZW50YW5nbGVkIHNjb3BlIGZ1bmN0aW9uXG4gIC8vIGhhcyBmaW5pc2hlZC5cbiAgaWYgKGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPT09IG51bGwpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG91dGVyIGFzeW5jIGFjdGlvbiBzY29wZS4gQ3JlYXRlIGEgbmV3IG9uZS5cbiAgICB2YXIgZW50YW5nbGVkTGlzdGVuZXJzID0gY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IFtdO1xuICAgIGN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQgPSAwO1xuICAgIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gcmVxdWVzdFRyYW5zaXRpb25MYW5lKCk7XG4gICAgdmFyIGVudGFuZ2xlZFRoZW5hYmxlID0ge1xuICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgZW50YW5nbGVkTGlzdGVuZXJzLnB1c2gocmVzb2x2ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBlbnRhbmdsZWRUaGVuYWJsZTtcbiAgfVxuXG4gIGN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQrKztcbiAgdGhlbmFibGUudGhlbihwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlLCBwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlKTtcbiAgcmV0dXJuIHRoZW5hYmxlO1xufVxuXG5mdW5jdGlvbiBwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlKCkge1xuICBpZiAoY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyAhPT0gbnVsbCAmJiAtLWN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQgPT09IDApIHtcbiAgICAvLyBBbGwgdGhlIGFjdGlvbnMgaGF2ZSBmaW5pc2hlZC4gQ2xvc2UgdGhlIGVudGFuZ2xlZCBhc3luYyBhY3Rpb24gc2NvcGVcbiAgICAvLyBhbmQgbm90aWZ5IGFsbCB0aGUgbGlzdGVuZXJzLlxuICAgIGlmIChjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzO1xuICAgIGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBudWxsO1xuICAgIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gTm9MYW5lO1xuICAgIGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hhaW5UaGVuYWJsZVZhbHVlKHRoZW5hYmxlLCByZXN1bHQpIHtcbiAgLy8gRXF1aXZhbGVudCB0bzogUHJvbWlzZS5yZXNvbHZlKHRoZW5hYmxlKS50aGVuKCgpID0+IHJlc3VsdCksIGV4Y2VwdCB3ZSBjYW5cbiAgLy8gY2hlYXQgYSBiaXQgc2luY2Ugd2Uga25vdyB0aGF0IHRoYXQgdGhpcyB0aGVuYWJsZSBpcyBvbmx5IGV2ZXIgY29uc3VtZWRcbiAgLy8gYnkgUmVhY3QuXG4gIC8vXG4gIC8vIFdlIGRvbid0IHRlY2huaWNhbGx5IHJlcXVpcmUgcHJvbWlzZSBzdXBwb3J0IG9uIHRoZSBjbGllbnQgeWV0LCBoZW5jZSB0aGlzXG4gIC8vIGV4dHJhIGNvZGUuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIHRoZW5hYmxlV2l0aE92ZXJyaWRlID0ge1xuICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgIHZhbHVlOiBudWxsLFxuICAgIHJlYXNvbjogbnVsbCxcbiAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgbGlzdGVuZXJzLnB1c2gocmVzb2x2ZSk7XG4gICAgfVxuICB9O1xuICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlV2l0aE92ZXJyaWRlO1xuICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xuICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gcmVzdWx0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgIGxpc3RlbmVyKHJlc3VsdCk7XG4gICAgfVxuICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlV2l0aE92ZXJyaWRlO1xuICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gJ3JlamVjdGVkJztcbiAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTsgLy8gVGhpcyBpcyBhIHBlcmYgaGFjayB3aGVyZSB3ZSBjYWxsIHRoZSBgb25GdWxmaWxsYCBwaW5nIGZ1bmN0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGBvblJlamVjdGAsIGJlY2F1c2Ugd2Uga25vdyB0aGF0IFJlYWN0IGlzIHRoZSBvbmx5XG4gICAgICAvLyBjb25zdW1lciBvZiB0aGVzZSBwcm9taXNlcywgYW5kIGl0IHBhc3NlcyB0aGUgc2FtZSBsaXN0ZW5lciB0byBib3RoLlxuICAgICAgLy8gV2UgYWxzbyBrbm93IHRoYXQgaXQgd2lsbCByZWFkIHRoZSBlcnJvciBkaXJlY3RseSBvZmYgdGhlXG4gICAgICAvLyBgLnJlYXNvbmAgZmllbGQuXG5cbiAgICAgIGxpc3RlbmVyKHVuZGVmaW5lZCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRoZW5hYmxlV2l0aE92ZXJyaWRlO1xufVxuZnVuY3Rpb24gcGVla0VudGFuZ2xlZEFjdGlvbkxhbmUoKSB7XG4gIHJldHVybiBjdXJyZW50RW50YW5nbGVkTGFuZTtcbn1cbmZ1bmN0aW9uIHBlZWtFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSgpIHtcbiAgcmV0dXJuIGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbn1cblxudmFyIFVwZGF0ZVN0YXRlID0gMDtcbnZhciBSZXBsYWNlU3RhdGUgPSAxO1xudmFyIEZvcmNlVXBkYXRlID0gMjtcbnZhciBDYXB0dXJlVXBkYXRlID0gMzsgLy8gR2xvYmFsIHN0YXRlIHRoYXQgaXMgcmVzZXQgYXQgdGhlIGJlZ2lubmluZyBvZiBjYWxsaW5nIGBwcm9jZXNzVXBkYXRlUXVldWVgLlxuLy8gSXQgc2hvdWxkIG9ubHkgYmUgcmVhZCByaWdodCBhZnRlciBjYWxsaW5nIGBwcm9jZXNzVXBkYXRlUXVldWVgLCB2aWFcbi8vIGBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nYC5cblxudmFyIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG52YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZTtcbnZhciBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWU7XG5cbntcbiAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IGZhbHNlO1xuICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplVXBkYXRlUXVldWUoZmliZXIpIHtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIGJhc2VTdGF0ZTogZmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICBmaXJzdEJhc2VVcGRhdGU6IG51bGwsXG4gICAgbGFzdEJhc2VVcGRhdGU6IG51bGwsXG4gICAgc2hhcmVkOiB7XG4gICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgICBoaWRkZW5DYWxsYmFja3M6IG51bGxcbiAgICB9LFxuICAgIGNhbGxiYWNrczogbnVsbFxuICB9O1xuICBmaWJlci51cGRhdGVRdWV1ZSA9IHF1ZXVlO1xufVxuZnVuY3Rpb24gY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBDbG9uZSB0aGUgdXBkYXRlIHF1ZXVlIGZyb20gY3VycmVudC4gVW5sZXNzIGl0J3MgYWxyZWFkeSBhIGNsb25lLlxuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgaWYgKHF1ZXVlID09PSBjdXJyZW50UXVldWUpIHtcbiAgICB2YXIgY2xvbmUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICBmaXJzdEJhc2VVcGRhdGU6IGN1cnJlbnRRdWV1ZS5maXJzdEJhc2VVcGRhdGUsXG4gICAgICBsYXN0QmFzZVVwZGF0ZTogY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlLFxuICAgICAgc2hhcmVkOiBjdXJyZW50UXVldWUuc2hhcmVkLFxuICAgICAgY2FsbGJhY2tzOiBudWxsXG4gICAgfTtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGNsb25lO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUobGFuZSkge1xuICB2YXIgdXBkYXRlID0ge1xuICAgIGxhbmU6IGxhbmUsXG4gICAgdGFnOiBVcGRhdGVTdGF0ZSxcbiAgICBwYXlsb2FkOiBudWxsLFxuICAgIGNhbGxiYWNrOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHVwZGF0ZTtcbn1cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgbGFuZSkge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcblxuICBpZiAodXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICAvLyBPbmx5IG9jY3VycyBpZiB0aGUgZmliZXIgaGFzIGJlZW4gdW5tb3VudGVkLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuXG4gIHtcbiAgICBpZiAoY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID09PSBzaGFyZWRRdWV1ZSAmJiAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKTtcblxuICAgICAgZXJyb3IoJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50OiAlcycsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNVbnNhZmVDbGFzc1JlbmRlclBoYXNlVXBkYXRlKCkpIHtcbiAgICAvLyBUaGlzIGlzIGFuIHVuc2FmZSByZW5kZXIgcGhhc2UgdXBkYXRlLiBBZGQgZGlyZWN0bHkgdG8gdGhlIHVwZGF0ZVxuICAgIC8vIHF1ZXVlIHNvIHdlIGNhbiBwcm9jZXNzIGl0IGltbWVkaWF0ZWx5IGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIuXG4gICAgdmFyIHBlbmRpbmcgPSBzaGFyZWRRdWV1ZS5wZW5kaW5nO1xuXG4gICAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG5cbiAgICBzaGFyZWRRdWV1ZS5wZW5kaW5nID0gdXBkYXRlOyAvLyBVcGRhdGUgdGhlIGNoaWxkTGFuZXMgZXZlbiB0aG91Z2ggd2UncmUgbW9zdCBsaWtlbHkgYWxyZWFkeSByZW5kZXJpbmdcbiAgICAvLyB0aGlzIGZpYmVyLiBUaGlzIGlzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBpbiB0aGUgY2FzZSB3aGVyZSB5b3VcbiAgICAvLyB1cGRhdGUgYSBkaWZmZXJlbnQgY29tcG9uZW50IGR1cmluZyByZW5kZXIgcGhhc2UgdGhhbiB0aGUgb25lIHRoYXQgaXNcbiAgICAvLyBjdXJyZW50bHkgcmVuZGVyaW5ncyAoYSBwYXR0ZXJuIHRoYXQgaXMgYWNjb21wYW5pZWQgYnkgYSB3YXJuaW5nKS5cblxuICAgIHJldHVybiB1bnNhZmVfbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIGxhbmUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbnF1ZXVlQ29uY3VycmVudENsYXNzVXBkYXRlKGZpYmVyLCBzaGFyZWRRdWV1ZSwgdXBkYXRlLCBsYW5lKTtcbiAgfVxufVxuZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSkge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcblxuICBpZiAodXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICAvLyBPbmx5IG9jY3VycyBpZiB0aGUgZmliZXIgaGFzIGJlZW4gdW5tb3VudGVkLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzaGFyZWRRdWV1ZSA9IHVwZGF0ZVF1ZXVlLnNoYXJlZDtcblxuICBpZiAoaXNUcmFuc2l0aW9uTGFuZShsYW5lKSkge1xuICAgIHZhciBxdWV1ZUxhbmVzID0gc2hhcmVkUXVldWUubGFuZXM7IC8vIElmIGFueSBlbnRhbmdsZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBwZW5kaW5nIG9uIHRoZSByb290LCB0aGVuIHRoZXkgbXVzdFxuICAgIC8vIGhhdmUgZmluaXNoZWQuIFdlIGNhbiByZW1vdmUgdGhlbSBmcm9tIHRoZSBzaGFyZWQgcXVldWUsIHdoaWNoIHJlcHJlc2VudHNcbiAgICAvLyBhIHN1cGVyc2V0IG9mIHRoZSBhY3R1YWxseSBwZW5kaW5nIGxhbmVzLiBJbiBzb21lIGNhc2VzIHdlIG1heSBlbnRhbmdsZVxuICAgIC8vIG1vcmUgdGhhbiB3ZSBuZWVkIHRvLCBidXQgdGhhdCdzIE9LLiBJbiBmYWN0IGl0J3Mgd29yc2UgaWYgd2UgKmRvbid0KlxuICAgIC8vIGVudGFuZ2xlIHdoZW4gd2Ugc2hvdWxkLlxuXG4gICAgcXVldWVMYW5lcyA9IGludGVyc2VjdExhbmVzKHF1ZXVlTGFuZXMsIHJvb3QucGVuZGluZ0xhbmVzKTsgLy8gRW50YW5nbGUgdGhlIG5ldyB0cmFuc2l0aW9uIGxhbmUgd2l0aCB0aGUgb3RoZXIgdHJhbnNpdGlvbiBsYW5lcy5cblxuICAgIHZhciBuZXdRdWV1ZUxhbmVzID0gbWVyZ2VMYW5lcyhxdWV1ZUxhbmVzLCBsYW5lKTtcbiAgICBzaGFyZWRRdWV1ZS5sYW5lcyA9IG5ld1F1ZXVlTGFuZXM7IC8vIEV2ZW4gaWYgcXVldWUubGFuZXMgYWxyZWFkeSBpbmNsdWRlIGxhbmUsIHdlIGRvbid0IGtub3cgZm9yIGNlcnRhaW4gaWZcbiAgICAvLyB0aGUgbGFuZSBmaW5pc2hlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIGVudGFuZ2xlZCBpdC4gU28gd2UgbmVlZCB0b1xuICAgIC8vIGVudGFuZ2xlIGl0IGFnYWluLCBqdXN0IHRvIGJlIHN1cmUuXG5cbiAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBuZXdRdWV1ZUxhbmVzKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBjYXB0dXJlZFVwZGF0ZSkge1xuICAvLyBDYXB0dXJlZCB1cGRhdGVzIGFyZSB1cGRhdGVzIHRoYXQgYXJlIHRocm93biBieSBhIGNoaWxkIGR1cmluZyB0aGUgcmVuZGVyXG4gIC8vIHBoYXNlLiBUaGV5IHNob3VsZCBiZSBkaXNjYXJkZWQgaWYgdGhlIHJlbmRlciBpcyBhYm9ydGVkLiBUaGVyZWZvcmUsXG4gIC8vIHdlIHNob3VsZCBvbmx5IHB1dCB0aGVtIG9uIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlLCBub3QgdGhlIGN1cnJlbnQgb25lLlxuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTsgLy8gQ2hlY2sgaWYgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgYSBjbG9uZS5cblxuICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gICAgaWYgKHF1ZXVlID09PSBjdXJyZW50UXVldWUpIHtcbiAgICAgIC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIHRoZSBzYW1lIGFzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuXG4gICAgICAvLyB3ZSBiYWlsIG91dCBvbiBhIHBhcmVudCBmaWJlciB0aGF0IHRoZW4gY2FwdHVyZXMgYW4gZXJyb3IgdGhyb3duIGJ5XG4gICAgICAvLyBhIGNoaWxkLiBTaW5jZSB3ZSB3YW50IHRvIGFwcGVuZCB0aGUgdXBkYXRlIG9ubHkgdG8gdGhlIHdvcmstaW5cbiAgICAgIC8vIC1wcm9ncmVzcyBxdWV1ZSwgd2UgbmVlZCB0byBjbG9uZSB0aGUgdXBkYXRlcy4gV2UgdXN1YWxseSBjbG9uZSBkdXJpbmdcbiAgICAgIC8vIHByb2Nlc3NVcGRhdGVRdWV1ZSwgYnV0IHRoYXQgZGlkbid0IGhhcHBlbiBpbiB0aGlzIGNhc2UgYmVjYXVzZSB3ZVxuICAgICAgLy8gc2tpcHBlZCBvdmVyIHRoZSBwYXJlbnQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuICAgICAgdmFyIG5ld0ZpcnN0ID0gbnVsbDtcbiAgICAgIHZhciBuZXdMYXN0ID0gbnVsbDtcbiAgICAgIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG5cbiAgICAgIGlmIChmaXJzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSB1cGRhdGVzIGFuZCBjbG9uZSB0aGVtLlxuICAgICAgICB2YXIgdXBkYXRlID0gZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgICBsYW5lOiB1cGRhdGUubGFuZSxcbiAgICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuICAgICAgICAgICAgLy8gV2hlbiB0aGlzIHVwZGF0ZSBpcyByZWJhc2VkLCB3ZSBzaG91bGQgbm90IGZpcmUgaXRzXG4gICAgICAgICAgICAvLyBjYWxsYmFjayBhZ2Fpbi5cbiAgICAgICAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobmV3TGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xhc3QubmV4dCA9IGNsb25lO1xuICAgICAgICAgICAgbmV3TGFzdCA9IGNsb25lO1xuICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwpOyAvLyBBcHBlbmQgdGhlIGNhcHR1cmVkIHVwZGF0ZSB0aGUgZW5kIG9mIHRoZSBjbG9uZWQgbGlzdC5cblxuXG4gICAgICAgIGlmIChuZXdMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3TGFzdC5uZXh0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgICAgbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGVyZSBhcmUgbm8gYmFzZSB1cGRhdGVzLlxuICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgIH1cblxuICAgICAgcXVldWUgPSB7XG4gICAgICAgIGJhc2VTdGF0ZTogY3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxcbiAgICAgICAgZmlyc3RCYXNlVXBkYXRlOiBuZXdGaXJzdCxcbiAgICAgICAgbGFzdEJhc2VVcGRhdGU6IG5ld0xhc3QsXG4gICAgICAgIHNoYXJlZDogY3VycmVudFF1ZXVlLnNoYXJlZCxcbiAgICAgICAgY2FsbGJhY2tzOiBjdXJyZW50UXVldWUuY2FsbGJhY2tzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBxdWV1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cblxuXG4gIHZhciBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuXG4gIGlmIChsYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIGxhc3RCYXNlVXBkYXRlLm5leHQgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgfVxuXG4gIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMsIGluc3RhbmNlKSB7XG4gIHN3aXRjaCAodXBkYXRlLnRhZykge1xuICAgIGNhc2UgUmVwbGFjZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IHVwZGF0ZS5wYXlsb2FkO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFVwZGF0ZXIgZnVuY3Rpb25cbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHBheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgICAgIH0gLy8gU3RhdGUgb2JqZWN0XG5cblxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2FwdHVyZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgIH1cbiAgICAvLyBJbnRlbnRpb25hbCBmYWxsdGhyb3VnaFxuXG4gICAgY2FzZSBVcGRhdGVTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXlsb2FkID0gdXBkYXRlLnBheWxvYWQ7XG4gICAgICAgIHZhciBwYXJ0aWFsU3RhdGU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFVwZGF0ZXIgZnVuY3Rpb25cbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gX3BheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3BheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUGFydGlhbCBzdGF0ZSBvYmplY3RcbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBOdWxsIGFuZCB1bmRlZmluZWQgYXJlIHRyZWF0ZWQgYXMgbm8tb3BzLlxuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICAgIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG4gICAgICAgIHJldHVybiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRm9yY2VVcGRhdGU6XG4gICAgICB7XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmV2U3RhdGU7XG59XG5cbnZhciBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gZmFsc2U7IC8vIEVhY2ggY2FsbCB0byBwcm9jZXNzVXBkYXRlUXVldWUgc2hvdWxkIGJlIGFjY29tcGFuaWVkIGJ5IGEgY2FsbCB0byB0aGlzLiBJdCdzXG4vLyBvbmx5IGluIGEgc2VwYXJhdGUgZnVuY3Rpb24gYmVjYXVzZSBpbiB1cGRhdGVIb3N0Um9vdCwgaXQgbXVzdCBoYXBwZW4gYWZ0ZXJcbi8vIGFsbCB0aGUgY29udGV4dCBzdGFja3MgaGF2ZSBiZWVuIHB1c2hlZCB0bywgdG8gcHJldmVudCBhIHN0YWNrIG1pc21hdGNoLiBBXG4vLyBiaXQgdW5mb3J0dW5hdGUuXG5cbmZ1bmN0aW9uIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKSB7XG4gIC8vIENoZWNrIGlmIHRoaXMgdXBkYXRlIGlzIHBhcnQgb2YgYSBwZW5kaW5nIGFzeW5jIGFjdGlvbi4gSWYgc28sIHdlJ2xsXG4gIC8vIG5lZWQgdG8gc3VzcGVuZCB1bnRpbCB0aGUgYWN0aW9uIGhhcyBmaW5pc2hlZCwgc28gdGhhdCBpdCdzIGJhdGNoZWRcbiAgLy8gdG9nZXRoZXIgd2l0aCBmdXR1cmUgdXBkYXRlcyBpbiB0aGUgc2FtZSBhY3Rpb24uXG4gIC8vIFRPRE86IE9uY2Ugd2Ugc3VwcG9ydCBob29rcyBpbnNpZGUgdXNlTWVtbyAob3IgYW4gZXF1aXZhbGVudFxuICAvLyBtZW1vaXphdGlvbiBib3VuZGFyeSBsaWtlIEZvcmdldCksIGhvaXN0IHRoaXMgbG9naWMgc28gdGhhdCBpdCBvbmx5XG4gIC8vIHN1c3BlbmRzIGlmIHRoZSBtZW1vIGJvdW5kYXJ5IHByb2R1Y2VzIGEgbmV3IHZhbHVlLlxuICBpZiAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbikge1xuICAgIHZhciBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IHBlZWtFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSgpO1xuXG4gICAgaWYgKGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJbnN0ZWFkIG9mIHRoZSB0aHJvd2luZyB0aGUgdGhlbmFibGUgZGlyZWN0bHksIHRocm93IGFcbiAgICAgIC8vIHNwZWNpYWwgb2JqZWN0IGxpa2UgYHVzZWAgZG9lcyBzbyB3ZSBjYW4gZGV0ZWN0IGlmIGl0J3MgY2FwdHVyZWRcbiAgICAgIC8vIGJ5IHVzZXJzcGFjZS5cbiAgICAgIHRocm93IGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBwcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKSB7XG4gIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSBmYWxzZTsgLy8gVGhpcyBpcyBhbHdheXMgbm9uLW51bGwgb24gYSBDbGFzc0NvbXBvbmVudCBvciBIb3N0Um9vdFxuXG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQ7XG4gIH1cblxuICB2YXIgZmlyc3RCYXNlVXBkYXRlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlO1xuICB2YXIgbGFzdEJhc2VVcGRhdGUgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTsgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmcgdXBkYXRlcy4gSWYgc28sIHRyYW5zZmVyIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG5cbiAgdmFyIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nUXVldWUgIT09IG51bGwpIHtcbiAgICBxdWV1ZS5zaGFyZWQucGVuZGluZyA9IG51bGw7IC8vIFRoZSBwZW5kaW5nIHF1ZXVlIGlzIGNpcmN1bGFyLiBEaXNjb25uZWN0IHRoZSBwb2ludGVyIGJldHdlZW4gZmlyc3RcbiAgICAvLyBhbmQgbGFzdCBzbyB0aGF0IGl0J3Mgbm9uLWNpcmN1bGFyLlxuXG4gICAgdmFyIGxhc3RQZW5kaW5nVXBkYXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgIHZhciBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgIGxhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsOyAvLyBBcHBlbmQgcGVuZGluZyB1cGRhdGVzIHRvIGJhc2UgcXVldWVcblxuICAgIGlmIChsYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0QmFzZVVwZGF0ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgIH1cblxuICAgIGxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7IC8vIElmIHRoZXJlJ3MgYSBjdXJyZW50IHF1ZXVlLCBhbmQgaXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgYmFzZSBxdWV1ZSwgdGhlblxuICAgIC8vIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlIHVwZGF0ZXMgdG8gdGhhdCBxdWV1ZSwgdG9vLiBCZWNhdXNlIHRoZSBiYXNlXG4gICAgLy8gcXVldWUgaXMgYSBzaW5nbHktbGlua2VkIGxpc3Qgd2l0aCBubyBjeWNsZXMsIHdlIGNhbiBhcHBlbmQgdG8gYm90aFxuICAgIC8vIGxpc3RzIGFuZCB0YWtlIGFkdmFudGFnZSBvZiBzdHJ1Y3R1cmFsIHNoYXJpbmcuXG4gICAgLy8gVE9ETzogUGFzcyBgY3VycmVudGAgYXMgYXJndW1lbnRcblxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgYWx3YXlzIG5vbi1udWxsIG9uIGEgQ2xhc3NDb21wb25lbnQgb3IgSG9zdFJvb3RcbiAgICAgIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgdmFyIGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSA9IGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSAhPT0gbGFzdEJhc2VVcGRhdGUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRRdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudExhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50UXVldWUubGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gVGhlc2UgdmFsdWVzIG1heSBjaGFuZ2UgYXMgd2UgcHJvY2VzcyB0aGUgcXVldWUuXG5cblxuICBpZiAoZmlyc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBsaXN0IG9mIHVwZGF0ZXMgdG8gY29tcHV0ZSB0aGUgcmVzdWx0LlxuICAgIHZhciBuZXdTdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTsgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmUgcmVuZGVyTGFuZXNcbiAgICAvLyBmcm9tIHRoZSBvcmlnaW5hbCBsYW5lcy5cblxuICAgIHZhciBuZXdMYW5lcyA9IE5vTGFuZXM7XG4gICAgdmFyIG5ld0Jhc2VTdGF0ZSA9IG51bGw7XG4gICAgdmFyIG5ld0ZpcnN0QmFzZVVwZGF0ZSA9IG51bGw7XG4gICAgdmFyIG5ld0xhc3RCYXNlVXBkYXRlID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgZG8ge1xuICAgICAgLy8gQW4gZXh0cmEgT2Zmc2NyZWVuTGFuZSBiaXQgaXMgYWRkZWQgdG8gdXBkYXRlcyB0aGF0IHdlcmUgbWFkZSB0b1xuICAgICAgLy8gYSBoaWRkZW4gdHJlZSwgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHVwZGF0ZXMgdGhhdCB3ZXJlXG4gICAgICAvLyBhbHJlYWR5IHRoZXJlIHdoZW4gdGhlIHRyZWUgd2FzIGhpZGRlbi5cbiAgICAgIHZhciB1cGRhdGVMYW5lID0gcmVtb3ZlTGFuZXModXBkYXRlLmxhbmUsIE9mZnNjcmVlbkxhbmUpO1xuICAgICAgdmFyIGlzSGlkZGVuVXBkYXRlID0gdXBkYXRlTGFuZSAhPT0gdXBkYXRlLmxhbmU7IC8vIENoZWNrIGlmIHRoaXMgdXBkYXRlIHdhcyBtYWRlIHdoaWxlIHRoZSB0cmVlIHdhcyBoaWRkZW4uIElmIHNvLCB0aGVuXG4gICAgICAvLyBpdCdzIG5vdCBhIFwiYmFzZVwiIHVwZGF0ZSBhbmQgd2Ugc2hvdWxkIGRpc3JlZ2FyZCB0aGUgZXh0cmEgYmFzZSBsYW5lc1xuICAgICAgLy8gdGhhdCB3ZXJlIGFkZGVkIHRvIHJlbmRlckxhbmVzIHdoZW4gd2UgZW50ZXJlZCB0aGUgT2Zmc2NyZWVuIHRyZWUuXG5cbiAgICAgIHZhciBzaG91bGRTa2lwVXBkYXRlID0gaXNIaWRkZW5VcGRhdGUgPyAhaXNTdWJzZXRPZkxhbmVzKGdldFdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKCksIHVwZGF0ZUxhbmUpIDogIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgdXBkYXRlTGFuZSk7XG5cbiAgICAgIGlmIChzaG91bGRTa2lwVXBkYXRlKSB7XG4gICAgICAgIC8vIFByaW9yaXR5IGlzIGluc3VmZmljaWVudC4gU2tpcCB0aGlzIHVwZGF0ZS4gSWYgdGhpcyBpcyB0aGUgZmlyc3RcbiAgICAgICAgLy8gc2tpcHBlZCB1cGRhdGUsIHRoZSBwcmV2aW91cyB1cGRhdGUvc3RhdGUgaXMgdGhlIG5ldyBiYXNlXG4gICAgICAgIC8vIHVwZGF0ZS9zdGF0ZS5cbiAgICAgICAgdmFyIGNsb25lID0ge1xuICAgICAgICAgIGxhbmU6IHVwZGF0ZUxhbmUsXG4gICAgICAgICAgdGFnOiB1cGRhdGUudGFnLFxuICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuICAgICAgICAgIGNhbGxiYWNrOiB1cGRhdGUuY2FsbGJhY2ssXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChuZXdMYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0ZpcnN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlID0gY2xvbmU7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3TGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZS5uZXh0ID0gY2xvbmU7XG4gICAgICAgIH0gLy8gVXBkYXRlIHRoZSByZW1haW5pbmcgcHJpb3JpdHkgaW4gdGhlIHF1ZXVlLlxuXG5cbiAgICAgICAgbmV3TGFuZXMgPSBtZXJnZUxhbmVzKG5ld0xhbmVzLCB1cGRhdGVMYW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHVwZGF0ZSBpcyBwYXJ0IG9mIGEgcGVuZGluZyBhc3luYyBhY3Rpb24uIElmIHNvLFxuICAgICAgICAvLyB3ZSdsbCBuZWVkIHRvIHN1c3BlbmQgdW50aWwgdGhlIGFjdGlvbiBoYXMgZmluaXNoZWQsIHNvIHRoYXQgaXQnc1xuICAgICAgICAvLyBiYXRjaGVkIHRvZ2V0aGVyIHdpdGggZnV0dXJlIHVwZGF0ZXMgaW4gdGhlIHNhbWUgYWN0aW9uLlxuICAgICAgICBpZiAodXBkYXRlTGFuZSAhPT0gTm9MYW5lICYmIHVwZGF0ZUxhbmUgPT09IHBlZWtFbnRhbmdsZWRBY3Rpb25MYW5lKCkpIHtcbiAgICAgICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdMYXN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfY2xvbmUgPSB7XG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZSBpcyBnb2luZyB0byBiZSBjb21taXR0ZWQgc28gd2UgbmV2ZXIgd2FudCB1bmNvbW1pdFxuICAgICAgICAgICAgLy8gaXQuIFVzaW5nIE5vTGFuZSB3b3JrcyBiZWNhdXNlIDAgaXMgYSBzdWJzZXQgb2YgYWxsIGJpdG1hc2tzLCBzb1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG5ldmVyIGJlIHNraXBwZWQgYnkgdGhlIGNoZWNrIGFib3ZlLlxuICAgICAgICAgICAgbGFuZTogTm9MYW5lLFxuICAgICAgICAgICAgdGFnOiB1cGRhdGUudGFnLFxuICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgICAvLyBXaGVuIHRoaXMgdXBkYXRlIGlzIHJlYmFzZWQsIHdlIHNob3VsZCBub3QgZmlyZSBpdHNcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIGFnYWluLlxuICAgICAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBuZXdMYXN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlLm5leHQgPSBfY2xvbmU7XG4gICAgICAgIH0gLy8gUHJvY2VzcyB0aGlzIHVwZGF0ZS5cblxuXG4gICAgICAgIG5ld1N0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgdXBkYXRlLCBuZXdTdGF0ZSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdXBkYXRlLmNhbGxiYWNrO1xuXG4gICAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IENhbGxiYWNrO1xuXG4gICAgICAgICAgaWYgKGlzSGlkZGVuVXBkYXRlKSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBWaXNpYmlsaXR5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBxdWV1ZS5jYWxsYmFja3M7XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2tzID09PSBudWxsKSB7XG4gICAgICAgICAgICBxdWV1ZS5jYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIHdlIGJhaWwgb3V0IHdoZW4gd2UgZ2V0IGEgbnVsbFxuXG5cbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuXG4gICAgICBpZiAodXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuXG4gICAgICAgIGlmIChwZW5kaW5nUXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhIHJlZHVjZXIuIEFkZCB0aGUgbmV3XG4gICAgICAgICAgLy8gcGVuZGluZyB1cGRhdGVzIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIGtlZXAgcHJvY2Vzc2luZy5cbiAgICAgICAgICB2YXIgX2xhc3RQZW5kaW5nVXBkYXRlID0gcGVuZGluZ1F1ZXVlOyAvLyBJbnRlbnRpb25hbGx5IHVuc291bmQuIFBlbmRpbmcgdXBkYXRlcyBmb3JtIGEgY2lyY3VsYXIgbGlzdCwgYnV0IHdlXG4gICAgICAgICAgLy8gdW5yYXZlbCB0aGVtIHdoZW4gdHJhbnNmZXJyaW5nIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG5cbiAgICAgICAgICB2YXIgX2ZpcnN0UGVuZGluZ1VwZGF0ZSA9IF9sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgICAgICAgIF9sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgICB1cGRhdGUgPSBfZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBuZXdCYXNlU3RhdGU7XG4gICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gbmV3Rmlyc3RCYXNlVXBkYXRlO1xuICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGU7XG5cbiAgICBpZiAoZmlyc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAvLyBgcXVldWUubGFuZXNgIGlzIHVzZWQgZm9yIGVudGFuZ2xpbmcgdHJhbnNpdGlvbnMuIFdlIGNhbiBzZXQgaXQgYmFjayB0b1xuICAgICAgLy8gemVybyBvbmNlIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAgICAgIHF1ZXVlLnNoYXJlZC5sYW5lcyA9IE5vTGFuZXM7XG4gICAgfSAvLyBTZXQgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUgdG8gYmUgd2hhdGV2ZXIgaXMgcmVtYWluaW5nIGluIHRoZSBxdWV1ZS5cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBmaW5lIGJlY2F1c2UgdGhlIG9ubHkgdHdvIG90aGVyIHRoaW5ncyB0aGF0IGNvbnRyaWJ1dGUgdG9cbiAgICAvLyBleHBpcmF0aW9uIHRpbWUgYXJlIHByb3BzIGFuZCBjb250ZXh0LiBXZSdyZSBhbHJlYWR5IGluIHRoZSBtaWRkbGUgb2YgdGhlXG4gICAgLy8gYmVnaW4gcGhhc2UgYnkgdGhlIHRpbWUgd2Ugc3RhcnQgcHJvY2Vzc2luZyB0aGUgcXVldWUsIHNvIHdlJ3ZlIGFscmVhZHlcbiAgICAvLyBkZWFsdCB3aXRoIHRoZSBwcm9wcy4gQ29udGV4dCBpbiBjb21wb25lbnRzIHRoYXQgc3BlY2lmeVxuICAgIC8vIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB0cmlja3k7IGJ1dCB3ZSdsbCBoYXZlIHRvIGFjY291bnQgZm9yXG4gICAgLy8gdGhhdCByZWdhcmRsZXNzLlxuXG5cbiAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKG5ld0xhbmVzKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG5ld0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCAnICsgKFwicmVjZWl2ZWQ6IFwiICsgY2FsbGJhY2spKTtcbiAgfVxuXG4gIGNhbGxiYWNrLmNhbGwoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCkge1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xufVxuZnVuY3Rpb24gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHtcbiAgcmV0dXJuIGhhc0ZvcmNlVXBkYXRlO1xufVxuZnVuY3Rpb24gZGVmZXJIaWRkZW5DYWxsYmFja3ModXBkYXRlUXVldWUpIHtcbiAgLy8gV2hlbiBhbiB1cGRhdGUgZmluaXNoZXMgb24gYSBoaWRkZW4gY29tcG9uZW50LCBpdHMgY2FsbGJhY2sgc2hvdWxkIG5vdFxuICAvLyBiZSBmaXJlZCB1bnRpbC91bmxlc3MgdGhlIGNvbXBvbmVudCBpcyBtYWRlIHZpc2libGUgYWdhaW4uIFN0YXNoIHRoZVxuICAvLyBjYWxsYmFjayBvbiB0aGUgc2hhcmVkIHF1ZXVlIG9iamVjdCBzbyBpdCBjYW4gYmUgZmlyZWQgbGF0ZXIuXG4gIHZhciBuZXdIaWRkZW5DYWxsYmFja3MgPSB1cGRhdGVRdWV1ZS5jYWxsYmFja3M7XG5cbiAgaWYgKG5ld0hpZGRlbkNhbGxiYWNrcyAhPT0gbnVsbCkge1xuICAgIHZhciBleGlzdGluZ0hpZGRlbkNhbGxiYWNrcyA9IHVwZGF0ZVF1ZXVlLnNoYXJlZC5oaWRkZW5DYWxsYmFja3M7XG5cbiAgICBpZiAoZXhpc3RpbmdIaWRkZW5DYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZVF1ZXVlLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPSBuZXdIaWRkZW5DYWxsYmFja3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZVF1ZXVlLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPSBleGlzdGluZ0hpZGRlbkNhbGxiYWNrcy5jb25jYXQobmV3SGlkZGVuQ2FsbGJhY2tzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbW1pdEhpZGRlbkNhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgY29udGV4dCkge1xuICAvLyBUaGlzIGNvbXBvbmVudCBpcyBzd2l0Y2hpbmcgZnJvbSBoaWRkZW4gLT4gdmlzaWJsZS4gQ29tbWl0IGFueSBjYWxsYmFja3NcbiAgLy8gdGhhdCB3ZXJlIHByZXZpb3VzbHkgZGVmZXJyZWQuXG4gIHZhciBoaWRkZW5DYWxsYmFja3MgPSB1cGRhdGVRdWV1ZS5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzO1xuXG4gIGlmIChoaWRkZW5DYWxsYmFja3MgIT09IG51bGwpIHtcbiAgICB1cGRhdGVRdWV1ZS5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBoaWRkZW5DYWxsYmFja3NbaV07XG4gICAgICBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29tbWl0Q2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBjb250ZXh0KSB7XG4gIHZhciBjYWxsYmFja3MgPSB1cGRhdGVRdWV1ZS5jYWxsYmFja3M7XG5cbiAgaWYgKGNhbGxiYWNrcyAhPT0gbnVsbCkge1xuICAgIHVwZGF0ZVF1ZXVlLmNhbGxiYWNrcyA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xuICAgICAgY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChvYmplY3RJcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjdXJyZW50S2V5ID0ga2V5c0FbaV07XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwgY3VycmVudEtleSkgfHwgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBsb3N0IHJlZmluZW1lbnQgb2YgYG9iakJgXG4gICAgIW9iamVjdElzKG9iakFbY3VycmVudEtleV0sIG9iakJbY3VycmVudEtleV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncyA9IHtcbiAgcmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3M6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICBmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gIHJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7fSxcbiAgZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZzogZnVuY3Rpb24gKCkge30sXG4gIGRpc2NhcmRQZW5kaW5nV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG57XG4gIHZhciBmaW5kU3RyaWN0Um9vdCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHZhciBtYXliZVN0cmljdFJvb3QgPSBudWxsO1xuICAgIHZhciBub2RlID0gZmliZXI7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgbWF5YmVTdHJpY3RSb290ID0gbm9kZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZVN0cmljdFJvb3Q7XG4gIH07XG5cbiAgdmFyIHNldFRvU29ydGVkU3RyaW5nID0gZnVuY3Rpb24gKHNldCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycmF5LnNvcnQoKS5qb2luKCcsICcpO1xuICB9O1xuXG4gIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdOyAvLyBUcmFja3MgY29tcG9uZW50cyB3ZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0LlxuXG4gIHZhciBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzID0gbmV3IFNldCgpO1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge1xuICAgIC8vIERlZHVwZSBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG4gICAgaWYgKGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMuXG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUgJiYgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUgJiYgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBXZSBkbyBhbiBpbml0aWFsIHBhc3MgdG8gZ2F0aGVyIGNvbXBvbmVudCBuYW1lc1xuICAgIHZhciBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfSAvLyBGaW5hbGx5LCB3ZSBmbHVzaCBhbGwgdGhlIHdhcm5pbmdzXG4gICAgLy8gVU5TQUZFXyBvbmVzIGJlZm9yZSB0aGUgZGVwcmVjYXRlZCBvbmVzLCBzaW5jZSB0aGV5J2xsIGJlICdsb3VkZXInXG5cblxuICAgIGlmIChVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgc29ydGVkTmFtZXMpO1xuICAgIH1cblxuICAgIGlmIChVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgJyArICdhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgXCIqIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIFwiICsgJ3JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvICcgKyAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kZXJpdmVkLXN0YXRlXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXMpO1xuICAgIH1cblxuICAgIGlmIChVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzMiA9IHNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMpO1xuXG4gICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkICcgKyAnYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXMyKTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbE1vdW50IHRvIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczMpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXM0ID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyBcIiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgcmVmYWN0b3IgeW91ciBcIiArICdjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJyArICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0LmRldi9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nICsgJyogUmVuYW1lIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczQpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXM1ID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbFVwZGF0ZSBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbFVwZGF0ZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzNSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgdmFyIHN0cmljdFJvb3QgPSBmaW5kU3RyaWN0Um9vdChmaWJlcik7XG5cbiAgICBpZiAoc3RyaWN0Um9vdCA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgYSBTdHJpY3RNb2RlIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuXG5cbiAgICBpZiAoZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZ3NGb3JSb290ID0gcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmdldChzdHJpY3RSb290KTtcblxuICAgIGlmIChmaWJlci50eXBlLmNvbnRleHRUeXBlcyAhPSBudWxsIHx8IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbCB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAod2FybmluZ3NGb3JSb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybmluZ3NGb3JSb290ID0gW107XG4gICAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5zZXQoc3RyaWN0Um9vdCwgd2FybmluZ3NGb3JSb290KTtcbiAgICAgIH1cblxuICAgICAgd2FybmluZ3NGb3JSb290LnB1c2goZmliZXIpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlckFycmF5LCBzdHJpY3RSb290KSB7XG4gICAgICBpZiAoZmliZXJBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyc3RGaWJlciA9IGZpYmVyQXJyYXlbMF07XG4gICAgICB2YXIgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICBmaWJlckFycmF5LmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmlyc3RGaWJlcik7XG5cbiAgICAgICAgZXJyb3IoJ0xlZ2FjeSBjb250ZXh0IEFQSSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gYSBzdHJpY3QtbW9kZSB0cmVlLicgKyAnXFxuXFxuVGhlIG9sZCBBUEkgd2lsbCBiZSBzdXBwb3J0ZWQgaW4gYWxsIDE2LnggcmVsZWFzZXMsIGJ1dCBhcHBsaWNhdGlvbnMgJyArICd1c2luZyBpdCBzaG91bGQgbWlncmF0ZSB0byB0aGUgbmV3IHZlcnNpb24uJyArICdcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnICsgJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQnLCBzb3J0ZWROYW1lcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFRoZW5hYmxlc0Zyb21TdGF0ZShzdGF0ZSkge1xuICB7XG4gICAgdmFyIGRldlN0YXRlID0gc3RhdGU7XG4gICAgcmV0dXJuIGRldlN0YXRlLnRoZW5hYmxlcztcbiAgfVxufSAvLyBBbiBlcnJvciB0aGF0IGlzIHRocm93biAoZS5nLiBieSBgdXNlYCkgdG8gdHJpZ2dlciBTdXNwZW5zZS4gSWYgd2Vcbi8vIGRldGVjdCB0aGlzIGlzIGNhdWdodCBieSB1c2Vyc3BhY2UsIHdlJ2xsIGxvZyBhIHdhcm5pbmcgaW4gZGV2ZWxvcG1lbnQuXG5cblxudmFyIFN1c3BlbnNlRXhjZXB0aW9uID0gbmV3IEVycm9yKFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gXCIgKyAnZGV0YWlsIG9mIGB1c2VgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciAnICsgJ3JldGhyb3cgaXQgaW1tZWRpYXRlbHksIG9yIG1vdmUgdGhlIGB1c2VgIGNhbGwgb3V0c2lkZSBvZiB0aGUgJyArICdgdHJ5L2NhdGNoYCBibG9jay4gQ2FwdHVyaW5nIHdpdGhvdXQgcmV0aHJvd2luZyB3aWxsIGxlYWQgdG8gJyArICd1bmV4cGVjdGVkIGJlaGF2aW9yLlxcblxcbicgKyAnVG8gaGFuZGxlIGFzeW5jIGVycm9ycywgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhbiBlcnJvciBib3VuZGFyeSwgb3IgJyArIFwiY2FsbCB0aGUgcHJvbWlzZSdzIGAuY2F0Y2hgIG1ldGhvZCBhbmQgcGFzcyB0aGUgcmVzdWx0IHRvIGB1c2VgXCIpO1xudmFyIFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbiA9IG5ldyBFcnJvcignU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IsIGFuZCBzaG91bGQgbm90IGxlYWsgaW50byAnICsgXCJ1c2Vyc3BhY2UuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgaXQncyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuXCIpOyAvLyBUaGlzIGlzIGEgbm9vcCB0aGVuYWJsZSB0aGF0IHdlIHVzZSB0byB0cmlnZ2VyIGEgZmFsbGJhY2sgaW4gdGhyb3dFeGNlcHRpb24uXG4vLyBUT0RPOiBJdCB3b3VsZCBiZSBiZXR0ZXIgdG8gcmVmYWN0b3IgdGhyb3dFeGNlcHRpb24gaW50byBtdWx0aXBsZSBmdW5jdGlvbnNcbi8vIHNvIHdlIGNhbiB0cmlnZ2VyIGEgZmFsbGJhY2sgZGlyZWN0bHkgd2l0aG91dCBoYXZpbmcgdG8gY2hlY2sgdGhlIHR5cGUuIEJ1dFxuLy8gZm9yIG5vdyB0aGlzIHdpbGwgZG8uXG5cbnZhciBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUgPSB7XG4gIHRoZW46IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEEgbGlzdGVuZXIgd2FzIHVuZXhwZWN0ZWRseSBhdHRhY2hlZCB0byBhICcgKyAnXCJub29wXCIgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVRoZW5hYmxlU3RhdGUoKSB7XG4gIC8vIFRoZSBUaGVuYWJsZVN0YXRlIGlzIGNyZWF0ZWQgdGhlIGZpcnN0IHRpbWUgYSBjb21wb25lbnQgc3VzcGVuZHMuIElmIGl0XG4gIC8vIHN1c3BlbmRzIGFnYWluLCB3ZSdsbCByZXVzZSB0aGUgc2FtZSBzdGF0ZS5cbiAge1xuICAgIHJldHVybiB7XG4gICAgICBkaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2U6IGZhbHNlLFxuICAgICAgdGhlbmFibGVzOiBbXVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVGhlbmFibGVSZXNvbHZlZCh0aGVuYWJsZSkge1xuICB2YXIgc3RhdHVzID0gdGhlbmFibGUuc3RhdHVzO1xuICByZXR1cm4gc3RhdHVzID09PSAnZnVsZmlsbGVkJyB8fCBzdGF0dXMgPT09ICdyZWplY3RlZCc7XG59XG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5cbmZ1bmN0aW9uIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCkge1xuICBpZiAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgIT09IG51bGwpIHtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5kaWRVc2VQcm9taXNlID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciB0cmFja2VkVGhlbmFibGVzID0gZ2V0VGhlbmFibGVzRnJvbVN0YXRlKHRoZW5hYmxlU3RhdGUpO1xuICB2YXIgcHJldmlvdXMgPSB0cmFja2VkVGhlbmFibGVzW2luZGV4XTtcblxuICBpZiAocHJldmlvdXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHRyYWNrZWRUaGVuYWJsZXMucHVzaCh0aGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByZXZpb3VzICE9PSB0aGVuYWJsZSkge1xuICAgICAgLy8gUmV1c2UgdGhlIHByZXZpb3VzIHRoZW5hYmxlLCBhbmQgZHJvcCB0aGUgbmV3IG9uZS4gV2UgY2FuIGFzc3VtZVxuICAgICAgLy8gdGhleSByZXByZXNlbnQgdGhlIHNhbWUgdmFsdWUsIGJlY2F1c2UgY29tcG9uZW50cyBhcmUgaWRlbXBvdGVudC5cbiAgICAgIHtcbiAgICAgICAgdmFyIHRoZW5hYmxlU3RhdGVEZXYgPSB0aGVuYWJsZVN0YXRlO1xuXG4gICAgICAgIGlmICghdGhlbmFibGVTdGF0ZURldi5kaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2UpIHtcbiAgICAgICAgICAvLyBXZSBzaG91bGQgb25seSB3YXJuIHRoZSBmaXJzdCB0aW1lIGFuIHVuY2FjaGVkIHRoZW5hYmxlIGlzXG4gICAgICAgICAgLy8gZGlzY292ZXJlZCBwZXIgY29tcG9uZW50LCBiZWNhdXNlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSwgdGhlXG4gICAgICAgICAgLy8gc3Vic2VxdWVudCBvbmVzIGFyZSBsaWtlbHkgZGVyaXZlZCBmcm9tIHRoZSBmaXJzdC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFdlIHRyYWNrIHRoaXMgb24gdGhlIHRoZW5hYmxlU3RhdGUgaW5zdGVhZCBvZiBkZWR1cGluZyB1c2luZyB0aGVcbiAgICAgICAgICAvLyBjb21wb25lbnQgbmFtZSBsaWtlIHdlIHVzdWFsbHkgZG8sIGJlY2F1c2UgaW4gdGhlIGNhc2Ugb2YgYVxuICAgICAgICAgIC8vIHByb21pc2UtYXMtUmVhY3Qtbm9kZSwgdGhlIG93bmVyIGNvbXBvbmVudCBpcyBsaWtlbHkgZGlmZmVyZW50IGZyb21cbiAgICAgICAgICAvLyB0aGUgcGFyZW50IHRoYXQncyBjdXJyZW50bHkgYmVpbmcgcmVjb25jaWxlZC4gV2UnZCBoYXZlIHRvIHRyYWNrXG4gICAgICAgICAgLy8gdGhlIG93bmVyIHVzaW5nIHN0YXRlLCB3aGljaCB3ZSdyZSB0cnlpbmcgdG8gbW92ZSBhd2F5IGZyb20uIFRob3VnaFxuICAgICAgICAgIC8vIHNpbmNlIHRoaXMgaXMgZGV2LW9ubHksIG1heWJlIHRoYXQnZCBiZSBPSy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEhvd2V2ZXIsIGFub3RoZXIgYmVuZWZpdCBvZiBkb2luZyBpdCB0aGlzIHdheSBpcyB3ZSBtaWdodFxuICAgICAgICAgIC8vIGV2ZW50dWFsbHkgaGF2ZSBhIHRoZW5hYmxlU3RhdGUgcGVyIG1lbW8vRm9yZ2V0IGJvdW5kYXJ5IGluc3RlYWRcbiAgICAgICAgICAvLyBvZiBwZXIgY29tcG9uZW50LCBzbyB0aGlzIHdvdWxkIGFsbG93IHVzIHRvIGhhdmUgbW9yZVxuICAgICAgICAgIC8vIGdyYW51bGFyIHdhcm5pbmdzLlxuICAgICAgICAgIHRoZW5hYmxlU3RhdGVEZXYuZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlID0gdHJ1ZTsgLy8gVE9ETzogVGhpcyB3YXJuaW5nIHNob3VsZCBsaW5rIHRvIGEgY29ycmVzcG9uZGluZyBkb2NzIHBhZ2UuXG5cbiAgICAgICAgICBlcnJvcignQSBjb21wb25lbnQgd2FzIHN1c3BlbmRlZCBieSBhbiB1bmNhY2hlZCBwcm9taXNlLiBDcmVhdGluZyAnICsgJ3Byb21pc2VzIGluc2lkZSBhIENsaWVudCBDb21wb25lbnQgb3IgaG9vayBpcyBub3QgeWV0ICcgKyAnc3VwcG9ydGVkLCBleGNlcHQgdmlhIGEgU3VzcGVuc2UtY29tcGF0aWJsZSBsaWJyYXJ5IG9yIGZyYW1ld29yay4nKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBBdm9pZCBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uIGVycm9ycyBmb3IgdGhlIFByb21pc2VzIHRoYXQgd2UnbGxcbiAgICAgIC8vIGludGVudGlvbmFsbHkgaWdub3JlLlxuXG5cbiAgICAgIHRoZW5hYmxlLnRoZW4obm9vcCQxLCBub29wJDEpO1xuICAgICAgdGhlbmFibGUgPSBwcmV2aW91cztcbiAgICB9XG4gIH0gLy8gV2UgdXNlIGFuIGV4cGFuZG8gdG8gdHJhY2sgdGhlIHN0YXR1cyBhbmQgcmVzdWx0IG9mIGEgdGhlbmFibGUgc28gdGhhdCB3ZVxuICAvLyBjYW4gc3luY2hyb25vdXNseSB1bndyYXAgdGhlIHZhbHVlLiBUaGluayBvZiB0aGlzIGFzIGFuIGV4dGVuc2lvbiBvZiB0aGVcbiAgLy8gUHJvbWlzZSBBUEksIG9yIGEgY3VzdG9tIGludGVyZmFjZSB0aGF0IGlzIGEgc3VwZXJzZXQgb2YgVGhlbmFibGUuXG4gIC8vXG4gIC8vIElmIHRoZSB0aGVuYWJsZSBkb2Vzbid0IGhhdmUgYSBzdGF0dXMsIHNldCBpdCB0byBcInBlbmRpbmdcIiBhbmQgYXR0YWNoXG4gIC8vIGEgbGlzdGVuZXIgdGhhdCB3aWxsIHVwZGF0ZSBpdHMgc3RhdHVzIGFuZCByZXN1bHQgd2hlbiBpdCByZXNvbHZlcy5cblxuXG4gIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgY2FzZSAnZnVsZmlsbGVkJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZ1bGZpbGxlZFZhbHVlID0gdGhlbmFibGUudmFsdWU7XG4gICAgICAgIHJldHVybiBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHJlamVjdGVkRXJyb3IgPSB0aGVuYWJsZS5yZWFzb247XG4gICAgICAgIGNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoKHJlamVjdGVkRXJyb3IpO1xuICAgICAgICB0aHJvdyByZWplY3RlZEVycm9yO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGVuYWJsZS5zdGF0dXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gT25seSBpbnN0cnVtZW50IHRoZSB0aGVuYWJsZSBpZiB0aGUgc3RhdHVzIGlmIG5vdCBkZWZpbmVkLiBJZlxuICAgICAgICAgIC8vIGl0J3MgZGVmaW5lZCwgYnV0IGFuIHVua25vd24gdmFsdWUsIGFzc3VtZSBpdCdzIGJlZW4gaW5zdHJ1bWVudGVkIGJ5XG4gICAgICAgICAgLy8gc29tZSBjdXN0b20gdXNlcnNwYWNlIGltcGxlbWVudGF0aW9uLiBXZSB0cmVhdCBpdCBhcyBcInBlbmRpbmdcIi5cbiAgICAgICAgICAvLyBBdHRhY2ggYSBkdW1teSBsaXN0ZW5lciwgdG8gZW5zdXJlIHRoYXQgYW55IGxhenkgaW5pdGlhbGl6YXRpb24gY2FuXG4gICAgICAgICAgLy8gaGFwcGVuLiBGbGlnaHQgbGF6aWx5IHBhcnNlcyBKU09OIHdoZW4gdGhlIHZhbHVlIGlzIGFjdHVhbGx5IGF3YWl0ZWQuXG4gICAgICAgICAgdGhlbmFibGUudGhlbihub29wJDEsIG5vb3AkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhbiB1bmNhY2hlZCB0aGVuYWJsZSB0aGF0IHdlIGhhdmVuJ3Qgc2VlbiBiZWZvcmUuXG4gICAgICAgICAgLy8gRGV0ZWN0IGluZmluaXRlIHBpbmcgbG9vcHMgY2F1c2VkIGJ5IHVuY2FjaGVkIHByb21pc2VzLlxuICAgICAgICAgIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCAmJiByb290LnNoZWxsU3VzcGVuZENvdW50ZXIgPiAxMDApIHtcbiAgICAgICAgICAgIC8vIFRoaXMgcm9vdCBoYXMgc3VzcGVuZGVkIHJlcGVhdGVkbHkgaW4gdGhlIHNoZWxsIHdpdGhvdXQgbWFraW5nIGFueVxuICAgICAgICAgICAgLy8gcHJvZ3Jlc3MgKGkuZS4gY29tbWl0dGluZyBzb21ldGhpbmcpLiBUaGlzIGlzIGhpZ2hseSBzdWdnZXN0aXZlIG9mXG4gICAgICAgICAgICAvLyBhbiBpbmZpbml0ZSBwaW5nIGxvb3AsIG9mdGVuIGNhdXNlZCBieSBhbiBhY2NpZGVudGFsIEFzeW5jIENsaWVudFxuICAgICAgICAgICAgLy8gQ29tcG9uZW50LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIER1cmluZyBhIHRyYW5zaXRpb24sIHdlIGNhbiBzdXNwZW5kIHRoZSB3b3JrIGxvb3AgdW50aWwgdGhlIHByb21pc2VcbiAgICAgICAgICAgIC8vIHRvIHJlc29sdmUsIGJ1dCB0aGlzIGlzIGEgc3luYyByZW5kZXIsIHNvIHRoYXQncyBub3QgYW4gb3B0aW9uLiBXZVxuICAgICAgICAgICAgLy8gYWxzbyBjYW4ndCBzaG93IGEgZmFsbGJhY2ssIGJlY2F1c2Ugbm9uZSB3YXMgcHJvdmlkZWQuIFNvIG91ciBsYXN0XG4gICAgICAgICAgICAvLyByZXNvcnQgaXMgdG8gdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgZXJyb3IgaW4gYSBmdXR1cmUgcmVsZWFzZS4gT3RoZXIgd2F5cyBvZiBoYW5kbGluZ1xuICAgICAgICAgICAgLy8gdGhpcyBjYXNlIGluY2x1ZGUgZm9yY2luZyBhIGNvbmN1cnJlbnQgcmVuZGVyLCBvciBwdXR0aW5nIHRoZSB3aG9sZVxuICAgICAgICAgICAgLy8gcm9vdCBpbnRvIG9mZnNjcmVlbiBtb2RlLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3luYy9hd2FpdCBpcyBub3QgeWV0IHN1cHBvcnRlZCBpbiBDbGllbnQgQ29tcG9uZW50cywgb25seSAnICsgJ1NlcnZlciBDb21wb25lbnRzLiBUaGlzIGVycm9yIGlzIG9mdGVuIGNhdXNlZCBieSBhY2NpZGVudGFsbHkgJyArIFwiYWRkaW5nIGAndXNlIGNsaWVudCdgIHRvIGEgbW9kdWxlIHRoYXQgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBcIiArICdmb3IgdGhlIHNlcnZlci4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGVuZGluZ1RoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgcGVuZGluZ1RoZW5hYmxlLnN0YXR1cyA9ICdwZW5kaW5nJztcbiAgICAgICAgICBwZW5kaW5nVGhlbmFibGUudGhlbihmdW5jdGlvbiAoZnVsZmlsbGVkVmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUuc3RhdHVzID0gJ2Z1bGZpbGxlZCc7XG4gICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodGhlbmFibGUuc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5zdGF0dXMgPSAncmVqZWN0ZWQnO1xuICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIENoZWNrIG9uZSBtb3JlIHRpbWUgaW4gY2FzZSB0aGUgdGhlbmFibGUgcmVzb2x2ZWQgc3luY2hyb25vdXNseS5cblxuXG4gICAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSAnZnVsZmlsbGVkJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWRUaGVuYWJsZS52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgdmFyIF9yZWplY3RlZEVycm9yID0gcmVqZWN0ZWRUaGVuYWJsZS5yZWFzb247XG4gICAgICAgICAgICAgIGNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoKF9yZWplY3RlZEVycm9yKTtcbiAgICAgICAgICAgICAgdGhyb3cgX3JlamVjdGVkRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gU3VzcGVuZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhyb3dpbmcgaGVyZSBpcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgdGhhdCBhbGxvd3MgdXMgdG8gdW53aW5kIHRoZVxuICAgICAgICAvLyBjYWxsIHN0YWNrLiBCdXQgd2Ugc2hvdWxkbid0IGFsbG93IGl0IHRvIGxlYWsgaW50byB1c2Vyc3BhY2UuIFRocm93IGFuXG4gICAgICAgIC8vIG9wYXF1ZSBwbGFjZWhvbGRlciB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSBhY3R1YWwgdGhlbmFibGUuIElmIGl0IGRvZXNuJ3RcbiAgICAgICAgLy8gZ2V0IGNhcHR1cmVkIGJ5IHRoZSB3b3JrIGxvb3AsIGxvZyBhIHdhcm5pbmcsIGJlY2F1c2UgdGhhdCBtZWFuc1xuICAgICAgICAvLyBzb21ldGhpbmcgaW4gdXNlcnNwYWNlIG11c3QgaGF2ZSBjYXVnaHQgaXQuXG5cblxuICAgICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBTdXNwZW5zZUV4Y2VwdGlvbjtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3VzcGVuZENvbW1pdCgpIHtcbiAgLy8gVGhpcyBleHRyYSBpbmRpcmVjdGlvbiBvbmx5IGV4aXN0cyBzbyBpdCBjYW4gaGFuZGxlIHBhc3NpbmdcbiAgLy8gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlIHRocm91Z2ggdG8gdGhyb3dFeGNlcHRpb24uXG4gIC8vIFRPRE86IEZhY3RvciB0aGUgdGhlbmFibGUgY2hlY2sgb3V0IG9mIHRocm93RXhjZXB0aW9uXG4gIHN1c3BlbmRlZFRoZW5hYmxlID0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlO1xuICB0aHJvdyBTdXNwZW5zZXlDb21taXRFeGNlcHRpb247XG59IC8vIFRoaXMgaXMgdXNlZCB0byB0cmFjayB0aGUgYWN0dWFsIHRoZW5hYmxlIHRoYXQgc3VzcGVuZGVkIHNvIGl0IGNhbiBiZVxuLy8gcGFzc2VkIHRvIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiDigJQgd2hpY2gsIGZvciBoaXN0b3JpY2FsXG4vLyByZWFzb25zLCBleHBlY3RzIHRvIHJlY2VpdmUgYSB0aGVuYWJsZS5cblxudmFyIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbnZhciBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIGB1c2VgIHN1c3BlbmRzIGJ5IHRocm93aW5nIGFuIGV4Y2VwdGlvbi4gYHVzZWBcbiAgLy8gdGhyb3dzIGFuIG9wYXF1ZSB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSB0aGVuYWJsZSBpdHNlbGYgc28gdGhhdCBpdCBjYW4ndCBiZVxuICAvLyBjYXVnaHQgaW4gdXNlcnNwYWNlLiBUaGVuIHRoZSB3b3JrIGxvb3AgYWNjZXNzZXMgdGhlIGFjdHVhbCB0aGVuYWJsZSB1c2luZ1xuICAvLyB0aGlzIGZ1bmN0aW9uLlxuICBpZiAoc3VzcGVuZGVkVGhlbmFibGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgc3VzcGVuZGVkIHRoZW5hYmxlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSAnICsgJ2FuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIHRoZW5hYmxlID0gc3VzcGVuZGVkVGhlbmFibGU7XG4gIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcblxuICB7XG4gICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0aGVuYWJsZTtcbn1cbmZ1bmN0aW9uIGNoZWNrSWZVc2VXcmFwcGVkSW5UcnlDYXRjaCgpIHtcbiAge1xuICAgIC8vIFRoaXMgd2FzIHNldCByaWdodCBiZWZvcmUgU3VzcGVuc2VFeGNlcHRpb24gd2FzIHRocm93biwgYW5kIGl0IHNob3VsZFxuICAgIC8vIGhhdmUgYmVlbiBjbGVhcmVkIHdoZW4gdGhlIGV4Y2VwdGlvbiB3YXMgaGFuZGxlZC4gSWYgaXQgd2Fzbid0LFxuICAgIC8vIGl0IG11c3QgaGF2ZSBiZWVuIGNhdWdodCBieSB1c2Vyc3BhY2UuXG4gICAgaWYgKG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWKSB7XG4gICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2gocmVqZWN0ZWRSZWFzb24pIHtcbiAgLy8gVGhpcyBjaGVjayBydW5zIGluIHByb2QsIHRvbywgYmVjYXVzZSBpdCBwcmV2ZW50cyBhIG1vcmUgY29uZnVzaW5nXG4gIC8vIGRvd25zdHJlYW0gZXJyb3IsIHdoZXJlIFN1c3BlbnNlRXhjZXB0aW9uIGlzIGNhdWdodCBieSBhIHByb21pc2UgYW5kXG4gIC8vIHRocm93biBhc3luY2hyb25vdXNseS5cbiAgLy8gVE9ETzogQW5vdGhlciB3YXkgdG8gcHJldmVudCBTdXNwZW5zZUV4Y2VwdGlvbiBmcm9tIGxlYWtpbmcgaW50byBhbiBhc3luY1xuICAvLyBleGVjdXRpb24gY29udGV4dCBpcyB0byBjaGVjayB0aGUgZGlzcGF0Y2hlciBldmVyeSB0aW1lIGB1c2VgIGlzIGNhbGxlZCxcbiAgLy8gb3Igc29tZSBlcXVpdmFsZW50LiBUaGF0IG1pZ2h0IGJlIHByZWZlcmFibGUgZm9yIG90aGVyIHJlYXNvbnMsIHRvbywgc2luY2VcbiAgLy8gaXQgbWF0Y2hlcyBob3cgd2UgcHJldmVudCBzaW1pbGFyIG1pc3Rha2VzIGZvciBvdGhlciBob29rcy5cbiAgaWYgKHJlamVjdGVkUmVhc29uID09PSBTdXNwZW5zZUV4Y2VwdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignSG9va3MgYXJlIG5vdCBzdXBwb3J0ZWQgaW5zaWRlIGFuIGFzeW5jIGNvbXBvbmVudC4gVGhpcyAnICsgXCJlcnJvciBpcyBvZnRlbiBjYXVzZWQgYnkgYWNjaWRlbnRhbGx5IGFkZGluZyBgJ3VzZSBjbGllbnQnYCBcIiArICd0byBhIG1vZHVsZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gZm9yIHRoZSBzZXJ2ZXIuJyk7XG4gIH1cbn1cblxudmFyIHRoZW5hYmxlU3RhdGUkMSA9IG51bGw7XG52YXIgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG5cbmZ1bmN0aW9uIG1lcmdlRGVidWdJbmZvKG91dGVyLCBpbm5lcikge1xuXG4gIGlmIChpbm5lciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG91dGVyO1xuICB9IGVsc2UgaWYgKG91dGVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGlubmVyO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHdlIGhhdmUgdHdvIGRlYnVnSW5mbywgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgb25lLiBUaGlzIG1ha2VzIHRoZSBhcnJheSBubyBsb25nZXJcbiAgICAvLyBsaXZlIHNvIHdlJ2xsIG1pc3MgYW55IGZ1dHVyZSB1cGRhdGVzIGlmIHdlIHJlY2VpdmVkIG1vcmUgc28gaWRlYWxseSB3ZSBzaG91bGQgYWx3YXlzXG4gICAgLy8gZG8gdGhpcyBhZnRlciBib3RoIGhhdmUgZnVsbHkgcmVzb2x2ZWQvdW5zdXNwZW5kZWQuXG4gICAgcmV0dXJuIG91dGVyLmNvbmNhdChpbm5lcik7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5BYm91dE1hcHM7XG52YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycztcbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmc7XG52YXIgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nO1xudmFyIG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmc7XG5cbnZhciB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCwgcmV0dXJuRmliZXIpIHt9O1xuXG57XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuICBvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nID0ge307XG5cbiAgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQsIHJldHVybkZpYmVyKSB7XG4gICAgaWYgKGNoaWxkID09PSBudWxsIHx8IHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCAoY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCB8fCBjaGlsZC5rZXkgIT0gbnVsbCkgJiYgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCAhPT0gMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2hpbGQuX3N0b3JlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSB1bmFibGUgdG8gbmFycm93IHR5cGUgZnJvbSBtaXhlZCB0byB3cml0YWJsZSBvYmplY3RcblxuXG4gICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IDE7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKTtcbiAgICB2YXIgY29tcG9uZW50S2V5ID0gY29tcG9uZW50TmFtZSB8fCAnbnVsbCc7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2NvbXBvbmVudEtleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50S2V5XSA9IHRydWU7XG4gICAgdmFyIGNoaWxkT3duZXIgPSBjaGlsZC5fb3duZXI7XG4gICAgdmFyIHBhcmVudE93bmVyID0gcmV0dXJuRmliZXIuX2RlYnVnT3duZXI7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnJztcblxuICAgIGlmIChwYXJlbnRPd25lciAmJiB0eXBlb2YgcGFyZW50T3duZXIudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHBhcmVudE93bmVyKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY3VycmVudENvbXBvbmVudEVycm9ySW5mbykge1xuICAgICAgaWYgKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH0gLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG5cbiAgICB2YXIgY2hpbGRPd25lckFwcGVuZGl4ID0gJyc7XG5cbiAgICBpZiAoY2hpbGRPd25lciAhPSBudWxsICYmIHBhcmVudE93bmVyICE9PSBjaGlsZE93bmVyKSB7XG4gICAgICB2YXIgb3duZXJOYW1lID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiBjaGlsZE93bmVyLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgb3duZXJOYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjaGlsZE93bmVyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkT3duZXIubmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3duZXJOYW1lID0gY2hpbGRPd25lci5uYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgICBjaGlsZE93bmVyQXBwZW5kaXggPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIG93bmVyTmFtZSArIFwiLlwiO1xuICAgICAgfVxuICAgIH0gLy8gV2UgY3JlYXRlIGEgZmFrZSBGaWJlciBmb3IgdGhlIGNoaWxkIHRvIGxvZyB0aGUgc3RhY2sgdHJhY2UgZnJvbS5cbiAgICAvLyBUT0RPOiBSZWZhY3RvciB0aGUgd2FybkZvck1pc3NpbmdLZXkgY2FsbHMgdG8gaGFwcGVuIGFmdGVyIGZpYmVyIGNyZWF0aW9uXG4gICAgLy8gc28gdGhhdCB3ZSBjYW4gZ2V0IGFjY2VzcyB0byB0aGUgZmliZXIgdGhhdCB3aWxsIGV2ZW50dWFsbHkgYmUgY3JlYXRlZC5cbiAgICAvLyBUaGF0IHdheSB0aGUgbG9nIGNhbiBzaG93IHVwIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmlnaHQgaW5zdGFuY2UgaW4gRGV2VG9vbHMuXG5cblxuICAgIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoY2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIDApO1xuICAgIGZpYmVyLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHZhciBwcmV2RGVidWdGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpO1xuICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lckFwcGVuZGl4KTtcblxuICAgIHNldEN1cnJlbnRGaWJlcihwcmV2RGVidWdGaWJlcik7XG4gIH07XG59IC8vIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuLy8gV2UgZG8gdGhpcyBoZXJlIGluc3RlYWQgb2YgQmVnaW5Xb3JrIGJlY2F1c2UgdGhlIEZyYWdtZW50IGZpYmVyIGRvZXNuJ3QgaGF2ZVxuLy8gdGhlIHdob2xlIHByb3BzIG9iamVjdCwgb25seSB0aGUgY2hpbGRyZW4gYW5kIGlzIHNoYXJlZCB3aXRoIGFycmF5cy5cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCwgZmliZXIsIHJldHVybkZpYmVyKSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIEZvciB1bmtleWVkIHJvb3QgZnJhZ21lbnRzIHRoZXJlJ3Mgbm8gRmliZXIuIFdlIGNyZWF0ZSBhIGZha2Ugb25lIGp1c3QgZm9yXG4gICAgICAgICAgLy8gZXJyb3Igc3RhY2sgaGFuZGxpbmcuXG4gICAgICAgICAgZmliZXIgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIDApO1xuICAgICAgICAgIGZpYmVyLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZXZEZWJ1Z0ZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihwcmV2RGVidWdGaWJlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSkge1xuICB2YXIgaW5kZXggPSB0aGVuYWJsZUluZGV4Q291bnRlciQxO1xuICB0aGVuYWJsZUluZGV4Q291bnRlciQxICs9IDE7XG5cbiAgaWYgKHRoZW5hYmxlU3RhdGUkMSA9PT0gbnVsbCkge1xuICAgIHRoZW5hYmxlU3RhdGUkMSA9IGNyZWF0ZVRoZW5hYmxlU3RhdGUoKTtcbiAgfVxuXG4gIHJldHVybiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlJDEsIHRoZW5hYmxlLCBpbmRleCk7XG59XG5cbmZ1bmN0aW9uIGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGVsZW1lbnQpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyBhIHRlbXBvcmFyeSwgaW50ZXJtZWRpYXRlIHN0ZXAuIFdoZW4gZW5hYmxlUmVmQXNQcm9wIGlzIG9uLFxuICAgIC8vIHdlIHNob3VsZCByZXNvbHZlIHRoZSBgcmVmYCBwcm9wIGR1cmluZyB0aGUgYmVnaW4gcGhhc2Ugb2YgdGhlIGNvbXBvbmVudFxuICAgIC8vIGl0J3MgYXR0YWNoZWQgdG8gKEhvc3RDb21wb25lbnQsIENsYXNzQ29tcG9uZW50LCBldGMpLlxuICAgIHZhciByZWZQcm9wID0gZWxlbWVudC5wcm9wcy5yZWY7XG4gICAgcmVmID0gcmVmUHJvcCAhPT0gdW5kZWZpbmVkID8gcmVmUHJvcCA6IG51bGw7XG4gIH0gLy8gVE9ETzogSWYgZW5hYmxlUmVmQXNQcm9wIGlzIG9uLCB3ZSBzaG91bGRuJ3QgdXNlIHRoZSBgcmVmYCBmaWVsZC4gV2VcbiAgLy8gc2hvdWxkIGFsd2F5cyByZWFkIHRoZSByZWYgZnJvbSB0aGUgcHJvcC5cblxuXG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IHJlZjtcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgUmVhY3QgRWxlbWVudCBmcm9tIGFuIG9sZGVyIHZlcnNpb24gb2YgUmVhY3Qgd2FzIHJlbmRlcmVkLiAnICsgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZC4gSXQgY2FuIGhhcHBlbiBpZjpcXG4nICsgJy0gTXVsdGlwbGUgY29waWVzIG9mIHRoZSBcInJlYWN0XCIgcGFja2FnZSBpcyB1c2VkLlxcbicgKyAnLSBBIGxpYnJhcnkgcHJlLWJ1bmRsZWQgYW4gb2xkIGNvcHkgb2YgXCJyZWFjdFwiIG9yIFwicmVhY3QvanN4LXJ1bnRpbWVcIi5cXG4nICsgJy0gQSBjb21waWxlciB0cmllcyB0byBcImlubGluZVwiIEpTWCBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBydW50aW1lLicpO1xuICB9IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cblxuXG4gIHZhciBjaGlsZFN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCk7XG4gIHRocm93IG5ldyBFcnJvcihcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRTdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbignLCAnKSArICd9JyA6IGNoaWxkU3RyaW5nKSArIFwiKS4gXCIgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyk7XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgaW52YWxpZENoaWxkKSB7XG4gIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgaWYgKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1twYXJlbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1twYXJlbnROYW1lXSA9IHRydWU7XG4gICAgdmFyIG5hbWUgPSBpbnZhbGlkQ2hpbGQuZGlzcGxheU5hbWUgfHwgaW52YWxpZENoaWxkLm5hbWUgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICBpZiAocmV0dXJuRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgZXJyb3IoJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gJXMgaW5zdGVhZCBvZiA8JXMgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXFxuJyArICcgIHJvb3QucmVuZGVyKCVzKScsIG5hbWUsIG5hbWUsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcignRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiAlcyBpbnN0ZWFkIG9mIDwlcyAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC5cXG4nICsgJyAgPCVzPnslc308LyVzPicsIG5hbWUsIG5hbWUsIHBhcmVudE5hbWUsIG5hbWUsIHBhcmVudE5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBpbnZhbGlkQ2hpbGQpIHtcbiAge1xuICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICBpZiAob3duZXJIYXNTeW1ib2xUeXBlV2FybmluZ1twYXJlbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gPSB0cnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuICAgIHZhciBuYW1lID0gU3RyaW5nKGludmFsaWRDaGlsZCk7XG5cbiAgICBpZiAocmV0dXJuRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgZXJyb3IoJ1N5bWJvbHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLlxcbicgKyAnICByb290LnJlbmRlciglcyknLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoJ1N5bWJvbHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLlxcbicgKyAnICA8JXM+JXM8LyVzPicsIHBhcmVudE5hbWUsIG5hbWUsIHBhcmVudE5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlTGF6eShsYXp5VHlwZSkge1xuICB2YXIgcGF5bG9hZCA9IGxhenlUeXBlLl9wYXlsb2FkO1xuICB2YXIgaW5pdCA9IGxhenlUeXBlLl9pbml0O1xuICByZXR1cm4gaW5pdChwYXlsb2FkKTtcbn0gLy8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGV4aXN0cyBiZWNhdXNlIEkgZXhwZWN0IHRvIGNsb25lIHRoZSBjb2RlIGluIGVhY2ggcGF0aFxuLy8gdG8gYmUgYWJsZSB0byBvcHRpbWl6ZSBlYWNoIHBhdGggaW5kaXZpZHVhbGx5IGJ5IGJyYW5jaGluZyBlYXJseS4gVGhpcyBuZWVkc1xuLy8gYSBjb21waWxlciBvciB3ZSBjYW4gZG8gaXQgbWFudWFsbHkuIEhlbHBlcnMgdGhhdCBkb24ndCBuZWVkIHRoaXMgYnJhbmNoaW5nXG4vLyBsaXZlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cblxuXG5mdW5jdGlvbiBjcmVhdGVDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2NoaWxkVG9EZWxldGVdO1xuICAgICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRpb25zLnB1c2goY2hpbGRUb0RlbGV0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4gICAgLy8gYXNzdW1pbmcgdGhhdCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgd2UndmUgYWxyZWFkeSBhZGRlZCBldmVyeXRoaW5nLlxuXG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkVG9EZWxldGUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIC8vIEFkZCB0aGUgcmVtYWluaW5nIGNoaWxkcmVuIHRvIGEgdGVtcG9yYXJ5IG1hcCBzbyB0aGF0IHdlIGNhbiBmaW5kIHRoZW0gYnlcbiAgICAvLyBrZXlzIHF1aWNrbHkuIEltcGxpY2l0IChudWxsKSBrZXlzIGdldCBhZGRlZCB0byB0aGlzIHNldCB3aXRoIHRoZWlyIGluZGV4XG4gICAgLy8gaW5zdGVhZC5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICB2YXIgZXhpc3RpbmdDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGV4aXN0aW5nQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChleGlzdGluZ0NoaWxkLmtleSAhPT0gbnVsbCkge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmtleSwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmluZGV4LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH1cblxuICAgICAgZXhpc3RpbmdDaGlsZCA9IGV4aXN0aW5nQ2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICByZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLCBwZW5kaW5nUHJvcHMpIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgc2V0IHNpYmxpbmcgdG8gbnVsbCBhbmQgaW5kZXggdG8gMCBoZXJlIGJlY2F1c2UgaXQgaXMgZWFzeVxuICAgIC8vIHRvIGZvcmdldCB0byBkbyBiZWZvcmUgcmV0dXJuaW5nIGl0LiBFLmcuIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuXG4gICAgdmFyIGNsb25lID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZmliZXIsIHBlbmRpbmdQcm9wcyk7XG4gICAgY2xvbmUuaW5kZXggPSAwO1xuICAgIGNsb25lLnNpYmxpbmcgPSBudWxsO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuXG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBEdXJpbmcgaHlkcmF0aW9uLCB0aGUgdXNlSWQgYWxnb3JpdGhtIG5lZWRzIHRvIGtub3cgd2hpY2ggZmliZXJzIGFyZVxuICAgICAgLy8gcGFydCBvZiBhIGxpc3Qgb2YgY2hpbGRyZW4gKGFycmF5cywgaXRlcmF0b3JzKS5cbiAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IEZvcmtlZDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnQgPSBuZXdGaWJlci5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZEluZGV4ID0gY3VycmVudC5pbmRleDtcblxuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5mbGFncyB8PSBQbGFjZW1lbnQgfCBQbGFjZW1lbnRERVY7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5mbGFncyB8PSBQbGFjZW1lbnQgfCBQbGFjZW1lbnRERVY7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcbiAgICAvLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdGaWJlci5mbGFncyB8PSBQbGFjZW1lbnQgfCBQbGFjZW1lbnRERVY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0ZpYmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnQsIHRleHRDb250ZW50LCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAge1xuICAgICAgICBjcmVhdGVkLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgdmFyIGVsZW1lbnRUeXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YXIgdXBkYXRlZCA9IHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LnByb3BzLmNoaWxkcmVuLCBsYW5lcywgZWxlbWVudC5rZXksIGRlYnVnSW5mbyk7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCwgdXBkYXRlZCwgcmV0dXJuRmliZXIpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjdXJyZW50LmVsZW1lbnRUeXBlID09PSBlbGVtZW50VHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGN1cnJlbnQsIGVsZW1lbnQpICkgfHwgLy8gTGF6eSB0eXBlcyBzaG91bGQgcmVjb25jaWxlIHRoZWlyIHJlc29sdmVkIHR5cGUuXG4gICAgICAvLyBXZSBuZWVkIHRvIGRvIHRoaXMgYWZ0ZXIgdGhlIEhvdCBSZWxvYWRpbmcgY2hlY2sgYWJvdmUsXG4gICAgICAvLyBiZWNhdXNlIGhvdCByZWxvYWRpbmcgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgdGhhbiBwcm9kIGJlY2F1c2VcbiAgICAgIC8vIGl0IGRvZXNuJ3QgcmVzdXNwZW5kLiBTbyB3ZSBjYW4ndCBsZXQgdGhlIGNhbGwgYmVsb3cgc3VzcGVuZC5cbiAgICAgIHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwgJiYgZWxlbWVudFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJiByZXNvbHZlTGF6eShlbGVtZW50VHlwZSkgPT09IGN1cnJlbnQudHlwZSkge1xuICAgICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGVsZW1lbnQucHJvcHMpO1xuICAgICAgICBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIGV4aXN0aW5nLCBlbGVtZW50KTtcbiAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAge1xuICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgZXhpc3RpbmcuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH1cbiAgICB9IC8vIEluc2VydFxuXG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgY3JlYXRlZCwgZWxlbWVudCk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgIHtcbiAgICAgIGNyZWF0ZWQuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlZC5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgIHtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgbGFuZXMsIGtleSwgZGVidWdJbmZvKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBrZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAge1xuICAgICAgICBjcmVhdGVkLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdiaWdpbnQnKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXSBGbG93IGRvZXNuJ3Qgd2FudCB1cyB0byB1c2UgYCtgIG9wZXJhdG9yIHdpdGggc3RyaW5nIGFuZCBiaWdpbnRcbiAgICAgICcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlZC5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgICAgICAgIGNvZXJjZVJlZihyZXR1cm5GaWJlciwgbnVsbCwgX2NyZWF0ZWQsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgIF9jcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIF9jcmVhdGVkLl9kZWJ1Z0luZm8gPSBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICAgICAgICBfY3JlYXRlZDIucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgX2NyZWF0ZWQyLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gbmV3Q2hpbGQuX3BheWxvYWQ7XG4gICAgICAgICAgICB2YXIgaW5pdCA9IG5ld0NoaWxkLl9pbml0O1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBpbml0KHBheWxvYWQpLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSAvLyBjYWxsIG1lcmdlIGFmdGVyIGluaXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkgfHwgZW5hYmxlQXN5bmNJdGVyYWJsZUNoaWxkcmVuICkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBudWxsKTtcblxuICAgICAgICBfY3JlYXRlZDMucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAge1xuICAgICAgICAgIF9jcmVhdGVkMy5fZGVidWdJbmZvID0gbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfY3JlYXRlZDM7XG4gICAgICB9IC8vIFVzYWJsZSBub2RlIHR5cGVzXG4gICAgICAvL1xuICAgICAgLy8gVW53cmFwIHRoZSBpbm5lciB2YWx1ZSBhbmQgcmVjdXJzaXZlbHkgY2FsbCB0aGlzIGZ1bmN0aW9uIGFnYWluLlxuXG5cbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgdGhlbmFibGUgPSBuZXdDaGlsZDtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSksIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBuZXdDaGlsZDtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBjb250ZXh0LCBsYW5lcyksIGxhbmVzLCBkZWJ1Z0luZm8pO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3ltYm9sJykge1xuICAgICAgICB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICAvLyBVcGRhdGUgdGhlIGZpYmVyIGlmIHRoZSBrZXlzIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG4gICAgdmFyIGtleSA9IG9sZEZpYmVyICE9PSBudWxsID8gb2xkRmliZXIua2V5IDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnICYmIG5ld0NoaWxkICE9PSAnJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgb2xkRmliZXIsIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXSBGbG93IGRvZXNuJ3Qgd2FudCB1cyB0byB1c2UgYCtgIG9wZXJhdG9yIHdpdGggc3RyaW5nIGFuZCBiaWdpbnRcbiAgICAgICcnICsgbmV3Q2hpbGQsIGxhbmVzLCBkZWJ1Z0luZm8pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgZGVidWdJbmZvKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IG5ld0NoaWxkLl9wYXlsb2FkO1xuICAgICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgaW5pdChwYXlsb2FkKSwgbGFuZXMsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpIHx8IGVuYWJsZUFzeW5jSXRlcmFibGVDaGlsZHJlbiApIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzLCBudWxsLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pKTtcbiAgICAgIH0gLy8gVXNhYmxlIG5vZGUgdHlwZXNcbiAgICAgIC8vXG4gICAgICAvLyBVbndyYXAgdGhlIGlubmVyIHZhbHVlIGFuZCByZWN1cnNpdmVseSBjYWxsIHRoaXMgZnVuY3Rpb24gYWdhaW4uXG5cblxuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciB0aGVuYWJsZSA9IG5ld0NoaWxkO1xuICAgICAgICByZXR1cm4gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3Q2hpbGQ7XG4gICAgICAgIHJldHVybiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgY29udGV4dCwgbGFuZXMpLCBsYW5lcywgZGVidWdJbmZvKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgbGFuZXMsIGRlYnVnSW5mbykge1xuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnICYmIG5ld0NoaWxkICE9PSAnJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLCBzbyB3ZSBuZWl0aGVyIGhhdmUgdG8gY2hlY2sgdGhlIG9sZCBub3JcbiAgICAgIC8vIG5ldyBub2RlIGZvciB0aGUga2V5LiBJZiBib3RoIGFyZSB0ZXh0IG5vZGVzLCB0aGV5IG1hdGNoLlxuICAgICAgdmFyIG1hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgbWF0Y2hlZEZpYmVyLCAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl0gRmxvdyBkb2Vzbid0IHdhbnQgdXMgdG8gdXNlIGArYCBvcGVyYXRvciB3aXRoIHN0cmluZyBhbmQgYmlnaW50XG4gICAgICAnJyArIG5ld0NoaWxkLCBsYW5lcywgZGVidWdJbmZvKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGxhbmVzLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IG5ld0NoaWxkLl9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgaW5pdChwYXlsb2FkKSwgbGFuZXMsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkgfHwgZW5hYmxlQXN5bmNJdGVyYWJsZUNoaWxkcmVuICkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjMgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMywgbmV3Q2hpbGQsIGxhbmVzLCBudWxsLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pKTtcbiAgICAgIH0gLy8gVXNhYmxlIG5vZGUgdHlwZXNcbiAgICAgIC8vXG4gICAgICAvLyBVbndyYXAgdGhlIGlubmVyIHZhbHVlIGFuZCByZWN1cnNpdmVseSBjYWxsIHRoaXMgZnVuY3Rpb24gYWdhaW4uXG5cblxuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciB0aGVuYWJsZSA9IG5ld0NoaWxkO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSksIGxhbmVzLCBkZWJ1Z0luZm8pO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IG5ld0NoaWxkO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBjb250ZXh0LCBsYW5lcyksIGxhbmVzLCBkZWJ1Z0luZm8pO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3ltYm9sJykge1xuICAgICAgICB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcikge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa25vd25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IoJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJywga2V5KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHZhciBwYXlsb2FkID0gY2hpbGQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBjaGlsZC5faW5pdDtcbiAgICAgICAgICB3YXJuT25JbnZhbGlkS2V5KGluaXQocGF5bG9hZCksIGtub3duS2V5cywgcmV0dXJuRmliZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrbm93bktleXM7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW4sIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RoIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cbiAgICAvLyBJbiB0aGlzIGZpcnN0IGl0ZXJhdGlvbiwgd2UnbGwganVzdCBsaXZlIHdpdGggaGl0dGluZyB0aGUgYmFkIGNhc2VcbiAgICAvLyAoYWRkaW5nIGV2ZXJ5dGhpbmcgdG8gYSBNYXApIGluIGZvciBldmVyeSBpbnNlcnQvbW92ZS5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcblxuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcywgZGVidWdJbmZvKTtcblxuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChuZXdJZHggPT09IG5ld0NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgICB2YXIgbnVtYmVyT2ZGb3JrcyA9IG5ld0lkeDtcbiAgICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBudW1iZXJPZkZvcmtzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgICB2YXIgX25ld0ZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzLCBkZWJ1Z0luZm8pO1xuXG4gICAgICAgIGlmIChfbmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgICB2YXIgX251bWJlck9mRm9ya3MgPSBuZXdJZHg7XG4gICAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgX251bWJlck9mRm9ya3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9IC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuXG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKG9sZEZpYmVyKTsgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcywgZGVidWdJbmZvKTtcblxuICAgICAgaWYgKF9uZXdGaWJlcjIgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyMi5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmRlbGV0ZShfbmV3RmliZXIyLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjIua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICB2YXIgX251bWJlck9mRm9ya3MyID0gbmV3SWR4O1xuICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBfbnVtYmVyT2ZGb3JrczIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRhYmxlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgbGFuZXMsIGRlYnVnSW5mbykge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluICcgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcblxuICAgIHtcbiAgICAgIGlmIChuZXdDaGlsZHJlbiA9PT0gbmV3Q2hpbGRyZW5JdGVyYWJsZSkge1xuICAgICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHJlbmRlcmluZyBHZW5lcmF0b3JzIGFzIHByb3BzIGJlY2F1c2UgaXQncyBhIG11dGF0aW9uLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjk5NVxuICAgICAgICAvLyBXZSBkbyBzdXBwb3J0IGdlbmVyYXRvcnMgaWYgdGhleSB3ZXJlIGNyZWF0ZWQgYnkgYSBHZW5lcmF0b3JGdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgLy8gYXMgaXRzIGRpcmVjdCBjaGlsZCBzaW5jZSB3ZSBjYW4gcmVjcmVhdGUgdGhvc2UgYnkgcmVyZW5kZXJpbmcgdGhlIGNvbXBvbmVudFxuICAgICAgICAvLyBhcyBuZWVkZWQuXG4gICAgICAgIHZhciBpc0dlbmVyYXRvckNvbXBvbmVudCA9IHJldHVybkZpYmVyLnRhZyA9PT0gRnVuY3Rpb25Db21wb25lbnQgJiYgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmV0dXJuRmliZXIudHlwZSkgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScgJiYgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGRyZW4pID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcblxuICAgICAgICBpZiAoIWlzR2VuZXJhdG9yQ29tcG9uZW50KSB7XG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZW5lcmF0b3JzKSB7XG4gICAgICAgICAgICBlcnJvcignVXNpbmcgSXRlcmF0b3JzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCAnICsgJ3VuZXhwZWN0ZWQgcmVzdWx0cyBiZWNhdXNlIGVudW1lcmF0aW5nIGEgZ2VuZXJhdG9yIG11dGF0ZXMgaXQuICcgKyAnWW91IG1heSBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggYEFycmF5LmZyb20oKWAgb3IgdGhlICcgKyAnYFsuLi5zcHJlYWRdYCBvcGVyYXRvciBiZWZvcmUgcmVuZGVyaW5nLiBZb3UgY2FuIGFsc28gdXNlIGFuICcgKyAnSXRlcmFibGUgdGhhdCBjYW4gaXRlcmF0ZSBtdWx0aXBsZSB0aW1lcyBvdmVyIHRoZSBzYW1lIGl0ZW1zLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgZXJyb3IoJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuLCBsYW5lcywgZGVidWdJbmZvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgbGFuZXMsIGRlYnVnSW5mbykge1xuICAgIGlmIChuZXdDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci4nKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgIHZhciBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpO1xuXG4gICAge1xuICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShzdGVwLnZhbHVlLCBrbm93bktleXMsIHJldHVybkZpYmVyKTtcbiAgICB9XG5cbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCksIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoc3RlcC52YWx1ZSwga25vd25LZXlzLCByZXR1cm5GaWJlcikgKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBzdGVwLnZhbHVlLCBsYW5lcywgZGVidWdJbmZvKTtcblxuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIG51bWJlck9mRm9ya3MgPSBuZXdJZHg7XG4gICAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbnVtYmVyT2ZGb3Jrcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpLCBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KHN0ZXAudmFsdWUsIGtub3duS2V5cywgcmV0dXJuRmliZXIpICkge1xuICAgICAgICB2YXIgX25ld0ZpYmVyMyA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBzdGVwLnZhbHVlLCBsYW5lcywgZGVidWdJbmZvKTtcblxuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgICB2YXIgX251bWJlck9mRm9ya3MzID0gbmV3SWR4O1xuICAgICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzMyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH0gLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG5cblxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ob2xkRmliZXIpOyAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG5cbiAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCksIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoc3RlcC52YWx1ZSwga25vd25LZXlzLCByZXR1cm5GaWJlcikgKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyNCA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgc3RlcC52YWx1ZSwgbGFuZXMsIGRlYnVnSW5mbyk7XG5cbiAgICAgIGlmIChfbmV3RmliZXI0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjQuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyNC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXI0LmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXI0LCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI0O1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgdmFyIF9udW1iZXJPZkZvcmtzNCA9IG5ld0lkeDtcbiAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgX251bWJlck9mRm9ya3M0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGxhbmVzKSB7XG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHRleHQgbm9kZXMgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhXG4gICAgLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBjdXJyZW50Rmlyc3RDaGlsZC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBzbyBsZXQncyBqdXN0IHVwZGF0ZSBpdCBhbmQgZGVsZXRlXG4gICAgICAvLyB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IC8vIFRoZSBleGlzdGluZyBmaXJzdCBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgLy8gYW5kIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lcy5cblxuXG4gICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50LCBleGlzdGluZywgcmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2hpbGQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnRUeXBlIHx8ICggLy8gS2VlcCB0aGlzIGNoZWNrIGlubGluZSBzbyBpdCBvbmx5IHJ1bnMgb24gdGhlIGZhbHNlIHBhdGg6XG4gICAgICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGNoaWxkLCBlbGVtZW50KSApIHx8IC8vIExhenkgdHlwZXMgc2hvdWxkIHJlY29uY2lsZSB0aGVpciByZXNvbHZlZCB0eXBlLlxuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdGhpcyBhZnRlciB0aGUgSG90IFJlbG9hZGluZyBjaGVjayBhYm92ZSxcbiAgICAgICAgICAvLyBiZWNhdXNlIGhvdCByZWxvYWRpbmcgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgdGhhbiBwcm9kIGJlY2F1c2VcbiAgICAgICAgICAvLyBpdCBkb2Vzbid0IHJlc3VzcGVuZC4gU28gd2UgY2FuJ3QgbGV0IHRoZSBjYWxsIGJlbG93IHN1c3BlbmQuXG4gICAgICAgICAgdHlwZW9mIGVsZW1lbnRUeXBlID09PSAnb2JqZWN0JyAmJiBlbGVtZW50VHlwZSAhPT0gbnVsbCAmJiBlbGVtZW50VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmIHJlc29sdmVMYXp5KGVsZW1lbnRUeXBlKSA9PT0gY2hpbGQudHlwZSkge1xuICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuXG4gICAgICAgICAgICB2YXIgX2V4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIGVsZW1lbnQucHJvcHMpO1xuXG4gICAgICAgICAgICBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGNoaWxkLCBfZXhpc3RpbmcsIGVsZW1lbnQpO1xuICAgICAgICAgICAgX2V4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIF9leGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgICBfZXhpc3RpbmcuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9leGlzdGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRGlkbid0IG1hdGNoLlxuXG5cbiAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50LnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcywgZWxlbWVudC5rZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAge1xuICAgICAgICBjcmVhdGVkLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICB9XG5cbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50LCBjcmVhdGVkLCByZXR1cm5GaWJlcik7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBfY3JlYXRlZDQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ0LnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICB7XG4gICAgICAgIF9jcmVhdGVkNC5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2NyZWF0ZWQ0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgbGFuZXMsIGRlYnVnSW5mbykge1xuICAgIHZhciBrZXkgPSBwb3J0YWwua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gSG9zdFBvcnRhbCAmJiBjaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT0gcG9ydGFsLmNvbnRhaW5lckluZm8gJiYgY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9IC8vIFRoaXMgQVBJIHdpbGwgdGFnIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSBzaWRlLWVmZmVjdCBvZiB0aGUgcmVjb25jaWxpYXRpb25cbiAgLy8gaXRzZWxmLiBUaGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNpZGUtZWZmZWN0IGxpc3QgYXMgd2UgcGFzcyB0aHJvdWdoIHRoZVxuICAvLyBjaGlsZHJlbiBhbmQgdGhlIHBhcmVudC5cblxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHJlY3Vyc2l2ZSBmb3IgVXNhYmxlcy9MYXp5IGFuZCBub3QgbmVzdGVkIGFycmF5cy5cbiAgICAvLyBUaGF0J3Mgc28gdGhhdCB1c2luZyBhIExhenkgd3JhcHBlciBpcyB1bm9ic2VydmFibGUgdG8gdGhlIEZyYWdtZW50XG4gICAgLy8gY29udmVudGlvbi5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG4gICAgLy8gSGFuZGxlIHRvcCBsZXZlbCB1bmtleWVkIGZyYWdtZW50cyBhcyBpZiB0aGV5IHdlcmUgYXJyYXlzLlxuICAgIC8vIFRoaXMgbGVhZHMgdG8gYW4gYW1iaWd1aXR5IGJldHdlZW4gPD57Wy4uLl19PC8+IGFuZCA8Pi4uLjwvPi5cbiAgICAvLyBXZSB0cmVhdCB0aGUgYW1iaWd1b3VzIGNhc2VzIGFib3ZlIHRoZSBzYW1lLlxuICAgIC8vIFdlIGRvbid0IHVzZSByZWN1cnNpb24gaGVyZSBiZWNhdXNlIGEgZnJhZ21lbnQgaW5zaWRlIGEgZnJhZ21lbnRcbiAgICAvLyBpcyBubyBsb25nZXIgY29uc2lkZXJlZCBcInRvcCBsZXZlbFwiIGZvciB0aGVzZSBwdXJwb3Nlcy5cbiAgICB2YXIgaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGw7XG5cbiAgICBpZiAoaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKG5ld0NoaWxkLCBudWxsLCByZXR1cm5GaWJlcik7XG4gICAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuO1xuICAgIH0gLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuXG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSk7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpKTtcblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IG5ld0NoaWxkLl9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG4gICAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGluaXQocGF5bG9hZCksIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpKSB7XG4gICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdGFibGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykpO1xuICAgICAgfVxuICAgICAgLy8gYSBjaGlsZCBwb3NpdGlvbiwgaXQgdW53cmFwcyBpdCB1c2luZyB0aGUgc2FtZSBhbGdvcml0aG0gYXMgYHVzZWAuIEZvclxuICAgICAgLy8gZXhhbXBsZSwgZm9yIHByb21pc2VzLCBSZWFjdCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiB0byB1bndpbmQgdGhlXG4gICAgICAvLyBzdGFjaywgdGhlbiByZXBsYXkgdGhlIGNvbXBvbmVudCBvbmNlIHRoZSBwcm9taXNlIHJlc29sdmVzLlxuICAgICAgLy9cbiAgICAgIC8vIEEgZGlmZmVyZW5jZSBmcm9tIGB1c2VgIGlzIHRoYXQgUmVhY3Qgd2lsbCBrZWVwIHVud3JhcHBpbmcgdGhlIHZhbHVlXG4gICAgICAvLyB1bnRpbCBpdCByZWFjaGVzIGEgbm9uLVVzYWJsZSB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIGUuZy4gVXNhYmxlPFVzYWJsZTxVc2FibGU8VD4+PiBzaG91bGQgcmVzb2x2ZSB0byBUXG4gICAgICAvL1xuICAgICAgLy8gVGhlIHN0cnVjdHVyZSBpcyBhIGJpdCB1bmZvcnR1bmF0ZS4gSWRlYWxseSwgd2Ugc2hvdWxkbid0IG5lZWQgdG9cbiAgICAgIC8vIHJlcGxheSB0aGUgZW50aXJlIGJlZ2luIHBoYXNlIG9mIHRoZSBwYXJlbnQgZmliZXIgaW4gb3JkZXIgdG8gcmVjb25jaWxlXG4gICAgICAvLyB0aGUgY2hpbGRyZW4gYWdhaW4uIFRoaXMgd291bGQgcmVxdWlyZSBhIHNvbWV3aGF0IHNpZ25pZmljYW50IHJlZmFjdG9yLFxuICAgICAgLy8gYmVjYXVzZSByZWNvbmNpbGF0aW9uIGhhcHBlbnMgZGVlcCB3aXRoaW4gdGhlIGJlZ2luIHBoYXNlLCBhbmRcbiAgICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiB3b3JrLCBub3QgYWx3YXlzIGF0IHRoZSBlbmQuIFdlIHNob3VsZFxuICAgICAgLy8gY29uc2lkZXIgYXMgYW4gZnV0dXJlIGltcHJvdmVtZW50LlxuXG5cbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgdGhlbmFibGUgPSBuZXdDaGlsZDtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSwgbGFuZXMsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgdGhlbmFibGUuX2RlYnVnSW5mbykpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IG5ld0NoaWxkO1xuICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgY29udGV4dCwgbGFuZXMpLCBsYW5lcywgZGVidWdJbmZvKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgJiYgbmV3Q2hpbGQgIT09ICcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnYmlnaW50Jykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl0gRmxvdyBkb2Vzbid0IHdhbnQgdXMgdG8gdXNlIGArYCBvcGVyYXRvciB3aXRoIHN0cmluZyBhbmQgYmlnaW50XG4gICAgICAnJyArIG5ld0NoaWxkLCBsYW5lcykpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgIH1cbiAgICB9IC8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG5cblxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRGaWJlcnMocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAvLyBUaGlzIGluZGlyZWN0aW9uIG9ubHkgZXhpc3RzIHNvIHdlIGNhbiByZXNldCBgdGhlbmFibGVTdGF0ZWAgYXQgdGhlIGVuZC5cbiAgICAvLyBJdCBzaG91bGQgZ2V0IGlubGluZWQgYnkgQ2xvc3VyZS5cbiAgICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMDtcbiAgICB2YXIgZmlyc3RDaGlsZEZpYmVyID0gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzLCBudWxsIC8vIGRlYnVnSW5mb1xuICAgICk7XG4gICAgdGhlbmFibGVTdGF0ZSQxID0gbnVsbDsgLy8gRG9uJ3QgYm90aGVyIHRvIHJlc2V0IGB0aGVuYWJsZUluZGV4Q291bnRlcmAgdG8gMCBiZWNhdXNlIGl0IGFsd2F5cyBnZXRzXG4gICAgLy8gc2V0IGF0IHRoZSBiZWdpbm5pbmcuXG5cbiAgICByZXR1cm4gZmlyc3RDaGlsZEZpYmVyO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBjcmVhdGVDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IGNyZWF0ZUNoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5mdW5jdGlvbiByZXNldENoaWxkUmVjb25jaWxlck9uVW53aW5kKCkge1xuICAvLyBPbiB1bndpbmQsIGNsZWFyIGFueSBwZW5kaW5nIHRoZW5hYmxlcyB0aGF0IHdlcmUgdXNlZC5cbiAgdGhlbmFibGVTdGF0ZSQxID0gbnVsbDtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG59XG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLmNoaWxkICE9PSBjdXJyZW50LmNoaWxkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuXG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7XG4gICAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cblxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn0gLy8gUmVzZXQgYSB3b3JrSW5Qcm9ncmVzcyBjaGlsZCBzZXQgdG8gcHJlcGFyZSBpdCBmb3IgYSBzZWNvbmQgcGFzcy5cblxuZnVuY3Rpb24gcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgdmFyIGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgcmVzZXRXb3JrSW5Qcm9ncmVzcyhjaGlsZCwgbGFuZXMpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG4vLyBUT0RPOiBUaGlzIGlzbid0IGJlaW5nIHVzZWQgeWV0LCBidXQgaXQncyBpbnRlbmRlZCB0byByZXBsYWNlIHRoZVxuLy8gSW52aXNpYmxlUGFyZW50Q29udGV4dCB0aGF0IGlzIGN1cnJlbnRseSBtYW5hZ2VkIGJ5IFN1c3BlbnNlQ29udGV4dC5cblxudmFyIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5vTGFuZXMpO1xuZnVuY3Rpb24gcHVzaEhpZGRlbkNvbnRleHQoZmliZXIsIGNvbnRleHQpIHtcbiAgdmFyIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyA9IGdldEVudGFuZ2xlZFJlbmRlckxhbmVzKCk7XG4gIHB1c2gocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLCBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMsIGZpYmVyKTtcbiAgcHVzaChjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7IC8vIFdoZW4gcmVuZGVyaW5nIGEgc3VidHJlZSB0aGF0J3MgY3VycmVudGx5IGhpZGRlbiwgd2UgbXVzdCBpbmNsdWRlIGFsbFxuICAvLyBsYW5lcyB0aGF0IHdvdWxkIGhhdmUgcmVuZGVyZWQgaWYgdGhlIGhpZGRlbiBzdWJ0cmVlIGhhZG4ndCBiZWVuIGRlZmVycmVkLlxuICAvLyBUaGF0IGlzLCBpbiBvcmRlciB0byByZXZlYWwgY29udGVudCBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlLCB3ZSBtdXN0IGNvbW1pdFxuICAvLyBhbGwgdGhlIHVwZGF0ZXMgdGhhdCB3ZSBza2lwcGVkIHdoZW4gd2Ugb3JpZ2luYWxseSBoaWQgdGhlIHRyZWUuXG5cbiAgc2V0RW50YW5nbGVkUmVuZGVyTGFuZXMobWVyZ2VMYW5lcyhwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMsIGNvbnRleHQuYmFzZUxhbmVzKSk7XG59XG5mdW5jdGlvbiByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKGZpYmVyKSB7XG4gIC8vIFRoaXMgc3VidHJlZSBpcyBub3QgY3VycmVudGx5IGhpZGRlbiwgc28gd2UgZG9uJ3QgbmVlZCB0byBhZGQgYW55IGxhbmVzXG4gIC8vIHRvIHRoZSByZW5kZXIgbGFuZXMuIEJ1dCB3ZSBzdGlsbCBuZWVkIHRvIHB1c2ggc29tZXRoaW5nIHRvIGF2b2lkIGFcbiAgLy8gY29udGV4dCBtaXNtYXRjaC4gUmV1c2UgdGhlIGV4aXN0aW5nIGNvbnRleHQgb24gdGhlIHN0YWNrLlxuICBwdXNoKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgZ2V0RW50YW5nbGVkUmVuZGVyTGFuZXMoKSwgZmliZXIpO1xuICBwdXNoKGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudCwgZmliZXIpO1xufVxuZnVuY3Rpb24gcG9wSGlkZGVuQ29udGV4dChmaWJlcikge1xuICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyByZW5kZXIgbGFuZXMgZnJvbSB0aGUgc3RhY2tcbiAgc2V0RW50YW5nbGVkUmVuZGVyTGFuZXMocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLmN1cnJlbnQpO1xuICBwb3AoY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLCBmaWJlcik7XG59XG5mdW5jdGlvbiBpc0N1cnJlbnRUcmVlSGlkZGVuKCkge1xuICByZXR1cm4gY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvci5jdXJyZW50ICE9PSBudWxsO1xufVxuXG4vLyBzdXNwZW5kcywgaS5lLiBpdCdzIHRoZSBuZWFyZXN0IGBjYXRjaGAgYmxvY2sgb24gdGhlIHN0YWNrLlxuXG52YXIgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7IC8vIFJlcHJlc2VudHMgdGhlIG91dGVybW9zdCBib3VuZGFyeSB0aGF0IGlzIG5vdCB2aXNpYmxlIGluIHRoZSBjdXJyZW50IHRyZWUuXG4vLyBFdmVyeXRoaW5nIGFib3ZlIHRoaXMgaXMgdGhlIFwic2hlbGxcIi4gV2hlbiB0aGlzIGlzIG51bGwsIGl0IG1lYW5zIHdlJ3JlXG4vLyByZW5kZXJpbmcgaW4gdGhlIHNoZWxsIG9mIHRoZSBhcHAuIElmIGl0J3Mgbm9uLW51bGwsIGl0IG1lYW5zIHdlJ3JlIHJlbmRlcmluZ1xuLy8gZGVlcGVyIHRoYW4gdGhlIHNoZWxsLCBpbnNpZGUgYSBuZXcgdHJlZSB0aGF0IHdhc24ndCBhbHJlYWR5IHZpc2libGUuXG4vL1xuLy8gVGhlIG1haW4gd2F5IHdlIHVzZSB0aGlzIGNvbmNlcHQgaXMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgc2hvd2luZyBhIGZhbGxiYWNrXG4vLyB3b3VsZCByZXN1bHQgaW4gYSBkZXNpcmFibGUgb3IgdW5kZXNpcmFibGUgbG9hZGluZyBzdGF0ZS4gQWN0aXZpbmcgYSBmYWxsYmFja1xuLy8gaW4gdGhlIHNoZWxsIGlzIGNvbnNpZGVyZWQgYW4gdW5kZXJzaXJhYmxlIGxvYWRpbmcgc3RhdGUsIGJlY2F1c2UgaXQgd291bGRcbi8vIG1lYW4gaGlkaW5nIHZpc2libGUgKGFsYmVpdCBzdGFsZSkgY29udGVudCBpbiB0aGUgY3VycmVudCB0cmVlIOKAlCB3ZSBwcmVmZXIgdG9cbi8vIHNob3cgdGhlIHN0YWxlIGNvbnRlbnQsIHJhdGhlciB0aGFuIHN3aXRjaCB0byBhIGZhbGxiYWNrLiBCdXQgc2hvd2luZyBhXG4vLyBmYWxsYmFjayBpbiBhIG5ldyB0cmVlIGlzIGZpbmUsIGJlY2F1c2UgdGhlcmUncyBubyBzdGFsZSBjb250ZW50IHRvXG4vLyBwcmVmZXIgaW5zdGVhZC5cblxudmFyIHNoZWxsQm91bmRhcnkgPSBudWxsO1xuZnVuY3Rpb24gZ2V0U2hlbGxCb3VuZGFyeSgpIHtcbiAgcmV0dXJuIHNoZWxsQm91bmRhcnk7XG59XG5mdW5jdGlvbiBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIoaGFuZGxlcikge1xuICAvLyBUT0RPOiBQYXNzIGFzIGFyZ3VtZW50XG4gIHZhciBjdXJyZW50ID0gaGFuZGxlci5hbHRlcm5hdGU7XG4gIC8vIHByb3BhZ2F0ZWQgYSBzaW5nbGUgbGV2ZWwuIEZvciBleGFtcGxlLCB3aGVuIEZvcmNlU3VzcGVuc2VGYWxsYmFjayBpcyBzZXQsXG4gIC8vIGl0IHNob3VsZCBvbmx5IGZvcmNlIHRoZSBuZWFyZXN0IFN1c3BlbnNlIGJvdW5kYXJ5IGludG8gZmFsbGJhY2sgbW9kZS5cblxuICBwdXNoU3VzcGVuc2VMaXN0Q29udGV4dChoYW5kbGVyLCBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlTGlzdENvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSk7IC8vIEV4cGVyaW1lbnRhbCBmZWF0dXJlOiBTb21lIFN1c3BlbnNlIGJvdW5kYXJpZXMgYXJlIG1hcmtlZCBhcyBoYXZpbmcgYW5cbiAgLy8gdG8gcHVzaCBhIG5lc3RlZCBTdXNwZW5zZSBoYW5kbGVyLCBiZWNhdXNlIGl0IHdpbGwgZ2V0IHJlcGxhY2VkIGJ5IHRoZVxuICAvLyBvdXRlciBmYWxsYmFjaywgYW55d2F5LiBDb25zaWRlciB0aGlzIGFzIGEgZnV0dXJlIG9wdGltaXphdGlvbi5cblxuXG4gIHB1c2goc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGhhbmRsZXIsIGhhbmRsZXIpO1xuXG4gIGlmIChzaGVsbEJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgaXNDdXJyZW50VHJlZUhpZGRlbigpKSB7XG4gICAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIG5vdCB2aXNpYmxlIGluIHRoZSBjdXJyZW50IFVJLlxuICAgICAgc2hlbGxCb3VuZGFyeSA9IGhhbmRsZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBib3VuZGFyeSBpcyBzaG93aW5nIGEgZmFsbGJhY2sgaW4gdGhlIGN1cnJlbnQgVUkuXG4gICAgICAgIHNoZWxsQm91bmRhcnkgPSBoYW5kbGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcHVzaEZhbGxiYWNrVHJlZVN1c3BlbnNlSGFuZGxlcihmaWJlcikge1xuICAvLyBXZSdyZSBhYm91dCB0byByZW5kZXIgdGhlIGZhbGxiYWNrLiBJZiBzb21ldGhpbmcgaW4gdGhlIGZhbGxiYWNrIHN1c3BlbmRzLFxuICAvLyBpdCdzIGFraW4gdG8gdGhyb3dpbmcgaW5zaWRlIG9mIGEgYGNhdGNoYCBibG9jay4gVGhpcyBib3VuZGFyeSBzaG91bGQgbm90XG4gIC8vIGNhcHR1cmUuIFJldXNlIHRoZSBleGlzdGluZyBoYW5kbGVyIG9uIHRoZSBzdGFjay5cbiAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKGZpYmVyKTtcbn1cbmZ1bmN0aW9uIHB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyA9PT0gT2Zmc2NyZWVuQ29tcG9uZW50KSB7XG4gICAgLy8gQSBTdXNwZW5zZUxpc3QgY29udGV4dCBpcyBvbmx5IHB1c2hlZCBoZXJlIHRvIGF2b2lkIGEgcHVzaC9wb3AgbWlzbWF0Y2guXG4gICAgLy8gUmV1c2UgdGhlIGN1cnJlbnQgdmFsdWUgb24gdGhlIHN0YWNrLlxuICAgIC8vIFRPRE86IFdlIGNhbiBhdm9pZCBuZWVkaW5nIHRvIHB1c2ggaGVyZSBieSBieSBmb3JraW5nIHBvcFN1c3BlbnNlSGFuZGxlclxuICAgIC8vIGludG8gc2VwYXJhdGUgZnVuY3Rpb25zIGZvciBTdXNwZW5zZSBhbmQgT2Zmc2NyZWVuLlxuICAgIHB1c2hTdXNwZW5zZUxpc3RDb250ZXh0KGZpYmVyLCBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHB1c2goc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG5cbiAgICBpZiAoc2hlbGxCb3VuZGFyeSAhPT0gbnVsbCkgOyBlbHNlIHtcbiAgICAgIHZhciBjdXJyZW50ID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBib3VuZGFyeSBpbiB0aGUgc3RhY2sgdGhhdCdzIGFscmVhZHkgc2hvd2luZ1xuICAgICAgICAgIC8vIGEgZmFsbGJhY2suIFNvIGV2ZXJ5dGhpbmcgb3V0c2lkZSBpcyBjb25zaWRlcmVkIHRoZSBzaGVsbC5cbiAgICAgICAgICBzaGVsbEJvdW5kYXJ5ID0gZmliZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIExlZ2FjeUhpZGRlbiBjb21wb25lbnQuXG4gICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKGZpYmVyKTtcbiAgfVxufVxuZnVuY3Rpb24gcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKGZpYmVyKSB7XG4gIHB1c2hTdXNwZW5zZUxpc3RDb250ZXh0KGZpYmVyLCBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICBwdXNoKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBnZXRTdXNwZW5zZUhhbmRsZXIoKSwgZmliZXIpO1xufVxuZnVuY3Rpb24gZ2V0U3VzcGVuc2VIYW5kbGVyKCkge1xuICByZXR1cm4gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbn1cbmZ1bmN0aW9uIHBvcFN1c3BlbnNlSGFuZGxlcihmaWJlcikge1xuICBwb3Aoc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcblxuICBpZiAoc2hlbGxCb3VuZGFyeSA9PT0gZmliZXIpIHtcbiAgICAvLyBQb3BwaW5nIGJhY2sgaW50byB0aGUgc2hlbGwuXG4gICAgc2hlbGxCb3VuZGFyeSA9IG51bGw7XG4gIH1cblxuICBwb3BTdXNwZW5zZUxpc3RDb250ZXh0KGZpYmVyKTtcbn0gLy8gU3VzcGVuc2VMaXN0IGNvbnRleHRcbi8vIFRPRE86IE1vdmUgdG8gYSBzZXBhcmF0ZSBtb2R1bGU/IFdlIG1heSBjaGFuZ2UgdGhlIFN1c3BlbnNlTGlzdFxuLy8gaW1wbGVtZW50YXRpb24gdG8gaGlkZS9zaG93IGluIHRoZSBjb21taXQgcGhhc2UsIGFueXdheS5cblxudmFyIERlZmF1bHRTdXNwZW5zZUNvbnRleHQgPSAwO1xudmFyIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrID0gMTsgLy8gRm9yY2VTdXNwZW5zZUZhbGxiYWNrIGNhbiBiZSB1c2VkIGJ5IFN1c3BlbnNlTGlzdCB0byBmb3JjZSBuZXdseSBhZGRlZFxuLy8gaXRlbXMgaW50byB0aGVpciBmYWxsYmFjayBzdGF0ZSBkdXJpbmcgb25lIG9mIHRoZSByZW5kZXIgcGFzc2VzLlxuXG52YXIgRm9yY2VTdXNwZW5zZUZhbGxiYWNrID0gMjtcbnZhciBzdXNwZW5zZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKERlZmF1bHRTdXNwZW5zZUNvbnRleHQpO1xuZnVuY3Rpb24gaGFzU3VzcGVuc2VMaXN0Q29udGV4dChwYXJlbnRDb250ZXh0LCBmbGFnKSB7XG4gIHJldHVybiAocGFyZW50Q29udGV4dCAmIGZsYWcpICE9PSAwO1xufVxuZnVuY3Rpb24gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUxpc3RDb250ZXh0KHBhcmVudENvbnRleHQpIHtcbiAgcmV0dXJuIHBhcmVudENvbnRleHQgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaztcbn1cbmZ1bmN0aW9uIHNldFNoYWxsb3dTdXNwZW5zZUxpc3RDb250ZXh0KHBhcmVudENvbnRleHQsIHNoYWxsb3dDb250ZXh0KSB7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0ICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2sgfCBzaGFsbG93Q29udGV4dDtcbn1cbmZ1bmN0aW9uIHB1c2hTdXNwZW5zZUxpc3RDb250ZXh0KGZpYmVyLCBuZXdDb250ZXh0KSB7XG4gIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgbmV3Q29udGV4dCwgZmliZXIpO1xufVxuZnVuY3Rpb24gcG9wU3VzcGVuc2VMaXN0Q29udGV4dChmaWJlcikge1xuICBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG4vLyBBIG5vbi1udWxsIFN1c3BlbnNlU3RhdGUgbWVhbnMgdGhhdCBpdCBpcyBibG9ja2VkIGZvciBvbmUgcmVhc29uIG9yIGFub3RoZXIuXG4vLyAtIEEgbm9uLW51bGwgZGVoeWRyYXRlZCBmaWVsZCBtZWFucyBpdCdzIGJsb2NrZWQgcGVuZGluZyBoeWRyYXRpb24uXG4vLyAgIC0gQSBub24tbnVsbCBkZWh5ZHJhdGVkIGZpZWxkIGNhbiB1c2UgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyBvclxuLy8gICAgIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrIHRvIHF1ZXJ5IHRoZSByZWFzb24gZm9yIGJlaW5nIGRlaHlkcmF0ZWQuXG4vLyAtIEEgbnVsbCBkZWh5ZHJhdGVkIGZpZWxkIG1lYW5zIGl0J3MgYmxvY2tlZCBieSBzb21ldGhpbmcgc3VzcGVuZGluZyBhbmRcbi8vICAgd2UncmUgY3VycmVudGx5IHNob3dpbmcgYSBmYWxsYmFjayBpbnN0ZWFkLlxuXG5mdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KSB7XG4gIHZhciBub2RlID0gcm93O1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlaHlkcmF0ZWQgPSBzdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChkZWh5ZHJhdGVkID09PSBudWxsIHx8IGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoZGVoeWRyYXRlZCkgfHwgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soZGVoeWRyYXRlZCkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlTGlzdENvbXBvbmVudCAmJiAvLyByZXZlYWxPcmRlciB1bmRlZmluZWQgY2FuJ3QgYmUgdHJ1c3RlZCBiZWNhdXNlIGl0IGRvbid0XG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIGl0IHN1c3BlbmRlZCBvciBub3QuXG4gICAgbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkaWRTdXNwZW5kID0gKG5vZGUuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncyQxO1xuXG4gICAgICBpZiAoZGlkU3VzcGVuZCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHJvdykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSByb3cpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgTm9GbGFncyA9XG4vKiAgICovXG4wOyAvLyBSZXByZXNlbnRzIHdoZXRoZXIgZWZmZWN0IHNob3VsZCBmaXJlLlxuXG52YXIgSGFzRWZmZWN0ID1cbi8qICovXG4xOyAvLyBSZXByZXNlbnRzIHRoZSBwaGFzZSBpbiB3aGljaCB0aGUgZWZmZWN0IChub3QgdGhlIGNsZWFuLXVwKSBmaXJlcy5cblxudmFyIEluc2VydGlvbiA9XG4vKiAqL1xuMjtcbnZhciBMYXlvdXQgPVxuLyogICAgKi9cbjQ7XG52YXIgUGFzc2l2ZSA9XG4vKiAgICovXG44O1xuXG52YXIgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50O1xudmFyIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90O1xudmFyIGRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoO1xudmFyIGRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZTtcblxue1xuICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlID0gbmV3IFNldCgpO1xufSAvLyBUaGUgZWZmZWN0IFwiaW5zdGFuY2VcIiBpcyBhIHNoYXJlZCBvYmplY3QgdGhhdCByZW1haW5zIHRoZSBzYW1lIGZvciB0aGUgZW50aXJlXG4vLyBsaWZldGltZSBvZiBhbiBlZmZlY3QuIEluIFJ1c3QgdGVybXMsIGEgUmVmQ2VsbC4gV2UgdXNlIGl0IHRvIHN0b3JlIHRoZVxuLy8gXCJkZXN0cm95XCIgZnVuY3Rpb24gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGFuIGVmZmVjdCwgYmVjYXVzZSB0aGF0IGlzIHN0YXRlZnVsLlxuLy8gVGhlIGZpZWxkIGlzIGB1bmRlZmluZWRgIGlmIHRoZSBlZmZlY3QgaXMgdW5tb3VudGVkLCBvciBpZiB0aGUgZWZmZWN0IHJhblxuLy8gYnV0IGlzIG5vdCBzdGF0ZWZ1bC4gV2UgZG9uJ3QgZXhwbGljaXRseSB0cmFjayB3aGV0aGVyIHRoZSBlZmZlY3QgaXMgbW91bnRlZFxuLy8gb3IgdW5tb3VudGVkIGJlY2F1c2UgdGhhdCBjYW4gYmUgaW5mZXJyZWQgYnkgdGhlIGhpZGRlbm5lc3Mgb2YgdGhlIGZpYmVyIGluXG4vLyB0aGUgdHJlZSwgaS5lLiB3aGV0aGVyIHRoZXJlIGlzIGEgaGlkZGVuIE9mZnNjcmVlbiBmaWJlciBhYm92ZSBpdC5cbi8vXG4vLyBJdCdzIHVuZm9ydHVuYXRlIHRoYXQgdGhpcyBpcyBzdG9yZWQgb24gYSBzZXBhcmF0ZSBvYmplY3QsIGJlY2F1c2UgaXQgYWRkc1xuLy8gbW9yZSBtZW1vcnkgcGVyIGVmZmVjdCBpbnN0YW5jZSwgYnV0IGl0J3MgY29uY2VwdHVhbGx5IHNvdW5kLiBJIHRoaW5rIHRoZXJlJ3Ncbi8vIGxpa2VseSBhIGJldHRlciBkYXRhIHN0cnVjdHVyZSB3ZSBjb3VsZCB1c2UgZm9yIGVmZmVjdHM7IHBlcmhhcHMganVzdCBvbmVcbi8vIGFycmF5IG9mIGVmZmVjdCBpbnN0YW5jZXMgcGVyIGZpYmVyLiBCdXQgSSB0aGluayB0aGlzIGlzIE9LIGZvciBub3cgZGVzcGl0ZVxuLy8gdGhlIGFkZGl0aW9uYWwgbWVtb3J5IGFuZCB3ZSBjYW4gZm9sbG93IHVwIHdpdGggcGVyZm9ybWFuY2Vcbi8vIG9wdGltaXphdGlvbnMgbGF0ZXIuXG4vLyBUaGVzZSBhcmUgc2V0IHJpZ2h0IGJlZm9yZSBjYWxsaW5nIHRoZSBjb21wb25lbnQuXG5cblxudmFyIHJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIEkndmUgbmFtZWQgaXQgZGlmZmVyZW50bHkgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbVxuLy8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsOyAvLyBIb29rcyBhcmUgc3RvcmVkIGFzIGEgbGlua2VkIGxpc3Qgb24gdGhlIGZpYmVyJ3MgbWVtb2l6ZWRTdGF0ZSBmaWVsZC4gVGhlXG4vLyBjdXJyZW50IGhvb2sgbGlzdCBpcyB0aGUgbGlzdCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGN1cnJlbnQgZmliZXIuIFRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBob29rIGxpc3QgaXMgYSBuZXcgbGlzdCB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuXG52YXIgY3VycmVudEhvb2sgPSBudWxsO1xudmFyIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7IC8vIFdoZXRoZXIgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgYXQgYW55IHBvaW50IGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGlzXG4vLyBkb2VzIG5vdCBnZXQgcmVzZXQgaWYgd2UgZG8gYW5vdGhlciByZW5kZXIgcGFzczsgb25seSB3aGVuIHdlJ3JlIGNvbXBsZXRlbHlcbi8vIGZpbmlzaGVkIGV2YWx1YXRpbmcgdGhpcyBjb21wb25lbnQuIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHNvIHdlIGtub3dcbi8vIHdoZXRoZXIgd2UgbmVlZCB0byBjbGVhciByZW5kZXIgcGhhc2UgdXBkYXRlcyBhZnRlciBhIHRocm93LlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlOyAvLyBXaGVyZSBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBvbmx5IGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIgcGFzcy4gVGhpc1xuLy8gZ2V0cyByZXNldCBhZnRlciBlYWNoIGF0dGVtcHQuXG4vLyBUT0RPOiBNYXliZSB0aGVyZSdzIHNvbWUgd2F5IHRvIGNvbnNvbGlkYXRlIHRoaXMgd2l0aFxuLy8gYGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVgLiBPciB3aXRoIGBudW1iZXJPZlJlUmVuZGVyc2AuXG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBmYWxzZTtcbnZhciBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9IGZhbHNlOyAvLyBDb3VudHMgdGhlIG51bWJlciBvZiB1c2VJZCBob29rcyBpbiB0aGlzIGNvbXBvbmVudC5cblxudmFyIGxvY2FsSWRDb3VudGVyID0gMDsgLy8gQ291bnRzIG51bWJlciBvZiBgdXNlYC1kIHRoZW5hYmxlc1xuXG52YXIgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xudmFyIHRoZW5hYmxlU3RhdGUgPSBudWxsOyAvLyBVc2VkIGZvciBpZHMgdGhhdCBhcmUgZ2VuZXJhdGVkIGNvbXBsZXRlbHkgY2xpZW50LXNpZGUgKGkuZS4gbm90IGR1cmluZ1xuLy8gaHlkcmF0aW9uKS4gVGhpcyBjb3VudGVyIGlzIGdsb2JhbCwgc28gY2xpZW50IGlkcyBhcmUgbm90IHN0YWJsZSBhY3Jvc3Ncbi8vIHJlbmRlciBhdHRlbXB0cy5cblxudmFyIGdsb2JhbENsaWVudElkQ291bnRlciA9IDA7XG52YXIgUkVfUkVOREVSX0xJTUlUID0gMjU7IC8vIEluIERFViwgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBwcmltaXRpdmUgaG9va1xuXG52YXIgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsOyAvLyBJbiBERVYsIHRoaXMgbGlzdCBlbnN1cmVzIHRoYXQgaG9va3MgYXJlIGNhbGxlZCBpbiB0aGUgc2FtZSBvcmRlciBiZXR3ZWVuIHJlbmRlcnMuXG4vLyBUaGUgbGlzdCBzdG9yZXMgdGhlIG9yZGVyIG9mIGhvb2tzIHVzZWQgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlciAobW91bnQpLlxuLy8gU3Vic2VxdWVudCByZW5kZXJzICh1cGRhdGVzKSByZWZlcmVuY2UgdGhpcyBsaXN0LlxuXG52YXIgaG9va1R5cGVzRGV2ID0gbnVsbDtcbnZhciBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBJbiBERVYsIHRoaXMgdHJhY2tzIHdoZXRoZXIgY3VycmVudGx5IHJlbmRlcmluZyBjb21wb25lbnQgbmVlZHMgdG8gaWdub3JlXG4vLyB0aGUgZGVwZW5kZW5jaWVzIGZvciBIb29rcyB0aGF0IG5lZWQgdGhlbSAoZS5nLiB1c2VFZmZlY3Qgb3IgdXNlTWVtbykuXG4vLyBXaGVuIHRydWUsIHN1Y2ggSG9va3Mgd2lsbCBhbHdheXMgYmUgXCJyZW1vdW50ZWRcIi4gT25seSB1c2VkIGR1cmluZyBob3QgcmVsb2FkLlxuXG52YXIgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBmYWxzZTtcblxuZnVuY3Rpb24gbW91bnRIb29rVHlwZXNEZXYoKSB7XG4gIHtcbiAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuICAgIGlmIChob29rVHlwZXNEZXYgPT09IG51bGwpIHtcbiAgICAgIGhvb2tUeXBlc0RldiA9IFtob29rTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tUeXBlc0Rldi5wdXNoKGhvb2tOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9va1R5cGVzRGV2KCkge1xuICB7XG4gICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbiAgICBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldisrO1xuXG4gICAgICBpZiAoaG9va1R5cGVzRGV2W2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2XSAhPT0gaG9va05hbWUpIHtcbiAgICAgICAgd2Fybk9uSG9va01pc21hdGNoSW5EZXYoaG9va05hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKSB7XG4gIHtcbiAgICBpZiAoZGVwcyAhPT0gdW5kZWZpbmVkICYmIGRlcHMgIT09IG51bGwgJiYgIWlzQXJyYXkoZGVwcykpIHtcbiAgICAgIC8vIFZlcmlmeSBkZXBzLCBidXQgb25seSBvbiBtb3VudCB0byBhdm9pZCBleHRyYSBjaGVja3MuXG4gICAgICAvLyBJdCdzIHVubGlrZWx5IHRoZWlyIHR5cGUgd291bGQgY2hhbmdlIGFzIHVzdWFsbHkgeW91IGRlZmluZSB0aGVtIGlubGluZS5cbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IHRoYXQgaXMgbm90IGFuIGFycmF5IChpbnN0ZWFkLCByZWNlaXZlZCBgJXNgKS4gV2hlbiAnICsgJ3NwZWNpZmllZCwgdGhlIGZpbmFsIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIHR5cGVvZiBkZXBzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uSG9va01pc21hdGNoSW5EZXYoY3VycmVudEhvb2tOYW1lKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSk7XG5cbiAgICBpZiAoIWRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgIGlmIChob29rVHlwZXNEZXYgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gJyc7XG4gICAgICAgIHZhciBzZWNvbmRDb2x1bW5TdGFydCA9IDMwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2OyBpKyspIHtcbiAgICAgICAgICB2YXIgb2xkSG9va05hbWUgPSBob29rVHlwZXNEZXZbaV07XG4gICAgICAgICAgdmFyIG5ld0hvb2tOYW1lID0gaSA9PT0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPyBjdXJyZW50SG9va05hbWUgOiBvbGRIb29rTmFtZTtcbiAgICAgICAgICB2YXIgcm93ID0gaSArIDEgKyBcIi4gXCIgKyBvbGRIb29rTmFtZTsgLy8gRXh0cmEgc3BhY2Ugc28gc2Vjb25kIGNvbHVtbiBsaW5lcyB1cFxuICAgICAgICAgIC8vIGxvbCBAIElFIG5vdCBzdXBwb3J0aW5nIFN0cmluZyNyZXBlYXRcblxuICAgICAgICAgIHdoaWxlIChyb3cubGVuZ3RoIDwgc2Vjb25kQ29sdW1uU3RhcnQpIHtcbiAgICAgICAgICAgIHJvdyArPSAnICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm93ICs9IG5ld0hvb2tOYW1lICsgJ1xcbic7XG4gICAgICAgICAgdGFibGUgKz0gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJ1JlYWN0IGhhcyBkZXRlY3RlZCBhIGNoYW5nZSBpbiB0aGUgb3JkZXIgb2YgSG9va3MgY2FsbGVkIGJ5ICVzLiAnICsgJ1RoaXMgd2lsbCBsZWFkIHRvIGJ1Z3MgYW5kIGVycm9ycyBpZiBub3QgZml4ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlYWQgdGhlIFJ1bGVzIG9mIEhvb2tzOiBodHRwczovL3JlYWN0LmRldi9saW5rL3J1bGVzLW9mLWhvb2tzXFxuXFxuJyArICcgICBQcmV2aW91cyByZW5kZXIgICAgICAgICAgICBOZXh0IHJlbmRlclxcbicgKyAnICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuJyArICclcycgKyAnICAgXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXFxuJywgY29tcG9uZW50TmFtZSwgdGFibGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpIHtcbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcblxuICAgIGlmICghZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgZXJyb3IoJ1JlYWN0RE9NLnVzZUZvcm1TdGF0ZSBoYXMgYmVlbiByZW5hbWVkIHRvIFJlYWN0LnVzZUFjdGlvblN0YXRlLiAnICsgJ1BsZWFzZSB1cGRhdGUgJXMgdG8gdXNlIFJlYWN0LnVzZUFjdGlvblN0YXRlLicsIGNvbXBvbmVudE5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuSWZBc3luY0NsaWVudENvbXBvbmVudChDb21wb25lbnQpIHtcbiAge1xuICAgIC8vIFRoaXMgZGV2LW9ubHkgY2hlY2sgb25seSB3b3JrcyBmb3IgZGV0ZWN0aW5nIG5hdGl2ZSBhc3luYyBmdW5jdGlvbnMsXG4gICAgLy8gbm90IHRyYW5zcGlsZWQgb25lcy4gVGhlcmUncyBhbHNvIGEgcHJvZCBjaGVjayB0aGF0IHdlIHVzZSB0byBwcmV2ZW50XG4gICAgLy8gYXN5bmMgY2xpZW50IGNvbXBvbmVudHMgZnJvbSBjcmFzaGluZyB0aGUgYXBwOyB0aGUgcHJvZCBvbmUgd29ya3MgZXZlblxuICAgIC8vIGZvciB0cmFuc3BpbGVkIGFzeW5jIGZ1bmN0aW9ucy4gTmVpdGhlciBtZWNoYW5pc20gaXMgY29tcGxldGVseVxuICAgIC8vIGJ1bGxldHByb29mIGJ1dCB0b2dldGhlciB0aGV5IGNvdmVyIHRoZSBtb3N0IGNvbW1vbiBjYXNlcy5cbiAgICB2YXIgaXNBc3luY0Z1bmN0aW9uID0gLy8gJEZsb3dJZ25vcmVbbWV0aG9kLXVuYmluZGluZ11cbiAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoQ29tcG9uZW50KSA9PT0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nIHx8IC8vICRGbG93SWdub3JlW21ldGhvZC11bmJpbmRpbmddXG4gICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKENvbXBvbmVudCkgPT09ICdbb2JqZWN0IEFzeW5jR2VuZXJhdG9yRnVuY3Rpb25dJztcblxuICAgIGlmIChpc0FzeW5jRnVuY3Rpb24pIHtcbiAgICAgIC8vIEVuY291bnRlcmVkIGFuIGFzeW5jIENsaWVudCBDb21wb25lbnQuIFRoaXMgaXMgbm90IHlldCBzdXBwb3J0ZWQuXG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignYXN5bmMvYXdhaXQgaXMgbm90IHlldCBzdXBwb3J0ZWQgaW4gQ2xpZW50IENvbXBvbmVudHMsIG9ubHkgJyArICdTZXJ2ZXIgQ29tcG9uZW50cy4gVGhpcyBlcnJvciBpcyBvZnRlbiBjYXVzZWQgYnkgYWNjaWRlbnRhbGx5ICcgKyBcImFkZGluZyBgJ3VzZSBjbGllbnQnYCB0byBhIG1vZHVsZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gXCIgKyAnZm9yIHRoZSBzZXJ2ZXIuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93SW52YWxpZEhvb2tFcnJvcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yJyArICcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4nICsgJzEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbicgKyAnMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbicgKyAnMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLicpO1xufVxuXG5mdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gIHtcbiAgICBpZiAoaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMpIHtcbiAgICAgIC8vIE9ubHkgdHJ1ZSB3aGVuIHRoaXMgY29tcG9uZW50IGlzIGJlaW5nIGhvdCByZWxvYWRlZC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJldkRlcHMgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCBub3QgZHVyaW5nICcgKyAndGhlIHByZXZpb3VzIHJlbmRlci4gRXZlbiB0aG91Z2ggdGhlIGZpbmFsIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCAnICsgJ2l0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLicsIGN1cnJlbnRIb29rTmFtZUluRGV2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB7XG4gICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZyBsZW5ndGhzIGluIHByb2QgYmVjYXVzZSB0aGVzZSBhcnJheXMgc2hvdWxkIGJlXG4gICAgLy8gcGFzc2VkIGlubGluZS5cbiAgICBpZiAobmV4dERlcHMubGVuZ3RoICE9PSBwcmV2RGVwcy5sZW5ndGgpIHtcbiAgICAgIGVycm9yKCdUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSAnICsgJ29yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuJyArICdQcmV2aW91czogJXNcXG4nICsgJ0luY29taW5nOiAlcycsIGN1cnJlbnRIb29rTmFtZUluRGV2LCBcIltcIiArIHByZXZEZXBzLmpvaW4oJywgJykgKyBcIl1cIiwgXCJbXCIgKyBuZXh0RGVwcy5qb2luKCcsICcpICsgXCJdXCIpO1xuICAgIH1cbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKykge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgIGlmIChvYmplY3RJcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcsIG5leHRSZW5kZXJMYW5lcykge1xuICByZW5kZXJMYW5lcyA9IG5leHRSZW5kZXJMYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IHdvcmtJblByb2dyZXNzO1xuXG4gIHtcbiAgICBob29rVHlwZXNEZXYgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5fZGVidWdIb29rVHlwZXMgOiBudWxsO1xuICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7IC8vIFVzZWQgZm9yIGhvdCByZWxvYWRpbmc6XG5cbiAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHdhcm5JZkFzeW5jQ2xpZW50Q29tcG9uZW50KENvbXBvbmVudCk7XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSBmb2xsb3dpbmcgc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHJlc2V0XG4gIC8vIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgLy8gd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgLy8gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAvLyBsb2NhbElkQ291bnRlciA9IDA7XG4gIC8vIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgLy8gdGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gIC8vIFRPRE8gV2FybiBpZiBubyBob29rcyBhcmUgdXNlZCBhdCBhbGwgZHVyaW5nIG1vdW50LCB0aGVuIHNvbWUgYXJlIHVzZWQgZHVyaW5nIHVwZGF0ZS5cbiAgLy8gQ3VycmVudGx5IHdlIHdpbGwgaWRlbnRpZnkgdGhlIHVwZGF0ZSByZW5kZXIgYXMgYSBtb3VudCBiZWNhdXNlIG1lbW9pemVkU3RhdGUgPT09IG51bGwuXG4gIC8vIFRoaXMgaXMgdHJpY2t5IGJlY2F1c2UgaXQncyB2YWxpZCBmb3IgY2VydGFpbiB0eXBlcyBvZiBjb21wb25lbnRzIChlLmcuIFJlYWN0LmxhenkpXG4gIC8vIFVzaW5nIG1lbW9pemVkU3RhdGUgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIG1vdW50L3VwZGF0ZSBvbmx5IHdvcmtzIGlmIGF0IGxlYXN0IG9uZSBzdGF0ZWZ1bCBob29rIGlzIHVzZWQuXG4gIC8vIE5vbi1zdGF0ZWZ1bCBob29rcyAoZS5nLiBjb250ZXh0KSBkb24ndCBnZXQgYWRkZWQgdG8gbWVtb2l6ZWRTdGF0ZSxcbiAgLy8gc28gbWVtb2l6ZWRTdGF0ZSB3b3VsZCBiZSBudWxsIGR1cmluZyB1cGRhdGVzIGFuZCBtb3VudHMuXG5cbiAge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgfSBlbHNlIGlmIChob29rVHlwZXNEZXYgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgZGlzcGF0Y2hlciBoYW5kbGVzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGNvbXBvbmVudCBpcyB1cGRhdGluZyxcbiAgICAgIC8vIGJ1dCBubyBzdGF0ZWZ1bCBob29rcyBoYXZlIGJlZW4gdXNlZC5cbiAgICAgIC8vIFdlIHdhbnQgdG8gbWF0Y2ggdGhlIHByb2R1Y3Rpb24gY29kZSBiZWhhdmlvciAod2hpY2ggd2lsbCB1c2UgSG9va3NEaXNwYXRjaGVyT25Nb3VudCksXG4gICAgICAvLyBidXQgd2l0aCB0aGUgZXh0cmEgREVWIHZhbGlkYXRpb24gdG8gZW5zdXJlIGhvb2tzIG9yZGVyaW5nIGhhc24ndCBjaGFuZ2VkLlxuICAgICAgLy8gVGhpcyBkaXNwYXRjaGVyIGRvZXMgdGhhdC5cbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgIH1cbiAgfSAvLyBJbiBTdHJpY3QgTW9kZSwgZHVyaW5nIGRldmVsb3BtZW50LCB1c2VyIGZ1bmN0aW9ucyBhcmUgZG91YmxlIGludm9rZWQgdG9cbiAgLy8gaGVscCBkZXRlY3Qgc2lkZSBlZmZlY3RzLiBUaGUgbG9naWMgZm9yIGhvdyB0aGlzIGlzIGltcGxlbWVudGVkIGZvciBpblxuICAvLyBob29rIGNvbXBvbmVudHMgaXMgYSBiaXQgY29tcGxleCBzbyBsZXQncyBicmVhayBpdCBkb3duLlxuICAvL1xuICAvLyBXZSB3aWxsIGludm9rZSB0aGUgZW50aXJlIGNvbXBvbmVudCBmdW5jdGlvbiB0d2ljZS4gSG93ZXZlciwgZHVyaW5nIHRoZVxuICAvLyBzZWNvbmQgaW52b2NhdGlvbiBvZiB0aGUgY29tcG9uZW50LCB0aGUgaG9vayBzdGF0ZSBmcm9tIHRoZSBmaXJzdFxuICAvLyBpbnZvY2F0aW9uIHdpbGwgYmUgcmV1c2VkLiBUaGF0IG1lYW5zIHRoaW5ncyBsaWtlIGB1c2VNZW1vYCBmdW5jdGlvbnMgd29uJ3RcbiAgLy8gcnVuIGFnYWluLCBiZWNhdXNlIHRoZSBkZXBzIHdpbGwgbWF0Y2ggYW5kIHRoZSBtZW1vaXplZCByZXN1bHQgd2lsbFxuICAvLyBiZSByZXVzZWQuXG4gIC8vXG4gIC8vIFdlIHdhbnQgbWVtb2l6ZWQgZnVuY3Rpb25zIHRvIHJ1biB0d2ljZSwgdG9vLCBzbyBhY2NvdW50IGZvciB0aGlzLCB1c2VyXG4gIC8vIGZ1bmN0aW9ucyBhcmUgZG91YmxlIGludm9rZWQgZHVyaW5nIHRoZSAqZmlyc3QqIGludm9jYXRpb24gb2YgdGhlIGNvbXBvbmVudFxuICAvLyBmdW5jdGlvbiwgYW5kIGFyZSAqbm90KiBkb3VibGUgaW52b2tlZCBkdXJpbmcgdGhlIHNlY29uZCBpbmNvdmF0aW9uOlxuICAvL1xuICAvLyAtIEZpcnN0IGV4ZWN1dGlvbiBvZiBjb21wb25lbnQgZnVuY3Rpb246IHVzZXIgZnVuY3Rpb25zIGFyZSBkb3VibGUgaW52b2tlZFxuICAvLyAtIFNlY29uZCBleGVjdXRpb24gb2YgY29tcG9uZW50IGZ1bmN0aW9uIChpbiBTdHJpY3QgTW9kZSwgZHVyaW5nXG4gIC8vICAgZGV2ZWxvcG1lbnQpOiB1c2VyIGZ1bmN0aW9ucyBhcmUgbm90IGRvdWJsZSBpbnZva2VkLlxuICAvL1xuICAvLyBUaGlzIGlzIGludGVudGlvbmFsIGZvciBhIGZldyByZWFzb25zOyBtb3N0IGltcG9ydGFudGx5LCBpdCdzIGJlY2F1c2Ugb2ZcbiAgLy8gaG93IGB1c2VgIHdvcmtzIHdoZW4gc29tZXRoaW5nIHN1c3BlbmRzOiBpdCByZXVzZXMgdGhlIHByb21pc2UgdGhhdCB3YXNcbiAgLy8gcGFzc2VkIGR1cmluZyB0aGUgZmlyc3QgYXR0ZW1wdC4gVGhpcyBpcyBpdHNlbGYgYSBmb3JtIG9mIG1lbW9pemF0aW9uLlxuICAvLyBXZSBuZWVkIHRvIGJlIGFibGUgdG8gbWVtb2l6ZSB0aGUgcmVhY3RpdmUgaW5wdXRzIHRvIHRoZSBgdXNlYCBjYWxsIHVzaW5nXG4gIC8vIGEgaG9vayAoaS5lLiBgdXNlTWVtb2ApLCB3aGljaCBtZWFucywgdGhlIHJlYWN0aXZlIGlucHV0cyB0byBgdXNlYCBtdXN0XG4gIC8vIGNvbWUgZnJvbSB0aGUgc2FtZSBjb21wb25lbnQgaW52b2NhdGlvbiBhcyB0aGUgb3V0cHV0LlxuICAvL1xuICAvLyBUaGVyZSBhcmUgcGxlbnR5IG9mIHRlc3RzIHRvIGVuc3VyZSB0aGlzIGJlaGF2aW9yIGlzIGNvcnJlY3QuXG5cblxuICB2YXIgc2hvdWxkRG91YmxlUmVuZGVyREVWID0gKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSAhPT0gTm9Nb2RlO1xuICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9IHNob3VsZERvdWJsZVJlbmRlckRFVjtcbiAgdmFyIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9IGZhbHNlOyAvLyBDaGVjayBpZiB0aGVyZSB3YXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlXG5cbiAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcykge1xuICAgIC8vIEtlZXAgcmVuZGVyaW5nIHVudGlsIHRoZSBjb21wb25lbnQgc3RhYmlsaXplcyAodGhlcmUgYXJlIG5vIG1vcmUgcmVuZGVyXG4gICAgLy8gcGhhc2UgdXBkYXRlcykuXG4gICAgY2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3NBZ2Fpbih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKTtcbiAgfVxuXG4gIGlmIChzaG91bGREb3VibGVSZW5kZXJERVYpIHtcbiAgICAvLyBJbiBkZXZlbG9wbWVudCwgY29tcG9uZW50cyBhcmUgaW52b2tlZCB0d2ljZSB0byBoZWxwIGRldGVjdCBzaWRlIGVmZmVjdHMuXG4gICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICB0cnkge1xuICAgICAgY2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3NBZ2Fpbih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGZpbmlzaFJlbmRlcmluZ0hvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KSB7XG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXMgPSBob29rVHlwZXNEZXY7XG4gIH0gLy8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY2UuXG5cblxuICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyOyAvLyBUaGlzIGNoZWNrIHVzZXMgY3VycmVudEhvb2sgc28gdGhhdCBpdCB3b3JrcyB0aGUgc2FtZSBpbiBERVYgYW5kIHByb2QgYnVuZGxlcy5cbiAgLy8gaG9va1R5cGVzRGV2IGNvdWxkIGNhdGNoIG1vcmUgY2FzZXMgKGUuZy4gY29udGV4dCkgYnV0IG9ubHkgaW4gREVWIGJ1bmRsZXMuXG5cbiAgdmFyIGRpZFJlbmRlclRvb0Zld0hvb2tzID0gY3VycmVudEhvb2sgIT09IG51bGwgJiYgY3VycmVudEhvb2submV4dCAhPT0gbnVsbDtcbiAgcmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgY3VycmVudEhvb2sgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7XG4gICAgaG9va1R5cGVzRGV2ID0gbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBDb25maXJtIHRoYXQgYSBzdGF0aWMgZmxhZyB3YXMgbm90IGFkZGVkIG9yIHJlbW92ZWQgc2luY2UgdGhlIGxhc3RcbiAgICAvLyByZW5kZXIuIElmIHRoaXMgZmlyZXMsIGl0IHN1Z2dlc3RzIHRoYXQgd2UgaW5jb3JyZWN0bHkgcmVzZXQgdGhlIHN0YXRpY1xuICAgIC8vIGZsYWdzIGluIHNvbWUgb3RoZXIgcGFydCBvZiB0aGUgY29kZWJhc2UuIFRoaXMgaGFzIGhhcHBlbmVkIGJlZm9yZSwgZm9yXG4gICAgLy8gZXhhbXBsZSwgaW4gdGhlIFN1c3BlbnNlTGlzdCBpbXBsZW1lbnRhdGlvbi5cblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIChjdXJyZW50LmZsYWdzICYgU3RhdGljTWFzaykgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIFN0YXRpY01hc2spICYmICggLy8gRGlzYWJsZSB0aGlzIHdhcm5pbmcgaW4gbGVnYWN5IG1vZGUsIGJlY2F1c2UgbGVnYWN5IFN1c3BlbnNlIGlzIHdlaXJkXG4gICAgLy8gYW5kIGNyZWF0ZXMgZmFsc2UgcG9zaXRpdmVzLiBUbyBtYWtlIHRoaXMgd29yayBpbiBsZWdhY3kgbW9kZSwgd2UnZFxuICAgIC8vIG5lZWQgdG8gbWFyayBmaWJlcnMgdGhhdCBjb21taXQgaW4gYW4gaW5jb21wbGV0ZSBzdGF0ZSwgc29tZWhvdy4gRm9yXG4gICAgLy8gbm93IEknbGwgZGlzYWJsZSB0aGUgd2FybmluZyB0aGF0IG1vc3Qgb2YgdGhlIGJ1Z3MgdGhhdCB3b3VsZCB0cmlnZ2VyXG4gICAgLy8gaXQgYXJlIGVpdGhlciBleGNsdXNpdmUgdG8gY29uY3VycmVudCBtb2RlIG9yIGV4aXN0IGluIGJvdGguXG4gICAgZGlzYWJsZUxlZ2FjeU1vZGUgKSkge1xuICAgICAgZXJyb3IoJ0ludGVybmFsIFJlYWN0IGVycm9yOiBFeHBlY3RlZCBzdGF0aWMgZmxhZyB3YXMgbWlzc2luZy4gUGxlYXNlICcgKyAnbm90aWZ5IHRoZSBSZWFjdCB0ZWFtLicpO1xuICAgIH1cbiAgfVxuXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gVGhpcyBpcyByZXNldCBieSBjaGVja0RpZFJlbmRlcklkSG9va1xuICAvLyBsb2NhbElkQ291bnRlciA9IDA7XG5cbiAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcblxuICBpZiAoZGlkUmVuZGVyVG9vRmV3SG9va3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIGZld2VyIGhvb2tzIHRoYW4gZXhwZWN0ZWQuIFRoaXMgbWF5IGJlIGNhdXNlZCBieSBhbiBhY2NpZGVudGFsICcgKyAnZWFybHkgcmV0dXJuIHN0YXRlbWVudC4nKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoY2hlY2tJZlVzZVdyYXBwZWRJblRyeUNhdGNoKCkpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoLmhhcyhjb21wb25lbnROYW1lKSAmJiAvLyBUaGlzIHdhcm5pbmcgYWxzbyBmaXJlcyBpZiB5b3Ugc3VzcGVuZCB3aXRoIGB1c2VgIGluc2lkZSBhblxuICAgICAgLy8gYXN5bmMgY29tcG9uZW50LiBTaW5jZSB3ZSB3YXJuIGZvciB0aGF0IGFib3ZlLCB3ZSdsbCBzaWxlbmNlIHRoaXNcbiAgICAgIC8vIHNlY29uZCB3YXJuaW5nIGJ5IGNoZWNraW5nIGhlcmUuXG4gICAgICAhZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignYHVzZWAgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIHRyeS9jYXRjaCBibG9jay4gVGhpcyBpcyBub3QgYWxsb3dlZCAnICsgJ2FuZCBjYW4gbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yLiBUbyBoYW5kbGUgZXJyb3JzIHRyaWdnZXJlZCAnICsgJ2J5IGB1c2VgLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGEgZXJyb3IgYm91bmRhcnkuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxheVN1c3BlbmRlZENvbXBvbmVudFdpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZXBsYXkgYSBjb21wb25lbnQgdGhhdCBwcmV2aW91c2x5IHN1c3BlbmRlZCxcbiAgLy8gYWZ0ZXIgaXRzIGRhdGEgcmVzb2x2ZXMuXG4gIC8vXG4gIC8vIEl0J3MgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgcmVuZGVyV2l0aEhvb2tzLCBidXQgaXQgZG9lc24ndCBuZWVkIHRvIGRvXG4gIC8vIG1vc3Qgb2YgdGhlIHNldCB1cCB3b3JrIGJlY2F1c2UgdGhleSB3ZXJlbid0IHJlc2V0IHdoZW4gd2Ugc3VzcGVuZGVkOyB0aGV5XG4gIC8vIG9ubHkgZ2V0IHJlc2V0IHdoZW4gdGhlIGNvbXBvbmVudCBlaXRoZXIgY29tcGxldGVzIChmaW5pc2hSZW5kZXJpbmdIb29rcylcbiAgLy8gb3IgdW53aW5kcyAocmVzZXRIb29rc09uVW53aW5kKS5cbiAge1xuICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7IC8vIFVzZWQgZm9yIGhvdCByZWxvYWRpbmc6XG5cbiAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB9XG5cbiAgdmFyIGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4od29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gIGZpbmlzaFJlbmRlcmluZ0hvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiByZW5kZXJXaXRoSG9va3NBZ2Fpbih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKSB7XG4gIC8vIFRoaXMgaXMgdXNlZCB0byBwZXJmb3JtIGFub3RoZXIgcmVuZGVyIHBhc3MuIEl0J3MgdXNlZCB3aGVuIHNldFN0YXRlIGlzXG4gIC8vIGNhbGxlZCBkdXJpbmcgcmVuZGVyLCBhbmQgZm9yIGRvdWJsZSBpbnZva2luZyBjb21wb25lbnRzIGluIFN0cmljdCBNb2RlXG4gIC8vIGR1cmluZyBkZXZlbG9wbWVudC5cbiAgLy9cbiAgLy8gVGhlIHN0YXRlIGZyb20gdGhlIHByZXZpb3VzIHBhc3MgaXMgcmV1c2VkIHdoZW5ldmVyIHBvc3NpYmxlLiBTbywgc3RhdGVcbiAgLy8gdXBkYXRlcyB0aGF0IHdlcmUgYWxyZWFkeSBwcm9jZXNzZWQgYXJlIG5vdCBwcm9jZXNzZWQgYWdhaW4sIGFuZCBtZW1vaXplZFxuICAvLyBmdW5jdGlvbnMgKGB1c2VNZW1vYCkgYXJlIG5vdCBpbnZva2VkIGFnYWluLlxuICAvL1xuICAvLyBLZWVwIHJlbmRlcmluZyBpbiBhIGxvb3AgZm9yIGFzIGxvbmcgYXMgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgY29udGludWUgdG9cbiAgLy8gYmUgc2NoZWR1bGVkLiBVc2UgYSBjb3VudGVyIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcbiAgdmFyIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgdmFyIGNoaWxkcmVuO1xuXG4gIGRvIHtcbiAgICBpZiAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzKSB7XG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgYSB1c2UoKSB2YWx1ZSBkZXBlbmRlZCBvbiBhIHN0YXRlIHRoYXQgd2FzIHVwZGF0ZWQgaW5cbiAgICAgIC8vIHRoaXMgcmVyZW5kZXIsIHNvIHdlIG5lZWQgdG8gd2F0Y2ggZm9yIGRpZmZlcmVudCB0aGVuYWJsZXMgdGhpcyB0aW1lLlxuICAgICAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGZhbHNlO1xuXG4gICAgaWYgKG51bWJlck9mUmVSZW5kZXJzID49IFJFX1JFTkRFUl9MSU1JVCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgJyArICdhbiBpbmZpbml0ZSBsb29wLicpO1xuICAgIH1cblxuICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7XG5cbiAgICB7XG4gICAgICAvLyBFdmVuIHdoZW4gaG90IHJlbG9hZGluZywgYWxsb3cgZGVwZW5kZW5jaWVzIHRvIHN0YWJpbGl6ZVxuICAgICAgLy8gYWZ0ZXIgZmlyc3QgcmVuZGVyIHRvIHByZXZlbnQgaW5maW5pdGUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMuXG4gICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGZhbHNlO1xuICAgIH0gLy8gU3RhcnQgb3ZlciBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RcblxuXG4gICAgY3VycmVudEhvb2sgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuXG4gICAge1xuICAgICAgLy8gQWxzbyB2YWxpZGF0ZSBob29rIG9yZGVyIGZvciBjYXNjYWRpbmcgdXBkYXRlcy5cbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgfVxuXG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA7XG4gICAgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gIH0gd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyk7XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiByZW5kZXJUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50V2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBsYW5lcykge1xuXG4gIHJldHVybiByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIFRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnQsIG51bGwsIG51bGwsIGxhbmVzKTtcbn1cbmZ1bmN0aW9uIFRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnQoKSB7XG5cbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuXG4gIHZhciBfZGlzcGF0Y2hlciR1c2VTdGF0ZSA9IGRpc3BhdGNoZXIudXNlU3RhdGUoKSxcbiAgICAgIG1heWJlVGhlbmFibGUgPSBfZGlzcGF0Y2hlciR1c2VTdGF0ZVswXTtcblxuICB2YXIgbmV4dFN0YXRlO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVUaGVuYWJsZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHRoZW5hYmxlID0gbWF5YmVUaGVuYWJsZTtcbiAgICBuZXh0U3RhdGUgPSB1c2VUaGVuYWJsZSh0aGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0YXR1cyA9IG1heWJlVGhlbmFibGU7XG4gICAgbmV4dFN0YXRlID0gc3RhdHVzO1xuICB9IC8vIFRoZSBcInJlc2V0IHN0YXRlXCIgaXMgYW4gb2JqZWN0LiBJZiBpdCBjaGFuZ2VzLCB0aGF0IG1lYW5zIHNvbWV0aGluZ1xuICAvLyByZXF1ZXN0ZWQgdGhhdCB3ZSByZXNldCB0aGUgZm9ybS5cblxuXG4gIHZhciBfZGlzcGF0Y2hlciR1c2VTdGF0ZTIgPSBkaXNwYXRjaGVyLnVzZVN0YXRlKCksXG4gICAgICBuZXh0UmVzZXRTdGF0ZSA9IF9kaXNwYXRjaGVyJHVzZVN0YXRlMlswXTtcblxuICB2YXIgcHJldlJlc2V0U3RhdGUgPSBjdXJyZW50SG9vayAhPT0gbnVsbCA/IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUgOiBudWxsO1xuXG4gIGlmIChwcmV2UmVzZXRTdGF0ZSAhPT0gbmV4dFJlc2V0U3RhdGUpIHtcbiAgICAvLyBTY2hlZHVsZSBhIGZvcm0gcmVzZXRcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IEZvcm1SZXNldDtcbiAgfVxuXG4gIHJldHVybiBuZXh0U3RhdGU7XG59XG5mdW5jdGlvbiBjaGVja0RpZFJlbmRlcklkSG9vaygpIHtcbiAgLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGV2ZXJ5IHJlbmRlcldpdGhIb29rcyBjYWxsLlxuICAvLyBDb25jZXB0dWFsbHksIGl0J3MgcGFydCBvZiB0aGUgcmV0dXJuIHZhbHVlIG9mIHJlbmRlcldpdGhIb29rczsgaXQncyBvbmx5IGFcbiAgLy8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gYXZvaWQgdXNpbmcgYW4gYXJyYXkgdHVwbGUuXG4gIHZhciBkaWRSZW5kZXJJZEhvb2sgPSBsb2NhbElkQ291bnRlciAhPT0gMDtcbiAgbG9jYWxJZENvdW50ZXIgPSAwO1xuICByZXR1cm4gZGlkUmVuZGVySWRIb29rO1xufVxuZnVuY3Rpb24gYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBsYW5lcykge1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7IC8vIFRPRE86IERvbid0IG5lZWQgdG8gcmVzZXQgdGhlIGZsYWdzIGhlcmUsIGJlY2F1c2UgdGhleSdyZSByZXNldCBpbiB0aGVcbiAgLy8gY29tcGxldGUgcGhhc2UgKGJ1YmJsZVByb3BlcnRpZXMpLlxuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfihNb3VudFBhc3NpdmVEZXYgfCBNb3VudExheW91dERldiB8IFBhc3NpdmUkMSB8IFVwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfihQYXNzaXZlJDEgfCBVcGRhdGUpO1xuICB9XG5cbiAgY3VycmVudC5sYW5lcyA9IHJlbW92ZUxhbmVzKGN1cnJlbnQubGFuZXMsIGxhbmVzKTtcbn1cbmZ1bmN0aW9uIHJlc2V0SG9va3NBZnRlclRocm93KCkge1xuICAvLyBUaGlzIGlzIGNhbGxlZCBpbW1lZGlhZXRseSBhZnRlciBhIHRocm93LiBJdCBzaG91bGRuJ3QgcmVzZXQgdGhlIGVudGlyZVxuICAvLyBtb2R1bGUgc3RhdGUsIGJlY2F1c2UgdGhlIHdvcmsgbG9vcCBtaWdodCBkZWNpZGUgdG8gcmVwbGF5IHRoZSBjb21wb25lbnRcbiAgLy8gYWdhaW4gd2l0aG91dCByZXdpbmRpbmcuXG4gIC8vXG4gIC8vIEl0IHNob3VsZCBvbmx5IHJlc2V0IHRoaW5ncyBsaWtlIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIsIHRvIHByZXZlbnQgaG9va3NcbiAgLy8gZnJvbSBiZWluZyBjYWxsZWQgb3V0c2lkZSBvZiBhIGNvbXBvbmVudC5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7IC8vIFdlIGNhbiBhc3N1bWUgdGhlIHByZXZpb3VzIGRpc3BhdGNoZXIgaXMgYWx3YXlzIHRoaXMgb25lLCBzaW5jZSB3ZSBzZXQgaXRcbiAgLy8gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVuZGVyIHBoYXNlIGFuZCB0aGVyZSdzIG5vIHJlLWVudHJhbmNlLlxuXG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG59XG5mdW5jdGlvbiByZXNldEhvb2tzT25VbndpbmQod29ya0luUHJvZ3Jlc3MpIHtcbiAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAvLyBUaGVyZSB3ZXJlIHJlbmRlciBwaGFzZSB1cGRhdGVzLiBUaGVzZSBhcmUgb25seSB2YWxpZCBmb3IgdGhpcyByZW5kZXJcbiAgICAvLyBwaGFzZSwgd2hpY2ggd2UgYXJlIG5vdyBhYm9ydGluZy4gUmVtb3ZlIHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlcyBzb1xuICAgIC8vIHRoZXkgZG8gbm90IHBlcnNpc3QgdG8gdGhlIG5leHQgcmVuZGVyLiBEbyBub3QgcmVtb3ZlIHVwZGF0ZXMgZnJvbSBob29rc1xuICAgIC8vIHRoYXQgd2VyZW4ndCBwcm9jZXNzZWQuXG4gICAgLy9cbiAgICAvLyBPbmx5IHJlc2V0IHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlIGlmIGl0IGhhcyBhIGNsb25lLiBJZiBpdCBkb2VzXG4gICAgLy8gbm90IGhhdmUgYSBjbG9uZSwgdGhhdCBtZWFucyBpdCB3YXNuJ3QgcHJvY2Vzc2VkLCBhbmQgdGhlIHVwZGF0ZXMgd2VyZVxuICAgIC8vIHNjaGVkdWxlZCBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIHZhciBob29rID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgIHdoaWxlIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuXG4gICAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhvb2sgPSBob29rLm5leHQ7XG4gICAgfVxuXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgY3VycmVudEhvb2sgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG4gIHtcbiAgICBob29rVHlwZXNEZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICB9XG5cbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG4gIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gIHZhciBob29rID0ge1xuICAgIG1lbW9pemVkU3RhdGU6IG51bGwsXG4gICAgYmFzZVN0YXRlOiBudWxsLFxuICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICBxdWV1ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3RcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBob29rO1xuICB9IGVsc2Uge1xuICAgIC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBob29rO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYm90aCBmb3IgdXBkYXRlcyBhbmQgZm9yIHJlLXJlbmRlcnMgdHJpZ2dlcmVkIGJ5IGFcbiAgLy8gcmVuZGVyIHBoYXNlIHVwZGF0ZS4gSXQgYXNzdW1lcyB0aGVyZSBpcyBlaXRoZXIgYSBjdXJyZW50IGhvb2sgd2UgY2FuXG4gIC8vIGNsb25lLCBvciBhIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBmcm9tIGEgcHJldmlvdXMgcmVuZGVyIHBhc3MgdGhhdCB3ZSBjYW5cbiAgLy8gdXNlIGFzIGEgYmFzZS5cbiAgdmFyIG5leHRDdXJyZW50SG9vaztcblxuICBpZiAoY3VycmVudEhvb2sgPT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEN1cnJlbnRIb29rID0gbnVsbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcbiAgfVxuXG4gIHZhciBuZXh0V29ya0luUHJvZ3Jlc3NIb29rO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlO1xuICB9IGVsc2Uge1xuICAgIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgfVxuXG4gIGlmIChuZXh0V29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbmV4dFdvcmtJblByb2dyZXNzSG9vaztcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2s7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2xvbmUgZnJvbSB0aGUgY3VycmVudCBob29rLlxuICAgIGlmIChuZXh0Q3VycmVudEhvb2sgPT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50RmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBpbml0aWFsIHJlbmRlci4gVGhpcyBicmFuY2ggaXMgcmVhY2hlZCB3aGVuIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gc3VzcGVuZHMsIHJlc3VtZXMsIHRoZW4gcmVuZGVycyBhbiBhZGRpdGlvbmFsIGhvb2suXG4gICAgICAgIC8vIFNob3VsZCBuZXZlciBiZSByZWFjaGVkIGJlY2F1c2Ugd2Ugc2hvdWxkIHN3aXRjaCB0byB0aGUgbW91bnQgZGlzcGF0Y2hlciBmaXJzdC5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVcGRhdGUgaG9vayBjYWxsZWQgb24gaW5pdGlhbCByZW5kZXIuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gdXBkYXRlLiBXZSBzaG91bGQgYWx3YXlzIGhhdmUgYSBjdXJyZW50IGhvb2suXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyZWQgbW9yZSBob29rcyB0aGFuIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICAgIHZhciBuZXdIb29rID0ge1xuICAgICAgbWVtb2l6ZWRTdGF0ZTogY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudEhvb2suYmFzZVN0YXRlLFxuICAgICAgYmFzZVF1ZXVlOiBjdXJyZW50SG9vay5iYXNlUXVldWUsXG4gICAgICBxdWV1ZTogY3VycmVudEhvb2sucXVldWUsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3QuXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXdIb29rO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gbmV3SG9vaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufSAvLyBOT1RFOiBkZWZpbmluZyB0d28gdmVyc2lvbnMgb2YgdGhpcyBmdW5jdGlvbiB0byBhdm9pZCBzaXplIGltcGFjdCB3aGVuIHRoaXMgZmVhdHVyZSBpcyBkaXNhYmxlZC5cbi8vIFByZXZpb3VzbHkgdGhpcyBmdW5jdGlvbiB3YXMgaW5saW5lZCwgdGhlIGFkZGl0aW9uYWwgYG1lbW9DYWNoZWAgcHJvcGVydHkgbWFrZXMgaXQgbm90IGlubGluZWQuXG5cblxudmFyIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWU7XG5cbntcbiAgY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFzdEVmZmVjdDogbnVsbCxcbiAgICAgIGV2ZW50czogbnVsbCxcbiAgICAgIHN0b3JlczogbnVsbCxcbiAgICAgIG1lbW9DYWNoZTogbnVsbFxuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gIC8vIFRyYWNrIHRoZSBwb3NpdGlvbiBvZiB0aGUgdGhlbmFibGUgd2l0aGluIHRoaXMgZmliZXIuXG4gIHZhciBpbmRleCA9IHRoZW5hYmxlSW5kZXhDb3VudGVyO1xuICB0aGVuYWJsZUluZGV4Q291bnRlciArPSAxO1xuXG4gIGlmICh0aGVuYWJsZVN0YXRlID09PSBudWxsKSB7XG4gICAgdGhlbmFibGVTdGF0ZSA9IGNyZWF0ZVRoZW5hYmxlU3RhdGUoKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpO1xuXG4gIGlmIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZSA9PT0gbnVsbCAmJiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsID8gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID09PSBudWxsIDogd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPT09IG51bGwpKSB7XG4gICAgLy8gSW5pdGlhbCByZW5kZXIsIGFuZCBlaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB0aGUgY29tcG9uZW50IGlzXG4gICAgLy8gY2FsbGVkLCBvciB0aGVyZSB3ZXJlIG5vIEhvb2tzIGNhbGxlZCBhZnRlciB0aGlzIHVzZSgpIHRoZSBwcmV2aW91c1xuICAgIC8vIHRpbWUgKHBlcmhhcHMgYmVjYXVzZSBpdCB0aHJldykuIFN1YnNlcXVlbnQgSG9vayBjYWxscyBzaG91bGQgdXNlIHRoZVxuICAgIC8vIG1vdW50IGRpc3BhdGNoZXIuXG4gICAge1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1c2UodXNhYmxlKSB7XG4gIGlmICh1c2FibGUgIT09IG51bGwgJiYgdHlwZW9mIHVzYWJsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gICAgaWYgKHR5cGVvZiB1c2FibGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRoZW5hYmxlLlxuICAgICAgdmFyIHRoZW5hYmxlID0gdXNhYmxlO1xuICAgICAgcmV0dXJuIHVzZVRoZW5hYmxlKHRoZW5hYmxlKTtcbiAgICB9IGVsc2UgaWYgKHVzYWJsZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHVzYWJsZTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0FuIHVuc3VwcG9ydGVkIHR5cGUgd2FzIHBhc3NlZCB0byB1c2UoKTogJyArIFN0cmluZyh1c2FibGUpKTtcbn1cblxuZnVuY3Rpb24gdXNlTWVtb0NhY2hlKHNpemUpIHtcbiAgdmFyIG1lbW9DYWNoZSA9IG51bGw7IC8vIEZhc3QtcGF0aCwgbG9hZCBtZW1vIGNhY2hlIGZyb20gd2lwIGZpYmVyIGlmIGFscmVhZHkgcHJlcGFyZWRcblxuICB2YXIgdXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgIG1lbW9DYWNoZSA9IHVwZGF0ZVF1ZXVlLm1lbW9DYWNoZTtcbiAgfSAvLyBPdGhlcndpc2UgY2xvbmUgZnJvbSB0aGUgY3VycmVudCBmaWJlclxuXG5cbiAgaWYgKG1lbW9DYWNoZSA9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudFVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICAgICAgaWYgKGN1cnJlbnRVcGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY3VycmVudE1lbW9DYWNoZSA9IGN1cnJlbnRVcGRhdGVRdWV1ZS5tZW1vQ2FjaGU7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRNZW1vQ2FjaGUgIT0gbnVsbCkge1xuICAgICAgICAgIG1lbW9DYWNoZSA9IHtcbiAgICAgICAgICAgIC8vIFdoZW4gZW5hYmxlTm9DbG9uaW5nTWVtb0NhY2hlIGlzIGVuYWJsZWQsIGluc3RlYWQgb2YgdHJlYXRpbmcgdGhlXG4gICAgICAgICAgICAvLyBjYWNoZSBhcyBjb3B5LW9uLXdyaXRlLCBsaWtlIHdlIGRvIHdpdGggZmliZXJzLCB3ZSBzaGFyZSB0aGUgc2FtZVxuICAgICAgICAgICAgLy8gY2FjaGUgaW5zdGFuY2UgYWNyb3NzIGFsbCByZW5kZXIgYXR0ZW1wdHMsIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgLy8gaXMgaW50ZXJydXB0ZWQgYmVmb3JlIGl0IGNvbW1pdHMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSWYgYW4gdXBkYXRlIGlzIGludGVycnVwdGVkLCBlaXRoZXIgYmVjYXVzZSBpdCBzdXNwZW5kZWQgb3JcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugb2YgYW5vdGhlciB1cGRhdGUsIHdlIGNhbiByZXVzZSB0aGUgbWVtb2l6ZWQgY29tcHV0YXRpb25zXG4gICAgICAgICAgICAvLyBmcm9tIHRoZSBwcmV2aW91cyBhdHRlbXB0LiBXZSBjYW4gZG8gdGhpcyBiZWNhdXNlIHRoZSBSZWFjdFxuICAgICAgICAgICAgLy8gQ29tcGlsZXIgcGVyZm9ybXMgYXRvbWljIHdyaXRlcyB0byB0aGUgbWVtbyBjYWNoZSwgaS5lLiBpdCB3aWxsXG4gICAgICAgICAgICAvLyBub3QgcmVjb3JkIHRoZSBpbnB1dHMgdG8gYSBtZW1vaXphdGlvbiB3aXRob3V0IGFsc28gcmVjb3JkaW5nIGl0c1xuICAgICAgICAgICAgLy8gb3V0cHV0LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgZ2l2ZXMgdXMgYSBmb3JtIG9mIFwicmVzdW1pbmdcIiB3aXRoaW4gY29tcG9uZW50cyBhbmQgaG9va3MuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyBvbmx5IHdvcmtzIHdoZW4gdXBkYXRpbmcgYSBjb21wb25lbnQgdGhhdCBhbHJlYWR5IG1vdW50ZWQuXG4gICAgICAgICAgICAvLyBJdCBoYXMgbm8gaW1wYWN0IGR1cmluZyBpbml0aWFsIHJlbmRlciwgYmVjYXVzZSB0aGUgbWVtbyBjYWNoZSBpc1xuICAgICAgICAgICAgLy8gc3RvcmVkIG9uIHRoZSBmaWJlciwgYW5kIHNpbmNlIHdlIGhhdmUgbm90IGltcGxlbWVudGVkIHJlc3VtaW5nXG4gICAgICAgICAgICAvLyBmb3IgZmliZXJzLCBpdCdzIGFsd2F5cyBhIGZyZXNoIG1lbW8gY2FjaGUsIGFueXdheS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBIb3dldmVyLCB0aGlzIGFsb25lIGlzIHByZXR0eSB1c2VmdWwg4oCUIGl0IGhhcHBlbnMgd2hlbmV2ZXIgeW91XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIFVJIHdpdGggZnJlc2ggZGF0YSBhZnRlciBhIG11dGF0aW9uL2FjdGlvbiwgd2hpY2ggaXNcbiAgICAgICAgICAgIC8vIGV4dHJlbWVseSBjb21tb24gaW4gYSBTdXNwZW5zZS1kcml2ZW4gKGUuZy4gUlNDIG9yIFJlbGF5KSBhcHAuXG4gICAgICAgICAgICBkYXRhOiAvLyBDbG9uZSB0aGUgbWVtbyBjYWNoZSBiZWZvcmUgZWFjaCByZW5kZXIgKGNvcHktb24td3JpdGUpXG4gICAgICAgICAgICBjdXJyZW50TWVtb0NhY2hlLmRhdGEubWFwKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgICByZXR1cm4gYXJyYXkuc2xpY2UoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEZpbmFsbHkgZmFsbCBiYWNrIHRvIGFsbG9jYXRpbmcgYSBmcmVzaCBpbnN0YW5jZSBvZiB0aGUgY2FjaGVcblxuXG4gIGlmIChtZW1vQ2FjaGUgPT0gbnVsbCkge1xuICAgIG1lbW9DYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgaW5kZXg6IDBcbiAgICB9O1xuICB9XG5cbiAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgdXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCk7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlO1xuICB9XG5cbiAgdXBkYXRlUXVldWUubWVtb0NhY2hlID0gbWVtb0NhY2hlO1xuICB2YXIgZGF0YSA9IG1lbW9DYWNoZS5kYXRhW21lbW9DYWNoZS5pbmRleF07XG5cbiAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGRhdGEgPSBtZW1vQ2FjaGUuZGF0YVttZW1vQ2FjaGUuaW5kZXhdID0gbmV3IEFycmF5KHNpemUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGRhdGFbaV0gPSBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCAhPT0gc2l6ZSkge1xuICAgIC8vIFRPRE86IGNvbnNpZGVyIHdhcm5pbmcgb3IgdGhyb3dpbmcgaGVyZVxuICAgIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCBhIGNvbnN0YW50IHNpemUgYXJndW1lbnQgZm9yIGVhY2ggaW52b2NhdGlvbiBvZiB1c2VNZW1vQ2FjaGUuICcgKyAnVGhlIHByZXZpb3VzIGNhY2hlIHdhcyBhbGxvY2F0ZWQgd2l0aCBzaXplICVzIGJ1dCBzaXplICVzIHdhcyByZXF1ZXN0ZWQuJywgZGF0YS5sZW5ndGgsIHNpemUpO1xuICAgIH1cbiAgfVxuXG4gIG1lbW9DYWNoZS5pbmRleCsrO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGluaXRpYWxTdGF0ZTtcblxuICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdChpbml0aWFsQXJnKTtcblxuICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG4gICAgICBpbml0KGluaXRpYWxBcmcpO1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsQXJnO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IHJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICB9O1xuICBob29rLnF1ZXVlID0gcXVldWU7XG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgcXVldWUpO1xuICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgcmV0dXJuIHVwZGF0ZVJlZHVjZXJJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCByZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVkdWNlckltcGwoaG9vaywgY3VycmVudCwgcmVkdWNlcikge1xuICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7IC8vIFRoZSBsYXN0IHJlYmFzZSB1cGRhdGUgdGhhdCBpcyBOT1QgcGFydCBvZiB0aGUgYmFzZSBzdGF0ZS5cblxuICB2YXIgYmFzZVF1ZXVlID0gaG9vay5iYXNlUXVldWU7IC8vIFRoZSBsYXN0IHBlbmRpbmcgdXBkYXRlIHRoYXQgaGFzbid0IGJlZW4gcHJvY2Vzc2VkIHlldC5cblxuICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZ1F1ZXVlICE9PSBudWxsKSB7XG4gICAgLy8gV2UgaGF2ZSBuZXcgdXBkYXRlcyB0aGF0IGhhdmVuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuICAgIC8vIFdlJ2xsIGFkZCB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuICAgIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIC8vIE1lcmdlIHRoZSBwZW5kaW5nIHF1ZXVlIGFuZCB0aGUgYmFzZSBxdWV1ZS5cbiAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgIHZhciBwZW5kaW5nRmlyc3QgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgIGJhc2VRdWV1ZS5uZXh0ID0gcGVuZGluZ0ZpcnN0O1xuICAgICAgcGVuZGluZ1F1ZXVlLm5leHQgPSBiYXNlRmlyc3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGN1cnJlbnQuYmFzZVF1ZXVlICE9PSBiYXNlUXVldWUpIHtcbiAgICAgICAgLy8gSW50ZXJuYWwgaW52YXJpYW50IHRoYXQgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGZlYXNpYmx5IGNvdWxkIGluXG4gICAgICAgIC8vIHRoZSBmdXR1cmUgaWYgd2UgaW1wbGVtZW50IHJlc3VtaW5nLCBvciBzb21lIGZvcm0gb2YgdGhhdC5cbiAgICAgICAgZXJyb3IoJ0ludGVybmFsIGVycm9yOiBFeHBlY3RlZCB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIHRvIGJlIGEgY2xvbmUuICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50LmJhc2VRdWV1ZSA9IGJhc2VRdWV1ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgfVxuXG4gIHZhciBiYXNlU3RhdGUgPSBob29rLmJhc2VTdGF0ZTtcblxuICBpZiAoYmFzZVF1ZXVlID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBlbmRpbmcgdXBkYXRlcywgdGhlbiB0aGUgbWVtb2l6ZWQgc3RhdGUgc2hvdWxkIGJlIHRoZVxuICAgIC8vIHNhbWUgYXMgdGhlIGJhc2Ugc3RhdGUuIEN1cnJlbnRseSB0aGVzZSBvbmx5IGRpdmVyZ2UgaW4gdGhlIGNhc2Ugb2ZcbiAgICAvLyB1c2VPcHRpbWlzdGljLCBiZWNhdXNlIHVzZU9wdGltaXN0aWMgYWNjZXB0cyBhIG5ldyBiYXNlU3RhdGUgb25cbiAgICAvLyBldmVyeSByZW5kZXIuXG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gYmFzZVN0YXRlOyAvLyBXZSBkb24ndCBuZWVkIHRvIGNhbGwgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUgYmVjYXVzZVxuICAgIC8vIGJhc2VTdGF0ZSBpcyBkZXJpdmVkIGZyb20gb3RoZXIgcmVhY3RpdmUgdmFsdWVzLlxuICB9IGVsc2Uge1xuICAgIC8vIFdlIGhhdmUgYSBxdWV1ZSB0byBwcm9jZXNzLlxuICAgIHZhciBmaXJzdCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgIHZhciBuZXdTdGF0ZSA9IGJhc2VTdGF0ZTtcbiAgICB2YXIgbmV3QmFzZVN0YXRlID0gbnVsbDtcbiAgICB2YXIgbmV3QmFzZVF1ZXVlRmlyc3QgPSBudWxsO1xuICAgIHZhciBuZXdCYXNlUXVldWVMYXN0ID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3Q7XG4gICAgdmFyIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSBmYWxzZTtcblxuICAgIGRvIHtcbiAgICAgIC8vIEFuIGV4dHJhIE9mZnNjcmVlbkxhbmUgYml0IGlzIGFkZGVkIHRvIHVwZGF0ZXMgdGhhdCB3ZXJlIG1hZGUgdG9cbiAgICAgIC8vIGEgaGlkZGVuIHRyZWUsIHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSB1cGRhdGVzIHRoYXQgd2VyZVxuICAgICAgLy8gYWxyZWFkeSB0aGVyZSB3aGVuIHRoZSB0cmVlIHdhcyBoaWRkZW4uXG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHJlbW92ZUxhbmVzKHVwZGF0ZS5sYW5lLCBPZmZzY3JlZW5MYW5lKTtcbiAgICAgIHZhciBpc0hpZGRlblVwZGF0ZSA9IHVwZGF0ZUxhbmUgIT09IHVwZGF0ZS5sYW5lOyAvLyBDaGVjayBpZiB0aGlzIHVwZGF0ZSB3YXMgbWFkZSB3aGlsZSB0aGUgdHJlZSB3YXMgaGlkZGVuLiBJZiBzbywgdGhlblxuICAgICAgLy8gaXQncyBub3QgYSBcImJhc2VcIiB1cGRhdGUgYW5kIHdlIHNob3VsZCBkaXNyZWdhcmQgdGhlIGV4dHJhIGJhc2UgbGFuZXNcbiAgICAgIC8vIHRoYXQgd2VyZSBhZGRlZCB0byByZW5kZXJMYW5lcyB3aGVuIHdlIGVudGVyZWQgdGhlIE9mZnNjcmVlbiB0cmVlLlxuXG4gICAgICB2YXIgc2hvdWxkU2tpcFVwZGF0ZSA9IGlzSGlkZGVuVXBkYXRlID8gIWlzU3Vic2V0T2ZMYW5lcyhnZXRXb3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcygpLCB1cGRhdGVMYW5lKSA6ICFpc1N1YnNldE9mTGFuZXMocmVuZGVyTGFuZXMsIHVwZGF0ZUxhbmUpO1xuXG4gICAgICBpZiAoc2hvdWxkU2tpcFVwZGF0ZSkge1xuICAgICAgICAvLyBQcmlvcml0eSBpcyBpbnN1ZmZpY2llbnQuIFNraXAgdGhpcyB1cGRhdGUuIElmIHRoaXMgaXMgdGhlIGZpcnN0XG4gICAgICAgIC8vIHNraXBwZWQgdXBkYXRlLCB0aGUgcHJldmlvdXMgdXBkYXRlL3N0YXRlIGlzIHRoZSBuZXcgYmFzZVxuICAgICAgICAvLyB1cGRhdGUvc3RhdGUuXG4gICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgIHJldmVydExhbmU6IHVwZGF0ZS5yZXZlcnRMYW5lLFxuICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG5ld0Jhc2VRdWV1ZUxhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdCYXNlUXVldWVGaXJzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QgPSBjbG9uZTtcbiAgICAgICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gY2xvbmU7XG4gICAgICAgIH0gLy8gVXBkYXRlIHRoZSByZW1haW5pbmcgcHJpb3JpdHkgaW4gdGhlIHF1ZXVlLlxuICAgICAgICAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhpcy4gSW5zdGVhZCwgd2UgY2FuIHJlbW92ZVxuICAgICAgICAvLyByZW5kZXJMYW5lcyBmcm9tIHRoZSBvcmlnaW5hbCBsYW5lcy5cblxuXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgPSBtZXJnZUxhbmVzKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMsIHVwZGF0ZUxhbmUpO1xuICAgICAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHVwZGF0ZUxhbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYW4gb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAgICAgIHZhciByZXZlcnRMYW5lID0gdXBkYXRlLnJldmVydExhbmU7XG5cbiAgICAgICAgaWYgKHJldmVydExhbmUgPT09IE5vTGFuZSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGFuIG9wdGltaXN0aWMgdXBkYXRlLCBhbmQgd2UncmUgZ29pbmcgdG8gYXBwbHkgaXQgbm93LlxuICAgICAgICAgIC8vIEJ1dCwgaWYgdGhlcmUgd2VyZSBlYXJsaWVyIHVwZGF0ZXMgdGhhdCB3ZXJlIHNraXBwZWQsIHdlIG5lZWQgdG9cbiAgICAgICAgICAvLyBsZWF2ZSB0aGlzIHVwZGF0ZSBpbiB0aGUgcXVldWUgc28gaXQgY2FuIGJlIHJlYmFzZWQgbGF0ZXIuXG4gICAgICAgICAgaWYgKG5ld0Jhc2VRdWV1ZUxhc3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfY2xvbmUgPSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgdXBkYXRlIGlzIGdvaW5nIHRvIGJlIGNvbW1pdHRlZCBzbyB3ZSBuZXZlciB3YW50IHVuY29tbWl0XG4gICAgICAgICAgICAgIC8vIGl0LiBVc2luZyBOb0xhbmUgd29ya3MgYmVjYXVzZSAwIGlzIGEgc3Vic2V0IG9mIGFsbCBiaXRtYXNrcywgc29cbiAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG5ldmVyIGJlIHNraXBwZWQgYnkgdGhlIGNoZWNrIGFib3ZlLlxuICAgICAgICAgICAgICBsYW5lOiBOb0xhbmUsXG4gICAgICAgICAgICAgIHJldmVydExhbmU6IE5vTGFuZSxcbiAgICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gX2Nsb25lO1xuICAgICAgICAgIH0gLy8gQ2hlY2sgaWYgdGhpcyB1cGRhdGUgaXMgcGFydCBvZiBhIHBlbmRpbmcgYXN5bmMgYWN0aW9uLiBJZiBzbyxcbiAgICAgICAgICAvLyB3ZSdsbCBuZWVkIHRvIHN1c3BlbmQgdW50aWwgdGhlIGFjdGlvbiBoYXMgZmluaXNoZWQsIHNvIHRoYXQgaXQnc1xuICAgICAgICAgIC8vIGJhdGNoZWQgdG9nZXRoZXIgd2l0aCBmdXR1cmUgdXBkYXRlcyBpbiB0aGUgc2FtZSBhY3Rpb24uXG5cblxuICAgICAgICAgIGlmICh1cGRhdGVMYW5lID09PSBwZWVrRW50YW5nbGVkQWN0aW9uTGFuZSgpKSB7XG4gICAgICAgICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhbiBvcHRpbWlzdGljIHVwZGF0ZS4gSWYgdGhlIFwicmV2ZXJ0XCIgcHJpb3JpdHkgaXNcbiAgICAgICAgICAvLyBzdWZmaWNpZW50LCBkb24ndCBhcHBseSB0aGUgdXBkYXRlLiBPdGhlcndpc2UsIGFwcGx5IHRoZSB1cGRhdGUsXG4gICAgICAgICAgLy8gYnV0IGxlYXZlIGl0IGluIHRoZSBxdWV1ZSBzbyBpdCBjYW4gYmUgZWl0aGVyIHJldmVydGVkIG9yXG4gICAgICAgICAgLy8gcmViYXNlZCBpbiBhIHN1YnNlcXVlbnQgcmVuZGVyLlxuICAgICAgICAgIGlmIChpc1N1YnNldE9mTGFuZXMocmVuZGVyTGFuZXMsIHJldmVydExhbmUpKSB7XG4gICAgICAgICAgICAvLyBUaGUgdHJhbnNpdGlvbiB0aGF0IHRoaXMgb3B0aW1pc3RpYyB1cGRhdGUgaXMgYXNzb2NpYXRlZCB3aXRoXG4gICAgICAgICAgICAvLyBoYXMgZmluaXNoZWQuIFByZXRlbmQgdGhlIHVwZGF0ZSBkb2Vzbid0IGV4aXN0IGJ5IHNraXBwaW5nXG4gICAgICAgICAgICAvLyBvdmVyIGl0LlxuICAgICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7IC8vIENoZWNrIGlmIHRoaXMgdXBkYXRlIGlzIHBhcnQgb2YgYSBwZW5kaW5nIGFzeW5jIGFjdGlvbi4gSWYgc28sXG4gICAgICAgICAgICAvLyB3ZSdsbCBuZWVkIHRvIHN1c3BlbmQgdW50aWwgdGhlIGFjdGlvbiBoYXMgZmluaXNoZWQsIHNvIHRoYXQgaXQnc1xuICAgICAgICAgICAgLy8gYmF0Y2hlZCB0b2dldGhlciB3aXRoIGZ1dHVyZSB1cGRhdGVzIGluIHRoZSBzYW1lIGFjdGlvbi5cblxuICAgICAgICAgICAgaWYgKHJldmVydExhbmUgPT09IHBlZWtFbnRhbmdsZWRBY3Rpb25MYW5lKCkpIHtcbiAgICAgICAgICAgICAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2Nsb25lMiA9IHtcbiAgICAgICAgICAgICAgLy8gT25jZSB3ZSBjb21taXQgYW4gb3B0aW1pc3RpYyB1cGRhdGUsIHdlIHNob3VsZG4ndCB1bmNvbW1pdCBpdFxuICAgICAgICAgICAgICAvLyB1bnRpbCB0aGUgdHJhbnNpdGlvbiBpdCBpcyBhc3NvY2lhdGVkIHdpdGggaGFzIGZpbmlzaGVkXG4gICAgICAgICAgICAgIC8vIChyZXByZXNlbnRlZCBieSByZXZlcnRMYW5lKS4gVXNpbmcgTm9MYW5lIGhlcmUgd29ya3MgYmVjYXVzZSAwXG4gICAgICAgICAgICAgIC8vIGlzIGEgc3Vic2V0IG9mIGFsbCBiaXRtYXNrcywgc28gdGhpcyB3aWxsIG5ldmVyIGJlIHNraXBwZWQgYnlcbiAgICAgICAgICAgICAgLy8gdGhlIGNoZWNrIGFib3ZlLlxuICAgICAgICAgICAgICBsYW5lOiBOb0xhbmUsXG4gICAgICAgICAgICAgIC8vIFJldXNlIHRoZSBzYW1lIHJldmVydExhbmUgc28gd2Uga25vdyB3aGVuIHRoZSB0cmFuc2l0aW9uXG4gICAgICAgICAgICAgIC8vIGhhcyBmaW5pc2hlZC5cbiAgICAgICAgICAgICAgcmV2ZXJ0TGFuZTogdXBkYXRlLnJldmVydExhbmUsXG4gICAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBuZXdCYXNlUXVldWVGaXJzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QgPSBfY2xvbmUyO1xuICAgICAgICAgICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBfY2xvbmUyO1xuICAgICAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG4gICAgICAgICAgICAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhpcy4gSW5zdGVhZCwgd2UgY2FuIHJlbW92ZVxuICAgICAgICAgICAgLy8gcmVuZGVyTGFuZXMgZnJvbSB0aGUgb3JpZ2luYWwgbGFuZXMuXG5cblxuICAgICAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyA9IG1lcmdlTGFuZXMoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcywgcmV2ZXJ0TGFuZSk7XG4gICAgICAgICAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHJldmVydExhbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuXG5cbiAgICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG5cbiAgICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgICAgcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cGRhdGUuaGFzRWFnZXJTdGF0ZSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgdXBkYXRlIGlzIGEgc3RhdGUgdXBkYXRlIChub3QgYSByZWR1Y2VyKSBhbmQgd2FzIHByb2Nlc3NlZCBlYWdlcmx5LFxuICAgICAgICAgIC8vIHdlIGNhbiB1c2UgdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGVcbiAgICAgICAgICBuZXdTdGF0ZSA9IHVwZGF0ZS5lYWdlclN0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwgJiYgdXBkYXRlICE9PSBmaXJzdCk7XG5cbiAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IG5ld0Jhc2VRdWV1ZUZpcnN0O1xuICAgIH0gLy8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuXG5cbiAgICBpZiAoIW9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpOyAvLyBDaGVjayBpZiB0aGlzIHVwZGF0ZSBpcyBwYXJ0IG9mIGEgcGVuZGluZyBhc3luYyBhY3Rpb24uIElmIHNvLCB3ZSdsbFxuICAgICAgLy8gbmVlZCB0byBzdXNwZW5kIHVudGlsIHRoZSBhY3Rpb24gaGFzIGZpbmlzaGVkLCBzbyB0aGF0IGl0J3MgYmF0Y2hlZFxuICAgICAgLy8gdG9nZXRoZXIgd2l0aCBmdXR1cmUgdXBkYXRlcyBpbiB0aGUgc2FtZSBhY3Rpb24uXG4gICAgICAvLyBUT0RPOiBPbmNlIHdlIHN1cHBvcnQgaG9va3MgaW5zaWRlIHVzZU1lbW8gKG9yIGFuIGVxdWl2YWxlbnRcbiAgICAgIC8vIG1lbW9pemF0aW9uIGJvdW5kYXJ5IGxpa2UgRm9yZ2V0KSwgaG9pc3QgdGhpcyBsb2dpYyBzbyB0aGF0IGl0IG9ubHlcbiAgICAgIC8vIHN1c3BlbmRzIGlmIHRoZSBtZW1vIGJvdW5kYXJ5IHByb2R1Y2VzIGEgbmV3IHZhbHVlLlxuXG4gICAgICBpZiAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbikge1xuICAgICAgICB2YXIgZW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBwZWVrRW50YW5nbGVkQWN0aW9uVGhlbmFibGUoKTtcblxuICAgICAgICBpZiAoZW50YW5nbGVkQWN0aW9uVGhlbmFibGUgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBJbnN0ZWFkIG9mIHRoZSB0aHJvd2luZyB0aGUgdGhlbmFibGUgZGlyZWN0bHksIHRocm93IGFcbiAgICAgICAgICAvLyBzcGVjaWFsIG9iamVjdCBsaWtlIGB1c2VgIGRvZXMgc28gd2UgY2FuIGRldGVjdCBpZiBpdCdzIGNhcHR1cmVkXG4gICAgICAgICAgLy8gYnkgdXNlcnNwYWNlLlxuICAgICAgICAgIHRocm93IGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgaG9vay5iYXNlU3RhdGUgPSBuZXdCYXNlU3RhdGU7XG4gICAgaG9vay5iYXNlUXVldWUgPSBuZXdCYXNlUXVldWVMYXN0O1xuICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gbmV3U3RhdGU7XG4gIH1cblxuICBpZiAoYmFzZVF1ZXVlID09PSBudWxsKSB7XG4gICAgLy8gYHF1ZXVlLmxhbmVzYCBpcyB1c2VkIGZvciBlbnRhbmdsaW5nIHRyYW5zaXRpb25zLiBXZSBjYW4gc2V0IGl0IGJhY2sgdG9cbiAgICAvLyB6ZXJvIG9uY2UgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuICAgIHF1ZXVlLmxhbmVzID0gTm9MYW5lcztcbiAgfVxuXG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoO1xuICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7IC8vIFRoaXMgaXMgYSByZS1yZW5kZXIuIEFwcGx5IHRoZSBuZXcgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG8gdGhlIHByZXZpb3VzXG4gIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cblxuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcbiAgdmFyIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHF1ZXVlLnBlbmRpbmc7XG4gIHZhciBuZXdTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAobGFzdFJlbmRlclBoYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHF1ZXVlIGRvZXNuJ3QgcGVyc2lzdCBwYXN0IHRoaXMgcmVuZGVyIHBhc3MuXG4gICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgIGRvIHtcbiAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgLy8gcHJpb3JpdHkgYmVjYXVzZSBpdCB3aWxsIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0aGUgY3VycmVudFxuICAgICAgLy8gcmVuZGVyJ3MuXG4gICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcbiAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSk7IC8vIE1hcmsgdGhhdCB0aGUgZmliZXIgcGVyZm9ybWVkIHdvcmssIGJ1dCBvbmx5IGlmIHRoZSBuZXcgc3RhdGUgaXNcbiAgICAvLyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZS5cblxuXG4gICAgaWYgKCFvYmplY3RJcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSkge1xuICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTsgLy8gRG9uJ3QgcGVyc2lzdCB0aGUgc3RhdGUgYWNjdW11bGF0ZWQgZnJvbSB0aGUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG9cbiAgICAvLyB0aGUgYmFzZSBzdGF0ZSB1bmxlc3MgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuICAgIC8vIFRPRE86IE5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGRlc2lyZWQgc2VtYW50aWNzLCBidXQgaXQncyB3aGF0IHdlXG4gICAgLy8gZG8gZm9yIGdEU0ZQLiBJIGNhbid0IHJlbWVtYmVyIHdoeS5cblxuICAgIGlmIChob29rLmJhc2VRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHRTbmFwc2hvdDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZ2V0SXNIeWRyYXRpbmcoKTtcblxuICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICBpZiAoZ2V0U2VydmVyU25hcHNob3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3IgJyArICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy4nKTtcbiAgICB9XG5cbiAgICBuZXh0U25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgICBpZiAobmV4dFNuYXBzaG90ICE9PSBnZXRTZXJ2ZXJTbmFwc2hvdCgpKSB7XG4gICAgICAgICAgZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U2VydmVyU25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7XG5cbiAgICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV4dFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICAgIHtcbiAgICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgICAgdmFyIGNhY2hlZFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICAgICAgICBpZiAoIW9iamVjdElzKG5leHRTbmFwc2hvdCwgY2FjaGVkU25hcHNob3QpKSB7XG4gICAgICAgICAgZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7XG5cbiAgICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFVubGVzcyB3ZSdyZSByZW5kZXJpbmcgYSBibG9ja2luZyBsYW5lLCBzY2hlZHVsZSBhIGNvbnNpc3RlbmN5IGNoZWNrLlxuICAgIC8vIFJpZ2h0IGJlZm9yZSBjb21taXR0aW5nLCB3ZSB3aWxsIHdhbGsgdGhlIHRyZWUgYW5kIGNoZWNrIGlmIGFueSBvZiB0aGVcbiAgICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkLlxuICAgIC8vXG4gICAgLy8gV2Ugd29uJ3QgZG8gdGhpcyBpZiB3ZSdyZSBoeWRyYXRpbmcgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQsIGJlY2F1c2UgaWZcbiAgICAvLyB0aGUgY29udGVudCBpcyBzdGFsZSwgaXQncyBhbHJlYWR5IHZpc2libGUgYW55d2F5LiBJbnN0ZWFkIHdlJ2xsIHBhdGNoXG4gICAgLy8gaXQgdXAgaW4gYSBwYXNzaXZlIGVmZmVjdC5cblxuXG4gICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICB2YXIgcm9vdFJlbmRlckxhbmVzID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMoKTtcblxuICAgIGlmICghaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCwgcm9vdFJlbmRlckxhbmVzKSkge1xuICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIG5leHRTbmFwc2hvdCk7XG4gICAgfVxuICB9IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBUaGlzIGJyZWFrcyB0aGVcbiAgLy8gbm9ybWFsIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBiZWNhdXNlIHN0b3JlIHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5leHRTbmFwc2hvdDtcbiAgdmFyIGluc3QgPSB7XG4gICAgdmFsdWU6IG5leHRTbmFwc2hvdCxcbiAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3RcbiAgfTtcbiAgaG9vay5xdWV1ZSA9IGluc3Q7IC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBzdWJzY3JpYmUgdG8gdGhlIHN0b3JlLlxuXG4gIG1vdW50RWZmZWN0KHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgaW5zdCwgc3Vic2NyaWJlKSwgW3N1YnNjcmliZV0pOyAvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gdXBkYXRlIHRoZSBtdXRhYmxlIGluc3RhbmNlIGZpZWxkcy4gV2Ugd2lsbCB1cGRhdGVcbiAgLy8gdGhpcyB3aGVuZXZlciBzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBvciB2YWx1ZSBjaGFuZ2VzLiBCZWNhdXNlIHRoZXJlJ3Mgbm9cbiAgLy8gY2xlYW4tdXAgZnVuY3Rpb24sIGFuZCB3ZSB0cmFjayB0aGUgZGVwcyBjb3JyZWN0bHksIHdlIGNhbiBjYWxsIHB1c2hFZmZlY3RcbiAgLy8gZGlyZWN0bHksIHdpdGhvdXQgc3RvcmluZyBhbnkgYWRkaXRpb25hbCBzdGF0ZS4gRm9yIHRoZSBzYW1lIHJlYXNvbiwgd2VcbiAgLy8gZG9uJ3QgbmVlZCB0byBzZXQgYSBzdGF0aWMgZmxhZywgZWl0aGVyLlxuXG4gIGZpYmVyLmZsYWdzIHw9IFBhc3NpdmUkMTtcbiAgcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBQYXNzaXZlLCB1cGRhdGVTdG9yZUluc3RhbmNlLmJpbmQobnVsbCwgZmliZXIsIGluc3QsIG5leHRTbmFwc2hvdCwgZ2V0U25hcHNob3QpLCBjcmVhdGVFZmZlY3RJbnN0YW5jZSgpLCBudWxsKTtcbiAgcmV0dXJuIG5leHRTbmFwc2hvdDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTsgLy8gUmVhZCB0aGUgY3VycmVudCBzbmFwc2hvdCBmcm9tIHRoZSBzdG9yZSBvbiBldmVyeSByZW5kZXIuIFRoaXMgYnJlYWtzIHRoZVxuICAvLyBub3JtYWwgcnVsZXMgb2YgUmVhY3QsIGFuZCBvbmx5IHdvcmtzIGJlY2F1c2Ugc3RvcmUgdXBkYXRlcyBhcmVcbiAgLy8gYWx3YXlzIHN5bmNocm9ub3VzLlxuXG4gIHZhciBuZXh0U25hcHNob3Q7XG4gIHZhciBpc0h5ZHJhdGluZyA9IGdldElzSHlkcmF0aW5nKCk7XG5cbiAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgLy8gTmVlZGVkIGZvciBzdHJpY3QgbW9kZSBkb3VibGUgcmVuZGVyXG4gICAgaWYgKGdldFNlcnZlclNuYXBzaG90ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBnZXRTZXJ2ZXJTbmFwc2hvdCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yICcgKyAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuJyk7XG4gICAgfVxuXG4gICAgbmV4dFNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QoKTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0U25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgICB2YXIgY2FjaGVkU25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuXG4gICAgICAgIGlmICghb2JqZWN0SXMobmV4dFNuYXBzaG90LCBjYWNoZWRTbmFwc2hvdCkpIHtcbiAgICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwcmV2U25hcHNob3QgPSAoY3VycmVudEhvb2sgfHwgaG9vaykubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHNuYXBzaG90Q2hhbmdlZCA9ICFvYmplY3RJcyhwcmV2U25hcHNob3QsIG5leHRTbmFwc2hvdCk7XG5cbiAgaWYgKHNuYXBzaG90Q2hhbmdlZCkge1xuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5leHRTbmFwc2hvdDtcbiAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICB9XG5cbiAgdmFyIGluc3QgPSBob29rLnF1ZXVlO1xuICB1cGRhdGVFZmZlY3Qoc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpLCBbc3Vic2NyaWJlXSk7IC8vIFdoZW5ldmVyIGdldFNuYXBzaG90IG9yIHN1YnNjcmliZSBjaGFuZ2VzLCB3ZSBuZWVkIHRvIGNoZWNrIGluIHRoZVxuICAvLyBjb21taXQgcGhhc2UgaWYgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIG11dGF0aW9uLiBJbiBjb25jdXJyZW50IG1vZGVcbiAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuICAvLyBlZmZlY3QgbWF5IGhhdmUgbXV0YXRlZCB0aGUgc3RvcmUuXG5cbiAgaWYgKGluc3QuZ2V0U25hcHNob3QgIT09IGdldFNuYXBzaG90IHx8IHNuYXBzaG90Q2hhbmdlZCB8fCAvLyBDaGVjayBpZiB0aGUgc3Vic2NyaWJlIGZ1bmN0aW9uIGNoYW5nZWQuIFdlIGNhbiBzYXZlIHNvbWUgbWVtb3J5IGJ5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgd2Ugc2NoZWR1bGVkIGEgc3Vic2NyaXB0aW9uIGVmZmVjdCBhYm92ZS5cbiAgd29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLnRhZyAmIEhhc0VmZmVjdCkge1xuICAgIGZpYmVyLmZsYWdzIHw9IFBhc3NpdmUkMTtcbiAgICBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IFBhc3NpdmUsIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChudWxsLCBmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCksIGNyZWF0ZUVmZmVjdEluc3RhbmNlKCksIG51bGwpOyAvLyBVbmxlc3Mgd2UncmUgcmVuZGVyaW5nIGEgYmxvY2tpbmcgbGFuZSwgc2NoZWR1bGUgYSBjb25zaXN0ZW5jeSBjaGVjay5cbiAgICAvLyBSaWdodCBiZWZvcmUgY29tbWl0dGluZywgd2Ugd2lsbCB3YWxrIHRoZSB0cmVlIGFuZCBjaGVjayBpZiBhbnkgb2YgdGhlXG4gICAgLy8gc3RvcmVzIHdlcmUgbXV0YXRlZC5cblxuICAgIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0h5ZHJhdGluZyAmJiAhaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCwgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgbmV4dFNuYXBzaG90KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dFNuYXBzaG90O1xufVxuXG5mdW5jdGlvbiBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgcmVuZGVyZWRTbmFwc2hvdCkge1xuICBmaWJlci5mbGFncyB8PSBTdG9yZUNvbnNpc3RlbmN5O1xuICB2YXIgY2hlY2sgPSB7XG4gICAgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90LFxuICAgIHZhbHVlOiByZW5kZXJlZFNuYXBzaG90XG4gIH07XG4gIHZhciBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG5cbiAgaWYgKGNvbXBvbmVudFVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCk7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlO1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLnN0b3JlcyA9IFtjaGVja107XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0b3JlcyA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlLnN0b3JlcztcblxuICAgIGlmIChzdG9yZXMgPT09IG51bGwpIHtcbiAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLnN0b3JlcyA9IFtjaGVja107XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3Jlcy5wdXNoKGNoZWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RvcmVJbnN0YW5jZShmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCkge1xuICAvLyBUaGVzZSBhcmUgdXBkYXRlZCBpbiB0aGUgcGFzc2l2ZSBwaGFzZVxuICBpbnN0LnZhbHVlID0gbmV4dFNuYXBzaG90O1xuICBpbnN0LmdldFNuYXBzaG90ID0gZ2V0U25hcHNob3Q7IC8vIFNvbWV0aGluZyBtYXkgaGF2ZSBiZWVuIG11dGF0ZWQgaW4gYmV0d2VlbiByZW5kZXIgYW5kIGNvbW1pdC4gVGhpcyBjb3VsZFxuICAvLyBoYXZlIGJlZW4gaW4gYW4gZXZlbnQgdGhhdCBmaXJlZCBiZWZvcmUgdGhlIHBhc3NpdmUgZWZmZWN0cywgb3IgaXQgY291bGRcbiAgLy8gaGF2ZSBiZWVuIGluIGEgbGF5b3V0IGVmZmVjdC4gSW4gdGhhdCBjYXNlLCB3ZSB3b3VsZCBoYXZlIHVzZWQgdGhlIG9sZFxuICAvLyBzbmFwc2hvIGFuZCBnZXRTbmFwc2hvdCB2YWx1ZXMgdG8gYmFpbCBvdXQuIFdlIG5lZWQgdG8gY2hlY2sgb25lIG1vcmUgdGltZS5cblxuICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuICAgIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlVG9TdG9yZShmaWJlciwgaW5zdCwgc3Vic2NyaWJlKSB7XG4gIHZhciBoYW5kbGVTdG9yZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUaGUgc3RvcmUgY2hhbmdlZC4gQ2hlY2sgaWYgdGhlIHNuYXBzaG90IGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZVxuICAgIC8vIHJlYWQgZnJvbSB0aGUgc3RvcmUuXG4gICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuICAgICAgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTtcbiAgICB9XG4gIH07IC8vIFN1YnNjcmliZSB0byB0aGUgc3RvcmUgYW5kIHJldHVybiBhIGNsZWFuLXVwIGZ1bmN0aW9uLlxuXG5cbiAgcmV0dXJuIHN1YnNjcmliZShoYW5kbGVTdG9yZUNoYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkge1xuICB2YXIgbGF0ZXN0R2V0U25hcHNob3QgPSBpbnN0LmdldFNuYXBzaG90O1xuICB2YXIgcHJldlZhbHVlID0gaW5zdC52YWx1ZTtcblxuICB0cnkge1xuICAgIHZhciBuZXh0VmFsdWUgPSBsYXRlc3RHZXRTbmFwc2hvdCgpO1xuICAgIHJldHVybiAhb2JqZWN0SXMocHJldlZhbHVlLCBuZXh0VmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcikge1xuICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRTdGF0ZUltcGwoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBpbml0aWFsU3RhdGVJbml0aWFsaXplciA9IGluaXRpYWxTdGF0ZTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcblxuICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxTdGF0ZUluaXRpYWxpemVyKCk7XG5cbiAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuXG4gICAgICBpbml0aWFsU3RhdGVJbml0aWFsaXplcigpO1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB2YXIgcXVldWUgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBsYW5lczogTm9MYW5lcyxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gIH07XG4gIGhvb2sucXVldWUgPSBxdWV1ZTtcbiAgcmV0dXJuIGhvb2s7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBob29rID0gbW91bnRTdGF0ZUltcGwoaW5pdGlhbFN0YXRlKTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcbiAgdmFyIGRpc3BhdGNoID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG59XG5cbmZ1bmN0aW9uIG1vdW50T3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIC8vIE9wdGltaXN0aWMgc3RhdGUgZG9lcyBub3QgdXNlIHRoZSBlYWdlciB1cGRhdGUgb3B0aW1pemF0aW9uLlxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IG51bGxcbiAgfTtcbiAgaG9vay5xdWV1ZSA9IHF1ZXVlOyAvLyBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBub3JtYWwgc2V0U3RhdGUgZnVuY3Rpb24uXG5cbiAgdmFyIGRpc3BhdGNoID0gZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUuYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCB0cnVlLCBxdWV1ZSk7XG4gIHF1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gIHJldHVybiBbcGFzc3Rocm91Z2gsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudEhvb2ssIHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudCwgcGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgLy8gT3B0aW1pc3RpYyB1cGRhdGVzIGFyZSBhbHdheXMgcmViYXNlZCBvbiB0b3Agb2YgdGhlIGxhdGVzdCB2YWx1ZSBwYXNzZWQgaW5cbiAgLy8gYXMgYW4gYXJndW1lbnQuIEl0J3MgY2FsbGVkIGEgcGFzc3Rocm91Z2ggYmVjYXVzZSBpZiB0aGVyZSBhcmUgbm8gcGVuZGluZ1xuICAvLyB1cGRhdGVzLCBpdCB3aWxsIGJlIHJldHVybmVkIGFzLWlzLlxuICAvL1xuICAvLyBSZXNldCB0aGUgYmFzZSBzdGF0ZSB0byB0aGUgcGFzc3Rocm91Z2guIEZ1dHVyZSB1cGRhdGVzIHdpbGwgYmUgYXBwbGllZFxuICAvLyBvbiB0b3Agb2YgdGhpcy5cbiAgaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDsgLy8gSWYgYSByZWR1Y2VyIGlzIG5vdCBwcm92aWRlZCwgZGVmYXVsdCB0byB0aGUgc2FtZSBvbmUgdXNlZCBieSB1c2VTdGF0ZS5cblxuICB2YXIgcmVzb2x2ZWRSZWR1Y2VyID0gdHlwZW9mIHJlZHVjZXIgPT09ICdmdW5jdGlvbicgPyByZWR1Y2VyIDogYmFzaWNTdGF0ZVJlZHVjZXI7XG4gIHJldHVybiB1cGRhdGVSZWR1Y2VySW1wbChob29rLCBjdXJyZW50SG9vaywgcmVzb2x2ZWRSZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gIC8vIFVubGlrZSB1c2VTdGF0ZSwgdXNlT3B0aW1pc3RpYyBkb2Vzbid0IHN1cHBvcnQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMuXG4gIC8vIEFsc28gdW5saWtlIHVzZVN0YXRlLCB3ZSBuZWVkIHRvIHJlcGxheSBhbGwgcGVuZGluZyB1cGRhdGVzIGFnYWluIGluIGNhc2VcbiAgLy8gdGhlIHBhc3N0aHJvdWdoIHZhbHVlIGNoYW5nZWQuXG4gIC8vXG4gIC8vIFNvIGluc3RlYWQgb2YgYSBmb3JrZWQgcmUtcmVuZGVyIGltcGxlbWVudGF0aW9uIHRoYXQga25vd3MgaG93IHRvIGhhbmRsZVxuICAvLyByZW5kZXIgcGhhc2UgdWRwYXRlcywgd2UgY2FuIHVzZSB0aGUgc2FtZSBpbXBsZW1lbnRhdGlvbiBhcyBkdXJpbmcgYVxuICAvLyByZWd1bGFyIG1vdW50IG9yIHVwZGF0ZS5cbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICBpZiAoY3VycmVudEhvb2sgIT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGFuIHVwZGF0ZS4gUHJvY2VzcyB0aGUgdXBkYXRlIHF1ZXVlLlxuICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50SG9vaywgcGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICB9IC8vIFRoaXMgaXMgYSBtb3VudC4gTm8gdXBkYXRlcyB0byBwcm9jZXNzLlxuICAvLyBSZXNldCB0aGUgYmFzZSBzdGF0ZSB0byB0aGUgcGFzc3Rocm91Z2guIEZ1dHVyZSB1cGRhdGVzIHdpbGwgYmUgYXBwbGllZFxuICAvLyBvbiB0b3Agb2YgdGhpcy5cblxuXG4gIGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gIHZhciBkaXNwYXRjaCA9IGhvb2sucXVldWUuZGlzcGF0Y2g7XG4gIHJldHVybiBbcGFzc3Rocm91Z2gsIGRpc3BhdGNoXTtcbn0gLy8gdXNlQWN0aW9uU3RhdGUgYWN0aW9ucyBydW4gc2VxdWVudGlhbGx5LCBiZWNhdXNlIGVhY2ggYWN0aW9uIHJlY2VpdmVzIHRoZVxuLy8gcHJldmlvdXMgc3RhdGUgYXMgYW4gYXJndW1lbnQuIFdlIHN0b3JlIHBlbmRpbmcgYWN0aW9ucyBvbiBhIHF1ZXVlLlxuXG5cbmZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uU3RhdGUoZmliZXIsIGFjdGlvblF1ZXVlLCBzZXRQZW5kaW5nU3RhdGUsIHNldFN0YXRlLCBwYXlsb2FkKSB7XG4gIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVwZGF0ZSBmb3JtIHN0YXRlIHdoaWxlIHJlbmRlcmluZy4nKTtcbiAgfVxuXG4gIHZhciBsYXN0ID0gYWN0aW9uUXVldWUucGVuZGluZztcblxuICBpZiAobGFzdCA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXJlIGFyZSBubyBwZW5kaW5nIGFjdGlvbnM7IHRoaXMgaXMgdGhlIGZpcnN0IG9uZS4gV2UgY2FuIHJ1blxuICAgIC8vIGl0IGltbWVkaWF0ZWx5LlxuICAgIHZhciBuZXdMYXN0ID0ge1xuICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgIG5leHQ6IG51bGwgLy8gY2lyY3VsYXJcblxuICAgIH07XG4gICAgbmV3TGFzdC5uZXh0ID0gYWN0aW9uUXVldWUucGVuZGluZyA9IG5ld0xhc3Q7XG4gICAgcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIHNldFBlbmRpbmdTdGF0ZSwgc2V0U3RhdGUsIHBheWxvYWQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhbiBhY3Rpb24gcnVubmluZy4gQWRkIHRvIHRoZSBxdWV1ZS5cbiAgICB2YXIgZmlyc3QgPSBsYXN0Lm5leHQ7XG4gICAgdmFyIF9uZXdMYXN0ID0ge1xuICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgIG5leHQ6IGZpcnN0XG4gICAgfTtcbiAgICBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gbGFzdC5uZXh0ID0gX25ld0xhc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIHNldFBlbmRpbmdTdGF0ZSwgc2V0U3RhdGUsIHBheWxvYWQpIHtcbiAgdmFyIGFjdGlvbiA9IGFjdGlvblF1ZXVlLmFjdGlvbjtcbiAgdmFyIHByZXZTdGF0ZSA9IGFjdGlvblF1ZXVlLnN0YXRlOyAvLyBUaGlzIGlzIGEgZm9yayBvZiBzdGFydFRyYW5zaXRpb25cblxuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICB2YXIgY3VycmVudFRyYW5zaXRpb24gPSB7fTtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuXG4gIHtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5ULl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xuICB9IC8vIE9wdGltaXN0aWNhbGx5IHVwZGF0ZSB0aGUgcGVuZGluZyBzdGF0ZSwgc2ltaWxhciB0byB1c2VUcmFuc2l0aW9uLlxuICAvLyBUaGlzIHdpbGwgYmUgcmV2ZXJ0ZWQgYXV0b21hdGljYWxseSB3aGVuIGFsbCBhY3Rpb25zIGFyZSBmaW5pc2hlZC5cblxuXG4gIHNldFBlbmRpbmdTdGF0ZSh0cnVlKTtcblxuICB0cnkge1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IGFjdGlvbihwcmV2U3RhdGUsIHBheWxvYWQpO1xuICAgIHZhciBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG5cbiAgICBpZiAob25TdGFydFRyYW5zaXRpb25GaW5pc2ggIT09IG51bGwpIHtcbiAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKGN1cnJlbnRUcmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHJldHVyblZhbHVlICE9PSBudWxsICYmIHR5cGVvZiByZXR1cm5WYWx1ZSA9PT0gJ29iamVjdCcgJiYgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdGhlbmFibGUgPSByZXR1cm5WYWx1ZTsgLy8gQXR0YWNoIGEgbGlzdGVuZXIgdG8gcmVhZCB0aGUgcmV0dXJuIHN0YXRlIG9mIHRoZSBhY3Rpb24uIEFzIHNvb24gYXNcbiAgICAgIC8vIHRoaXMgcmVzb2x2ZXMsIHdlIGNhbiBydW4gdGhlIG5leHQgYWN0aW9uIGluIHRoZSBzZXF1ZW5jZS5cblxuICAgICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobmV4dFN0YXRlKSB7XG4gICAgICAgIGFjdGlvblF1ZXVlLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICBmaW5pc2hSdW5uaW5nQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIHNldFBlbmRpbmdTdGF0ZSwgc2V0U3RhdGUpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmluaXNoUnVubmluZ0FjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBzZXRQZW5kaW5nU3RhdGUsIHNldFN0YXRlKTtcbiAgICAgIH0pO1xuICAgICAgc2V0U3RhdGUodGhlbmFibGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTdGF0ZShyZXR1cm5WYWx1ZSk7XG4gICAgICB2YXIgbmV4dFN0YXRlID0gcmV0dXJuVmFsdWU7XG4gICAgICBhY3Rpb25RdWV1ZS5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIGZpbmlzaFJ1bm5pbmdBY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgc2V0UGVuZGluZ1N0YXRlLCBzZXRTdGF0ZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFRoaXMgaXMgYSB0cmljayB0byBnZXQgdGhlIGB1c2VBY3Rpb25TdGF0ZWAgaG9vayB0byByZXRocm93IHRoZSBlcnJvci5cbiAgICAvLyBXaGVuIGl0IHVud3JhcHMgdGhlIHRoZW5hYmxlIHdpdGggdGhlIGB1c2VgIGFsZ29yaXRobSwgdGhlIGVycm9yXG4gICAgLy8gd2lsbCBiZSB0aHJvd24uXG4gICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB7XG4gICAgICB0aGVuOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHN0YXR1czogJ3JlamVjdGVkJyxcbiAgICAgIHJlYXNvbjogZXJyb3IgLy8gJEZsb3dGaXhNZTogTm90IHN1cmUgd2h5IHRoaXMgZG9lc24ndCB3b3JrXG5cbiAgICB9O1xuICAgIHNldFN0YXRlKHJlamVjdGVkVGhlbmFibGUpO1xuICAgIGZpbmlzaFJ1bm5pbmdBY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgc2V0UGVuZGluZ1N0YXRlLCBzZXRTdGF0ZSk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uO1xuXG4gICAge1xuICAgICAgaWYgKHByZXZUcmFuc2l0aW9uID09PSBudWxsICYmIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgIHZhciB1cGRhdGVkRmliZXJzQ291bnQgPSBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplO1xuXG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZWRGaWJlcnNDb3VudCA+IDEwKSB7XG4gICAgICAgICAgd2FybignRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiAnICsgJ0lmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuICcgKyAnT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaFJ1bm5pbmdBY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgc2V0UGVuZGluZ1N0YXRlLCBzZXRTdGF0ZSkge1xuICAvLyBUaGUgYWN0aW9uIGZpbmlzaGVkIHJ1bm5pbmcuIFBvcCBpdCBmcm9tIHRoZSBxdWV1ZSBhbmQgcnVuIHRoZSBuZXh0IHBlbmRpbmdcbiAgLy8gYWN0aW9uLCBpZiB0aGVyZSBhcmUgYW55LlxuICB2YXIgbGFzdCA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3QgPSBsYXN0Lm5leHQ7XG5cbiAgICBpZiAoZmlyc3QgPT09IGxhc3QpIHtcbiAgICAgIC8vIFRoaXMgd2FzIHRoZSBsYXN0IGFjdGlvbiBpbiB0aGUgcXVldWUuXG4gICAgICBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBub2RlIGZyb20gdGhlIGNpcmN1bGFyIHF1ZXVlLlxuICAgICAgdmFyIG5leHQgPSBmaXJzdC5uZXh0O1xuICAgICAgbGFzdC5uZXh0ID0gbmV4dDsgLy8gUnVuIHRoZSBuZXh0IGFjdGlvbi5cblxuICAgICAgcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIHNldFBlbmRpbmdTdGF0ZSwgc2V0U3RhdGUsIG5leHQucGF5bG9hZCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFjdGlvblN0YXRlUmVkdWNlcihvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuXG5mdW5jdGlvbiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlUHJvcCwgcGVybWFsaW5rKSB7XG4gIHZhciBpbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGVQcm9wO1xuXG4gIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcbiAgICB2YXIgc3NyRm9ybVN0YXRlID0gcm9vdC5mb3JtU3RhdGU7IC8vIElmIGEgZm9ybVN0YXRlIG9wdGlvbiB3YXMgcGFzc2VkIHRvIHRoZSByb290LCB0aGVyZSBhcmUgZm9ybSBzdGF0ZVxuICAgIC8vIG1hcmtlcnMgdGhhdCB3ZSBuZWVkIHRvIGh5ZHJhdGUuIFRoZXNlIGluZGljYXRlIHdoZXRoZXIgdGhlIGZvcm0gc3RhdGVcbiAgICAvLyBtYXRjaGVzIHRoaXMgaG9vayBpbnN0YW5jZS5cblxuICAgIGlmIChzc3JGb3JtU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBpc01hdGNoaW5nID0gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlRm9ybU1hcmtlckluc3RhbmNlKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuXG4gICAgICBpZiAoaXNNYXRjaGluZykge1xuICAgICAgICBpbml0aWFsU3RhdGUgPSBzc3JGb3JtU3RhdGVbMF07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFN0YXRlIGhvb2suIFRoZSBzdGF0ZSBpcyBzdG9yZWQgaW4gYSB0aGVuYWJsZSB3aGljaCBpcyB0aGVuIHVud3JhcHBlZCBieVxuICAvLyB0aGUgYHVzZWAgYWxnb3JpdGhtIGR1cmluZyByZW5kZXIuXG5cblxuICB2YXIgc3RhdGVIb29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgc3RhdGVIb29rLm1lbW9pemVkU3RhdGUgPSBzdGF0ZUhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlOyAvLyBUT0RPOiBUeXBpbmcgdGhpcyBcImNvcnJlY3RseVwiIHJlc3VsdHMgaW4gcmVjdXJzaW9uIGxpbWl0IGVycm9yc1xuICAvLyBjb25zdCBzdGF0ZVF1ZXVlOiBVcGRhdGVRdWV1ZTxTIHwgQXdhaXRlZDxTPiwgUyB8IEF3YWl0ZWQ8Uz4+ID0ge1xuXG4gIHZhciBzdGF0ZVF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYWN0aW9uU3RhdGVSZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgc3RhdGVIb29rLnF1ZXVlID0gc3RhdGVRdWV1ZTtcbiAgdmFyIHNldFN0YXRlID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHN0YXRlUXVldWUpO1xuICBzdGF0ZVF1ZXVlLmRpc3BhdGNoID0gc2V0U3RhdGU7IC8vIFBlbmRpbmcgc3RhdGUuIFRoaXMgaXMgdXNlZCB0byBzdG9yZSB0aGUgcGVuZGluZyBzdGF0ZSBvZiB0aGUgYWN0aW9uLlxuICAvLyBUcmFja2VkIG9wdGltaXN0aWNhbGx5LCBsaWtlIGEgdHJhbnNpdGlvbiBwZW5kaW5nIHN0YXRlLlxuXG4gIHZhciBwZW5kaW5nU3RhdGVIb29rID0gbW91bnRTdGF0ZUltcGwoZmFsc2UpO1xuICB2YXIgc2V0UGVuZGluZ1N0YXRlID0gZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUuYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBmYWxzZSwgcGVuZGluZ1N0YXRlSG9vay5xdWV1ZSk7IC8vIEFjdGlvbiBxdWV1ZSBob29rLiBUaGlzIGlzIHVzZWQgdG8gcXVldWUgcGVuZGluZyBhY3Rpb25zLiBUaGUgcXVldWUgaXNcbiAgLy8gc2hhcmVkIGJldHdlZW4gYWxsIGluc3RhbmNlcyBvZiB0aGUgaG9vay4gU2ltaWxhciB0byBhIHJlZ3VsYXIgc3RhdGUgcXVldWUsXG4gIC8vIGJ1dCBkaWZmZXJlbnQgYmVjYXVzZSB0aGUgYWN0aW9ucyBhcmUgcnVuIHNlcXVlbnRpYWxseSwgYW5kIHRoZXkgcnVuIGluXG4gIC8vIGFuIGV2ZW50IGluc3RlYWQgb2YgZHVyaW5nIHJlbmRlci5cblxuICB2YXIgYWN0aW9uUXVldWVIb29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGFjdGlvblF1ZXVlID0ge1xuICAgIHN0YXRlOiBpbml0aWFsU3RhdGUsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgLy8gY2lyY3VsYXJcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBwZW5kaW5nOiBudWxsXG4gIH07XG4gIGFjdGlvblF1ZXVlSG9vay5xdWV1ZSA9IGFjdGlvblF1ZXVlO1xuICB2YXIgZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvblN0YXRlLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgYWN0aW9uUXVldWUsIHNldFBlbmRpbmdTdGF0ZSwgc2V0U3RhdGUpO1xuICBhY3Rpb25RdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoOyAvLyBTdGFzaCB0aGUgYWN0aW9uIGZ1bmN0aW9uIG9uIHRoZSBtZW1vaXplZCBzdGF0ZSBvZiB0aGUgaG9vay4gV2UnbGwgdXNlIHRoaXNcbiAgLy8gdG8gZGV0ZWN0IHdoZW4gdGhlIGFjdGlvbiBmdW5jdGlvbiBjaGFuZ2VzIHNvIHdlIGNhbiB1cGRhdGUgaXQgaW5cbiAgLy8gYW4gZWZmZWN0LlxuXG4gIGFjdGlvblF1ZXVlSG9vay5tZW1vaXplZFN0YXRlID0gYWN0aW9uO1xuICByZXR1cm4gW2luaXRpYWxTdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICB2YXIgc3RhdGVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBjdXJyZW50U3RhdGVIb29rID0gY3VycmVudEhvb2s7XG4gIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gIHZhciBfdXBkYXRlUmVkdWNlckltcGwgPSB1cGRhdGVSZWR1Y2VySW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvblN0YXRlUmVkdWNlciksXG4gICAgICBhY3Rpb25SZXN1bHQgPSBfdXBkYXRlUmVkdWNlckltcGxbMF07XG5cbiAgdmFyIF91cGRhdGVTdGF0ZSA9IHVwZGF0ZVN0YXRlKCksXG4gICAgICBpc1BlbmRpbmcgPSBfdXBkYXRlU3RhdGVbMF07IC8vIFRoaXMgd2lsbCBzdXNwZW5kIHVudGlsIHRoZSBhY3Rpb24gZmluaXNoZXMuXG5cblxuICB2YXIgc3RhdGUgPSB0eXBlb2YgYWN0aW9uUmVzdWx0ID09PSAnb2JqZWN0JyAmJiBhY3Rpb25SZXN1bHQgIT09IG51bGwgJiYgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICB0eXBlb2YgYWN0aW9uUmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicgPyB1c2VUaGVuYWJsZShhY3Rpb25SZXN1bHQpIDogYWN0aW9uUmVzdWx0O1xuICB2YXIgYWN0aW9uUXVldWVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBhY3Rpb25RdWV1ZSA9IGFjdGlvblF1ZXVlSG9vay5xdWV1ZTtcbiAgdmFyIGRpc3BhdGNoID0gYWN0aW9uUXVldWUuZGlzcGF0Y2g7IC8vIENoZWNrIGlmIGEgbmV3IGFjdGlvbiB3YXMgcGFzc2VkLiBJZiBzbywgdXBkYXRlIGl0IGluIGFuIGVmZmVjdC5cblxuICB2YXIgcHJldkFjdGlvbiA9IGFjdGlvblF1ZXVlSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChhY3Rpb24gIT09IHByZXZBY3Rpb24pIHtcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IFBhc3NpdmUkMTtcbiAgICBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IFBhc3NpdmUsIGFjdGlvblN0YXRlQWN0aW9uRWZmZWN0LmJpbmQobnVsbCwgYWN0aW9uUXVldWUsIGFjdGlvbiksIGNyZWF0ZUVmZmVjdEluc3RhbmNlKCksIG51bGwpO1xuICB9XG5cbiAgcmV0dXJuIFtzdGF0ZSwgZGlzcGF0Y2gsIGlzUGVuZGluZ107XG59XG5cbmZ1bmN0aW9uIGFjdGlvblN0YXRlQWN0aW9uRWZmZWN0KGFjdGlvblF1ZXVlLCBhY3Rpb24pIHtcbiAgYWN0aW9uUXVldWUuYWN0aW9uID0gYWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgLy8gVW5saWtlIHVzZVN0YXRlLCB1c2VBY3Rpb25TdGF0ZSBkb2Vzbid0IHN1cHBvcnQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMuXG4gIC8vIEFsc28gdW5saWtlIHVzZVN0YXRlLCB3ZSBuZWVkIHRvIHJlcGxheSBhbGwgcGVuZGluZyB1cGRhdGVzIGFnYWluIGluIGNhc2VcbiAgLy8gdGhlIHBhc3N0aHJvdWdoIHZhbHVlIGNoYW5nZWQuXG4gIC8vXG4gIC8vIFNvIGluc3RlYWQgb2YgYSBmb3JrZWQgcmUtcmVuZGVyIGltcGxlbWVudGF0aW9uIHRoYXQga25vd3MgaG93IHRvIGhhbmRsZVxuICAvLyByZW5kZXIgcGhhc2UgdWRwYXRlcywgd2UgY2FuIHVzZSB0aGUgc2FtZSBpbXBsZW1lbnRhdGlvbiBhcyBkdXJpbmcgYVxuICAvLyByZWd1bGFyIG1vdW50IG9yIHVwZGF0ZS5cbiAgdmFyIHN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgY3VycmVudFN0YXRlSG9vayA9IGN1cnJlbnRIb29rO1xuXG4gIGlmIChjdXJyZW50U3RhdGVIb29rICE9PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyBhbiB1cGRhdGUuIFByb2Nlc3MgdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGVJbXBsKHN0YXRlSG9vaywgY3VycmVudFN0YXRlSG9vaywgYWN0aW9uKTtcbiAgfVxuXG4gIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpOyAvLyBTdGF0ZVxuICAvLyBUaGlzIGlzIGEgbW91bnQuIE5vIHVwZGF0ZXMgdG8gcHJvY2Vzcy5cblxuICB2YXIgc3RhdGUgPSBzdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIGFjdGlvblF1ZXVlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgYWN0aW9uUXVldWUgPSBhY3Rpb25RdWV1ZUhvb2sucXVldWU7XG4gIHZhciBkaXNwYXRjaCA9IGFjdGlvblF1ZXVlLmRpc3BhdGNoOyAvLyBUaGlzIG1heSBoYXZlIGNoYW5nZWQgZHVyaW5nIHRoZSByZXJlbmRlci5cblxuICBhY3Rpb25RdWV1ZUhvb2subWVtb2l6ZWRTdGF0ZSA9IGFjdGlvbjsgLy8gRm9yIG1vdW50LCBwZW5kaW5nIGlzIGFsd2F5cyBmYWxzZS5cblxuICByZXR1cm4gW3N0YXRlLCBkaXNwYXRjaCwgZmFsc2VdO1xufVxuXG5mdW5jdGlvbiBwdXNoRWZmZWN0KHRhZywgY3JlYXRlLCBpbnN0LCBkZXBzKSB7XG4gIHZhciBlZmZlY3QgPSB7XG4gICAgdGFnOiB0YWcsXG4gICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgaW5zdDogaW5zdCxcbiAgICBkZXBzOiBkZXBzLFxuICAgIC8vIENpcmN1bGFyXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICB2YXIgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChjb21wb25lbnRVcGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpO1xuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSBjb21wb25lbnRVcGRhdGVRdWV1ZTtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxhc3RFZmZlY3QgPSBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0O1xuXG4gICAgaWYgKGxhc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgbGFzdEVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICAgICAgZWZmZWN0Lm5leHQgPSBmaXJzdEVmZmVjdDtcbiAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3Q7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVmZmVjdDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWZmZWN0SW5zdGFuY2UoKSB7XG4gIHJldHVybiB7XG4gICAgZGVzdHJveTogdW5kZWZpbmVkXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciByZWYgPSB7XG4gICAgY3VycmVudDogaW5pdGlhbFZhbHVlXG4gIH07XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZjtcbiAgcmV0dXJuIHJlZjtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICByZXR1cm4gaG9vay5tZW1vaXplZFN0YXRlO1xufVxuXG5mdW5jdGlvbiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IGhvb2tGbGFncywgY3JlYXRlLCBjcmVhdGVFZmZlY3RJbnN0YW5jZSgpLCBuZXh0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBlZmZlY3QgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gIHZhciBpbnN0ID0gZWZmZWN0Lmluc3Q7IC8vIGN1cnJlbnRIb29rIGlzIG51bGwgb24gaW5pdGlhbCBtb3VudCB3aGVuIHJlcmVuZGVyaW5nIGFmdGVyIGEgcmVuZGVyIHBoYXNlXG4gIC8vIHN0YXRlIHVwZGF0ZSBvciBmb3Igc3RyaWN0IG1vZGUuXG5cbiAgaWYgKGN1cnJlbnRIb29rICE9PSBudWxsKSB7XG4gICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldkVmZmVjdCA9IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICB2YXIgcHJldkRlcHMgPSBwcmV2RWZmZWN0LmRlcHM7XG5cbiAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KGhvb2tGbGFncywgY3JlYXRlLCBpbnN0LCBuZXh0RGVwcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IGZpYmVyRmxhZ3M7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgaG9va0ZsYWdzLCBjcmVhdGUsIGluc3QsIG5leHREZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIGlmICgoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUgJiYgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIE5vU3RyaWN0UGFzc2l2ZUVmZmVjdHNNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgbW91bnRFZmZlY3RJbXBsKE1vdW50UGFzc2l2ZURldiB8IFBhc3NpdmUkMSB8IFBhc3NpdmVTdGF0aWMsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gIH0gZWxzZSB7XG4gICAgbW91bnRFZmZlY3RJbXBsKFBhc3NpdmUkMSB8IFBhc3NpdmVTdGF0aWMsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB1cGRhdGVFZmZlY3RJbXBsKFBhc3NpdmUkMSwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIG1vdW50RWZmZWN0SW1wbChVcGRhdGUsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBmaWJlckZsYWdzID0gVXBkYXRlIHwgTGF5b3V0U3RhdGljO1xuXG4gIGlmICgoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICBmaWJlckZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuICB9XG5cbiAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QoY3JlYXRlLCByZWYpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVmQ2FsbGJhY2sgPSByZWY7XG4gICAgdmFyIGluc3QgPSBjcmVhdGUoKTtcbiAgICB2YXIgcmVmQ2xlYW51cCA9IHJlZkNhbGxiYWNrKGluc3QpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodHlwZW9mIHJlZkNsZWFudXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSB3ZSBuZWVkIHRvIGFzc3VtZSBubyBwYXJhbWV0ZXJzXG4gICAgICAgIHJlZkNsZWFudXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZkNhbGxiYWNrKG51bGwpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAocmVmICE9PSBudWxsICYmIHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlZk9iamVjdCA9IHJlZjtcblxuICAgIHtcbiAgICAgIGlmICghcmVmT2JqZWN0Lmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBmaXJzdCBhcmd1bWVudCB0byBlaXRoZXIgYmUgYSAnICsgJ3JlZiBjYWxsYmFjayBvciBSZWFjdC5jcmVhdGVSZWYoKSBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsICdhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMocmVmT2JqZWN0KS5qb2luKCcsICcpICsgJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2luc3QgPSBjcmVhdGUoKTtcblxuICAgIHJlZk9iamVjdC5jdXJyZW50ID0gX2luc3Q7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlZk9iamVjdC5jdXJyZW50ID0gbnVsbDtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjcmVhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24gJyArICd0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNyZWF0ZSAhPT0gbnVsbCA/IHR5cGVvZiBjcmVhdGUgOiAnbnVsbCcpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBJZiBkZXBzIGFyZSBwcm92aWRlZCwgc2hvdWxkIHdlIHNraXAgY29tcGFyaW5nIHRoZSByZWYgaXRzZWxmP1xuXG5cbiAgdmFyIGVmZmVjdERlcHMgPSBkZXBzICE9PSBudWxsICYmIGRlcHMgIT09IHVuZGVmaW5lZCA/IGRlcHMuY29uY2F0KFtyZWZdKSA6IG51bGw7XG4gIHZhciBmaWJlckZsYWdzID0gVXBkYXRlIHwgTGF5b3V0U3RhdGljO1xuXG4gIGlmICgoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICBmaWJlckZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuICB9XG5cbiAgbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIExheW91dCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZWZmZWN0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY3JlYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjcmVhdGUgIT09IG51bGwgPyB0eXBlb2YgY3JlYXRlIDogJ251bGwnKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogSWYgZGVwcyBhcmUgcHJvdmlkZWQsIHNob3VsZCB3ZSBza2lwIGNvbXBhcmluZyB0aGUgcmVmIGl0c2VsZj9cblxuXG4gIHZhciBlZmZlY3REZXBzID0gZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB1bmRlZmluZWQgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLCBlZmZlY3REZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnREZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikgey8vIFRoaXMgaG9vayBpcyBub3JtYWxseSBhIG5vLW9wLlxuICAvLyBUaGUgcmVhY3QtZGVidWctaG9va3MgcGFja2FnZSBpbmplY3RzIGl0cyBvd24gaW1wbGVtZW50YXRpb25cbiAgLy8gc28gdGhhdCBlLmcuIERldlRvb2xzIGNhbiBkaXNwbGF5IGN1c3RvbSBob29rIHZhbHVlcy5cbn1cblxudmFyIHVwZGF0ZURlYnVnVmFsdWUgPSBtb3VudERlYnVnVmFsdWU7XG5cbmZ1bmN0aW9uIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBuZXh0RGVwc107XG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZEZXBzID0gcHJldlN0YXRlWzFdO1xuXG4gICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgIH1cbiAgfVxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgbmV4dERlcHNdO1xuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIG1vdW50TWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG5cbiAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG4gICAgbmV4dENyZWF0ZSgpO1xuICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgfVxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlOyAvLyBBc3N1bWUgdGhlc2UgYXJlIGRlZmluZWQuIElmIHRoZXkncmUgbm90LCBhcmVIb29rSW5wdXRzRXF1YWwgd2lsbCB3YXJuLlxuXG4gIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuXG4gIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuICAgIG5leHRDcmVhdGUoKTtcbiAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcmVzb2x2ZWRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rO1xuICB2YXIgcHJldlZhbHVlID0gcmVzb2x2ZWRDdXJyZW50SG9vay5tZW1vaXplZFN0YXRlO1xuICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgcHJldlZhbHVlLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICBpZiAoY3VycmVudEhvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVyZW5kZXIgZHVyaW5nIGEgbW91bnQuXG4gICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlcmVuZGVyIGR1cmluZyBhbiB1cGRhdGUuXG4gICAgdmFyIHByZXZWYWx1ZSA9IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHByZXZWYWx1ZSwgdmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gIGlmICgvLyBXaGVuIGBpbml0aWFsVmFsdWVgIGlzIHByb3ZpZGVkLCB3ZSBkZWZlciB0aGUgaW5pdGlhbCByZW5kZXIgZXZlbiBpZiB0aGVcbiAgLy8gY3VycmVudCByZW5kZXIgaXMgbm90IHN5bmNocm9ub3VzLlxuICBpbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCAmJiAvLyBIb3dldmVyLCB0byBhdm9pZCB3YXRlcmZhbGxzLCB3ZSBkbyBub3QgZGVmZXIgaWYgdGhpcyByZW5kZXJcbiAgLy8gd2FzIGl0c2VsZiBzcGF3bmVkIGJ5IGFuIGVhcmxpZXIgdXNlRGVmZXJyZWRWYWx1ZS4gQ2hlY2sgaWYgRGVmZXJyZWRMYW5lXG4gIC8vIGlzIHBhcnQgb2YgdGhlIHJlbmRlciBsYW5lcy5cbiAgIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIERlZmVycmVkTGFuZSkpIHtcbiAgICAvLyBSZW5kZXIgd2l0aCB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxWYWx1ZTsgLy8gU2NoZWR1bGUgYSBkZWZlcnJlZCByZW5kZXIgdG8gc3dpdGNoIHRvIHRoZSBmaW5hbCB2YWx1ZS5cblxuICAgIHZhciBkZWZlcnJlZExhbmUgPSByZXF1ZXN0RGVmZXJyZWRMYW5lKCk7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyA9IG1lcmdlTGFuZXMoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcywgZGVmZXJyZWRMYW5lKTtcbiAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGRlZmVycmVkTGFuZSk7XG4gICAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgcHJldlZhbHVlLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gIGlmIChvYmplY3RJcyh2YWx1ZSwgcHJldlZhbHVlKSkge1xuICAgIC8vIFRoZSBpbmNvbWluZyB2YWx1ZSBpcyByZWZlcmVudGlhbGx5IGlkZW50aWNhbCB0byB0aGUgY3VycmVudGx5IHJlbmRlcmVkXG4gICAgLy8gdmFsdWUsIHNvIHdlIGNhbiBiYWlsIG91dCBxdWlja2x5LlxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZWNlaXZlZCBhIG5ldyB2YWx1ZSB0aGF0J3MgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgaW5zaWRlIGEgaGlkZGVuIHRyZWVcbiAgICBpZiAoaXNDdXJyZW50VHJlZUhpZGRlbigpKSB7XG4gICAgICAvLyBSZXZlYWxpbmcgYSBwcmVyZW5kZXJlZCB0cmVlIGlzIGNvbnNpZGVyZWQgdGhlIHNhbWUgYXMgbW91bnRpbmcgbmV3XG4gICAgICAvLyBvbmUsIHNvIHdlIHJldXNlIHRoZSBcIm1vdW50XCIgcGF0aCBpbiB0aGlzIGNhc2UuXG4gICAgICB2YXIgcmVzdWx0VmFsdWUgPSBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpOyAvLyBVbmxpa2UgZHVyaW5nIGFuIGFjdHVhbCBtb3VudCwgd2UgbmVlZCB0byBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlIGlmXG4gICAgICAvLyB0aGUgdmFsdWUgY2hhbmdlZC5cblxuICAgICAgaWYgKCFvYmplY3RJcyhyZXN1bHRWYWx1ZSwgcHJldlZhbHVlKSkge1xuICAgICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZERlZmVyVmFsdWUgPSAhaW5jbHVkZXNPbmx5Tm9uVXJnZW50TGFuZXMocmVuZGVyTGFuZXMpO1xuXG4gICAgaWYgKHNob3VsZERlZmVyVmFsdWUpIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gdXJnZW50IHVwZGF0ZS4gU2luY2UgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCBrZWVwIHVzaW5nIHRoZVxuICAgICAgLy8gcHJldmlvdXMgdmFsdWUgYW5kIHNwYXduIGEgZGVmZXJyZWQgcmVuZGVyIHRvIHVwZGF0ZSBpdCBsYXRlci5cbiAgICAgIC8vIFNjaGVkdWxlIGEgZGVmZXJyZWQgcmVuZGVyXG4gICAgICB2YXIgZGVmZXJyZWRMYW5lID0gcmVxdWVzdERlZmVycmVkTGFuZSgpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyA9IG1lcmdlTGFuZXMoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcywgZGVmZXJyZWRMYW5lKTtcbiAgICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMoZGVmZXJyZWRMYW5lKTsgLy8gUmV1c2UgdGhlIHByZXZpb3VzIHZhbHVlLiBXZSBkbyBub3QgbmVlZCB0byBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLFxuICAgICAgLy8gYmVjYXVzZSB3ZSBkaWQgbm90IHJlbmRlciBhIG5ldyB2YWx1ZS5cblxuICAgICAgcmV0dXJuIHByZXZWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBub3QgYW4gdXJnZW50IHVwZGF0ZSwgc28gd2UgY2FuIHVzZSB0aGUgbGF0ZXN0IHZhbHVlIHJlZ2FyZGxlc3NcbiAgICAgIC8vIG9mIHdoYXQgaXQgaXMuIE5vIG5lZWQgdG8gZGVmZXIgaXQuXG4gICAgICAvLyBNYXJrIHRoaXMgYXMgYW4gdXBkYXRlIHRvIHByZXZlbnQgdGhlIGZpYmVyIGZyb20gYmFpbGluZyBvdXQuXG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihmaWJlciwgcXVldWUsIHBlbmRpbmdTdGF0ZSwgZmluaXNoZWRTdGF0ZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KGhpZ2hlckV2ZW50UHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSwgQ29udGludW91c0V2ZW50UHJpb3JpdHkpKTtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgdmFyIGN1cnJlbnRUcmFuc2l0aW9uID0ge307XG5cbiAge1xuICAgIC8vIFdlIGRvbid0IHJlYWxseSBuZWVkIHRvIHVzZSBhbiBvcHRpbWlzdGljIHVwZGF0ZSBoZXJlLCBiZWNhdXNlIHdlXG4gICAgLy8gc2NoZWR1bGUgYSBzZWNvbmQgXCJyZXZlcnRcIiB1cGRhdGUgYmVsb3cgKHdoaWNoIHdlIHVzZSB0byBzdXNwZW5kIHRoZVxuICAgIC8vIHRyYW5zaXRpb24gdW50aWwgdGhlIGFzeW5jIGFjdGlvbiBzY29wZSBoYXMgZmluaXNoZWQpLiBCdXQgd2UnbGwgdXNlIGFuXG4gICAgLy8gb3B0aW1pc3RpYyB1cGRhdGUgYW55d2F5IHRvIG1ha2UgaXQgbGVzcyBsaWtlbHkgdGhlIGJlaGF2aW9yIGFjY2lkZW50YWxseVxuICAgIC8vIGRpdmVyZ2VzOyBmb3IgZXhhbXBsZSwgYm90aCBhbiBvcHRpbWlzdGljIHVwZGF0ZSBhbmQgdGhpcyBvbmUgc2hvdWxkXG4gICAgLy8gc2hhcmUgdGhlIHNhbWUgbGFuZS5cbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG4gICAgZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUoZmliZXIsIGZhbHNlLCBxdWV1ZSwgcGVuZGluZ1N0YXRlKTtcbiAgfVxuXG4gIHtcbiAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGVuYWJsZUFzeW5jQWN0aW9ucykge1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gY2FsbGJhY2soKTtcbiAgICAgIHZhciBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG5cbiAgICAgIGlmIChvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAhPT0gbnVsbCkge1xuICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgICAgfSAvLyBDaGVjayBpZiB3ZSdyZSBpbnNpZGUgYW4gYXN5bmMgYWN0aW9uIHNjb3BlLiBJZiBzbywgd2UnbGwgZW50YW5nbGVcbiAgICAgIC8vIHRoaXMgbmV3IGFjdGlvbiB3aXRoIHRoZSBleGlzdGluZyBzY29wZS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB3ZSdyZSBub3QgYWxyZWFkeSBpbnNpZGUgYW4gYXN5bmMgYWN0aW9uIHNjb3BlLCBhbmQgdGhpcyBhY3Rpb24gaXNcbiAgICAgIC8vIGFzeW5jLCB0aGVuIHdlJ2xsIGNyZWF0ZSBhIG5ldyBhc3luYyBzY29wZS5cbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgYXN5bmMgY2FzZSwgdGhlIHJlc3VsdGluZyByZW5kZXIgd2lsbCBzdXNwZW5kIHVudGlsIHRoZSBhc3luY1xuICAgICAgLy8gYWN0aW9uIHNjb3BlIGhhcyBmaW5pc2hlZC5cblxuXG4gICAgICBpZiAocmV0dXJuVmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHJldHVyblZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgdGhlbmFibGUgPSByZXR1cm5WYWx1ZTsgLy8gQ3JlYXRlIGEgdGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBgZmluaXNoZWRTdGF0ZWAgb25jZSB0aGUgYXN5bmNcbiAgICAgICAgLy8gYWN0aW9uIGhhcyBjb21wbGV0ZWQuXG5cbiAgICAgICAgdmFyIHRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSA9IGNoYWluVGhlbmFibGVWYWx1ZSh0aGVuYWJsZSwgZmluaXNoZWRTdGF0ZSk7XG4gICAgICAgIGRpc3BhdGNoU2V0U3RhdGUoZmliZXIsIHF1ZXVlLCB0aGVuYWJsZUZvckZpbmlzaGVkU3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGF0Y2hTZXRTdGF0ZShmaWJlciwgcXVldWUsIGZpbmlzaGVkU3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB7XG4gICAgICAvLyBUaGlzIGlzIGEgdHJpY2sgdG8gZ2V0IHRoZSBgdXNlVHJhbnNpdGlvbmAgaG9vayB0byByZXRocm93IHRoZSBlcnJvci5cbiAgICAgIC8vIFdoZW4gaXQgdW53cmFwcyB0aGUgdGhlbmFibGUgd2l0aCB0aGUgYHVzZWAgYWxnb3JpdGhtLCB0aGUgZXJyb3JcbiAgICAgIC8vIHdpbGwgYmUgdGhyb3duLlxuICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB7XG4gICAgICAgIHRoZW46IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBzdGF0dXM6ICdyZWplY3RlZCcsXG4gICAgICAgIHJlYXNvbjogZXJyb3JcbiAgICAgIH07XG4gICAgICBkaXNwYXRjaFNldFN0YXRlKGZpYmVyLCBxdWV1ZSwgcmVqZWN0ZWRUaGVuYWJsZSk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG5cbiAgICB7XG4gICAgICBpZiAocHJldlRyYW5zaXRpb24gPT09IG51bGwgJiYgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgdmFyIHVwZGF0ZWRGaWJlcnNDb3VudCA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemU7XG5cbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKTtcblxuICAgICAgICBpZiAodXBkYXRlZEZpYmVyc0NvdW50ID4gMTApIHtcbiAgICAgICAgICB3YXJuKCdEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uICcgKyAnSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gJyArICdPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gc3RhcnRIb3N0VHJhbnNpdGlvbihmb3JtRmliZXIsIHBlbmRpbmdTdGF0ZSwgYWN0aW9uLCBmb3JtRGF0YSkge1xuXG4gIGlmIChmb3JtRmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZm9ybSBpbnN0YW5jZSB0byBiZSBhIEhvc3RDb21wb25lbnQuIFRoaXMgJyArICdpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfVxuXG4gIHZhciBzdGF0ZUhvb2sgPSBlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bChmb3JtRmliZXIpO1xuICB2YXIgcXVldWUgPSBzdGF0ZUhvb2sucXVldWU7XG4gIHN0YXJ0VHJhbnNpdGlvbihmb3JtRmliZXIsIHF1ZXVlLCBwZW5kaW5nU3RhdGUsIE5vdFBlbmRpbmdUcmFuc2l0aW9uLCAvLyBUT0RPOiBgc3RhcnRUcmFuc2l0aW9uYCBib3RoIHNldHMgdGhlIHBlbmRpbmcgc3RhdGUgYW5kIGRpc3BhdGNoZXNcbiAgLy8gdGhlIGFjdGlvbiwgaWYgb25lIGlzIHByb3ZpZGVkLiBDb25zaWRlciByZWZhY3RvcmluZyB0aGVzZSB0d29cbiAgLy8gY29uY2VybnMgdG8gYXZvaWQgdGhlIGV4dHJhIGxhbWJkYS5cbiAgYWN0aW9uID09PSBudWxsID8gLy8gTm8gYWN0aW9uIHdhcyBwcm92aWRlZCwgYnV0IHdlIHN0aWxsIGNhbGwgYHN0YXJ0VHJhbnNpdGlvbmAgdG9cbiAgLy8gc2V0IHRoZSBwZW5kaW5nIGZvcm0gc3RhdHVzLlxuICBub29wIDogZnVuY3Rpb24gKCkge1xuICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVzZXQgdGhlIGZvcm0gd2hlbiB0aGUgYWN0aW9uIGNvbXBsZXRlcy5cbiAgICByZXF1ZXN0Rm9ybVJlc2V0KGZvcm1GaWJlcik7XG4gICAgcmV0dXJuIGFjdGlvbihmb3JtRGF0YSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bChmb3JtRmliZXIpIHtcbiAgdmFyIGV4aXN0aW5nU3RhdGVIb29rID0gZm9ybUZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKGV4aXN0aW5nU3RhdGVIb29rICE9PSBudWxsKSB7XG4gICAgLy8gVGhpcyBmaWJlciB3YXMgYWxyZWFkeSB1cGdyYWRlZCB0byBiZSBzdGF0ZWZ1bC5cbiAgICByZXR1cm4gZXhpc3RpbmdTdGF0ZUhvb2s7XG4gIH0gLy8gVXBncmFkZSB0aGlzIGhvc3QgY29tcG9uZW50IGZpYmVyIHRvIGJlIHN0YXRlZnVsLiBXZSdyZSBnb2luZyB0byBwcmV0ZW5kXG4gIC8vIGl0IHdhcyBzdGF0ZWZ1bCBhbGwgYWxvbmcgc28gd2UgY2FuIHJldXNlIG1vc3Qgb2YgdGhlIGltcGxlbWVudGF0aW9uXG4gIC8vIGZvciBmdW5jdGlvbiBjb21wb25lbnRzIGFuZCB1c2VUcmFuc2l0aW9uLlxuICAvL1xuICAvLyBDcmVhdGUgdGhlIHN0YXRlIGhvb2sgdXNlZCBieSBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50LiBUaGlzIGlzXG4gIC8vIGVzc2VudGlhbGx5IGFuIGlubGluZWQgdmVyc2lvbiBvZiBtb3VudFN0YXRlLlxuXG5cbiAgdmFyIG5ld1F1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgLy8gV2UncmUgZ29pbmcgdG8gY2hlYXQgYW5kIGludGVudGlvbmFsbHkgbm90IGNyZWF0ZSBhIGJvdW5kIGRpc3BhdGNoXG4gICAgLy8gbWV0aG9kLCBiZWNhdXNlIHdlIGNhbiBjYWxsIGl0IGRpcmVjdGx5IGluIHN0YXJ0VHJhbnNpdGlvbi5cbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogTm90UGVuZGluZ1RyYW5zaXRpb25cbiAgfTtcbiAgdmFyIHN0YXRlSG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICBiYXNlU3RhdGU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uLFxuICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICBxdWV1ZTogbmV3UXVldWUsXG4gICAgbmV4dDogbnVsbFxuICB9OyAvLyBXZSB1c2UgYW5vdGhlciBzdGF0ZSBob29rIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGZvcm0gbmVlZHMgdG8gYmUgcmVzZXQuXG4gIC8vIFRoZSBzdGF0ZSBpcyBhbiBlbXB0eSBvYmplY3QuIFRvIHRyaWdnZXIgYSByZXNldCwgd2UgdXBkYXRlIHRoZSBzdGF0ZVxuICAvLyB0byBhIG5ldyBvYmplY3QuIFRoZW4gZHVyaW5nIHJlbmRlcmluZywgd2UgZGV0ZWN0IHRoYXQgdGhlIHN0YXRlIGhhc1xuICAvLyBjaGFuZ2VkIGFuZCBzY2hlZHVsZSBhIGNvbW1pdCBlZmZlY3QuXG5cbiAgdmFyIGluaXRpYWxSZXNldFN0YXRlID0ge307XG4gIHZhciBuZXdSZXNldFN0YXRlUXVldWUgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBsYW5lczogTm9MYW5lcyxcbiAgICAvLyBXZSdyZSBnb2luZyB0byBjaGVhdCBhbmQgaW50ZW50aW9uYWxseSBub3QgY3JlYXRlIGEgYm91bmQgZGlzcGF0Y2hcbiAgICAvLyBtZXRob2QsIGJlY2F1c2Ugd2UgY2FuIGNhbGwgaXQgZGlyZWN0bHkgaW4gc3RhcnRUcmFuc2l0aW9uLlxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsUmVzZXRTdGF0ZVxuICB9O1xuICB2YXIgcmVzZXRTdGF0ZUhvb2sgPSB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGUsXG4gICAgYmFzZVN0YXRlOiBpbml0aWFsUmVzZXRTdGF0ZSxcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IG5ld1Jlc2V0U3RhdGVRdWV1ZSxcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIHN0YXRlSG9vay5uZXh0ID0gcmVzZXRTdGF0ZUhvb2s7IC8vIEFkZCB0aGUgaG9vayBsaXN0IHRvIGJvdGggZmliZXIgYWx0ZXJuYXRlcy4gVGhlIGlkZWEgaXMgdGhhdCB0aGUgZmliZXJcbiAgLy8gaGFkIHRoaXMgaG9vayBhbGwgYWxvbmcuXG5cbiAgZm9ybUZpYmVyLm1lbW9pemVkU3RhdGUgPSBzdGF0ZUhvb2s7XG4gIHZhciBhbHRlcm5hdGUgPSBmb3JtRmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICBhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlSG9vaztcbiAgfVxuXG4gIHJldHVybiBzdGF0ZUhvb2s7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RGb3JtUmVzZXQoZm9ybUZpYmVyKSB7XG4gIHZhciB0cmFuc2l0aW9uID0gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCk7XG5cbiAge1xuICAgIGlmICh0cmFuc2l0aW9uID09PSBudWxsKSB7XG4gICAgICAvLyBBbiBvcHRpbWlzdGljIHVwZGF0ZSBvY2N1cnJlZCwgYnV0IHN0YXJ0VHJhbnNpdGlvbiBpcyBub3Qgb24gdGhlIHN0YWNrLlxuICAgICAgLy8gVGhlIGZvcm0gcmVzZXQgd2lsbCBiZSBzY2hlZHVsZWQgYXQgZGVmYXVsdCAoc3luYykgcHJpb3JpdHksIHdoaWNoXG4gICAgICAvLyBpcyBwcm9iYWJseSBub3Qgd2hhdCB0aGUgdXNlciBpbnRlbmRlZC4gTW9zdCBsaWtlbHkgYmVjYXVzZSB0aGVcbiAgICAgIC8vIHJlcXVlc3RGb3JtUmVzZXQgY2FsbCBoYXBwZW5lZCBhZnRlciBhbiBgYXdhaXRgLlxuICAgICAgLy8gVE9ETzogVGhlb3JldGljYWxseSwgcmVxdWVzdEZvcm1SZXNldCBpcyBzdGlsbCB1c2VmdWwgZXZlbiBmb3JcbiAgICAgIC8vIG5vbi10cmFuc2l0aW9uIHVwZGF0ZXMgYmVjYXVzZSBpdCBhbGxvd3MgeW91IHRvIHVwZGF0ZSBkZWZhdWx0VmFsdWVcbiAgICAgIC8vIHN5bmNocm9ub3VzbHkgYW5kIHRoZW4gd2FpdCB0byByZXNldCB1bnRpbCBhZnRlciB0aGUgdXBkYXRlIGNvbW1pdHMuXG4gICAgICAvLyBJJ3ZlIGNob3NlbiB0byB3YXJuIGFueXdheSBiZWNhdXNlIGl0J3MgbW9yZSBsaWtlbHkgdGhlIGBhd2FpdGAgbWlzdGFrZVxuICAgICAgLy8gZGVzY3JpYmVkIGFib3ZlLiBCdXQgYXJndWFibHkgd2Ugc2hvdWxkbid0LlxuICAgICAgZXJyb3IoJ3JlcXVlc3RGb3JtUmVzZXQgd2FzIGNhbGxlZCBvdXRzaWRlIGEgdHJhbnNpdGlvbiBvciBhY3Rpb24uIFRvICcgKyAnZml4LCBtb3ZlIHRvIGFuIGFjdGlvbiwgb3Igd3JhcCB3aXRoIHN0YXJ0VHJhbnNpdGlvbi4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGVIb29rID0gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKTtcbiAgdmFyIG5ld1Jlc2V0U3RhdGUgPSB7fTtcbiAgdmFyIHJlc2V0U3RhdGVIb29rID0gc3RhdGVIb29rLm5leHQ7XG4gIHZhciByZXNldFN0YXRlUXVldWUgPSByZXNldFN0YXRlSG9vay5xdWV1ZTtcbiAgZGlzcGF0Y2hTZXRTdGF0ZShmb3JtRmliZXIsIHJlc2V0U3RhdGVRdWV1ZSwgbmV3UmVzZXRTdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIG1vdW50VHJhbnNpdGlvbigpIHtcbiAgdmFyIHN0YXRlSG9vayA9IG1vdW50U3RhdGVJbXBsKGZhbHNlKTsgLy8gVGhlIGBzdGFydGAgbWV0aG9kIG5ldmVyIGNoYW5nZXMuXG5cbiAgdmFyIHN0YXJ0ID0gc3RhcnRUcmFuc2l0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgc3RhdGVIb29rLnF1ZXVlLCB0cnVlLCBmYWxzZSk7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gc3RhcnQ7XG4gIHJldHVybiBbZmFsc2UsIHN0YXJ0XTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbigpIHtcbiAgdmFyIF91cGRhdGVTdGF0ZTIgPSB1cGRhdGVTdGF0ZSgpLFxuICAgICAgYm9vbGVhbk9yVGhlbmFibGUgPSBfdXBkYXRlU3RhdGUyWzBdO1xuXG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBzdGFydCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIGlzUGVuZGluZyA9IHR5cGVvZiBib29sZWFuT3JUaGVuYWJsZSA9PT0gJ2Jvb2xlYW4nID8gYm9vbGVhbk9yVGhlbmFibGUgOiAvLyBUaGlzIHdpbGwgc3VzcGVuZCB1bnRpbCB0aGUgYXN5bmMgYWN0aW9uIHNjb3BlIGhhcyBmaW5pc2hlZC5cbiAgdXNlVGhlbmFibGUoYm9vbGVhbk9yVGhlbmFibGUpO1xuICByZXR1cm4gW2lzUGVuZGluZywgc3RhcnRdO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlclRyYW5zaXRpb24oKSB7XG4gIHZhciBfcmVyZW5kZXJTdGF0ZSA9IHJlcmVuZGVyU3RhdGUoKSxcbiAgICAgIGJvb2xlYW5PclRoZW5hYmxlID0gX3JlcmVuZGVyU3RhdGVbMF07XG5cbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHN0YXJ0ID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICB2YXIgaXNQZW5kaW5nID0gdHlwZW9mIGJvb2xlYW5PclRoZW5hYmxlID09PSAnYm9vbGVhbicgPyBib29sZWFuT3JUaGVuYWJsZSA6IC8vIFRoaXMgd2lsbCBzdXNwZW5kIHVudGlsIHRoZSBhc3luYyBhY3Rpb24gc2NvcGUgaGFzIGZpbmlzaGVkLlxuICB1c2VUaGVuYWJsZShib29sZWFuT3JUaGVuYWJsZSk7XG4gIHJldHVybiBbaXNQZW5kaW5nLCBzdGFydF07XG59XG5cbmZ1bmN0aW9uIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzKCkge1xuXG4gIHZhciBzdGF0dXMgPSByZWFkQ29udGV4dChIb3N0VHJhbnNpdGlvbkNvbnRleHQpO1xuICByZXR1cm4gc3RhdHVzICE9PSBudWxsID8gc3RhdHVzIDogTm90UGVuZGluZ1RyYW5zaXRpb247XG59XG5cbmZ1bmN0aW9uIG1vdW50SWQoKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTsgLy8gVE9ETzogSW4gRml6eiwgaWQgZ2VuZXJhdGlvbiBpcyBzcGVjaWZpYyB0byBlYWNoIHNlcnZlciBjb25maWcuIE1heWJlIHdlXG4gIC8vIHNob3VsZCBkbyB0aGlzIGluIEZpYmVyLCB0b28/IERlZmVycmluZyB0aGlzIGRlY2lzaW9uIGZvciBub3cgYmVjYXVzZVxuICAvLyB0aGVyZSdzIG5vIG90aGVyIHBsYWNlIHRvIHN0b3JlIHRoZSBwcmVmaXggZXhjZXB0IGZvciBhbiBpbnRlcm5hbCBmaWVsZCBvblxuICAvLyB0aGUgcHVibGljIGNyZWF0ZVJvb3Qgb2JqZWN0LCB3aGljaCB0aGUgZmliZXIgdHJlZSBkb2VzIG5vdCBjdXJyZW50bHkgaGF2ZVxuICAvLyBhIHJlZmVyZW5jZSB0by5cblxuICB2YXIgaWRlbnRpZmllclByZWZpeCA9IHJvb3QuaWRlbnRpZmllclByZWZpeDtcbiAgdmFyIGlkO1xuXG4gIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgdmFyIHRyZWVJZCA9IGdldFRyZWVJZCgpOyAvLyBVc2UgYSBjYXB0aWFsIFIgcHJlZml4IGZvciBzZXJ2ZXItZ2VuZXJhdGVkIGlkcy5cblxuICAgIGlkID0gJzonICsgaWRlbnRpZmllclByZWZpeCArICdSJyArIHRyZWVJZDsgLy8gVW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IGlkIGF0IHRoaXMgbGV2ZWwsIGFwcGVuZCBhIG51bWJlciBhdCB0aGUgZW5kXG4gICAgLy8gdGhhdCByZXByZXNlbnRzIHRoZSBwb3NpdGlvbiBvZiB0aGlzIHVzZUlkIGhvb2sgYW1vbmcgYWxsIHRoZSB1c2VJZFxuICAgIC8vIGhvb2tzIGZvciB0aGlzIGZpYmVyLlxuXG4gICAgdmFyIGxvY2FsSWQgPSBsb2NhbElkQ291bnRlcisrO1xuXG4gICAgaWYgKGxvY2FsSWQgPiAwKSB7XG4gICAgICBpZCArPSAnSCcgKyBsb2NhbElkLnRvU3RyaW5nKDMyKTtcbiAgICB9XG5cbiAgICBpZCArPSAnOic7XG4gIH0gZWxzZSB7XG4gICAgLy8gVXNlIGEgbG93ZXJjYXNlIHIgcHJlZml4IGZvciBjbGllbnQtZ2VuZXJhdGVkIGlkcy5cbiAgICB2YXIgZ2xvYmFsQ2xpZW50SWQgPSBnbG9iYWxDbGllbnRJZENvdW50ZXIrKztcbiAgICBpZCA9ICc6JyArIGlkZW50aWZpZXJQcmVmaXggKyAncicgKyBnbG9iYWxDbGllbnRJZC50b1N0cmluZygzMikgKyAnOic7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBpZDtcbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJZCgpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGlkID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVmcmVzaCgpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcmVmcmVzaCA9IGhvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZnJlc2hDYWNoZS5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuICByZXR1cm4gcmVmcmVzaDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVmcmVzaCgpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgcmV0dXJuIGhvb2subWVtb2l6ZWRTdGF0ZTtcbn1cblxuZnVuY3Rpb24gcmVmcmVzaENhY2hlKGZpYmVyLCBzZWVkS2V5LCBzZWVkVmFsdWUpIHtcbiAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBpZiB0aGUgcmVmcmVzaCBpcyBhdCBkaXNjcmV0ZSBwcmlvcml0eSwgb3IgaWYgd2VcbiAgLy8gb3RoZXJ3aXNlIHN1c3BlY3QgdGhhdCBpdCB3YXNuJ3QgYmF0Y2hlZCBwcm9wZXJseS5cblxuXG4gIHZhciBwcm92aWRlciA9IGZpYmVyLnJldHVybjtcblxuICB3aGlsZSAocHJvdmlkZXIgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHByb3ZpZGVyLnRhZykge1xuICAgICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNhY2hlIGJvdW5kYXJ5IHRvIHRyaWdnZXIgYSByZWZyZXNoLlxuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUocHJvdmlkZXIpO1xuICAgICAgICAgIHZhciByZWZyZXNoVXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgICAgIHZhciByb290ID0gZW5xdWV1ZVVwZGF0ZShwcm92aWRlciwgcmVmcmVzaFVwZGF0ZSwgbGFuZSk7XG5cbiAgICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIHByb3ZpZGVyLCBsYW5lKTtcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgcHJvdmlkZXIsIGxhbmUpO1xuICAgICAgICAgIH0gLy8gVE9ETzogSWYgYSByZWZyZXNoIG5ldmVyIGNvbW1pdHMsIHRoZSBuZXcgY2FjaGUgY3JlYXRlZCBoZXJlIG11c3QgYmVcbiAgICAgICAgICAvLyByZWxlYXNlZC4gQSBzaW1wbGUgY2FzZSBpcyBzdGFydCByZWZyZXNoaW5nIGEgY2FjaGUgYm91bmRhcnksIGJ1dCB0aGVuXG4gICAgICAgICAgLy8gdW5tb3VudCB0aGF0IGJvdW5kYXJ5IGJlZm9yZSB0aGUgcmVmcmVzaCBjb21wbGV0ZXMuXG5cblxuICAgICAgICAgIHZhciBzZWVkZWRDYWNoZSA9IGNyZWF0ZUNhY2hlKCk7XG5cbiAgICAgICAgICBpZiAoc2VlZEtleSAhPT0gbnVsbCAmJiBzZWVkS2V5ICE9PSB1bmRlZmluZWQgJiYgcm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ1RoZSBzZWVkIGFyZ3VtZW50IGlzIG5vdCBlbmFibGVkIG91dHNpZGUgZXhwZXJpbWVudGFsIGNoYW5uZWxzLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgICAgICBjYWNoZTogc2VlZGVkQ2FjaGVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlZnJlc2hVcGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdmlkZXIgPSBwcm92aWRlci5yZXR1cm47XG4gIH0gLy8gVE9ETzogV2FybiBpZiB1bm1vdW50ZWQ/XG5cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uKGZpYmVyLCBxdWV1ZSwgYWN0aW9uKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBcIiArICdzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciAnICsgJ3JlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgdmFyIHVwZGF0ZSA9IHtcbiAgICBsYW5lOiBsYW5lLFxuICAgIHJldmVydExhbmU6IE5vTGFuZSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBoYXNFYWdlclN0YXRlOiBmYWxzZSxcbiAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcblxuICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSk7XG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCwgcXVldWUsIGxhbmUpO1xuICAgIH1cbiAgfVxuXG4gIG1hcmtVcGRhdGVJbkRldlRvb2xzKGZpYmVyLCBsYW5lKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hTZXRTdGF0ZShmaWJlciwgcXVldWUsIGFjdGlvbikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgXCIgKyAnc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgJyArICdyZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICByZXZlcnRMYW5lOiBOb0xhbmUsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgaGFzRWFnZXJTdGF0ZTogZmFsc2UsXG4gICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG5cbiAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSB7XG4gICAgZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICBpZiAoZmliZXIubGFuZXMgPT09IE5vTGFuZXMgJiYgKGFsdGVybmF0ZSA9PT0gbnVsbCB8fCBhbHRlcm5hdGUubGFuZXMgPT09IE5vTGFuZXMpKSB7XG4gICAgICAvLyBUaGUgcXVldWUgaXMgY3VycmVudGx5IGVtcHR5LCB3aGljaCBtZWFucyB3ZSBjYW4gZWFnZXJseSBjb21wdXRlIHRoZVxuICAgICAgLy8gbmV4dCBzdGF0ZSBiZWZvcmUgZW50ZXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gSWYgdGhlIG5ldyBzdGF0ZSBpcyB0aGVcbiAgICAgIC8vIHNhbWUgYXMgdGhlIGN1cnJlbnQgc3RhdGUsIHdlIG1heSBiZSBhYmxlIHRvIGJhaWwgb3V0IGVudGlyZWx5LlxuICAgICAgdmFyIGxhc3RSZW5kZXJlZFJlZHVjZXIgPSBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyO1xuXG4gICAgICBpZiAobGFzdFJlbmRlcmVkUmVkdWNlciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBudWxsO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gcXVldWUubGFzdFJlbmRlcmVkU3RhdGU7XG4gICAgICAgICAgdmFyIGVhZ2VyU3RhdGUgPSBsYXN0UmVuZGVyZWRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTsgLy8gU3Rhc2ggdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGUsIGFuZCB0aGUgcmVkdWNlciB1c2VkIHRvIGNvbXB1dGVcbiAgICAgICAgICAvLyBpdCwgb24gdGhlIHVwZGF0ZSBvYmplY3QuIElmIHRoZSByZWR1Y2VyIGhhc24ndCBjaGFuZ2VkIGJ5IHRoZVxuICAgICAgICAgIC8vIHRpbWUgd2UgZW50ZXIgdGhlIHJlbmRlciBwaGFzZSwgdGhlbiB0aGUgZWFnZXIgc3RhdGUgY2FuIGJlIHVzZWRcbiAgICAgICAgICAvLyB3aXRob3V0IGNhbGxpbmcgdGhlIHJlZHVjZXIgYWdhaW4uXG5cbiAgICAgICAgICB1cGRhdGUuaGFzRWFnZXJTdGF0ZSA9IHRydWU7XG4gICAgICAgICAgdXBkYXRlLmVhZ2VyU3RhdGUgPSBlYWdlclN0YXRlO1xuXG4gICAgICAgICAgaWYgKG9iamVjdElzKGVhZ2VyU3RhdGUsIGN1cnJlbnRTdGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aC4gV2UgY2FuIGJhaWwgb3V0IHdpdGhvdXQgc2NoZWR1bGluZyBSZWFjdCB0byByZS1yZW5kZXIuXG4gICAgICAgICAgICAvLyBJdCdzIHN0aWxsIHBvc3NpYmxlIHRoYXQgd2UnbGwgbmVlZCB0byByZWJhc2UgdGhpcyB1cGRhdGUgbGF0ZXIsXG4gICAgICAgICAgICAvLyBpZiB0aGUgY29tcG9uZW50IHJlLXJlbmRlcnMgZm9yIGEgZGlmZmVyZW50IHJlYXNvbiBhbmQgYnkgdGhhdFxuICAgICAgICAgICAgLy8gdGltZSB0aGUgcmVkdWNlciBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgIC8vIFRPRE86IERvIHdlIHN0aWxsIG5lZWQgdG8gZW50YW5nbGUgdHJhbnNpdGlvbnMgaW4gdGhpcyBjYXNlP1xuICAgICAgICAgICAgZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlQW5kRWFnZXJseUJhaWxvdXQoZmliZXIsIHF1ZXVlLCB1cGRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTdXBwcmVzcyB0aGUgZXJyb3IuIEl0IHdpbGwgdGhyb3cgYWdhaW4gaW4gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSk7XG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCwgcXVldWUsIGxhbmUpO1xuICAgIH1cbiAgfVxuXG4gIG1hcmtVcGRhdGVJbkRldlRvb2xzKGZpYmVyLCBsYW5lKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUoZmliZXIsIHRocm93SWZEdXJpbmdSZW5kZXIsIHF1ZXVlLCBhY3Rpb24pIHtcbiAgdmFyIHRyYW5zaXRpb24gPSByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKTtcblxuICB7XG4gICAgaWYgKHRyYW5zaXRpb24gPT09IG51bGwpIHtcbiAgICAgIC8vIEFuIG9wdGltaXN0aWMgdXBkYXRlIG9jY3VycmVkLCBidXQgc3RhcnRUcmFuc2l0aW9uIGlzIG5vdCBvbiB0aGUgc3RhY2suXG4gICAgICAvLyBUaGVyZSBhcmUgdHdvIGxpa2VseSBzY2VuYXJpb3MuXG4gICAgICAvLyBPbmUgcG9zc2liaWxpdHkgaXMgdGhhdCB0aGUgb3B0aW1pc3RpYyB1cGRhdGUgaXMgdHJpZ2dlcmVkIGJ5IGEgcmVndWxhclxuICAgICAgLy8gZXZlbnQgaGFuZGxlciAoZS5nLiBgb25TdWJtaXRgKSBpbnN0ZWFkIG9mIGFuIGFjdGlvbi4gVGhpcyBpcyBhIG1pc3Rha2VcbiAgICAgIC8vIGFuZCB3ZSB3aWxsIHdhcm4uXG4gICAgICAvLyBUaGUgb3RoZXIgcG9zc2liaWxpdHkgaXMgdGhlIG9wdGltaXN0aWMgdXBkYXRlIGlzIGluc2lkZSBhbiBhc3luY1xuICAgICAgLy8gYWN0aW9uLCBidXQgYWZ0ZXIgYW4gYGF3YWl0YC4gSW4gdGhpcyBjYXNlLCB3ZSBjYW4gbWFrZSBpdCBcImp1c3Qgd29ya1wiXG4gICAgICAvLyBieSBhc3NvY2lhdGluZyB0aGUgb3B0aW1pc3RpYyB1cGRhdGUgd2l0aCB0aGUgcGVuZGluZyBhc3luYyBhY3Rpb24uXG4gICAgICAvLyBUZWNobmljYWxseSBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIG9wdGltaXN0aWMgdXBkYXRlIGlzIHVucmVsYXRlZCB0b1xuICAgICAgLy8gdGhlIHBlbmRpbmcgYWN0aW9uLCBidXQgd2UgZG9uJ3QgaGF2ZSBhIHdheSBvZiBrbm93aW5nIHRoaXMgZm9yIHN1cmVcbiAgICAgIC8vIGJlY2F1c2UgYnJvd3NlcnMgY3VycmVudGx5IGRvIG5vdCBwcm92aWRlIGEgd2F5IHRvIHRyYWNrIGFzeW5jIHNjb3BlLlxuICAgICAgLy8gKFRoZSBBc3luY0NvbnRleHQgcHJvcG9zYWwsIGlmIGl0IGxhbmRzLCB3aWxsIHNvbHZlIHRoaXMgaW4gdGhlXG4gICAgICAvLyBmdXR1cmUuKSBIb3dldmVyLCB0aGlzIGlzIG5vIGRpZmZlcmVudCB0aGFuIHRoZSBwcm9ibGVtIG9mIHVucmVsYXRlZFxuICAgICAgLy8gdHJhbnNpdGlvbnMgYmVpbmcgZ3JvdXBlZCB0b2dldGhlciDigJQgaXQncyBub3Qgd3JvbmcgcGVyIHNlLCBidXQgaXQnc1xuICAgICAgLy8gbm90IGlkZWFsLlxuICAgICAgLy8gT25jZSBBc3luY0NvbnRleHQgc3RhcnRzIGxhbmRpbmcgaW4gYnJvd3NlcnMsIHdlIHdpbGwgcHJvdmlkZSBiZXR0ZXJcbiAgICAgIC8vIHdhcm5pbmdzIGluIGRldmVsb3BtZW50IGZvciB0aGVzZSBjYXNlcy5cbiAgICAgIGlmIChwZWVrRW50YW5nbGVkQWN0aW9uTGFuZSgpICE9PSBOb0xhbmUpIDsgZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gcGVuZGluZyBhc3luYyBhY3Rpb24uIFRoZSBtb3N0IGxpa2VseSBjYXVzZSBpcyB0aGF0IHdlJ3JlXG4gICAgICAgIC8vIGluc2lkZSBhIHJlZ3VsYXIgZXZlbnQgaGFuZGxlciAoZS5nLiBvblN1Ym1pdCkgaW5zdGVhZCBvZiBhbiBhY3Rpb24uXG4gICAgICAgIGVycm9yKCdBbiBvcHRpbWlzdGljIHN0YXRlIHVwZGF0ZSBvY2N1cnJlZCBvdXRzaWRlIGEgdHJhbnNpdGlvbiBvciAnICsgJ2FjdGlvbi4gVG8gZml4LCBtb3ZlIHRoZSB1cGRhdGUgdG8gYW4gYWN0aW9uLCBvciB3cmFwICcgKyAnd2l0aCBzdGFydFRyYW5zaXRpb24uJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZSA9IHtcbiAgICAvLyBBbiBvcHRpbWlzdGljIHVwZGF0ZSBjb21taXRzIHN5bmNocm9ub3VzbHkuXG4gICAgbGFuZTogU3luY0xhbmUsXG4gICAgLy8gQWZ0ZXIgY29tbWl0dGluZywgdGhlIG9wdGltaXN0aWMgdXBkYXRlIGlzIFwicmV2ZXJ0ZWRcIiB1c2luZyB0aGUgc2FtZVxuICAgIC8vIGxhbmUgYXMgdGhlIHRyYW5zaXRpb24gaXQncyBhc3NvY2lhdGVkIHdpdGguXG4gICAgcmV2ZXJ0TGFuZTogcmVxdWVzdFRyYW5zaXRpb25MYW5lKCksXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgaGFzRWFnZXJTdGF0ZTogZmFsc2UsXG4gICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG5cbiAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSB7XG4gICAgLy8gV2hlbiBjYWxsaW5nIHN0YXJ0VHJhbnNpdGlvbiBkdXJpbmcgcmVuZGVyLCB0aGlzIHdhcm5zIGluc3RlYWQgb2ZcbiAgICAvLyB0aHJvd2luZyBiZWNhdXNlIHRocm93aW5nIHdvdWxkIGJlIGEgYnJlYWtpbmcgY2hhbmdlLiBzZXRPcHRpbWlzdGljU3RhdGVcbiAgICAvLyBpcyBhIG5ldyBBUEkgc28gaXQncyBPSyB0byB0aHJvdy5cbiAgICBpZiAodGhyb3dJZkR1cmluZ1JlbmRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXBkYXRlIG9wdGltaXN0aWMgc3RhdGUgd2hpbGUgcmVuZGVyaW5nLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdGFydFRyYW5zaXRpb24gd2FzIGNhbGxlZCBkdXJpbmcgcmVuZGVyLiBXZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAvLyBiZXNpZGVzIHdhcm4gaGVyZSBiZWNhdXNlIHRoZSByZW5kZXIgcGhhc2UgdXBkYXRlIHdvdWxkIGJlIG92ZXJpZGRlbiBieVxuICAgICAgLy8gdGhlIHNlY29uZCB1cGRhdGUsIGFueXdheS4gV2UgY2FuIHJlbW92ZSB0aGlzIGJyYW5jaCBhbmQgbWFrZSBpdCB0aHJvd1xuICAgICAgLy8gaW4gYSBmdXR1cmUgcmVsZWFzZS5cbiAgICAgIHtcbiAgICAgICAgZXJyb3IoJ0Nhbm5vdCBjYWxsIHN0YXJ0VHJhbnNpdGlvbiB3aGlsZSByZW5kZXJpbmcuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBTeW5jTGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgLy8gTk9URTogVGhlIG9wdGltaXN0aWMgdXBkYXRlIGltcGxlbWVudGF0aW9uIGFzc3VtZXMgdGhhdCB0aGUgdHJhbnNpdGlvblxuICAgICAgLy8gd2lsbCBuZXZlciBiZSBhdHRlbXB0ZWQgYmVmb3JlIHRoZSBvcHRpbWlzdGljIHVwZGF0ZS4gVGhpcyBjdXJyZW50bHlcbiAgICAgIC8vIGhvbGRzIGJlY2F1c2UgdGhlIG9wdGltaXN0aWMgdXBkYXRlIGlzIGFsd2F5cyBzeW5jaHJvbm91cy4gSWYgd2UgZXZlclxuICAgICAgLy8gY2hhbmdlIHRoYXQsIHdlJ2xsIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhpcy5cbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUpOyAvLyBPcHRpbWlzdGljIHVwZGF0ZXMgYXJlIGFsd2F5cyBzeW5jaHJvbm91cywgc28gd2UgZG9uJ3QgbmVlZCB0byBjYWxsXG4gICAgICAvLyBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUgaGVyZS5cbiAgICB9XG4gIH1cblxuICBtYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlciwgU3luY0xhbmUpO1xufVxuXG5mdW5jdGlvbiBpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIHJldHVybiBmaWJlciA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSB8fCBhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xufVxuXG5mdW5jdGlvbiBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSkge1xuICAvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gU3Rhc2ggaXQgaW4gYSBsYXppbHktY3JlYXRlZCBtYXAgb2ZcbiAgLy8gcXVldWUgLT4gbGlua2VkIGxpc3Qgb2YgdXBkYXRlcy4gQWZ0ZXIgdGhpcyByZW5kZXIgcGFzcywgd2UnbGwgcmVzdGFydFxuICAvLyBhbmQgYXBwbHkgdGhlIHN0YXNoZWQgdXBkYXRlcyBvbiB0b3Agb2YgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHRydWU7XG4gIHZhciBwZW5kaW5nID0gcXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gIH1cblxuICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xufSAvLyBUT0RPOiBNb3ZlIHRvIFJlYWN0RmliZXJDb25jdXJyZW50VXBkYXRlcz9cblxuXG5mdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCwgcXVldWUsIGxhbmUpIHtcbiAgaWYgKGlzVHJhbnNpdGlvbkxhbmUobGFuZSkpIHtcbiAgICB2YXIgcXVldWVMYW5lcyA9IHF1ZXVlLmxhbmVzOyAvLyBJZiBhbnkgZW50YW5nbGVkIGxhbmVzIGFyZSBubyBsb25nZXIgcGVuZGluZyBvbiB0aGUgcm9vdCwgdGhlbiB0aGV5XG4gICAgLy8gbXVzdCBoYXZlIGZpbmlzaGVkLiBXZSBjYW4gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc2hhcmVkIHF1ZXVlLCB3aGljaFxuICAgIC8vIHJlcHJlc2VudHMgYSBzdXBlcnNldCBvZiB0aGUgYWN0dWFsbHkgcGVuZGluZyBsYW5lcy4gSW4gc29tZSBjYXNlcyB3ZVxuICAgIC8vIG1heSBlbnRhbmdsZSBtb3JlIHRoYW4gd2UgbmVlZCB0bywgYnV0IHRoYXQncyBPSy4gSW4gZmFjdCBpdCdzIHdvcnNlIGlmXG4gICAgLy8gd2UgKmRvbid0KiBlbnRhbmdsZSB3aGVuIHdlIHNob3VsZC5cblxuICAgIHF1ZXVlTGFuZXMgPSBpbnRlcnNlY3RMYW5lcyhxdWV1ZUxhbmVzLCByb290LnBlbmRpbmdMYW5lcyk7IC8vIEVudGFuZ2xlIHRoZSBuZXcgdHJhbnNpdGlvbiBsYW5lIHdpdGggdGhlIG90aGVyIHRyYW5zaXRpb24gbGFuZXMuXG5cbiAgICB2YXIgbmV3UXVldWVMYW5lcyA9IG1lcmdlTGFuZXMocXVldWVMYW5lcywgbGFuZSk7XG4gICAgcXVldWUubGFuZXMgPSBuZXdRdWV1ZUxhbmVzOyAvLyBFdmVuIGlmIHF1ZXVlLmxhbmVzIGFscmVhZHkgaW5jbHVkZSBsYW5lLCB3ZSBkb24ndCBrbm93IGZvciBjZXJ0YWluIGlmXG4gICAgLy8gdGhlIGxhbmUgZmluaXNoZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBlbnRhbmdsZWQgaXQuIFNvIHdlIG5lZWQgdG9cbiAgICAvLyBlbnRhbmdsZSBpdCBhZ2FpbiwganVzdCB0byBiZSBzdXJlLlxuXG4gICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbmV3UXVldWVMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1VwZGF0ZUluRGV2VG9vbHMoZmliZXIsIGxhbmUsIGFjdGlvbikge1xuXG4gIHtcbiAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICB9XG59XG5cbnZhciBDb250ZXh0T25seURpc3BhdGNoZXIgPSB7XG4gIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlOiB1c2UsXG4gIHVzZUNhbGxiYWNrOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUNvbnRleHQ6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTGF5b3V0RWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VNZW1vOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZHVjZXI6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlUmVmOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN0YXRlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlYnVnVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRGVmZXJyZWRWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VUcmFuc2l0aW9uOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUlkOiB0aHJvd0ludmFsaWRIb29rRXJyb3Jcbn07XG5cbntcbiAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUNhY2hlUmVmcmVzaCA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbn1cblxue1xuICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlTWVtb0NhY2hlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xufVxuXG57XG4gIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUZvcm1TdGF0ZSA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUFjdGlvblN0YXRlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xufVxuXG57XG4gIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VPcHRpbWlzdGljID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xufVxuXG52YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsO1xudmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsO1xudmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcblxue1xuICB2YXIgd2FybkludmFsaWRDb250ZXh0QWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgfTtcblxuICB2YXIgd2FybkludmFsaWRIb29rQWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuICcgKyAnWW91IGNhbiBvbmx5IGNhbGwgSG9va3MgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIFJlYWN0IGZ1bmN0aW9uLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgJyArICdodHRwczovL3JlYWN0LmRldi9saW5rL3J1bGVzLW9mLWhvb2tzJyk7XG4gIH07XG5cbiAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlOiB1c2UsXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudElkKCk7XG4gICAgfVxuICB9O1xuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlQ2FjaGVSZWZyZXNoID0gZnVuY3Rpb24gdXNlQ2FjaGVSZWZyZXNoKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FjaGVSZWZyZXNoJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuXG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIHVzZUZvcm1TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VGb3JtU3RhdGUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuXG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gdXNlQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQWN0aW9uU3RhdGUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gdXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3B0aW1pc3RpYyc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50T3B0aW1pc3RpYyhwYXNzdGhyb3VnaCk7XG4gICAgfTtcbiAgfVxuXG4gIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2U6IHVzZSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICB9XG4gIH07XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlQ2FjaGVSZWZyZXNoID0gZnVuY3Rpb24gdXNlQ2FjaGVSZWZyZXNoKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FjaGVSZWZyZXNoJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmcmVzaCgpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuXG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiB1c2VGb3JtU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRm9ybVN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgd2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuXG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIHVzZUFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUFjdGlvblN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gdXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3B0aW1pc3RpYyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgIH07XG4gIH1cblxuICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlOiB1c2UsXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSWQoKTtcbiAgICB9XG4gIH07XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlQ2FjaGVSZWZyZXNoID0gZnVuY3Rpb24gdXNlQ2FjaGVSZWZyZXNoKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FjaGVSZWZyZXNoJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZnJlc2goKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcblxuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gdXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUZvcm1TdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuXG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIHVzZUFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUFjdGlvblN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiB1c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcHRpbWlzdGljJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gIH1cblxuICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2U6IHVzZSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUlkKCk7XG4gICAgfVxuICB9O1xuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlQ2FjaGVSZWZyZXNoID0gZnVuY3Rpb24gdXNlQ2FjaGVSZWZyZXNoKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FjaGVSZWZyZXNoJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZnJlc2goKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG5cbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gdXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUZvcm1TdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG5cbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VBY3Rpb25TdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIHVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wdGltaXN0aWMnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICB9XG5cbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiB1c2UodXNhYmxlKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgIH1cbiAgfTtcblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VDYWNoZVJlZnJlc2ggPSBmdW5jdGlvbiB1c2VDYWNoZVJlZnJlc2goKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWNoZVJlZnJlc2gnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZnJlc2goKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlTWVtb0NhY2hlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgcmV0dXJuIHVzZU1lbW9DYWNoZShzaXplKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcblxuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gdXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUZvcm1TdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcblxuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VBY3Rpb25TdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiB1c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcHRpbWlzdGljJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgIH07XG4gIH1cblxuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiB1c2UodXNhYmxlKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUlkKCk7XG4gICAgfVxuICB9O1xuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VDYWNoZVJlZnJlc2ggPSBmdW5jdGlvbiB1c2VDYWNoZVJlZnJlc2goKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWNoZVJlZnJlc2gnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmcmVzaCgpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlTWVtb0NhY2hlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgcmV0dXJuIHVzZU1lbW9DYWNoZShzaXplKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG5cbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiB1c2VGb3JtU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRm9ybVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuXG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VBY3Rpb25TdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gdXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3B0aW1pc3RpYyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gIH1cblxuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2U6IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgcmV0dXJuIHVzZSh1c2FibGUpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH1cbiAgfTtcblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VDYWNoZVJlZnJlc2ggPSBmdW5jdGlvbiB1c2VDYWNoZVJlZnJlc2goKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWNoZVJlZnJlc2gnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmcmVzaCgpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VNZW1vQ2FjaGUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICByZXR1cm4gdXNlTWVtb0NhY2hlKHNpemUpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuXG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiB1c2VGb3JtU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRm9ybVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG5cbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gdXNlQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQWN0aW9uU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiB1c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcHRpbWlzdGljJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBub3cgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93O1xudmFyIGNvbW1pdFRpbWUgPSAwO1xudmFyIGxheW91dEVmZmVjdFN0YXJ0VGltZSA9IC0xO1xudmFyIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG52YXIgcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZSA9IC0xO1xuLyoqXG4gKiBUcmFja3Mgd2hldGhlciB0aGUgY3VycmVudCB1cGRhdGUgd2FzIGEgbmVzdGVkL2Nhc2NhZGluZyB1cGRhdGUgKHNjaGVkdWxlZCBmcm9tIGEgbGF5b3V0IGVmZmVjdCkuXG4gKlxuICogVGhlIG92ZXJhbGwgc2VxdWVuY2UgaXM6XG4gKiAgIDEuIHJlbmRlclxuICogICAyLiBjb21taXQgKGFuZCBjYWxsIGBvblJlbmRlcmAsIGBvbkNvbW1pdGApXG4gKiAgIDMuIGNoZWNrIGZvciBuZXN0ZWQgdXBkYXRlc1xuICogICA0LiBmbHVzaCBwYXNzaXZlIGVmZmVjdHMgKGFuZCBjYWxsIGBvblBvc3RDb21taXRgKVxuICpcbiAqIE5lc3RlZCB1cGRhdGVzIGFyZSBpZGVudGlmaWVkIGluIHN0ZXAgMyBhYm92ZSxcbiAqIGJ1dCBzdGVwIDQgc3RpbGwgYXBwbGllcyB0byB0aGUgd29yayB0aGF0IHdhcyBqdXN0IGNvbW1pdHRlZC5cbiAqIFdlIHVzZSB0d28gZmxhZ3MgdG8gdHJhY2sgbmVzdGVkIHVwZGF0ZXMgdGhlbjpcbiAqIG9uZSB0cmFja3Mgd2hldGhlciB0aGUgdXBjb21pbmcgdXBkYXRlIGlzIGEgbmVzdGVkIHVwZGF0ZSxcbiAqIGFuZCB0aGUgb3RoZXIgdHJhY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgdXBkYXRlIHdhcyBhIG5lc3RlZCB1cGRhdGUuXG4gKiBUaGUgZmlyc3QgdmFsdWUgZ2V0cyBzeW5jZWQgdG8gdGhlIHNlY29uZCBhdCB0aGUgc3RhcnQgb2YgdGhlIHJlbmRlciBwaGFzZS5cbiAqL1xuXG52YXIgY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gZmFsc2U7XG52YXIgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGlzQ3VycmVudFVwZGF0ZU5lc3RlZCgpIHtcbiAgcmV0dXJuIGN1cnJlbnRVcGRhdGVJc05lc3RlZDtcbn1cblxuZnVuY3Rpb24gbWFya05lc3RlZFVwZGF0ZVNjaGVkdWxlZCgpIHtcbiAge1xuICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXROZXN0ZWRVcGRhdGVGbGFnKCkge1xuICB7XG4gICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gZmFsc2U7XG4gICAgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3luY05lc3RlZFVwZGF0ZUZsYWcoKSB7XG4gIHtcbiAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQ7XG4gICAgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29tbWl0VGltZSgpIHtcbiAgcmV0dXJuIGNvbW1pdFRpbWU7XG59XG5cbmZ1bmN0aW9uIHJlY29yZENvbW1pdFRpbWUoKSB7XG5cbiAgY29tbWl0VGltZSA9IG5vdygpO1xufVxuXG5mdW5jdGlvbiBzdGFydFByb2ZpbGVyVGltZXIoZmliZXIpIHtcblxuICBwcm9maWxlclN0YXJ0VGltZSA9IG5vdygpO1xuXG4gIGlmIChmaWJlci5hY3R1YWxTdGFydFRpbWUgPCAwKSB7XG4gICAgZmliZXIuYWN0dWFsU3RhcnRUaW1lID0gbm93KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoZmliZXIpIHtcblxuICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGZpYmVyLCBvdmVycmlkZUJhc2VUaW1lKSB7XG5cbiAgaWYgKHByb2ZpbGVyU3RhcnRUaW1lID49IDApIHtcbiAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3coKSAtIHByb2ZpbGVyU3RhcnRUaW1lO1xuICAgIGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuXG4gICAgaWYgKG92ZXJyaWRlQmFzZVRpbWUpIHtcbiAgICAgIGZpYmVyLnNlbGZCYXNlRHVyYXRpb24gPSBlbGFwc2VkVGltZTtcbiAgICB9XG5cbiAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpYmVyKSB7XG5cbiAgaWYgKGxheW91dEVmZmVjdFN0YXJ0VGltZSA+PSAwKSB7XG4gICAgdmFyIGVsYXBzZWRUaW1lID0gbm93KCkgLSBsYXlvdXRFZmZlY3RTdGFydFRpbWU7XG4gICAgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gLTE7IC8vIFN0b3JlIGR1cmF0aW9uIG9uIHRoZSBuZXh0IG5lYXJlc3QgUHJvZmlsZXIgYW5jZXN0b3JcbiAgICAvLyBPciB0aGUgcm9vdCAoZm9yIHRoZSBEZXZUb29scyBQcm9maWxlciB0byByZWFkKVxuXG4gICAgdmFyIHBhcmVudEZpYmVyID0gZmliZXIucmV0dXJuO1xuXG4gICAgd2hpbGUgKHBhcmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHZhciByb290ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIHJvb3QuZWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGZpYmVyKSB7XG5cbiAgaWYgKHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdygpIC0gcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZTtcbiAgICBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lID0gLTE7IC8vIFN0b3JlIGR1cmF0aW9uIG9uIHRoZSBuZXh0IG5lYXJlc3QgUHJvZmlsZXIgYW5jZXN0b3JcbiAgICAvLyBPciB0aGUgcm9vdCAoZm9yIHRoZSBEZXZUb29scyBQcm9maWxlciB0byByZWFkKVxuXG4gICAgdmFyIHBhcmVudEZpYmVyID0gZmliZXIucmV0dXJuO1xuXG4gICAgd2hpbGUgKHBhcmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHZhciByb290ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAocGFyZW50U3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEZXRhY2hlZCBmaWJlcnMgaGF2ZSB0aGVpciBzdGF0ZSBub2RlIGNsZWFyZWQgb3V0LlxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB0aGUgcmV0dXJuIHBvaW50ZXIgaXMgYWxzbyBjbGVhcmVkIG91dCxcbiAgICAgICAgICAgIC8vIHNvIHdlIHdvbid0IGJlIGFibGUgdG8gcmVwb3J0IHRoZSB0aW1lIHNwZW50IGluIHRoaXMgUHJvZmlsZXIncyBzdWJ0cmVlLlxuICAgICAgICAgICAgcGFyZW50U3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIucmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydExheW91dEVmZmVjdFRpbWVyKCkge1xuXG4gIGxheW91dEVmZmVjdFN0YXJ0VGltZSA9IG5vdygpO1xufVxuXG5mdW5jdGlvbiBzdGFydFBhc3NpdmVFZmZlY3RUaW1lcigpIHtcblxuICBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lID0gbm93KCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24oZmliZXIpIHtcbiAgLy8gVHJhbnNmZXIgdGltZSBzcGVudCByZW5kZXJpbmcgdGhlc2UgY2hpbGRyZW4gc28gd2UgZG9uJ3QgbG9zZSBpdFxuICAvLyBhZnRlciB3ZSByZXJlbmRlci4gVGhpcyBpcyB1c2VkIGFzIGEgaGVscGVyIGluIHNwZWNpYWwgY2FzZXNcbiAgLy8gd2hlcmUgd2Ugc2hvdWxkIGNvdW50IHRoZSB3b3JrIG9mIG11bHRpcGxlIHBhc3Nlcy5cbiAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dIGFkZGl0aW9uIHdpdGggcG9zc2libGUgbnVsbC91bmRlZmluZWQgdmFsdWVcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn1cblxudmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307XG52YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGU7XG52YXIgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGU7XG52YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlO1xudmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjaztcblxue1xuICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTsgLy8gVGhpcyBpcyBzbyBncm9zcyBidXQgaXQncyBhdCBsZWFzdCBub24tY3JpdGljYWwgYW5kIGNhbiBiZSByZW1vdmVkIGlmXG4gIC8vIGl0IGNhdXNlcyBwcm9ibGVtcy4gVGhpcyBpcyBtZWFudCB0byBnaXZlIGEgbmljZXIgZXJyb3IgbWVzc2FnZSBmb3JcbiAgLy8gUmVhY3RET00xNS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihyZWFjdERPTTE2Q29tcG9uZW50LFxuICAvLyAuLi4pKSB3aGljaCBvdGhlcndpc2UgdGhyb3dzIGEgXCJfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYSBmdW5jdGlvblwiXG4gIC8vIGV4Y2VwdGlvbi5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgJyArICdtZWFucyB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgYW5kIGFyZSBhdHRlbXB0aW5nIHRvIG5lc3QgJyArICdhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyAnICsgXCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkLiBUcnkgXCIgKyAndG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggJyArICd0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAge1xuICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIga2V5ID0gU3RyaW5nKGNhbGxiYWNrKTtcblxuICAgIGlmICghZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmhhcyhrZXkpKSB7XG4gICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSk7XG5cbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUodHlwZSwgcGFydGlhbFN0YXRlKSB7XG4gIHtcbiAgICBpZiAocGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV4dFByb3BzKSB7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcblxuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUoY3RvciwgcGFydGlhbFN0YXRlKTtcbiAgfSAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuXG5cbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG1lbW9pemVkU3RhdGU7IC8vIE9uY2UgdGhlIHVwZGF0ZSBxdWV1ZSBpcyBlbXB0eSwgcGVyc2lzdCB0aGUgZGVyaXZlZCBzdGF0ZSBvbnRvIHRoZVxuICAvLyBiYXNlIHN0YXRlLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIFF1ZXVlIGlzIGFsd2F5cyBub24tbnVsbCBmb3IgY2xhc3Nlc1xuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgIHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IG1lbW9pemVkU3RhdGU7XG4gIH1cbn1cblxudmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgbGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9LFxuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIHZhciByb290ID0gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBsYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gIH0sXG4gIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgbGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY3Rvciwgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgICB7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJbnZva2UgdGhlIGZ1bmN0aW9uIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yKCclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQpIHtcbiAgICByZXR1cm4gIXNoYWxsb3dFcXVhbChvbGRQcm9wcywgbmV3UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG4gICAgdmFyIHJlbmRlclByZXNlbnQgPSBpbnN0YW5jZS5yZW5kZXI7XG5cbiAgICBpZiAoIXJlbmRlclByZXNlbnQpIHtcbiAgICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiB0eXBlb2YgY3Rvci5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSAlcyAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlICYmICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgIWluc3RhbmNlLnN0YXRlKSB7XG4gICAgICBlcnJvcignZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiYgIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wVHlwZXMpIHtcbiAgICAgIGVycm9yKCdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuY29udGV4dFR5cGUpIHtcbiAgICAgIGVycm9yKCdjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGN0b3IuY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJyVzIHVzZXMgdGhlIGxlZ2FjeSBjaGlsZENvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuICcgKyAnVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3Rvci5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJyVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiAnICsgJ1VzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgd2l0aCBzdGF0aWMgY29udGV4dFR5cGUgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQSBwdXJlIGNvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgKyAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSBuZXdQcm9wcztcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gdW5kZWZpbmVkICYmIGhhc011dGF0ZWRQcm9wcykge1xuICAgICAgZXJyb3IoJ1doZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyBcInVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZGVmYXVsdFByb3BzKSB7XG4gICAgICBlcnJvcignU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICFkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKGN0b3IpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKGN0b3IpO1xuXG4gICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gJyArICdUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gICAgaWYgKHN0YXRlICYmICh0eXBlb2Ygc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoc3RhdGUpKSkge1xuICAgICAgZXJyb3IoJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHByb3BzKSB7XG4gIHZhciBjb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIHtcbiAgICBpZiAoJ2NvbnRleHRUeXBlJyBpbiBjdG9yKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IC8vIEFsbG93IG51bGwgZm9yIGNvbmRpdGlvbmFsIGRlY2xhcmF0aW9uXG4gICAgICBjb250ZXh0VHlwZSA9PT0gbnVsbCB8fCBjb250ZXh0VHlwZSAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG5cbiAgICAgIGlmICghaXNWYWxpZCAmJiAhZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmhhcyhjdG9yKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKGN0b3IpO1xuICAgICAgICB2YXIgYWRkZW5kdW0gPSAnJztcblxuICAgICAgICBpZiAoY29udGV4dFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiAnICsgJ1RoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuICcgKyAnVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gJyArICd0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhICcgKyB0eXBlb2YgY29udGV4dFR5cGUgKyAnLic7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEUpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTsgLy8gSW5zdGFudGlhdGUgdHdpY2UgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGUgIT09IG51bGwgJiYgaW5zdGFuY2Uuc3RhdGUgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIFRoZSBpbnN0YW5jZSBuZWVkcyBhY2Nlc3MgdG8gdGhlIGZpYmVyIHNvIHRoYXQgaXQgY2FuIHNjaGVkdWxlIHVwZGF0ZXNcblxuICBzZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICB7XG4gICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cblxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgICB2YXIgbmV3QXBpTmFtZSA9IHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKScgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBlcnJvcignVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJyArICclcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuJyArICdUaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG4nICsgJ2h0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzJywgX2NvbXBvbmVudE5hbWUsIG5ld0FwaU5hbWUsIGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbE1vdW50TmFtZSA6ICcnLCBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA6ICcnLCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsVXBkYXRlTmFtZSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gIH1cblxuICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgfVxufSAvLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG5cblxuZnVuY3Rpb24gbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIGluc3RhbmNlLnJlZnMgPSB7fTtcbiAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IG5ld1Byb3BzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSAnICsgXCJiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBcIiArICdJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICB9XG5cbiAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBuZXdQcm9wcyk7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9IC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuXG5cbiAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpOyAvLyBJZiB3ZSBoYWQgYWRkaXRpb25hbCBzdGF0ZSB1cGRhdGVzIGR1cmluZyB0aGlzIGxpZmUtY3ljbGUsIGxldCdzXG4gICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cblxuICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJMYW5lcyk7XG4gICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGUgfCBMYXlvdXRTdGF0aWM7XG4gIH1cblxuICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIHVucmVzb2x2ZWRPbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIHZhciBvbGRQcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKGN0b3IsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgbmV4dENvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7IC8vIFdoZW4gY29tcGFyaW5nIHdoZXRoZXIgcHJvcHMgY2hhbmdlZCwgd2Ugc2hvdWxkIGNvbXBhcmUgdXNpbmcgdGhlXG4gIC8vIHVucmVzb2x2ZWQgcHJvcHMgb2JqZWN0IHRoYXQgaXMgc3RvcmVkIG9uIHRoZSBmaWJlciwgcmF0aGVyIHRoYW4gdGhlXG4gIC8vIG9uZSB0aGF0IGdldHMgYXNzaWduZWQgdG8gdGhlIGluc3RhbmNlLCBiZWNhdXNlIHRoYXQgb2JqZWN0IG1heSBoYXZlIGJlZW5cbiAgLy8gY2xvbmVkIHRvIHJlc29sdmUgZGVmYXVsdCBwcm9wcyBhbmQvb3IgcmVtb3ZlIGByZWZgLlxuXG4gIHZhciB1bnJlc29sdmVkTmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBkaWRSZWNlaXZlTmV3UHJvcHMgPSB1bnJlc29sdmVkTmV3UHJvcHMgIT09IHVucmVzb2x2ZWRPbGRQcm9wczsgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAoZGlkUmVjZWl2ZU5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKCFkaWRSZWNlaXZlTmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZSB8IExheW91dFN0YXRpYztcbiAgICB9XG5cbiAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gTW91bnRMYXlvdXREZXY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBuZXdQcm9wcyk7XG4gICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSB8fCBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY3Rvciwgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGUgfCBMYXlvdXRTdGF0aWM7XG4gICAgfVxuXG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZSB8IExheW91dFN0YXRpYztcbiAgICB9XG5cbiAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gTW91bnRMYXlvdXREZXY7XG4gICAgfSAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuXG5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufSAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoY3RvciwgdW5yZXNvbHZlZE9sZFByb3BzKTtcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcbiAgdmFyIHVucmVzb2x2ZWROZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICB2YXIgbmV4dENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJzsgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSB1bnJlc29sdmVkTmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpO1xuICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgbmV3U3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAodW5yZXNvbHZlZE9sZFByb3BzID09PSB1bnJlc29sdmVkTmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgJiYgIShlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uICAgKSkge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpIHx8IC8vIFRPRE86IEluIHNvbWUgY2FzZXMsIHdlJ2xsIGVuZCB1cCBjaGVja2luZyBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkIHR3aWNlLFxuICAvLyBib3RoIGJlZm9yZSBhbmQgYWZ0ZXIgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAgaGFzIGJlZW4gY2FsbGVkLiBOb3QgaWRlYWwsXG4gIC8vIGJ1dCBJJ20gbG9hdGggdG8gcmVmYWN0b3IgdGhpcyBmdW5jdGlvbi4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIG1lbW9pemVkXG4gIC8vIGNvbXBvbmVudHMgc28gaXQncyBub3QgdGhhdCBjb21tb24uXG4gIGVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24gICA7XG5cbiAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgICB9XG4gICAgfSAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgcHJvcHMvc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuXG5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIGJhc2VQcm9wcywgLy8gT25seSByZXNvbHZlIGRlZmF1bHQgcHJvcHMgaWYgdGhpcyBpcyBhIGxhenkgY29tcG9uZW50LiBPdGhlcndpc2UsIHRoZXlcbi8vIHdvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHJlc29sdmVkIGJ5IHRoZSBKU1ggcnVudGltZS5cbi8vIFRPRE86IFdlJ3JlIGdvaW5nIHRvIHJlbW92ZSBkZWZhdWx0IHByb3AgcmVzb2x1dGlvbiBmcm9tIHRoZSBKU1ggcnVudGltZVxuLy8gYW5kIGtlZXAgaXQgb25seSBmb3IgY2xhc3MgY29tcG9uZW50cy4gQXMgcGFydCBvZiB0aGF0IGNoYW5nZSwgd2Ugc2hvdWxkXG4vLyByZW1vdmUgdGhpcyBleHRyYSBjaGVjay5cbmFscmVhZHlSZXNvbHZlZERlZmF1bHRQcm9wcykge1xuICB2YXIgbmV3UHJvcHMgPSBiYXNlUHJvcHM7XG5cbiAge1xuICAgIC8vIFJlbW92ZSByZWYgZnJvbSB0aGUgcHJvcHMgb2JqZWN0LCBpZiBpdCBleGlzdHMuXG4gICAgaWYgKCdyZWYnIGluIGJhc2VQcm9wcykge1xuICAgICAgbmV3UHJvcHMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gYmFzZVByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSAhPT0gJ3JlZicpIHtcbiAgICAgICAgICBuZXdQcm9wc1twcm9wTmFtZV0gPSBiYXNlUHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy5cblxuXG4gIHZhciBkZWZhdWx0UHJvcHMgPSBDb21wb25lbnQuZGVmYXVsdFByb3BzO1xuXG4gIGlmIChkZWZhdWx0UHJvcHMgJiYgKCAvLyBJZiBkaXNhYmxlRGVmYXVsdFByb3BzRXhjZXB0Rm9yQ2xhc3NlcyBpcyB0cnVlLCB3ZSBhbHdheXMgcmVzb2x2ZVxuICAvLyBkZWZhdWx0IHByb3BzIGhlcmUgaW4gdGhlIHJlY29uY2lsZXIsIHJhdGhlciB0aGFuIGluIHRoZSBKU1ggcnVudGltZS5cbiAgZGlzYWJsZURlZmF1bHRQcm9wc0V4Y2VwdEZvckNsYXNzZXMgKSkge1xuICAgIC8vIFdlIG1heSBoYXZlIGFscmVhZHkgY29waWVkIHRoZSBwcm9wcyBvYmplY3QgYWJvdmUgdG8gcmVtb3ZlIHJlZi4gSWYgc28sXG4gICAgLy8gd2UgY2FuIG1vZGlmeSB0aGF0LiBPdGhlcndpc2UsIGNvcHkgdGhlIHByb3BzIG9iamVjdCB3aXRoIE9iamVjdC5hc3NpZ24uXG4gICAgaWYgKG5ld1Byb3BzID09PSBiYXNlUHJvcHMpIHtcbiAgICAgIG5ld1Byb3BzID0gYXNzaWduKHt9LCBuZXdQcm9wcyk7XG4gICAgfSAvLyBUYWtlbiBmcm9tIG9sZCBKU1ggcnVudGltZSwgd2hlcmUgdGhpcyB1c2VkIHRvIGxpdmUuXG5cblxuICAgIGZvciAodmFyIF9wcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChuZXdQcm9wc1tfcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3UHJvcHNbX3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1tfcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdQcm9wcztcbn1cblxudmFyIHJlcG9ydEdsb2JhbEVycm9yID0gdHlwZW9mIHJlcG9ydEVycm9yID09PSAnZnVuY3Rpb24nID8gLy8gSW4gbW9kZXJuIGJyb3dzZXJzLCByZXBvcnRFcnJvciB3aWxsIGRpc3BhdGNoIGFuIGVycm9yIGV2ZW50LFxuLy8gZW11bGF0aW5nIGFuIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3IuXG5yZXBvcnRFcnJvciA6IGZ1bmN0aW9uIChlcnJvcikge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHdpbmRvdy5FcnJvckV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gQnJvd3NlciBQb2x5ZmlsbFxuICAgIHZhciBtZXNzYWdlID0gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICBTdHJpbmcoZXJyb3IubWVzc2FnZSkgOiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICBTdHJpbmcoZXJyb3IpO1xuICAgIHZhciBldmVudCA9IG5ldyB3aW5kb3cuRXJyb3JFdmVudCgnZXJyb3InLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBlcnJvcjogZXJyb3JcbiAgICB9KTtcbiAgICB2YXIgc2hvdWxkTG9nID0gd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgaWYgKCFzaG91bGRMb2cpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgdHlwZW9mIHByb2Nlc3MuZW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIE5vZGUgUG9seWZpbGxcbiAgICBwcm9jZXNzLmVtaXQoJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cblxuICBjb25zb2xlWydlcnJvciddKGVycm9yKTtcbn07XG5cbnZhciBjb21wb25lbnROYW1lID0gbnVsbDtcbnZhciBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGw7XG5mdW5jdGlvbiBkZWZhdWx0T25VbmNhdWdodEVycm9yKGVycm9yLCBlcnJvckluZm8pIHtcbiAgLy8gT3ZlcnJpZGluZyB0aGlzIGNhbiBzaWxlbmNlIHRoZXNlIHdhcm5pbmdzIGUuZy4gZm9yIHRlc3RzLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTMzODRcbiAgLy8gRm9yIHVuY2F1Z2h0IHJvb3QgZXJyb3JzIHdlIHJlcG9ydCB0aGVtIGFzIHVuY2F1Z2h0IHRvIHRoZSBicm93c2VyJ3NcbiAgLy8gb25lcnJvciBjYWxsYmFjay4gVGhpcyB3b24ndCBoYXZlIGNvbXBvbmVudCBzdGFja3MgYW5kIHRoZSBlcnJvciBhZGRlbmR1bS5cbiAgLy8gU28gd2UgYWRkIHRob3NlIGludG8gYSBzZXBhcmF0ZSBjb25zb2xlLndhcm4uXG4gIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKTtcblxuICB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZSA/IFwiQW4gZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDxcIiArIGNvbXBvbmVudE5hbWUgKyBcIj4gY29tcG9uZW50LlwiIDogJ0FuIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHMuJztcbiAgICB2YXIgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnQ29uc2lkZXIgYWRkaW5nIGFuIGVycm9yIGJvdW5kYXJ5IHRvIHlvdXIgdHJlZSB0byBjdXN0b21pemUgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IuXFxuJyArICdWaXNpdCBodHRwczovL3JlYWN0LmRldi9saW5rL2Vycm9yLWJvdW5kYXJpZXMgdG8gbGVhcm4gbW9yZSBhYm91dCBlcnJvciBib3VuZGFyaWVzLic7XG5cbiAgICB7XG4gICAgICAvLyBUaGUgY3VycmVudCBGaWJlciBpcyBkaXNjb25uZWN0ZWQgYXQgdGhpcyBwb2ludCB3aGljaCBtZWFucyB0aGF0IGNvbnNvbGUgcHJpbnRpbmdcbiAgICAgIC8vIGNhbm5vdCBhZGQgYSBjb21wb25lbnQgc3RhY2sgc2luY2UgaXQgdGVybWluYXRlcyBhdCB0aGUgZGVsZXRpb24gbm9kZS4gVGhpcyBpcyBub3RcbiAgICAgIC8vIGEgcHJvYmxlbSBmb3Igb3duZXIgc3RhY2tzIHdoaWNoIGFyZSBub3QgZGlzY29ubmVjdGVkIGJ1dCBmb3IgdGhlIHBhcmVudCBjb21wb25lbnRcbiAgICAgIC8vIHN0YWNrcyB3ZSBuZWVkIHRvIHVzZSB0aGUgc25hcHNob3Qgd2UndmUgcHJldmlvdXNseSBleHRyYWN0ZWQuXG4gICAgICB2YXIgY29tcG9uZW50U3RhY2sgPSBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgIT0gbnVsbCA/IGVycm9ySW5mby5jb21wb25lbnRTdGFjayA6ICcnOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcblxuICAgICAgY29uc29sZVsnd2FybiddKCclc1xcblxcbiVzXFxuJXMnLCBjb21wb25lbnROYW1lTWVzc2FnZSwgZXJyb3JCb3VuZGFyeU1lc3NhZ2UsIGNvbXBvbmVudFN0YWNrKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmF1bHRPbkNhdWdodEVycm9yKGVycm9yJDEsIGVycm9ySW5mbykge1xuICAvLyBPdmVycmlkaW5nIHRoaXMgY2FuIHNpbGVuY2UgdGhlc2Ugd2FybmluZ3MgZS5nLiBmb3IgdGVzdHMuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMzM4NFxuICAvLyBDYXVnaHQgYnkgZXJyb3IgYm91bmRhcnlcbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWUgPyBcIlRoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPFwiICsgY29tcG9uZW50TmFtZSArIFwiPiBjb21wb25lbnQuXCIgOiAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHMuJzsgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdoaWNoIGluY2x1ZGVzIHRoZSBjb21wb25lbnQgc3RhY2tcbiAgICAvLyBpbiBhZGRpdGlvbiB0byB0aGUgZXJyb3IuXG5cbiAgICB2YXIgcmVjcmVhdGVNZXNzYWdlID0gXCJSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCBcIiArIChcInVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsIFwiICsgKGVycm9yQm91bmRhcnlOYW1lIHx8ICdBbm9ueW1vdXMnKSArIFwiLlwiKTtcblxuICAgIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IEZpYmVyIGlzIGRpc2Nvbm5lY3RlZCBhdCB0aGlzIHBvaW50IHdoaWNoIG1lYW5zIHRoYXQgY29uc29sZSBwcmludGluZ1xuICAgICAgLy8gY2Fubm90IGFkZCBhIGNvbXBvbmVudCBzdGFjayBzaW5jZSBpdCB0ZXJtaW5hdGVzIGF0IHRoZSBkZWxldGlvbiBub2RlLiBUaGlzIGlzIG5vdFxuICAgICAgLy8gYSBwcm9ibGVtIGZvciBvd25lciBzdGFja3Mgd2hpY2ggYXJlIG5vdCBkaXNjb25uZWN0ZWQgYnV0IGZvciB0aGUgcGFyZW50IGNvbXBvbmVudFxuICAgICAgLy8gc3RhY2tzIHdlIG5lZWQgdG8gdXNlIHRoZSBzbmFwc2hvdCB3ZSd2ZSBwcmV2aW91c2x5IGV4dHJhY3RlZC5cbiAgICAgIHZhciBjb21wb25lbnRTdGFjayA9IGVycm9ySW5mby5jb21wb25lbnRTdGFjayAhPSBudWxsID8gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrIDogJyc7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuXG4gICAgICBjb25zb2xlWydlcnJvciddKCclb1xcblxcbiVzXFxuXFxuJXNcXG4lcycsIGVycm9yJDEsIGNvbXBvbmVudE5hbWVNZXNzYWdlLCByZWNyZWF0ZU1lc3NhZ2UsIGNvbXBvbmVudFN0YWNrKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IoZXJyb3IsIGVycm9ySW5mbykge1xuICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG59XG5mdW5jdGlvbiBsb2dVbmNhdWdodEVycm9yKHJvb3QsIGVycm9ySW5mbykge1xuICB0cnkge1xuICAgIGlmICh0cnVlKSB7XG4gICAgICBjb21wb25lbnROYW1lID0gZXJyb3JJbmZvLnNvdXJjZSA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZXJyb3JJbmZvLnNvdXJjZSkgOiBudWxsO1xuICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcblxuICAgIGlmICh0cnVlICYmIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAvLyBGb3IgdW5jYXVnaHQgZXJyb3JzIGluc2lkZSBhY3QsIHdlIHRyYWNrIHRoZW0gb24gdGhlIGFjdCBhbmQgdGhlblxuICAgICAgLy8gcmV0aHJvdyB0aGVtIGludG8gdGhlIHRlc3QuXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9uVW5jYXVnaHRFcnJvciA9IHJvb3Qub25VbmNhdWdodEVycm9yO1xuICAgIG9uVW5jYXVnaHRFcnJvcihlcnJvciwge1xuICAgICAgY29tcG9uZW50U3RhY2s6IGVycm9ySW5mby5zdGFja1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgbXVzdCBub3QgdGhyb3csIG9yIFJlYWN0IGludGVybmFsIHN0YXRlIHdpbGwgZ2V0IG1lc3NlZCB1cC5cbiAgICAvLyBJZiBjb25zb2xlLmVycm9yIGlzIG92ZXJyaWRkZW4sIG9yIGxvZ0NhcHR1cmVkRXJyb3IoKSBzaG93cyBhIGRpYWxvZyB0aGF0IHRocm93cyxcbiAgICAvLyB3ZSB3YW50IHRvIHJlcG9ydCB0aGlzIGVycm9yIG91dHNpZGUgb2YgdGhlIG5vcm1hbCBzdGFjayBhcyBhIGxhc3QgcmVzb3J0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTMxODhcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxvZ0NhdWdodEVycm9yKHJvb3QsIGJvdW5kYXJ5LCBlcnJvckluZm8pIHtcbiAgdHJ5IHtcbiAgICBpZiAodHJ1ZSkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGVycm9ySW5mby5zb3VyY2UgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGVycm9ySW5mby5zb3VyY2UpIDogbnVsbDtcbiAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihib3VuZGFyeSk7XG4gICAgfVxuXG4gICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgIHZhciBvbkNhdWdodEVycm9yID0gcm9vdC5vbkNhdWdodEVycm9yO1xuICAgIG9uQ2F1Z2h0RXJyb3IoZXJyb3IsIHtcbiAgICAgIGNvbXBvbmVudFN0YWNrOiBlcnJvckluZm8uc3RhY2ssXG4gICAgICBlcnJvckJvdW5kYXJ5OiBib3VuZGFyeS50YWcgPT09IENsYXNzQ29tcG9uZW50ID8gYm91bmRhcnkuc3RhdGVOb2RlIC8vIFRoaXMgc2hvdWxkIGFsd2F5cyBiZSB0aGUgY2FzZSBhcyBsb25nIGFzIHdlIG9ubHkgaGF2ZSBjbGFzcyBib3VuZGFyaWVzXG4gICAgICA6IG51bGxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRoaXMgbWV0aG9kIG11c3Qgbm90IHRocm93LCBvciBSZWFjdCBpbnRlcm5hbCBzdGF0ZSB3aWxsIGdldCBtZXNzZWQgdXAuXG4gICAgLy8gSWYgY29uc29sZS5lcnJvciBpcyBvdmVycmlkZGVuLCBvciBsb2dDYXB0dXJlZEVycm9yKCkgc2hvd3MgYSBkaWFsb2cgdGhhdCB0aHJvd3MsXG4gICAgLy8gd2Ugd2FudCB0byByZXBvcnQgdGhpcyBlcnJvciBvdXRzaWRlIG9mIHRoZSBub3JtYWwgc3RhY2sgYXMgYSBsYXN0IHJlc29ydC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMTg4XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290LCBlcnJvckluZm8sIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTsgLy8gVW5tb3VudCB0aGUgcm9vdCBieSByZW5kZXJpbmcgbnVsbC5cblxuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTsgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG5cbiAgdXBkYXRlLnBheWxvYWQgPSB7XG4gICAgZWxlbWVudDogbnVsbFxuICB9O1xuXG4gIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJldkZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7IC8vIHNob3VsZCBqdXN0IGJlIHRoZSByb290XG5cbiAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGVycm9ySW5mby5zb3VyY2UpO1xuICAgIGxvZ1VuY2F1Z2h0RXJyb3Iocm9vdCwgZXJyb3JJbmZvKTtcbiAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHByZXZGaWJlcik7XG4gIH07XG5cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZSh1cGRhdGUsIHJvb3QsIGZpYmVyLCBlcnJvckluZm8pIHtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZpYmVyLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGVycm9yJDEgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgICB1cGRhdGUucGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IkMSk7XG4gICAgfTtcblxuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHtcbiAgICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldkZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7IC8vIHNob3VsZCBiZSB0aGUgZXJyb3IgYm91bmRhcnlcblxuICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihlcnJvckluZm8uc291cmNlKTtcbiAgICAgIGxvZ0NhdWdodEVycm9yKHJvb3QsIGZpYmVyLCBlcnJvckluZm8pO1xuICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihwcmV2RmliZXIpO1xuICAgIH07XG4gIH1cblxuICB2YXIgaW5zdCA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICBpZiAoaW5zdCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICRGbG93Rml4TWVbbWlzc2luZy10aGlzLWFubm90XVxuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAge1xuICAgICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2RmliZXIgPSBnZXRDdXJyZW50RmliZXIoKTsgLy8gc2hvdWxkIGJlIHRoZSBlcnJvciBib3VuZGFyeVxuXG4gICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGVycm9ySW5mby5zb3VyY2UpO1xuICAgICAgbG9nQ2F1Z2h0RXJyb3Iocm9vdCwgZmliZXIsIGVycm9ySW5mbyk7XG4gICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHByZXZGaWJlcik7XG5cbiAgICAgIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRvIHByZXNlcnZlIHRoZSBwcmVleGlzdGluZyByZXRyeSBiZWhhdmlvciBvZiBlcnJvciBib3VuZGFyaWVzLFxuICAgICAgICAvLyB3ZSBrZWVwIHRyYWNrIG9mIHdoaWNoIG9uZXMgYWxyZWFkeSBmYWlsZWQgZHVyaW5nIHRoaXMgYmF0Y2guXG4gICAgICAgIC8vIFRoaXMgZ2V0cyByZXNldCBiZWZvcmUgd2UgeWllbGQgYmFjayB0byB0aGUgYnJvd3Nlci5cbiAgICAgICAgLy8gVE9ETzogV2FybiBpbiBzdHJpY3QgbW9kZSBpZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgaXNcbiAgICAgICAgLy8gbm90IGRlZmluZWQuXG4gICAgICAgIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlcnJvciQxID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgdGhpcy5jb21wb25lbnREaWRDYXRjaChlcnJvciQxLCB7XG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBzdGFjayAhPT0gbnVsbCA/IHN0YWNrIDogJydcbiAgICAgIH0pO1xuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gSWYgY29tcG9uZW50RGlkQ2F0Y2ggaXMgdGhlIG9ubHkgZXJyb3IgYm91bmRhcnkgbWV0aG9kIGRlZmluZWQsXG4gICAgICAgICAgLy8gdGhlbiBpdCBuZWVkcyB0byBjYWxsIHNldFN0YXRlIHRvIHJlY292ZXIgZnJvbSBlcnJvcnMuXG4gICAgICAgICAgLy8gSWYgbm8gc3RhdGUgdXBkYXRlIGlzIHNjaGVkdWxlZCB0aGVuIHRoZSBib3VuZGFyeSB3aWxsIHN3YWxsb3cgdGhlIGVycm9yLlxuICAgICAgICAgIGlmICghaW5jbHVkZXNTb21lTGFuZShmaWJlci5sYW5lcywgU3luY0xhbmUpKSB7XG4gICAgICAgICAgICBlcnJvcignJXM6IEVycm9yIGJvdW5kYXJpZXMgc2hvdWxkIGltcGxlbWVudCBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKS4gJyArICdJbiB0aGF0IG1ldGhvZCwgcmV0dXJuIGEgc3RhdGUgdXBkYXRlIHRvIGRpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZSBvciBmYWxsYmFjayBVSS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N1c3BlbnNlQm91bmRhcnlTaG91bGRDYXB0dXJlKHN1c3BlbnNlQm91bmRhcnksIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgcm9vdCwgcm9vdFJlbmRlckxhbmVzKSB7XG4gIC8vIHdpdGggdGhlIG5vcm1hbCBzdXNwZW5kIHBhdGguXG4gIC8vXG4gIC8vIEFmdGVyIHRoaXMgd2UnbGwgdXNlIGEgc2V0IG9mIGhldXJpc3RpY3MgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpc1xuICAvLyByZW5kZXIgcGFzcyB3aWxsIHJ1biB0byBjb21wbGV0aW9uIG9yIHJlc3RhcnQgb3IgXCJzdXNwZW5kXCIgdGhlIGNvbW1pdC5cbiAgLy8gVGhlIGFjdHVhbCBsb2dpYyBmb3IgdGhpcyBpcyBzcHJlYWQgb3V0IGluIGRpZmZlcmVudCBwbGFjZXMuXG4gIC8vXG4gIC8vIFRoaXMgZmlyc3QgcHJpbmNpcGxlIGlzIHRoYXQgaWYgd2UncmUgZ29pbmcgdG8gc3VzcGVuZCB3aGVuIHdlIGNvbXBsZXRlXG4gIC8vIGEgcm9vdCwgdGhlbiB3ZSBzaG91bGQgYWxzbyByZXN0YXJ0IGlmIHdlIGdldCBhbiB1cGRhdGUgb3IgcGluZyB0aGF0XG4gIC8vIG1pZ2h0IHVuc3VzcGVuZCBpdCwgYW5kIHZpY2UgdmVyc2EuIFRoZSBvbmx5IHJlYXNvbiB0byBzdXNwZW5kIGlzXG4gIC8vIGJlY2F1c2UgeW91IHRoaW5rIHlvdSBtaWdodCB3YW50IHRvIHJlc3RhcnQgYmVmb3JlIGNvbW1pdHRpbmcuIEhvd2V2ZXIsXG4gIC8vIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byByZXN0YXJ0IG9ubHkgd2hpbGUgaW4gdGhlIHBlcmlvZCB3ZSdyZSBzdXNwZW5kZWQuXG4gIC8vXG4gIC8vIFJlc3RhcnRpbmcgdG9vIGFnZ3Jlc3NpdmVseSBpcyBhbHNvIG5vdCBnb29kIGJlY2F1c2UgaXQgc3RhcnZlcyBvdXQgYW55XG4gIC8vIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBTbyB3ZSB1c2UgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hlbi5cbiAgLy8gU3VzcGVuc2UgSGV1cmlzdGljc1xuICAvL1xuICAvLyBJZiBub3RoaW5nIHRocmV3IGEgUHJvbWlzZSBvciBhbGwgdGhlIHNhbWUgZmFsbGJhY2tzIGFyZSBhbHJlYWR5IHNob3dpbmcsXG4gIC8vIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LlxuICAvL1xuICAvLyBJZiB0aGlzIGlzIGFuIGluaXRpYWwgcmVuZGVyIG9mIGEgbmV3IHRyZWUgb2YgU3VzcGVuc2UgYm91bmRhcmllcyBhbmRcbiAgLy8gdGhvc2UgdHJpZ2dlciBhIGZhbGxiYWNrLCB0aGVuIGRvbid0IHN1c3BlbmQvcmVzdGFydC4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBjYW4gc2hvdyB0aGUgaW5pdGlhbCBsb2FkaW5nIHN0YXRlIGFzIHF1aWNrbHkgYXMgcG9zc2libGUuXG4gIC8vXG4gIC8vIElmIHdlIGhpdCBhIFwiRGVsYXllZFwiIGNhc2UsIHN1Y2ggYXMgd2hlbiB3ZSdkIHN3aXRjaCBmcm9tIGNvbnRlbnQgYmFjayBpbnRvXG4gIC8vIGEgZmFsbGJhY2ssIHRoZW4gd2Ugc2hvdWxkIGFsd2F5cyBzdXNwZW5kL3Jlc3RhcnQuIFRyYW5zaXRpb25zIGFwcGx5XG4gIC8vIHRvIHRoaXMgY2FzZS4gSWYgbm9uZSBpcyBkZWZpbmVkLCBKTkQgaXMgdXNlZCBpbnN0ZWFkLlxuICAvL1xuICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjayBhbmQgaXQgZ2V0cyBcInJldHJpZWRcIiwgYWxsb3dpbmcgdXMgdG8gc2hvd1xuICAvLyBhbm90aGVyIGxldmVsLCBidXQgdGhlcmUncyBzdGlsbCBhbiBpbm5lciBib3VuZGFyeSB0aGF0IHdvdWxkIHNob3cgYSBmYWxsYmFjayxcbiAgLy8gdGhlbiB3ZSBzdXNwZW5kL3Jlc3RhcnQgZm9yIDUwMG1zIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2Ugc2hvd2VkIGEgZmFsbGJhY2tcbiAgLy8gYW55d2hlcmUgaW4gdGhlIHRyZWUuIFRoaXMgZWZmZWN0aXZlbHkgdGhyb3R0bGVzIHByb2dyZXNzaXZlIGxvYWRpbmcgaW50byBhXG4gIC8vIGNvbnNpc3RlbnQgdHJhaW4gb2YgY29tbWl0cy4gVGhpcyBhbHNvIGdpdmVzIHVzIGFuIG9wcG9ydHVuaXR5IHRvIHJlc3RhcnQgdG9cbiAgLy8gZ2V0IHRvIHRoZSBjb21wbGV0ZWQgc3RhdGUgc2xpZ2h0bHkgZWFybGllci5cbiAgLy9cbiAgLy8gSWYgdGhlcmUncyBhbWJpZ3VpdHkgZHVlIHRvIGJhdGNoaW5nIGl0J3MgcmVzb2x2ZWQgaW4gcHJlZmVyZW5jZSBvZjpcbiAgLy8gMSkgXCJkZWxheWVkXCIsIDIpIFwiaW5pdGlhbCByZW5kZXJcIiwgMykgXCJyZXRyeVwiLlxuICAvL1xuICAvLyBXZSB3YW50IHRvIGVuc3VyZSB0aGF0IGEgXCJidXN5XCIgc3RhdGUgZG9lc24ndCBnZXQgZm9yY2UgY29tbWl0dGVkLiBXZSB3YW50IHRvXG4gIC8vIGVuc3VyZSB0aGF0IG5ldyBpbml0aWFsIGxvYWRpbmcgc3RhdGVzIGNhbiBjb21taXQgYXMgc29vbiBhcyBwb3NzaWJsZS5cblxuXG4gIHN1c3BlbnNlQm91bmRhcnkuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTsgLy8gVE9ETzogSSB0aGluayB3ZSBjYW4gcmVtb3ZlIHRoaXMsIHNpbmNlIHdlIG5vdyB1c2UgYERpZENhcHR1cmVgIGluXG4gIC8vIHRoZSBiZWdpbiBwaGFzZSB0byBwcmV2ZW50IGFuIGVhcmx5IGJhaWxvdXQuXG5cbiAgc3VzcGVuc2VCb3VuZGFyeS5sYW5lcyA9IHJvb3RSZW5kZXJMYW5lcztcbiAgcmV0dXJuIHN1c3BlbnNlQm91bmRhcnk7XG59XG5cbmZ1bmN0aW9uIHRocm93RXhjZXB0aW9uKHJvb3QsIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgdmFsdWUsIHJvb3RSZW5kZXJMYW5lcykge1xuICAvLyBUaGUgc291cmNlIGZpYmVyIGRpZCBub3QgY29tcGxldGUuXG4gIHNvdXJjZUZpYmVyLmZsYWdzIHw9IEluY29tcGxldGU7XG5cbiAge1xuICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHdvcmsgc3RpbGwsIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHVwZGF0ZXJzXG4gICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHdha2VhYmxlLiBUaGUgY29tcG9uZW50IHN1c3BlbmRlZC5cbiAgICAgIHZhciB3YWtlYWJsZSA9IHZhbHVlO1xuXG4gICAgICB7XG4gICAgICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIChkaXNhYmxlTGVnYWN5TW9kZSApKSB7XG4gICAgICAgICAgbWFya0RpZFRocm93V2hpbGVIeWRyYXRpbmdERVYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIHZhciBzdXNwZW5zZUJvdW5kYXJ5ID0gZ2V0U3VzcGVuc2VIYW5kbGVyKCk7XG5cbiAgICAgIGlmIChzdXNwZW5zZUJvdW5kYXJ5ICE9PSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAoc3VzcGVuc2VCb3VuZGFyeS50YWcpIHtcbiAgICAgICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBJZiB0aGlzIHN1c3BlbnNlIGJvdW5kYXJ5IGlzIG5vdCBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjaywgbWFya1xuICAgICAgICAgICAgICAvLyB0aGUgaW4tcHJvZ3Jlc3MgcmVuZGVyIGFzIHN1c3BlbmRlZC4gV2UgdHJ5IHRvIHBlcmZvcm0gdGhpcyBsb2dpY1xuICAgICAgICAgICAgICAvLyBhcyBzb29uIGFzIHNvb24gYXMgcG9zc2libGUgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvIHRoZSB3b3JrXG4gICAgICAgICAgICAgIC8vIGxvb3AgY2FuIGtub3cgdGhpbmdzIGxpa2Ugd2hldGhlciBpdCdzIE9LIHRvIHN3aXRjaCB0byBvdGhlciB0YXNrcyxcbiAgICAgICAgICAgICAgLy8gb3Igd2hldGhlciBpdCBjYW4gd2FpdCBmb3IgZGF0YSB0byByZXNvbHZlIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgICAgICAvLyBUT0RPOiBNb3N0IG9mIHRoZXNlIGNoZWNrcyBhcmUgYWxyZWFkeSBwZXJmb3JtZWQgd2hlbiBlbnRlcmluZyBhXG4gICAgICAgICAgICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJ5LiBXZSBzaG91bGQgdHJhY2sgdGhlIGluZm9ybWF0aW9uIG9uIHRoZSBzdGFjayBzb1xuICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIHRvIHJlY29tcHV0ZSBpdCBvbiBkZW1hbmQuIFRoaXMgd291bGQgYWxzbyBhbGxvdyB1c1xuICAgICAgICAgICAgICAvLyB0byB1bmlmeSB3aXRoIGB1c2VgIHdoaWNoIG5lZWRzIHRvIHBlcmZvcm0gdGhpcyBsb2dpYyBldmVuIHNvb25lcixcbiAgICAgICAgICAgICAgLy8gYmVmb3JlIGB0aHJvd0V4Y2VwdGlvbmAgaXMgY2FsbGVkLlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGdldFNoZWxsQm91bmRhcnkoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgLy8gU3VzcGVuZGVkIGluIHRoZSBcInNoZWxsXCIgb2YgdGhlIGFwcC4gVGhpcyBpcyBhbiB1bmRlc2lyYWJsZVxuICAgICAgICAgICAgICAgICAgLy8gbG9hZGluZyBzdGF0ZS4gV2Ugc2hvdWxkIGF2b2lkIGNvbW1pdHRpbmcgdGhpcyB0cmVlLlxuICAgICAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBzdXNwZW5kZWQgZGVlcGVyIHRoYW4gdGhlIHNoZWxsLCB3ZSBkb24ndCBuZWVkIHRvIGRlbGF5XG4gICAgICAgICAgICAgICAgICAvLyB0aGUgY29tbW1pdC4gSG93ZXZlciwgd2Ugc3RpbGwgY2FsbCByZW5kZXJEaWRTdXNwZW5kIGlmIHRoaXMgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGEgbmV3IGJvdW5kYXJ5LCB0byB0ZWxsIHRoZSB3b3JrIGxvb3AgdGhhdCBhIG5ldyBmYWxsYmFjayBoYXNcbiAgICAgICAgICAgICAgICAgIC8vIGFwcGVhcmVkIGR1cmluZyB0aGlzIHJlbmRlci5cbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoZW9yZXRpY2FsbHkgd2Ugc2hvdWxkIGJlIGFibGUgdG8gZGVsZXRlIHRoaXMgYnJhbmNoLlxuICAgICAgICAgICAgICAgICAgLy8gSXQncyBjdXJyZW50bHkgdXNlZCBmb3IgdHdvIHRoaW5nczogMSkgdG8gdGhyb3R0bGUgdGhlXG4gICAgICAgICAgICAgICAgICAvLyBhcHBlYXJhbmNlIG9mIHN1Y2Nlc3NpdmUgbG9hZGluZyBzdGF0ZXMsIGFuZCAyKSBpblxuICAgICAgICAgICAgICAgICAgLy8gU3VzcGVuc2VMaXN0LCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgY2hpbGRyZW4gaW5jbHVkZSBhbnlcbiAgICAgICAgICAgICAgICAgIC8vIHBlbmRpbmcgZmFsbGJhY2tzLiBGb3IgMSwgd2Ugc2hvdWxkIGFwcGx5IHRocm90dGxpbmcgdG8gYWxsXG4gICAgICAgICAgICAgICAgICAvLyByZXRyaWVzLCBub3QganVzdCBvbmVzIHRoYXQgcmVuZGVyIGFuIGFkZGl0aW9uYWwgZmFsbGJhY2suIEZvclxuICAgICAgICAgICAgICAgICAgLy8gMiwgd2Ugc2hvdWxkIGNoZWNrIHN1YnRyZWVGbGFncyBpbnN0ZWFkLiBUaGVuIHdlIGNhbiBkZWxldGVcbiAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYnJhbmNoLlxuICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBzdXNwZW5zZUJvdW5kYXJ5LmFsdGVybmF0ZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN1c3BlbnNlQm91bmRhcnkuZmxhZ3MgJj0gfkZvcmNlQ2xpZW50UmVuZGVyO1xuICAgICAgICAgICAgICBtYXJrU3VzcGVuc2VCb3VuZGFyeVNob3VsZENhcHR1cmUoc3VzcGVuc2VCb3VuZGFyeSwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCByb290LCByb290UmVuZGVyTGFuZXMpOyAvLyBSZXRyeSBsaXN0ZW5lclxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgZmFsbGJhY2sgZG9lcyBjb21taXQsIHdlIG5lZWQgdG8gYXR0YWNoIGEgZGlmZmVyZW50IHR5cGUgb2ZcbiAgICAgICAgICAgICAgLy8gbGlzdGVuZXIuIFRoaXMgb25lIHNjaGVkdWxlcyBhbiB1cGRhdGUgb24gdGhlIFN1c3BlbnNlIGJvdW5kYXJ5IHRvXG4gICAgICAgICAgICAgIC8vIHR1cm4gdGhlIGZhbGxiYWNrIHN0YXRlIG9mZi5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gU3Rhc2ggdGhlIHdha2VhYmxlIG9uIHRoZSBib3VuZGFyeSBmaWJlciBzbyB3ZSBjYW4gYWNjZXNzIGl0IGluIHRoZVxuICAgICAgICAgICAgICAvLyBjb21taXQgcGhhc2UuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIFdoZW4gdGhlIHdha2VhYmxlIHJlc29sdmVzLCB3ZSdsbCBhdHRlbXB0IHRvIHJlbmRlciB0aGUgYm91bmRhcnlcbiAgICAgICAgICAgICAgLy8gYWdhaW4gKFwicmV0cnlcIikuXG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBTdXNwZW5zZXkgcmVzb3VyY2UuIFdlIGRvIG5vdCBhdHRhY2ggcmV0cnlcbiAgICAgICAgICAgICAgLy8gbGlzdGVuZXJzIHRvIHRoZXNlLCBiZWNhdXNlIHdlIGRvbid0IGFjdHVhbGx5IG5lZWQgdGhlbSBmb3JcbiAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nLiBPbmx5IGZvciBjb21taXR0aW5nLiBJbnN0ZWFkLCBpZiBhIGZhbGxiYWNrIGNvbW1pdHNcbiAgICAgICAgICAgICAgLy8gYW5kIHRoZSBvbmx5IHRoaW5nIHRoYXQgc3VzcGVuZGVkIHdhcyBhIFN1c3BlbnNleSByZXNvdXJjZSwgd2VcbiAgICAgICAgICAgICAgLy8gcmV0cnkgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgIC8vIFRPRE86IFJlZmFjdG9yIHRocm93RXhjZXB0aW9uIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBkbyB0aGlzIHR5cGVcbiAgICAgICAgICAgICAgLy8gY2hlY2suIFRoZSBjYWxsZXIgYWxyZWFkeSBrbm93cyB3aGF0IHRoZSBjYXVzZSB3YXMuXG5cbiAgICAgICAgICAgICAgdmFyIGlzU3VzcGVuc2V5UmVzb3VyY2UgPSB3YWtlYWJsZSA9PT0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlO1xuXG4gICAgICAgICAgICAgIGlmIChpc1N1c3BlbnNleVJlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBTY2hlZHVsZVJldHJ5O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXRyeVF1ZXVlID0gc3VzcGVuc2VCb3VuZGFyeS51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXRyeVF1ZXVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBzdXNwZW5zZUJvdW5kYXJ5LnVwZGF0ZVF1ZXVlID0gbmV3IFNldChbd2FrZWFibGVdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0cnlRdWV1ZS5hZGQod2FrZWFibGUpO1xuICAgICAgICAgICAgICAgIH0gLy8gV2Ugb25seSBhdHRhY2ggcGluZyBsaXN0ZW5lcnMgaW4gY29uY3VycmVudCBtb2RlLiBMZWdhY3lcbiAgICAgICAgICAgICAgICAvLyBTdXNwZW5zZSBhbHdheXMgY29tbWl0cyBmYWxsYmFja3Mgc3luY2hyb25vdXNseSwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICAgICAgLy8gbm8gcGluZ3MuXG5cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1c3BlbnNlQm91bmRhcnkuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcblxuICAgICAgICAgICAgICAgIHZhciBfaXNTdXNwZW5zZXlSZXNvdXJjZSA9IHdha2VhYmxlID09PSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoX2lzU3VzcGVuc2V5UmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgIHN1c3BlbnNlQm91bmRhcnkuZmxhZ3MgfD0gU2NoZWR1bGVSZXRyeTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIG9mZnNjcmVlblF1ZXVlID0gc3VzcGVuc2VCb3VuZGFyeS51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG9mZnNjcmVlblF1ZXVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdPZmZzY3JlZW5RdWV1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJJbnN0YW5jZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgcmV0cnlRdWV1ZTogbmV3IFNldChbd2FrZWFibGVdKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZUJvdW5kYXJ5LnVwZGF0ZVF1ZXVlID0gbmV3T2Zmc2NyZWVuUXVldWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JldHJ5UXVldWUgPSBvZmZzY3JlZW5RdWV1ZS5yZXRyeVF1ZXVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfcmV0cnlRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIG9mZnNjcmVlblF1ZXVlLnJldHJ5UXVldWUgPSBuZXcgU2V0KFt3YWtlYWJsZV0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIF9yZXRyeVF1ZXVlLmFkZCh3YWtlYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBTdXNwZW5zZSBoYW5kbGVyIHRhZyAoXCIgKyBzdXNwZW5zZUJvdW5kYXJ5LnRhZyArIFwiKS4gVGhpcyBcIiArICdpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIGJvdW5kYXJ5IHdhcyBmb3VuZC4gVW5sZXNzIHRoaXMgaXMgYSBzeW5jIHVwZGF0ZSwgdGhpcyBpcyBPSy5cbiAgICAgICAgLy8gV2UgY2FuIHN1c3BlbmQgYW5kIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBJbiBhIGNvbmN1cnJlbnQgcm9vdCwgc3VzcGVuZGluZyB3aXRob3V0IGEgU3VzcGVuc2UgYm91bmRhcnkgaXNcbiAgICAgICAgICAvLyBhbGxvd2VkLiBJdCB3aWxsIHN1c3BlbmQgaW5kZWZpbml0ZWx5IHdpdGhvdXQgY29tbWl0dGluZy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSBoYXZlIGRpZmZlcmVudCBiZWhhdmlvciBmb3IgZGlzY3JldGUgdXBkYXRlcz8gV2hhdFxuICAgICAgICAgIC8vIGFib3V0IGZsdXNoU3luYz8gTWF5YmUgaXQgc2hvdWxkIHB1dCB0aGUgdHJlZSBpbnRvIGFuIGluZXJ0IHN0YXRlLFxuICAgICAgICAgIC8vIGFuZCBwb3RlbnRpYWxseSBsb2cgYSB3YXJuaW5nLiBSZXZpc2l0IHRoaXMgZm9yIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gVGhpcyBpcyBhIHJlZ3VsYXIgZXJyb3IsIG5vdCBhIFN1c3BlbnNlIHdha2VhYmxlLlxuXG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgKGRpc2FibGVMZWdhY3lNb2RlICkpIHtcbiAgICBtYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFVigpO1xuXG4gICAgdmFyIF9zdXNwZW5zZUJvdW5kYXJ5ID0gZ2V0U3VzcGVuc2VIYW5kbGVyKCk7IC8vIElmIHRoZSBlcnJvciB3YXMgdGhyb3duIGR1cmluZyBoeWRyYXRpb24sIHdlIG1heSBiZSBhYmxlIHRvIHJlY292ZXIgYnlcbiAgICAvLyBkaXNjYXJkaW5nIHRoZSBkZWh5ZHJhdGVkIGNvbnRlbnQgYW5kIHN3aXRjaGluZyB0byBhIGNsaWVudCByZW5kZXIuXG4gICAgLy8gSW5zdGVhZCBvZiBzdXJmYWNpbmcgdGhlIGVycm9yLCBmaW5kIHRoZSBuZWFyZXN0IFN1c3BlbnNlIGJvdW5kYXJ5XG4gICAgLy8gYW5kIHJlbmRlciBpdCBhZ2FpbiB3aXRob3V0IGh5ZHJhdGlvbi5cblxuXG4gICAgaWYgKF9zdXNwZW5zZUJvdW5kYXJ5ICE9PSBudWxsKSB7XG4gICAgICBpZiAoKF9zdXNwZW5zZUJvdW5kYXJ5LmZsYWdzICYgU2hvdWxkQ2FwdHVyZSkgPT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAvLyBTZXQgYSBmbGFnIHRvIGluZGljYXRlIHRoYXQgd2Ugc2hvdWxkIHRyeSByZW5kZXJpbmcgdGhlIG5vcm1hbFxuICAgICAgICAvLyBjaGlsZHJlbiBhZ2Fpbiwgbm90IHRoZSBmYWxsYmFjay5cbiAgICAgICAgX3N1c3BlbnNlQm91bmRhcnkuZmxhZ3MgfD0gRm9yY2VDbGllbnRSZW5kZXI7XG4gICAgICB9XG5cbiAgICAgIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShfc3VzcGVuc2VCb3VuZGFyeSwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCByb290LCByb290UmVuZGVyTGFuZXMpOyAvLyBFdmVuIHRob3VnaCB0aGUgdXNlciBtYXkgbm90IGJlIGFmZmVjdGVkIGJ5IHRoaXMgZXJyb3IsIHdlIHNob3VsZFxuICAgICAgLy8gc3RpbGwgbG9nIGl0IHNvIGl0IGNhbiBiZSBmaXhlZC5cblxuICAgICAgaWYgKHZhbHVlICE9PSBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbikge1xuICAgICAgICB2YXIgX3dyYXBwZXJFcnJvciA9IG5ldyBFcnJvcignVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGh5ZHJhdGluZyBidXQgUmVhY3Qgd2FzIGFibGUgdG8gcmVjb3ZlciBieSAnICsgJ2luc3RlYWQgY2xpZW50IHJlbmRlcmluZyBmcm9tIHRoZSBuZWFyZXN0IFN1c3BlbnNlIGJvdW5kYXJ5LicsIHtcbiAgICAgICAgICBjYXVzZTogdmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihfd3JhcHBlckVycm9yLCBzb3VyY2VGaWJlcikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24pIHtcbiAgICAgICAgdmFyIF93cmFwcGVyRXJyb3IyID0gbmV3IEVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIGJ1dCBSZWFjdCB3YXMgYWJsZSB0byByZWNvdmVyIGJ5ICcgKyAnaW5zdGVhZCBjbGllbnQgcmVuZGVyaW5nIHRoZSBlbnRpcmUgcm9vdC4nLCB7XG4gICAgICAgICAgY2F1c2U6IHZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IoY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoX3dyYXBwZXJFcnJvcjIsIHNvdXJjZUZpYmVyKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfd29ya0luUHJvZ3Jlc3MgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlOyAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgYXQgdGhlIHJvb3QgdG8gbG9nIHRoZSBlcnJvciBidXQgdGhpcyBzaG91bGRuJ3RcbiAgICAgIC8vIGFjdHVhbGx5IGhhcHBlbiBiZWNhdXNlIHdlIHNob3VsZCByZWNvdmVyLlxuXG4gICAgICBfd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICAgIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUocm9vdFJlbmRlckxhbmVzKTtcbiAgICAgIF93b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMoX3dvcmtJblByb2dyZXNzLmxhbmVzLCBsYW5lKTtcbiAgICAgIHZhciByb290RXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUoX3dvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgcm9vdEVycm9ySW5mbywgLy8gVGhpcyBzaG91bGQgbmV2ZXIgYWN0dWFsbHkgZ2V0IGxvZ2dlZCBkdWUgdG8gdGhlIHJlY292ZXJ5LlxuICAgICAgbGFuZSk7XG4gICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUoX3dvcmtJblByb2dyZXNzLCB1cGRhdGUpO1xuICAgICAgcmVuZGVyRGlkRXJyb3IoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgd3JhcHBlckVycm9yID0gbmV3IEVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3IgZHVyaW5nIGNvbmN1cnJlbnQgcmVuZGVyaW5nIGJ1dCBSZWFjdCB3YXMgYWJsZSB0byByZWNvdmVyIGJ5ICcgKyAnaW5zdGVhZCBzeW5jaHJvbm91c2x5IHJlbmRlcmluZyB0aGUgZW50aXJlIHJvb3QuJywge1xuICAgIGNhdXNlOiB2YWx1ZVxuICB9KTtcbiAgcXVldWVDb25jdXJyZW50RXJyb3IoY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIod3JhcHBlckVycm9yLCBzb3VyY2VGaWJlcikpO1xuICByZW5kZXJEaWRFcnJvcigpOyAvLyBXZSBkaWRuJ3QgZmluZCBhIGJvdW5kYXJ5IHRoYXQgY291bGQgaGFuZGxlIHRoaXMgdHlwZSBvZiBleGNlcHRpb24uIFN0YXJ0XG4gIC8vIG92ZXIgYW5kIHRyYXZlcnNlIHBhcmVudCBwYXRoIGFnYWluLCB0aGlzIHRpbWUgdHJlYXRpbmcgdGhlIGV4Y2VwdGlvblxuICAvLyBhcyBhbiBlcnJvci5cblxuICBpZiAocmV0dXJuRmliZXIgPT09IG51bGwpIHtcbiAgICAvLyBUaGVyZSdzIG5vIHJldHVybiBmaWJlciwgd2hpY2ggbWVhbnMgdGhlIHJvb3QgZXJyb3JlZC4gVGhpcyBzaG91bGQgbmV2ZXJcbiAgICAvLyBoYXBwZW4uIFJldHVybiBgdHJ1ZWAgdG8gdHJpZ2dlciBhIGZhdGFsIGVycm9yIChwYW5pYykuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG5cbiAgZG8ge1xuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcblxuICAgICAgICAgIHZhciBfbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJvb3RSZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIF9sYW5lKTtcblxuICAgICAgICAgIHZhciBfdXBkYXRlID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgZXJyb3JJbmZvLCBfbGFuZSk7XG5cbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIF91cGRhdGUpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAvLyBDYXB0dXJlIGFuZCByZXRyeVxuICAgICAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MkMSAmJiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nIHx8IGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcblxuICAgICAgICAgIHZhciBfbGFuZTIgPSBwaWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO1xuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLCBfbGFuZTIpOyAvLyBTY2hlZHVsZSB0aGUgZXJyb3IgYm91bmRhcnkgdG8gcmUtcmVuZGVyIHVzaW5nIHVwZGF0ZWQgc3RhdGVcblxuICAgICAgICAgIHZhciBfdXBkYXRlMiA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoX2xhbmUyKTtcblxuICAgICAgICAgIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKF91cGRhdGUyLCByb290LCB3b3JrSW5Qcm9ncmVzcywgZXJyb3JJbmZvKTtcbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIF91cGRhdGUyKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIHdlIGJhaWwgb3V0IHdoZW4gd2UgZ2V0IGEgbnVsbFxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgfSB3aGlsZSAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpO1xuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gaW50byBhIGRlaHlkcmF0ZWQgYm91bmRhcnkuXG5cbnZhciBTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24gPSBuZXcgRXJyb3IoXCJUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IuIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIFJlYWN0J3MgXCIgKyBcInNlbGVjdGl2ZSBoeWRyYXRpb24gZmVhdHVyZS4gSWYgdGhpcyBsZWFrcyBpbnRvIHVzZXJzcGFjZSwgaXQncyBhIGJ1ZyBpbiBcIiArICdSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG52YXIgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5BYm91dEJhZENsYXNzO1xudmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHM7XG52YXIgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXI7XG52YXIgZGlkV2FybkFib3V0VGFpbE9wdGlvbnM7XG5cbntcbiAgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbiAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbiAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlciA9IHt9O1xuICBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucyA9IHt9O1xufVxuXG5mdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoaXMgaXMgYSBmcmVzaCBuZXcgY29tcG9uZW50IHRoYXQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0LCB3ZVxuICAgIC8vIHdvbid0IHVwZGF0ZSBpdHMgY2hpbGQgc2V0IGJ5IGFwcGx5aW5nIG1pbmltYWwgc2lkZS1lZmZlY3RzLiBJbnN0ZWFkLFxuICAgIC8vIHdlIHdpbGwgYWRkIHRoZW0gYWxsIHRvIHRoZSBjaGlsZCBiZWZvcmUgaXQgZ2V0cyByZW5kZXJlZC4gVGhhdCBtZWFuc1xuICAgIC8vIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIHJlY29uY2lsaWF0aW9uIHBhc3MgYnkgbm90IHRyYWNraW5nIHNpZGUtZWZmZWN0cy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoZSBjdXJyZW50IGNoaWxkIGlzIHRoZSBzYW1lIGFzIHRoZSB3b3JrIGluIHByb2dyZXNzLCBpdCBtZWFucyB0aGF0XG4gICAgLy8gd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCBhbnkgd29yayBvbiB0aGVzZSBjaGlsZHJlbi4gVGhlcmVmb3JlLCB3ZSB1c2VcbiAgICAvLyB0aGUgY2xvbmUgYWxnb3JpdGhtIHRvIGNyZWF0ZSBhIGNvcHkgb2YgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuLlxuICAgIC8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4gICAgLy8gbGV0J3MgdGhyb3cgaXQgb3V0LlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcmNlVW5tb3VudEN1cnJlbnRBbmRSZWNvbmNpbGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBmb3JrIG9mIHJlY29uY2lsZUNoaWxkcmVuLiBJdCdzIHVzZWQgaW4gY2FzZXMgd2hlcmUgd2VcbiAgLy8gd2FudCB0byByZWNvbmNpbGUgd2l0aG91dCBtYXRjaGluZyBhZ2FpbnN0IHRoZSBleGlzdGluZyBzZXQuIFRoaXMgaGFzIHRoZVxuICAvLyBlZmZlY3Qgb2YgYWxsIGN1cnJlbnQgY2hpbGRyZW4gYmVpbmcgdW5tb3VudGVkOyBldmVuIGlmIHRoZSB0eXBlIGFuZCBrZXlcbiAgLy8gYXJlIHRoZSBzYW1lLCB0aGUgb2xkIGNoaWxkIGlzIHVubW91bnRlZCBhbmQgYSBuZXcgY2hpbGQgaXMgY3JlYXRlZC5cbiAgLy9cbiAgLy8gVG8gZG8gdGhpcywgd2UncmUgZ29pbmcgdG8gZ28gdGhyb3VnaCB0aGUgcmVjb25jaWxlIGFsZ29yaXRobSB0d2ljZS4gSW5cbiAgLy8gdGhlIGZpcnN0IHBhc3MsIHdlIHNjaGVkdWxlIGEgZGVsZXRpb24gZm9yIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbiBieVxuICAvLyBwYXNzaW5nIG51bGwuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG51bGwsIHJlbmRlckxhbmVzKTsgLy8gSW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBtb3VudCB0aGUgbmV3IGNoaWxkcmVuLiBUaGUgdHJpY2sgaGVyZSBpcyB0aGF0IHdlXG4gIC8vIHBhc3MgbnVsbCBpbiBwbGFjZSBvZiB3aGVyZSB3ZSB1c3VhbGx5IHBhc3MgdGhlIGN1cnJlbnQgY2hpbGQgc2V0LiBUaGlzIGhhc1xuICAvLyB0aGUgZWZmZWN0IG9mIHJlbW91bnRpbmcgYWxsIGNoaWxkcmVuIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGVpclxuICAvLyBpZGVudGl0aWVzIG1hdGNoLlxuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGb3J3YXJkUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVE9ETzogY3VycmVudCBjYW4gYmUgbm9uLW51bGwgaGVyZSBldmVuIGlmIHRoZSBjb21wb25lbnRcbiAgLy8gaGFzbid0IHlldCBtb3VudGVkLiBUaGlzIGhhcHBlbnMgYWZ0ZXIgdGhlIGZpcnN0IHJlbmRlciBzdXNwZW5kcy5cbiAgLy8gV2UnbGwgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoaXMgaXMgZmluZSBvciBjYW4gY2F1c2UgaXNzdWVzLlxuICB2YXIgcmVuZGVyID0gQ29tcG9uZW50LnJlbmRlcjtcbiAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgdmFyIHByb3BzV2l0aG91dFJlZjtcblxuICBpZiAoJ3JlZicgaW4gbmV4dFByb3BzKSB7XG4gICAgLy8gYHJlZmAgaXMganVzdCBhIHByb3Agbm93LCBidXQgYGZvcndhcmRSZWZgIGV4cGVjdHMgaXQgdG8gbm90IGFwcGVhciBpblxuICAgIC8vIHRoZSBwcm9wcyBvYmplY3QuIFRoaXMgdXNlZCB0byBoYXBwZW4gaW4gdGhlIEpTWCBydW50aW1lLCBidXQgbm93IHdlIGRvXG4gICAgLy8gaXQgaGVyZS5cbiAgICBwcm9wc1dpdGhvdXRSZWYgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIC8vIFNpbmNlIGByZWZgIHNob3VsZCBvbmx5IGFwcGVhciBpbiBwcm9wcyB2aWEgdGhlIEpTWCB0cmFuc2Zvcm0sIHdlIGNhblxuICAgICAgLy8gYXNzdW1lIHRoYXQgdGhpcyBpcyBhIHBsYWluIG9iamVjdC4gU28gd2UgZG9uJ3QgbmVlZCBhXG4gICAgICAvLyBoYXNPd25Qcm9wZXJ0eSBjaGVjay5cbiAgICAgIGlmIChrZXkgIT09ICdyZWYnKSB7XG4gICAgICAgIHByb3BzV2l0aG91dFJlZltrZXldID0gbmV4dFByb3BzW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHByb3BzV2l0aG91dFJlZiA9IG5leHRQcm9wcztcbiAgfSAvLyBUaGUgcmVzdCBpcyBhIGZvcmsgb2YgdXBkYXRlRnVuY3Rpb25Db21wb25lbnRcblxuXG4gIHZhciBuZXh0Q2hpbGRyZW47XG4gIHZhciBoYXNJZDtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAge1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyLCBwcm9wc1dpdGhvdXRSZWYsIHJlZiwgcmVuZGVyTGFuZXMpO1xuICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH1cblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmICFkaWRSZWNlaXZlVXBkYXRlKSB7XG4gICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGhhc0lkKSB7XG4gICAgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHZhciB0eXBlID0gQ29tcG9uZW50LnR5cGU7XG5cbiAgICBpZiAoaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCh0eXBlKSAmJiBDb21wb25lbnQuY29tcGFyZSA9PT0gbnVsbCAmJiAoIC8vIFNpbXBsZU1lbW9Db21wb25lbnQgY29kZXBhdGggZG9lc24ndCByZXNvbHZlIG91dGVyIHByb3BzIGVpdGhlci5cbiAgICBkaXNhYmxlRGVmYXVsdFByb3BzRXhjZXB0Rm9yQ2xhc3NlcyApKSB7XG4gICAgICB2YXIgcmVzb2x2ZWRUeXBlID0gdHlwZTtcblxuICAgICAge1xuICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSk7XG4gICAgICB9IC8vIElmIHRoaXMgaXMgYSBwbGFpbiBmdW5jdGlvbiBjb21wb25lbnQgd2l0aG91dCBkZWZhdWx0IHByb3BzLFxuICAgICAgLy8gYW5kIHdpdGggb25seSB0aGUgZGVmYXVsdCBzaGFsbG93IGNvbXBhcmlzb24sIHdlIHVwZ3JhZGUgaXRcbiAgICAgIC8vIHRvIGEgU2ltcGxlTWVtb0NvbXBvbmVudCB0byBhbGxvdyBmYXN0IHBhdGggdXBkYXRlcy5cblxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBTaW1wbGVNZW1vQ29tcG9uZW50O1xuICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVkVHlwZTtcblxuICAgICAge1xuICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIHR5cGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVzb2x2ZWRUeXBlLCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoQ29tcG9uZW50LnR5cGUsIG51bGwsIG5leHRQcm9wcywgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLm1vZGUsIHJlbmRlckxhbmVzKTtcbiAgICBjaGlsZC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgY2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjaGlsZDtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gY3VycmVudC5jaGlsZDsgLy8gVGhpcyBpcyBhbHdheXMgZXhhY3RseSBvbmUgY2hpbGRcblxuICB2YXIgaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0ID0gY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpO1xuXG4gIGlmICghaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KSB7XG4gICAgLy8gVGhpcyB3aWxsIGJlIHRoZSBwcm9wcyB3aXRoIHJlc29sdmVkIGRlZmF1bHRQcm9wcyxcbiAgICAvLyB1bmxpa2UgY3VycmVudC5tZW1vaXplZFByb3BzIHdoaWNoIHdpbGwgYmUgdGhlIHVucmVzb2x2ZWQgb25lcy5cbiAgICB2YXIgcHJldlByb3BzID0gY3VycmVudENoaWxkLm1lbW9pemVkUHJvcHM7IC8vIERlZmF1bHQgdG8gc2hhbGxvdyBjb21wYXJpc29uXG5cbiAgICB2YXIgY29tcGFyZSA9IENvbXBvbmVudC5jb21wYXJlO1xuICAgIGNvbXBhcmUgPSBjb21wYXJlICE9PSBudWxsID8gY29tcGFyZSA6IHNoYWxsb3dFcXVhbDtcblxuICAgIGlmIChjb21wYXJlKHByZXZQcm9wcywgbmV4dFByb3BzKSAmJiBjdXJyZW50LnJlZiA9PT0gd29ya0luUHJvZ3Jlc3MucmVmKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIG5leHRQcm9wcyk7XG4gIG5ld0NoaWxkLnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG4gIHJldHVybiBuZXdDaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4gIC8vIGhhc24ndCB5ZXQgbW91bnRlZC4gVGhpcyBoYXBwZW5zIHdoZW4gdGhlIGlubmVyIHJlbmRlciBzdXNwZW5kcy5cbiAgLy8gV2UnbGwgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoaXMgaXMgZmluZSBvciBjYW4gY2F1c2UgaXNzdWVzLlxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG5cbiAgICBpZiAoc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgbmV4dFByb3BzKSAmJiBjdXJyZW50LnJlZiA9PT0gd29ya0luUHJvZ3Jlc3MucmVmICYmICggLy8gUHJldmVudCBiYWlsb3V0IGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIGR1ZSB0byBob3QgcmVsb2FkLlxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZSApKSB7XG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7IC8vIFRoZSBwcm9wcyBhcmUgc2hhbGxvd2x5IGVxdWFsLiBSZXVzZSB0aGUgcHJldmlvdXMgcHJvcHMgb2JqZWN0LCBsaWtlIHdlXG4gICAgICAvLyB3b3VsZCBkdXJpbmcgYSBub3JtYWwgZmliZXIgYmFpbG91dC5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBkb24ndCBoYXZlIHN0cm9uZyBndWFyYW50ZWVzIHRoYXQgdGhlIHByb3BzIG9iamVjdCBpcyByZWZlcmVudGlhbGx5XG4gICAgICAvLyBlcXVhbCBkdXJpbmcgdXBkYXRlcyB3aGVyZSB3ZSBjYW4ndCBiYWlsIG91dCBhbnl3YXkg4oCUIGxpa2UgaWYgdGhlIHByb3BzXG4gICAgICAvLyBhcmUgc2hhbGxvd2x5IGVxdWFsLCBidXQgdGhlcmUncyBhIGxvY2FsIHN0YXRlIG9yIGNvbnRleHQgdXBkYXRlIGluIHRoZVxuICAgICAgLy8gc2FtZSBiYXRjaC5cbiAgICAgIC8vXG4gICAgICAvLyBIb3dldmVyLCBhcyBhIHByaW5jaXBsZSwgd2Ugc2hvdWxkIGFpbSB0byBtYWtlIHRoZSBiZWhhdmlvciBjb25zaXN0ZW50XG4gICAgICAvLyBhY3Jvc3MgZGlmZmVyZW50IHdheXMgb2YgbWVtb2l6aW5nIGEgY29tcG9uZW50LiBGb3IgZXhhbXBsZSwgUmVhY3QubWVtb1xuICAgICAgLy8gaGFzIGEgZGlmZmVyZW50IGludGVybmFsIEZpYmVyIGxheW91dCBpZiB5b3UgcGFzcyBhIG5vcm1hbCBmdW5jdGlvblxuICAgICAgLy8gY29tcG9uZW50IChTaW1wbGVNZW1vQ29tcG9uZW50KSB2ZXJzdXMgaWYgeW91IHBhc3MgYSBkaWZmZXJlbnQgdHlwZVxuICAgICAgLy8gbGlrZSBmb3J3YXJkUmVmIChNZW1vQ29tcG9uZW50KS4gQnV0IHRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuICAgICAgLy8gV3JhcHBpbmcgYSBjb21wb25lbnQgaW4gZm9yd2FyZFJlZiAob3IgUmVhY3QubGF6eSwgZXRjKSBzaG91bGRuJ3RcbiAgICAgIC8vIGFmZmVjdCB3aGV0aGVyIHRoZSBwcm9wcyBvYmplY3QgaXMgcmV1c2VkIGR1cmluZyBhIGJhaWxvdXQuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IG5leHRQcm9wcyA9IHByZXZQcm9wcztcblxuICAgICAgaWYgKCFjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykpIHtcbiAgICAgICAgLy8gVGhlIHBlbmRpbmcgbGFuZXMgd2VyZSBjbGVhcmVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgYmVnaW5Xb3JrLiBXZSdyZVxuICAgICAgICAvLyBhYm91dCB0byBiYWlsIG91dCwgYnV0IHRoZXJlIG1pZ2h0IGJlIG90aGVyIGxhbmVzIHRoYXQgd2VyZW4ndFxuICAgICAgICAvLyBpbmNsdWRlZCBpbiB0aGUgY3VycmVudCByZW5kZXIuIFVzdWFsbHksIHRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGVcbiAgICAgICAgLy8gcmVtYWluaW5nIHVwZGF0ZXMgaXMgYWNjdW11bGF0ZWQgZHVyaW5nIHRoZSBldmFsdWF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBjb21wb25lbnQgKGkuZS4gd2hlbiBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUpLiBCdXQgc2luY2Ugc2luY2VcbiAgICAgICAgLy8gd2UncmUgYmFpbGluZyBvdXQgZWFybHkgKndpdGhvdXQqIGV2YWx1YXRpbmcgdGhlIGNvbXBvbmVudCwgd2UgbmVlZFxuICAgICAgICAvLyB0byBhY2NvdW50IGZvciBpdCBoZXJlLCB0b28uIFJlc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBmaWJlci5cbiAgICAgICAgLy8gTk9URTogVGhpcyBvbmx5IGFwcGxpZXMgdG8gU2ltcGxlTWVtb0NvbXBvbmVudCwgbm90IE1lbW9Db21wb25lbnQsXG4gICAgICAgIC8vIGJlY2F1c2UgYSBNZW1vQ29tcG9uZW50IGZpYmVyIGRvZXMgbm90IGhhdmUgaG9va3Mgb3IgYW4gdXBkYXRlIHF1ZXVlO1xuICAgICAgICAvLyByYXRoZXIsIGl0IHdyYXBzIGFyb3VuZCBhbiBpbm5lciBjb21wb25lbnQsIHdoaWNoIG1heSBvciBtYXkgbm90XG4gICAgICAgIC8vIGNvbnRhaW5zIGhvb2tzLlxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoZSByZXNldCBhdCBpbiBiZWdpbldvcmsgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBzbyB0aGF0XG4gICAgICAgIC8vIHRoaXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIGlmICgoY3VycmVudC5mbGFncyAmIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzE5MjE2LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIG5leHRJc0RldGFjaGVkID0gKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5fcGVuZGluZ1Zpc2liaWxpdHkgJiBPZmZzY3JlZW5EZXRhY2hlZCkgIT09IDA7XG4gIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcbiAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgaWYgKG5leHRQcm9wcy5tb2RlID09PSAnaGlkZGVuJyB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IG5leHRJc0RldGFjaGVkKSB7XG4gICAgLy8gUmVuZGVyaW5nIGEgaGlkZGVuIHRyZWUuXG4gICAgdmFyIGRpZFN1c3BlbmQgPSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncyQxO1xuXG4gICAgaWYgKGRpZFN1c3BlbmQpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQgaW5zaWRlIGEgaGlkZGVuIHRyZWVcbiAgICAgIC8vIEluY2x1ZGUgdGhlIGJhc2UgbGFuZXMgZnJvbSB0aGUgbGFzdCByZW5kZXJcbiAgICAgIHZhciBuZXh0QmFzZUxhbmVzID0gcHJldlN0YXRlICE9PSBudWxsID8gbWVyZ2VMYW5lcyhwcmV2U3RhdGUuYmFzZUxhbmVzLCByZW5kZXJMYW5lcykgOiByZW5kZXJMYW5lcztcblxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gUmVzZXQgdG8gdGhlIGN1cnJlbnQgY2hpbGRyZW5cbiAgICAgICAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDsgLy8gVGhlIGN1cnJlbnQgcmVuZGVyIHN1c3BlbmRlZCwgYnV0IHRoZXJlIG1heSBiZSBvdGhlciBsYW5lcyB3aXRoXG4gICAgICAgIC8vIHBlbmRpbmcgd29yay4gV2UgY2FuJ3QgcmVhZCBgY2hpbGRMYW5lc2AgZnJvbSB0aGUgY3VycmVudCBPZmZzY3JlZW5cbiAgICAgICAgLy8gZmliZXIgYmVjYXVzZSB3ZSByZXNldCBpdCB3aGVuIGl0IHdhcyBkZWZlcnJlZDsgaG93ZXZlciwgd2UgY2FuIHJlYWRcbiAgICAgICAgLy8gdGhlIHBlbmRpbmcgbGFuZXMgZnJvbSB0aGUgY2hpbGQgZmliZXJzLlxuXG4gICAgICAgIHZhciBjdXJyZW50Q2hpbGRMYW5lcyA9IE5vTGFuZXM7XG5cbiAgICAgICAgd2hpbGUgKGN1cnJlbnRDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhtZXJnZUxhbmVzKGN1cnJlbnRDaGlsZExhbmVzLCBjdXJyZW50Q2hpbGQubGFuZXMpLCBjdXJyZW50Q2hpbGQuY2hpbGRMYW5lcyk7XG4gICAgICAgICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFuZXNXZUp1c3RBdHRlbXB0ZWQgPSBuZXh0QmFzZUxhbmVzO1xuICAgICAgICB2YXIgcmVtYWluaW5nQ2hpbGRMYW5lcyA9IHJlbW92ZUxhbmVzKGN1cnJlbnRDaGlsZExhbmVzLCBsYW5lc1dlSnVzdEF0dGVtcHRlZCk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSByZW1haW5pbmdDaGlsZExhbmVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0QmFzZUxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpKSB7XG4gICAgICAvLyBXZSdyZSBoaWRkZW4sIGFuZCB3ZSdyZSBub3QgcmVuZGVyaW5nIGF0IE9mZnNjcmVlbi4gV2Ugd2lsbCBiYWlsIG91dFxuICAgICAgLy8gYW5kIHJlc3VtZSB0aGlzIHRyZWUgbGF0ZXIuXG4gICAgICAvLyBTY2hlZHVsZSB0aGlzIGZpYmVyIHRvIHJlLXJlbmRlciBhdCBPZmZzY3JlZW4gcHJpb3JpdHlcbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGxhbmVUb0xhbmVzKE9mZnNjcmVlbkxhbmUpOyAvLyBJbmNsdWRlIHRoZSBiYXNlIGxhbmVzIGZyb20gdGhlIGxhc3QgcmVuZGVyXG5cbiAgICAgIHZhciBfbmV4dEJhc2VMYW5lcyA9IHByZXZTdGF0ZSAhPT0gbnVsbCA/IG1lcmdlTGFuZXMocHJldlN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpIDogcmVuZGVyTGFuZXM7XG5cbiAgICAgIHJldHVybiBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRCYXNlTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBzZWNvbmQgcmVuZGVyLiBUaGUgc3Vycm91bmRpbmcgdmlzaWJsZSBjb250ZW50IGhhcyBhbHJlYWR5XG4gICAgICAvLyBjb21taXR0ZWQuIE5vdyB3ZSByZXN1bWUgcmVuZGVyaW5nIHRoZSBoaWRkZW4gdHJlZS5cbiAgICAgIC8vIFJlbmRlcmluZyBhdCBvZmZzY3JlZW4sIHNvIHdlIGNhbiBjbGVhciB0aGUgYmFzZSBsYW5lcy5cbiAgICAgIHZhciBfbmV4dFN0YXRlID0ge1xuICAgICAgICBiYXNlTGFuZXM6IE5vTGFuZXMsXG4gICAgICAgIGNhY2hlUG9vbDogbnVsbFxuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfbmV4dFN0YXRlO1xuXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGUgcmVuZGVyIHRoYXQgc3Bhd25lZCB0aGlzIG9uZSBhY2Nlc3NlZCB0aGUgY2FjaGUgcG9vbCwgcmVzdW1lXG4gICAgICAgIC8vIHVzaW5nIHRoZSBzYW1lIGNhY2hlLiBVbmxlc3MgdGhlIHBhcmVudCBjaGFuZ2VkLCBzaW5jZSB0aGF0IG1lYW5zXG4gICAgICAgIC8vIHRoZXJlIHdhcyBhIHJlZnJlc2guXG4gICAgICAgIHZhciBwcmV2Q2FjaGVQb29sID0gcHJldlN0YXRlICE9PSBudWxsID8gcHJldlN0YXRlLmNhY2hlUG9vbCA6IG51bGw7IC8vIFRPRE86IENvbnNpZGVyIGlmIGFuZCBob3cgT2Zmc2NyZWVuIHByZS1yZW5kZXJpbmcgc2hvdWxkXG4gICAgICAgIC8vIGJlIGF0dHJpYnV0ZWQgdG8gdGhlIHRyYW5zaXRpb24gdGhhdCBzcGF3bmVkIGl0XG5cbiAgICAgICAgcHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIHByZXZDYWNoZVBvb2wpO1xuICAgICAgfSAvLyBQdXNoIHRoZSBsYW5lcyB0aGF0IHdlcmUgc2tpcHBlZCB3aGVuIHdlIGJhaWxlZCBvdXQuXG5cblxuICAgICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBwdXNoSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2sod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVuZGVyaW5nIGEgdmlzaWJsZSB0cmVlLlxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIGdvaW5nIGZyb20gaGlkZGVuIC0+IHZpc2libGUuXG4gICAgICB2YXIgX3ByZXZDYWNoZVBvb2wgPSBudWxsO1xuXG4gICAgICB7XG4gICAgICAgIC8vIElmIHRoZSByZW5kZXIgdGhhdCBzcGF3bmVkIHRoaXMgb25lIGFjY2Vzc2VkIHRoZSBjYWNoZSBwb29sLCByZXN1bWVcbiAgICAgICAgLy8gdXNpbmcgdGhlIHNhbWUgY2FjaGUuIFVubGVzcyB0aGUgcGFyZW50IGNoYW5nZWQsIHNpbmNlIHRoYXQgbWVhbnNcbiAgICAgICAgLy8gdGhlcmUgd2FzIGEgcmVmcmVzaC5cbiAgICAgICAgX3ByZXZDYWNoZVBvb2wgPSBwcmV2U3RhdGUuY2FjaGVQb29sO1xuICAgICAgfVxuXG4gICAgICBwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgX3ByZXZDYWNoZVBvb2wpOyAvLyBQdXNoIHRoZSBsYW5lcyB0aGF0IHdlcmUgc2tpcHBlZCB3aGVuIHdlIGJhaWxlZCBvdXQuXG5cbiAgICAgIHB1c2hIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2U3RhdGUpO1xuICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKTsgLy8gU2luY2Ugd2UncmUgbm90IGhpZGRlbiBhbnltb3JlLCByZXNldCB0aGUgc3RhdGVcblxuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHdlcmVuJ3QgcHJldmlvdXNseSBoaWRkZW4sIGFuZCB3ZSBzdGlsbCBhcmVuJ3QsIHNvIHRoZXJlJ3Mgbm90aGluZ1xuICAgICAgLy8gc3BlY2lhbCB0byBkby4gTmVlZCB0byBwdXNoIHRvIHRoZSBzdGFjayByZWdhcmRsZXNzLCB0aG91Z2gsIHRvIGF2b2lkXG4gICAgICAvLyBhIHB1c2gvcG9wIG1pc2FsaWdubWVudC5cbiAgICAgIHtcbiAgICAgICAgLy8gSWYgdGhlIHJlbmRlciB0aGF0IHNwYXduZWQgdGhpcyBvbmUgYWNjZXNzZWQgdGhlIGNhY2hlIHBvb2wsIHJlc3VtZVxuICAgICAgICAvLyB1c2luZyB0aGUgc2FtZSBjYWNoZS4gVW5sZXNzIHRoZSBwYXJlbnQgY2hhbmdlZCwgc2luY2UgdGhhdCBtZWFuc1xuICAgICAgICAvLyB0aGVyZSB3YXMgYSByZWZyZXNoLlxuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXZSdyZSBhYm91dCB0byBiYWlsIG91dCwgYnV0IHdlIG5lZWQgdG8gcHVzaCB0aGlzIHRvIHRoZSBzdGFjayBhbnl3YXlcbiAgICAgIC8vIHRvIGF2b2lkIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxuXG5cbiAgICAgIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2sod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH1cblxuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRCYXNlTGFuZXMsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0U3RhdGUgPSB7XG4gICAgYmFzZUxhbmVzOiBuZXh0QmFzZUxhbmVzLFxuICAgIC8vIFNhdmUgdGhlIGNhY2hlIHBvb2wgc28gd2UgY2FuIHJlc3VtZSBsYXRlci5cbiAgICBjYWNoZVBvb2w6IGdldE9mZnNjcmVlbkRlZmVycmVkQ2FjaGUoKSBcbiAgfTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHRTdGF0ZTtcblxuICB7XG4gICAgLy8gcHVzaCB0aGUgY2FjaGUgcG9vbCBldmVuIHRob3VnaCB3ZSdyZSBnb2luZyB0byBiYWlsIG91dFxuICAgIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZXJlJ2QgYmUgYSBjb250ZXh0IG1pc21hdGNoXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgICB9XG4gIH0gLy8gV2UncmUgYWJvdXQgdG8gYmFpbCBvdXQsIGJ1dCB3ZSBuZWVkIHRvIHB1c2ggdGhpcyB0byB0aGUgc3RhY2sgYW55d2F5XG4gIC8vIHRvIGF2b2lkIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxuXG5cbiAgcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayh3b3JrSW5Qcm9ncmVzcyk7XG4gIHB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gIHJldHVybiBudWxsO1xufSAvLyBOb3RlOiBUaGVzZSBoYXBwZW4gdG8gaGF2ZSBpZGVudGljYWwgYmVnaW4gcGhhc2VzLCBmb3Igbm93LiBXZSBzaG91bGRuJ3QgaG9sZFxuXG5mdW5jdGlvbiB1cGRhdGVDYWNoZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgcGFyZW50Q2FjaGUgPSByZWFkQ29udGV4dChDYWNoZUNvbnRleHQpO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSW5pdGlhbCBtb3VudC4gUmVxdWVzdCBhIGZyZXNoIGNhY2hlIGZyb20gdGhlIHBvb2wuXG4gICAgdmFyIGZyZXNoQ2FjaGUgPSByZXF1ZXN0Q2FjaGVGcm9tUG9vbChyZW5kZXJMYW5lcyk7XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHtcbiAgICAgIHBhcmVudDogcGFyZW50Q2FjaGUsXG4gICAgICBjYWNoZTogZnJlc2hDYWNoZVxuICAgIH07XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2hDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBmcmVzaENhY2hlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDaGVjayBmb3IgdXBkYXRlc1xuICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKGN1cnJlbnQubGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgICAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG51bGwsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlOyAvLyBDb21wYXJlIHRoZSBuZXcgcGFyZW50IGNhY2hlIHRvIHRoZSBwcmV2aW91cyB0byBzZWUgZGV0ZWN0IHRoZXJlIHdhc1xuICAgIC8vIGEgcmVmcmVzaC5cblxuICAgIGlmIChwcmV2U3RhdGUucGFyZW50ICE9PSBwYXJlbnRDYWNoZSkge1xuICAgICAgLy8gUmVmcmVzaCBpbiBwYXJlbnQuIFVwZGF0ZSB0aGUgcGFyZW50LlxuICAgICAgdmFyIGRlcml2ZWRTdGF0ZSA9IHtcbiAgICAgICAgcGFyZW50OiBwYXJlbnRDYWNoZSxcbiAgICAgICAgY2FjaGU6IHBhcmVudENhY2hlXG4gICAgICB9OyAvLyBDb3BpZWQgZnJvbSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgaW1wbGVtZW50YXRpb24uIE9uY2UgdGhlIHVwZGF0ZVxuICAgICAgLy8gcXVldWUgaXMgZW1wdHksIHBlcnNpc3QgdGhlIGRlcml2ZWQgc3RhdGUgb250byB0aGUgYmFzZSBzdGF0ZS5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGRlcml2ZWRTdGF0ZTtcblxuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmxhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gdXBkYXRlUXVldWUuYmFzZVN0YXRlID0gZGVyaXZlZFN0YXRlO1xuICAgICAgfVxuXG4gICAgICBwdXNoQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgcGFyZW50Q2FjaGUpOyAvLyBObyBuZWVkIHRvIHByb3BhZ2F0ZSBhIGNvbnRleHQgY2hhbmdlIGJlY2F1c2UgdGhlIHJlZnJlc2hlZCBwYXJlbnRcbiAgICAgIC8vIGFscmVhZHkgZGlkLlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcGFyZW50IGRpZG4ndCByZWZyZXNoLiBOb3cgY2hlY2sgaWYgdGhpcyBjYWNoZSBkaWQuXG4gICAgICB2YXIgbmV4dENhY2hlID0gbmV4dFN0YXRlLmNhY2hlO1xuICAgICAgcHVzaENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIG5leHRDYWNoZSk7XG5cbiAgICAgIGlmIChuZXh0Q2FjaGUgIT09IHByZXZTdGF0ZS5jYWNoZSkge1xuICAgICAgICAvLyBUaGlzIGNhY2hlIHJlZnJlc2hlZC4gUHJvcGFnYXRlIGEgY29udGV4dCBjaGFuZ2UuXG4gICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufSAvLyBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiB0aGUgbmFtZSBjaGFuZ2VzXG5cbmZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuXG4gICAge1xuICAgICAgLy8gUmVzZXQgZWZmZWN0IGR1cmF0aW9ucyBmb3IgdGhlIG5leHQgZXZlbnR1YWwgZWZmZWN0IHBoYXNlLlxuICAgICAgLy8gVGhlc2UgYXJlIHJlc2V0IGR1cmluZyByZW5kZXIgdG8gYWxsb3cgdGhlIERldlRvb2xzIGNvbW1pdCBob29rIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSxcbiAgICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gVE9ETzogQ2hlY2sgcHJvcHMucmVmIGluc3RlYWQgb2YgZmliZXIucmVmIHdoZW4gZW5hYmxlUmVmQXNQcm9wIGlzIG9uLlxuICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuXG4gIGlmIChyZWYgPT09IG51bGwpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgLy8gU2NoZWR1bGUgYSBSZWYgZWZmZWN0XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBSZWYgfCBSZWZTdGF0aWM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgcmVmICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByZWYgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uLCBhbiBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlUmVmKCksIG9yIHVuZGVmaW5lZC9udWxsLicpO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQucmVmICE9PSByZWYpIHtcblxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBSZWYgfCBSZWZTdGF0aWM7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBTb21lIHZhbGlkYXRpb25zIHdlcmUgcHJldmlvdXNseSBkb25lIGluIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudCBob3dldmVyIGFuZCBhcmUgbm93IHJ1blxuICAgICAgLy8gaW4gdXBkYXRlRnVudGlvbkNvbXBvbmVudCBidXQgb25seSBvbiBtb3VudFxuICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy50eXBlKTtcblxuICAgICAgaWYgKENvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJyVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiAnICsgJ1VzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgd2l0aCBSZWFjdC51c2VDb250ZXh0KCkgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0O1xuXG4gIHZhciBuZXh0Q2hpbGRyZW47XG4gIHZhciBoYXNJZDtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAge1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gIH1cblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSkge1xuICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiBoYXNJZCkge1xuICAgIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBDb21wb25lbnQsIHNlY29uZEFyZywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJlcGxheSBhIGNvbXBvbmVudCB0aGF0IHByZXZpb3VzbHkgc3VzcGVuZGVkLFxuICAvLyBhZnRlciBpdHMgZGF0YSByZXNvbHZlcy4gSXQncyBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZlxuICAvLyB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudCB0aGF0IHJldXNlcyB0aGUgaG9va3MgZnJvbSB0aGUgcHJldmlvdXMgYXR0ZW1wdC5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbiA9IHJlcGxheVN1c3BlbmRlZENvbXBvbmVudFdpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHNlY29uZEFyZyk7XG4gIHZhciBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gIH1cblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSkge1xuICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiBoYXNJZCkge1xuICAgIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICAvLyBUaGlzIGlzIHVzZWQgYnkgRGV2VG9vbHMgdG8gZm9yY2UgYSBib3VuZGFyeSB0byBlcnJvci5cbiAgICBzd2l0Y2ggKHNob3VsZEVycm9yKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlOyAvLyBUT0RPIFRoaXMgd2F5IG9mIHJlc2V0dGluZyB0aGUgZXJyb3IgYm91bmRhcnkgc3RhdGUgaXMgYSBoYWNrLlxuICAgICAgICAgIC8vIElzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzP1xuXG4gICAgICAgICAgdmFyIHRlbXBJbnN0YW5jZSA9IG5ldyBjdG9yKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsIF9pbnN0YW5jZS5jb250ZXh0KTtcbiAgICAgICAgICB2YXIgc3RhdGUgPSB0ZW1wSW5zdGFuY2Uuc3RhdGU7XG5cbiAgICAgICAgICBfaW5zdGFuY2UudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUoX2luc3RhbmNlLCBzdGF0ZSwgbnVsbCk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHRydWU6XG4gICAgICAgIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG5cbiAgICAgICAgICB2YXIgZXJyb3IkMSA9IG5ldyBFcnJvcignU2ltdWxhdGVkIGVycm9yIGNvbWluZyBmcm9tIERldlRvb2xzJyk7XG4gICAgICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcyk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLCBsYW5lKTsgLy8gU2NoZWR1bGUgdGhlIGVycm9yIGJvdW5kYXJ5IHRvIHJlLXJlbmRlciB1c2luZyB1cGRhdGVkIHN0YXRlXG5cbiAgICAgICAgICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuXG4gICAgICAgICAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGxhbmUpO1xuICAgICAgICAgIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKHVwZGF0ZSwgcm9vdCwgd29ya0luUHJvZ3Jlc3MsIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yJDEsIHdvcmtJblByb2dyZXNzKSk7XG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCB1cGRhdGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9IC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuXG5cbiAgdmFyIGhhc0NvbnRleHQ7XG5cbiAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKCkpIHtcbiAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIHZhciBzaG91bGRVcGRhdGU7XG5cbiAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG5cbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcyk7XG4gICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgIHNob3VsZFVwZGF0ZSA9IHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICBzaG91bGRVcGRhdGUgPSB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcyk7XG5cbiAge1xuICAgIHZhciBpbnN0ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSAmJiBpbnN0LnByb3BzICE9PSBuZXh0UHJvcHMpIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICBlcnJvcignSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuICcgKyAnVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBjYW4gbGVhZCB0byBjb25mdXNpbmcgYnVncy4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCAnYSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRVbml0T2ZXb3JrO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFJlZnMgc2hvdWxkIHVwZGF0ZSBldmVuIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlXG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MkMTtcblxuICBpZiAoIXNob3VsZFVwZGF0ZSAmJiAhZGlkQ2FwdHVyZUVycm9yKSB7XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOyAvLyBSZXJlbmRlclxuXG4gIHtcbiAgICBzZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbjtcblxuICBpZiAoZGlkQ2FwdHVyZUVycm9yICYmIHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gSWYgd2UgY2FwdHVyZWQgYW4gZXJyb3IsIGJ1dCBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgaXMgbm90IGRlZmluZWQsXG4gICAgLy8gdW5tb3VudCBhbGwgdGhlIGNoaWxkcmVuLiBjb21wb25lbnREaWRDYXRjaCB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSB0b1xuICAgIC8vIHJlLXJlbmRlciBhIGZhbGxiYWNrLiBUaGlzIGlzIHRlbXBvcmFyeSB1bnRpbCB3ZSBtaWdyYXRlIGV2ZXJ5b25lIHRvXG4gICAgLy8gdGhlIG5ldyBBUEkuXG4gICAgLy8gVE9ETzogV2FybiBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG5cbiAgICB7XG4gICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZygpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAge1xuICAgICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBpbnN0YW5jZS5yZW5kZXIoKTtcblxuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIElmIHdlJ3JlIHJlY292ZXJpbmcgZnJvbSBhbiBlcnJvciwgcmVjb25jaWxlIHdpdGhvdXQgcmV1c2luZyBhbnkgb2ZcbiAgICAvLyB0aGUgZXhpc3RpbmcgY2hpbGRyZW4uIENvbmNlcHR1YWxseSwgdGhlIG5vcm1hbCBjaGlsZHJlbiBhbmQgdGhlIGNoaWxkcmVuXG4gICAgLy8gdGhhdCBhcmUgc2hvd24gb24gZXJyb3IgYXJlIHR3byBkaWZmZXJlbnQgc2V0cywgc28gd2Ugc2hvdWxkbid0IHJldXNlXG4gICAgLy8gbm9ybWFsIGNoaWxkcmVuIGV2ZW4gaWYgdGhlaXIgaWRlbnRpdGllcyBtYXRjaC5cbiAgICBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gLy8gTWVtb2l6ZSBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gIC8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlOyAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIGhhdmUgYSBjdXJyZW50IGZpYmVyLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9XG5cbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBwcmV2Q2hpbGRyZW4gPSBwcmV2U3RhdGUuZWxlbWVudDtcbiAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIHtcbiAgICB2YXIgbmV4dENhY2hlID0gbmV4dFN0YXRlLmNhY2hlO1xuICAgIHB1c2hDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBuZXh0Q2FjaGUpO1xuXG4gICAgaWYgKG5leHRDYWNoZSAhPT0gcHJldlN0YXRlLmNhY2hlKSB7XG4gICAgICAvLyBUaGUgcm9vdCBjYWNoZSByZWZyZXNoZWQuXG4gICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gVGhpcyB3b3VsZCBpZGVhbGx5IGdvIGluc2lkZSBwcm9jZXNzVXBkYXRlUXVldWUsIGJ1dCBiZWNhdXNlIGl0IHN1c3BlbmRzLFxuICAvLyBpdCBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgdGhlIGBwdXNoQ2FjaGVQcm92aWRlcmAgY2FsbCBhYm92ZSB0byBhdm9pZCBhXG4gIC8vIGNvbnRleHQgc3RhY2sgbWlzbWF0Y2guIEEgYml0IHVuZm9ydHVuYXRlLlxuXG5cbiAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG5cbiAgaWYgKHN1cHBvcnRzSHlkcmF0aW9uICYmIHByZXZTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAvLyBUaGlzIGlzIGEgaHlkcmF0aW9uIHJvb3Qgd2hvc2Ugc2hlbGwgaGFzIG5vdCB5ZXQgaHlkcmF0ZWQuIFdlIHNob3VsZFxuICAgIC8vIGF0dGVtcHQgdG8gaHlkcmF0ZS5cbiAgICAvLyBGbGlwIGlzRGVoeWRyYXRlZCB0byBmYWxzZSB0byBpbmRpY2F0ZSB0aGF0IHdoZW4gdGhpcyByZW5kZXJcbiAgICAvLyBmaW5pc2hlcywgdGhlIHJvb3Qgd2lsbCBubyBsb25nZXIgYmUgZGVoeWRyYXRlZC5cbiAgICB2YXIgb3ZlcnJpZGVTdGF0ZSA9IHtcbiAgICAgIGVsZW1lbnQ6IG5leHRDaGlsZHJlbixcbiAgICAgIGlzRGVoeWRyYXRlZDogZmFsc2UsXG4gICAgICBjYWNoZTogbmV4dFN0YXRlLmNhY2hlXG4gICAgfTtcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTsgLy8gYGJhc2VTdGF0ZWAgY2FuIGFsd2F5cyBiZSB0aGUgbGFzdCBzdGF0ZSBiZWNhdXNlIHRoZSByb290IGRvZXNuJ3RcbiAgICAvLyBoYXZlIHJlZHVjZXIgZnVuY3Rpb25zIHNvIGl0IGRvZXNuJ3QgbmVlZCByZWJhc2luZy5cblxuICAgIHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IG92ZXJyaWRlU3RhdGU7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG92ZXJyaWRlU3RhdGU7XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JjZUNsaWVudFJlbmRlcikge1xuICAgICAgLy8gU29tZXRoaW5nIGVycm9yZWQgZHVyaW5nIGEgcHJldmlvdXMgYXR0ZW1wdCB0byBoeWRyYXRlIHRoZSBzaGVsbCwgc28gd2VcbiAgICAgIC8vIGZvcmNlZCBhIGNsaWVudCByZW5kZXIuIFdlIHNob3VsZCBoYXZlIGEgcmVjb3ZlcmFibGUgZXJyb3IgYWxyZWFkeSBzY2hlZHVsZWQuXG4gICAgICByZXR1cm4gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9PSBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciByZWNvdmVyYWJsZUVycm9yID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIobmV3IEVycm9yKCdUaGlzIHJvb3QgcmVjZWl2ZWQgYW4gZWFybHkgdXBkYXRlLCBiZWZvcmUgYW55dGhpbmcgd2FzIGFibGUgJyArICdoeWRyYXRlLiBTd2l0Y2hlZCB0aGUgZW50aXJlIHJvb3QgdG8gY2xpZW50IHJlbmRlcmluZy4nKSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihyZWNvdmVyYWJsZUVycm9yKTtcbiAgICAgIHJldHVybiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBvdXRlcm1vc3Qgc2hlbGwgaGFzIG5vdCBoeWRyYXRlZCB5ZXQuIFN0YXJ0IGh5ZHJhdGluZy5cbiAgICAgIGVudGVySHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdmFyIGNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGNoaWxkO1xuICAgICAgdmFyIG5vZGUgPSBjaGlsZDtcblxuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgLy8gTWFyayBlYWNoIGNoaWxkIGFzIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGZhc3QgcGF0aCB0byBrbm93IHdoZXRoZXIgdGhpc1xuICAgICAgICAvLyB0cmVlIGlzIHBhcnQgb2YgYSBoeWRyYXRpbmcgdHJlZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIGNoaWxkXG4gICAgICAgIC8vIG5vZGUgaGFzIGZ1bGx5IG1vdW50ZWQgeWV0LCBhbmQgZm9yIHNjaGVkdWxpbmcgZXZlbnQgcmVwbGF5aW5nLlxuICAgICAgICAvLyBDb25jZXB0dWFsbHkgdGhpcyBpcyBzaW1pbGFyIHRvIFBsYWNlbWVudCBpbiB0aGF0IGEgbmV3IHN1YnRyZWUgaXNcbiAgICAgICAgLy8gaW5zZXJ0ZWQgaW50byB0aGUgUmVhY3QgdHJlZSBoZXJlLiBJdCBqdXN0IGhhcHBlbnMgdG8gbm90IG5lZWQgRE9NXG4gICAgICAgIC8vIG11dGF0aW9ucyBiZWNhdXNlIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgICAgICBub2RlLmZsYWdzID0gbm9kZS5mbGFncyAmIH5QbGFjZW1lbnQgfCBIeWRyYXRpbmc7XG4gICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJvb3QgaXMgbm90IGRlaHlkcmF0ZWQuIEVpdGhlciB0aGlzIGlzIGEgY2xpZW50LW9ubHkgcm9vdCwgb3IgaXRcbiAgICAvLyBhbHJlYWR5IGh5ZHJhdGVkLlxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcblxuICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IHByZXZDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG5cbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIC8vIFJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlxuICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IEZvcmNlQ2xpZW50UmVuZGVyO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YXIgaXNEaXJlY3RUZXh0Q2hpbGQgPSBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBuZXh0UHJvcHMpO1xuXG4gIGlmIChpc0RpcmVjdFRleHRDaGlsZCkge1xuICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgLy8gY2FzZS4gV2Ugd29uJ3QgaGFuZGxlIGl0IGFzIGEgcmVpZmllZCBjaGlsZC4gV2Ugd2lsbCBpbnN0ZWFkIGhhbmRsZVxuICAgIC8vIHRoaXMgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQgdGhhdCBhbHNvIGhhcyBhY2Nlc3MgdG8gdGhpcyBwcm9wLiBUaGF0XG4gICAgLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbiAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKHByZXZQcm9wcyAhPT0gbnVsbCAmJiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcmV2UHJvcHMpKSB7XG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbiAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IENvbnRlbnRSZXNldDtcbiAgfVxuXG4gIHtcbiAgICB2YXIgbWVtb2l6ZWRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAobWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBmaWJlciBoYXMgYmVlbiB1cGdyYWRlZCB0byBhIHN0YXRlZnVsIGNvbXBvbmVudC4gVGhlIG9ubHkgd2F5XG4gICAgICAvLyBoYXBwZW5zIGN1cnJlbnRseSBpcyBmb3IgZm9ybSBhY3Rpb25zLiBXZSB1c2UgaG9va3MgdG8gdHJhY2sgdGhlXG4gICAgICAvLyBwZW5kaW5nIGFuZCBlcnJvciBzdGF0ZSBvZiB0aGUgZm9ybS5cbiAgICAgIC8vXG4gICAgICAvLyBPbmNlIGEgZmliZXIgaXMgdXBncmFkZWQgdG8gYmUgc3RhdGVmdWwsIGl0IHJlbWFpbnMgc3RhdGVmdWwgZm9yIHRoZVxuICAgICAgLy8gcmVzdCBvZiBpdHMgbGlmZXRpbWUuXG4gICAgICB2YXIgbmV3U3RhdGUgPSByZW5kZXJUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50V2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7IC8vIElmIHRoZSB0cmFuc2l0aW9uIHN0YXRlIGNoYW5nZWQsIHByb3BhZ2F0ZSB0aGUgY2hhbmdlIHRvIGFsbCB0aGVcbiAgICAgIC8vIGRlc2NlbmRlbnRzLiBXZSB1c2UgQ29udGV4dCBhcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgZm9yIHRoaXMuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHNldCBoZXJlIGluc3RlYWQgb2YgcHVzaEhvc3RDb250ZXh0IGJlY2F1c2VcbiAgICAgIC8vIHB1c2hIb3N0Q29udGV4dCBnZXRzIGNhbGxlZCBiZWZvcmUgd2UgcHJvY2VzcyB0aGUgc3RhdGUgaG9vaywgdG8gYXZvaWRcbiAgICAgIC8vIGEgc3RhdGUgbWlzbWF0Y2ggaW4gdGhlIGV2ZW50IHRoYXQgc29tZXRoaW5nIHN1c3BlbmRzLlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IFRoaXMgYXNzdW1lcyB0aGF0IHRoZXJlIGNhbm5vdCBiZSBuZXN0ZWQgdHJhbnNpdGlvbiBwcm92aWRlcnMsXG4gICAgICAvLyBiZWNhdXNlIHRoZSBvbmx5IHJlbmRlcmVyIHRoYXQgaW1wbGVtZW50cyB0aGlzIGZlYXR1cmUgaXMgUmVhY3QgRE9NLFxuICAgICAgLy8gYW5kIGZvcm1zIGNhbm5vdCBiZSBuZXN0ZWQuIElmIHdlIGRpZCBzdXBwb3J0IG5lc3RlZCBwcm92aWRlcnMsIHRoZW5cbiAgICAgIC8vIHdlIHdvdWxkIG5lZWQgdG8gcHVzaCBhIGNvbnRleHQgdmFsdWUgZXZlbiBmb3IgaG9zdCBmaWJlcnMgdGhhdFxuICAgICAgLy8gaGF2ZW4ndCBiZWVuIHVwZ3JhZGVkIHlldC5cblxuICAgICAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgICAgIEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlID0gbmV3U3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBuZXdTdGF0ZTtcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICBpZiAoZGlkUmVjZWl2ZVVwZGF0ZSkge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgb2xkU3RhdGVIb29rID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgdmFyIG9sZFN0YXRlID0gb2xkU3RhdGVIb29rLm1lbW9pemVkU3RhdGU7IC8vIFRoaXMgdXNlcyByZWd1bGFyIGVxdWFsaXR5IGluc3RlYWQgb2YgT2JqZWN0LmlzIGJlY2F1c2Ugd2UgYXNzdW1lXG4gICAgICAgICAgICAvLyB0aGF0IGhvc3QgdHJhbnNpdGlvbiBzdGF0ZSBkb2Vzbid0IGluY2x1ZGUgTmFOIGFzIGEgdmFsaWQgdHlwZS5cblxuICAgICAgICAgICAgaWYgKG9sZFN0YXRlICE9PSBuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBIb3N0VHJhbnNpdGlvbkNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RIb2lzdGFibGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgY3VycmVudFByb3BzID0gY3VycmVudCA9PT0gbnVsbCA/IG51bGwgOiBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIHZhciByZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBnZXRSZXNvdXJjZSh3b3JrSW5Qcm9ncmVzcy50eXBlLCBjdXJyZW50UHJvcHMsIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyk7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICBpZiAoIWdldElzSHlkcmF0aW5nKCkgJiYgcmVzb3VyY2UgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgbm90IGEgUmVzb3VyY2UgSG9pc3RhYmxlIGFuZCB3ZSBhcmVuJ3QgaHlkcmF0aW5nIHNvIHdlIGNvbnN0cnVjdCB0aGUgaW5zdGFuY2UuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVIb2lzdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsIGdldFJvb3RIb3N0Q29udGFpbmVyKCksIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH0gLy8gUmVzb3VyY2VzIG5ldmVyIGhhdmUgcmVjb25jaWxlciBtYW5hZ2VkIGNoaWxkcmVuLiBJdCBpcyBwb3NzaWJsZSBmb3JcbiAgLy8gdGhlIGhvc3QgaW1wbGVtZW50YXRpb24gb2YgZ2V0UmVzb3VyY2UgdG8gY29uc2lkZXIgY2hpbGRyZW4gaW4gdGhlXG4gIC8vIHJlc291cmNlIGNvbnN0cnVjdGlvbiBidXQgdGhleSB3aWxsIG90aGVyd2lzZSBiZSBkaXNjYXJkZWQuIEluIHByYWN0aWNlXG4gIC8vIHRoaXMgcHJlY2x1ZGVzIGFsbCBidXQgdGhlIHNpbXBsZXN0IGNoaWxkcmVuIGFuZCBIb3N0IHNwZWNpZmljIHdhcm5pbmdzXG4gIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCB0byB3YXJuIHdoZW4gY2hpbGRyZW4gYXJlIHBhc3NzZWQgd2hlbiBvdGhlcndpc2Ugbm90XG4gIC8vIGV4cGVjdGVkXG5cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFNpbmdsZXRvbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIGNsYWltSHlkcmF0YWJsZVNpbmdsZXRvbih3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsICYmICFnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgLy8gU2ltaWxhciB0byBQb3J0YWxzIHdlIGFwcGVuZCBTaW5nbGV0b24gY2hpbGRyZW4gaW4gdGhlIGNvbW1pdCBwaGFzZS4gU28gd2VcbiAgICAvLyBUcmFjayBpbnNlcnRpb25zIGV2ZW4gb24gbW91bnQuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0VGV4dCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlVGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfSAvLyBOb3RoaW5nIHRvIGRvIGhlcmUuIFRoaXMgaXMgdGVybWluYWwuIFdlJ2xsIGRvIHRoZSBjb21wbGV0aW9uIHN0ZXBcbiAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG5cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbW91bnRMYXp5Q29tcG9uZW50KF9jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBwcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIGxhenlDb21wb25lbnQgPSBlbGVtZW50VHlwZTtcbiAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG4gIHZhciBDb21wb25lbnQgPSBpbml0KHBheWxvYWQpOyAvLyBTdG9yZSB0aGUgdW53cmFwcGVkIGNvbXBvbmVudCBpbiB0aGUgdHlwZS5cblxuICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50O1xuXG4gIGlmICh0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGlzRnVuY3Rpb25DbGFzc0NvbXBvbmVudChDb21wb25lbnQpKSB7XG4gICAgICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3Jlc29sdmVkUHJvcHMgPSBwcm9wcyA7XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uQ29tcG9uZW50O1xuXG4gICAgICB7XG4gICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgX3Jlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgJiYgQ29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gQ29tcG9uZW50LiQkdHlwZW9mO1xuXG4gICAgaWYgKCQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICB2YXIgX3Jlc29sdmVkUHJvcHMyID0gcHJvcHMgO1xuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBGb3J3YXJkUmVmO1xuXG4gICAgICB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBfcmVzb2x2ZWRQcm9wczIsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2UgaWYgKCQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczMgPSBwcm9wcyA7XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IE1lbW9Db21wb25lbnQ7XG4gICAgICByZXR1cm4gdXBkYXRlTWVtb0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBfcmVzb2x2ZWRQcm9wczMgLCAvLyBUaGUgaW5uZXIgdHlwZSBjYW4gaGF2ZSBkZWZhdWx0cyB0b29cbiAgICAgIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaGludCA9ICcnO1xuXG4gIHtcbiAgICBpZiAoQ29tcG9uZW50ICE9PSBudWxsICYmIHR5cGVvZiBDb21wb25lbnQgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICBoaW50ID0gJyBEaWQgeW91IHdyYXAgYSBjb21wb25lbnQgaW4gUmVhY3QubGF6eSgpIG1vcmUgdGhhbiBvbmNlPyc7XG4gICAgfVxuICB9IC8vIFRoaXMgbWVzc2FnZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgbWVudGlvbiBGb3J3YXJkUmVmIG9yIE1lbW9Db21wb25lbnRcbiAgLy8gYmVjYXVzZSB0aGUgZmFjdCB0aGF0IGl0J3MgYSBzZXBhcmF0ZSB0eXBlIG9mIHdvcmsgaXMgYW5cbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQuIFJlY2VpdmVkIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvOiBcIiArIENvbXBvbmVudCArIFwiLiBcIiArIChcIkxhenkgZWxlbWVudCB0eXBlIG11c3QgcmVzb2x2ZSB0byBhIGNsYXNzIG9yIGZ1bmN0aW9uLlwiICsgaGludCkpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCkge1xuICB7XG4gICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgaWYgKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuXFxuJyArICcgICVzLmNoaWxkQ29udGV4dFR5cGVzID0gLi4uJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTIgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdKSB7XG4gICAgICAgIGVycm9yKCclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJywgX2NvbXBvbmVudE5hbWUyKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsIF9jb21wb25lbnROYW1lMyk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgU1VTUEVOREVEX01BUktFUiA9IHtcbiAgZGVoeWRyYXRlZDogbnVsbCxcbiAgdHJlZUNvbnRleHQ6IG51bGwsXG4gIHJldHJ5TGFuZTogTm9MYW5lXG59O1xuXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYXNlTGFuZXM6IHJlbmRlckxhbmVzLFxuICAgIGNhY2hlUG9vbDogZ2V0U3VzcGVuZGVkQ2FjaGUoKVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHByZXZPZmZzY3JlZW5TdGF0ZSwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGNhY2hlUG9vbCA9IG51bGw7XG5cbiAge1xuICAgIHZhciBwcmV2Q2FjaGVQb29sID0gcHJldk9mZnNjcmVlblN0YXRlLmNhY2hlUG9vbDtcblxuICAgIGlmIChwcmV2Q2FjaGVQb29sICE9PSBudWxsKSB7XG4gICAgICB2YXIgcGFyZW50Q2FjaGUgPSBpc1ByaW1hcnlSZW5kZXJlciA/IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlIDogQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuXG4gICAgICBpZiAocHJldkNhY2hlUG9vbC5wYXJlbnQgIT09IHBhcmVudENhY2hlKSB7XG4gICAgICAgIC8vIERldGVjdGVkIGEgcmVmcmVzaCBpbiB0aGUgcGFyZW50LiBUaGlzIG92ZXJyaWRlcyBhbnkgcHJldmlvdXNseVxuICAgICAgICAvLyBzdXNwZW5kZWQgY2FjaGUuXG4gICAgICAgIGNhY2hlUG9vbCA9IHtcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudENhY2hlLFxuICAgICAgICAgIHBvb2w6IHBhcmVudENhY2hlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBjYW4gcmV1c2UgdGhlIGNhY2hlIGZyb20gbGFzdCB0aW1lLiBUaGUgb25seSB0aGluZyB0aGF0IHdvdWxkIGhhdmVcbiAgICAgICAgLy8gb3ZlcnJpZGRlbiBpdCBpcyBhIHBhcmVudCByZWZyZXNoLCB3aGljaCB3ZSBjaGVja2VkIGZvciBhYm92ZS5cbiAgICAgICAgY2FjaGVQb29sID0gcHJldkNhY2hlUG9vbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBwcmV2aW91cyBjYWNoZSBwb29sLCBncmFiIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgIGNhY2hlUG9vbCA9IGdldFN1c3BlbmRlZENhY2hlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiYXNlTGFuZXM6IG1lcmdlTGFuZXMocHJldk9mZnNjcmVlblN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpLFxuICAgIGNhY2hlUG9vbDogY2FjaGVQb29sXG4gIH07XG59IC8vIFRPRE86IFByb2JhYmx5IHNob3VsZCBpbmxpbmUgdGhpcyBiYWNrXG5cblxuZnVuY3Rpb24gc2hvdWxkUmVtYWluT25GYWxsYmFjayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gSWYgd2UncmUgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2ssIHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB3ZSBuZWVkIHRvXG4gIC8vIHJlbWFpbiBvbiB0aGF0IGZhbGxiYWNrIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgY29udGVudCBoYXMgcmVzb2x2ZWQuXG4gIC8vIEZvciBleGFtcGxlLCBTdXNwZW5zZUxpc3QgY29vcmRpbmF0ZXMgd2hlbiBuZXN0ZWQgY29udGVudCBhcHBlYXJzLlxuICAvLyBUT0RPOiBGb3IgY29tcGF0aWJpbGl0eSB3aXRoIG9mZnNjcmVlbiBwcmVyZW5kZXJpbmcsIHRoaXMgc2hvdWxkIGFsc28gY2hlY2tcbiAgLy8gd2hldGhlciB0aGUgY3VycmVudCBmaWJlciAoaWYgaXQgZXhpc3RzKSB3YXMgdmlzaWJsZSBpbiB0aGUgcHJldmlvdXMgdHJlZS5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChzdXNwZW5zZVN0YXRlID09PSBudWxsKSB7XG4gICAgICAvLyBDdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBEb24ndCBoaWRlIGl0LCBldmVuIGlmIEZvcmNlU3VzcGVuc2VGYWxsYmFja1xuICAgICAgLy8gaXMgdHJ1ZS4gTW9yZSBwcmVjaXNlIG5hbWUgbWlnaHQgYmUgXCJGb3JjZVJlbWFpblN1c3BlbnNlRmFsbGJhY2tcIi5cbiAgICAgIC8vIE5vdGU6IFRoaXMgaXMgYSBmYWN0b3Jpbmcgc21lbGwuIENhbid0IHJlbWFpbiBvbiBhIGZhbGxiYWNrIGlmIHRoZXJlJ3NcbiAgICAgIC8vIG5vIGZhbGxiYWNrIHRvIHJlbWFpbiBvbi5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gTm90IGN1cnJlbnRseSBzaG93aW5nIGNvbnRlbnQuIENvbnN1bHQgdGhlIFN1c3BlbnNlIGNvbnRleHQuXG5cblxuICB2YXIgc3VzcGVuc2VDb250ZXh0ID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O1xuICByZXR1cm4gaGFzU3VzcGVuc2VMaXN0Q29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHByaW1hcnlUcmVlRGlkRGVmZXIsIHJlbmRlckxhbmVzKSB7XG4gIHZhciByZW1haW5pbmdMYW5lcyA9IGN1cnJlbnQgIT09IG51bGwgPyByZW1vdmVMYW5lcyhjdXJyZW50LmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKSA6IE5vTGFuZXM7XG5cbiAgaWYgKHByaW1hcnlUcmVlRGlkRGVmZXIpIHtcbiAgICAvLyBBIHVzZURlZmVycmVkVmFsdWUgaG9vayBzcGF3bmVkIGEgZGVmZXJyZWQgdGFzayBpbnNpZGUgdGhlIHByaW1hcnkgdHJlZS5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXRyeSB0aGlzIGNvbXBvbmVudCBhdCB0aGUgZGVmZXJyZWQgcHJpb3JpdHkuXG4gICAgLy8gVE9ETzogV2UgY291bGQgbWFrZSB0aGlzIGEgcGVyLXN1YnRyZWUgdmFsdWUgaW5zdGVhZCBvZiBhIGdsb2JhbCBvbmUuXG4gICAgLy8gV291bGQgbmVlZCB0byB0cmFjayBpdCBvbiB0aGUgY29udGV4dCBzdGFjayBzb21laG93LCBzaW1pbGFyIHRvIHdoYXRcbiAgICAvLyB3ZSdkIGhhdmUgdG8gZG8gZm9yIHJlc3VtYWJsZSBjb250ZXh0cy5cbiAgICByZW1haW5pbmdMYW5lcyA9IG1lcmdlTGFuZXMocmVtYWluaW5nTGFuZXMsIHBlZWtEZWZlcnJlZExhbmUoKSk7XG4gIH1cblxuICByZXR1cm4gcmVtYWluaW5nTGFuZXM7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBUaGlzIGlzIHVzZWQgYnkgRGV2VG9vbHMgdG8gZm9yY2UgYSBib3VuZGFyeSB0byBzdXNwZW5kLlxuXG4gIHtcbiAgICBpZiAoc2hvdWxkU3VzcGVuZCh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNob3dGYWxsYmFjayA9IGZhbHNlO1xuICB2YXIgZGlkU3VzcGVuZCA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzJDE7XG5cbiAgaWYgKGRpZFN1c3BlbmQgfHwgc2hvdWxkUmVtYWluT25GYWxsYmFjayhjdXJyZW50KSkge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGlzIGJvdW5kYXJ5J3Mgc3VidHJlZSBhbHJlYWR5IHN1c3BlbmRlZC4gU3dpdGNoIHRvXG4gICAgLy8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICBzaG93RmFsbGJhY2sgPSB0cnVlO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5EaWRDYXB0dXJlO1xuICB9IC8vIENoZWNrIGlmIHRoZSBwcmltYXJ5IGNoaWxkcmVuIHNwYXduZWQgYSBkZWZlcnJlZCB0YXNrICh1c2VEZWZlcnJlZFZhbHVlKVxuICAvLyBkdXJpbmcgdGhlIGZpcnN0IHBhc3MuXG5cblxuICB2YXIgZGlkUHJpbWFyeUNoaWxkcmVuRGVmZXIgPSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWREZWZlcikgIT09IE5vRmxhZ3MkMTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfkRpZERlZmVyOyAvLyBPSywgdGhlIG5leHQgcGFydCBpcyBjb25mdXNpbmcuIFdlJ3JlIGFib3V0IHRvIHJlY29uY2lsZSB0aGUgU3VzcGVuc2VcbiAgLy8gYm91bmRhcnkncyBjaGlsZHJlbi4gVGhpcyBpbnZvbHZlcyBzb21lIGN1c3RvbSByZWNvbmNpbGlhdGlvbiBsb2dpYy4gVHdvXG4gIC8vIG1haW4gcmVhc29ucyB0aGlzIGlzIHNvIGNvbXBsaWNhdGVkLlxuICAvL1xuICAvLyBGaXJzdCwgTGVnYWN5IE1vZGUgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGVcbiAgLy8gcHJpbWFyeSB0cmVlIHdpbGwgY29tbWl0IGluIGFuIGluY29uc2lzdGVudCBzdGF0ZSwgc28gd2hlbiB3ZSBkbyB0aGVcbiAgLy8gc2Vjb25kIHBhc3MgdG8gcmVuZGVyIHRoZSBmYWxsYmFjaywgd2UgZG8gc29tZSBleGNlZWRpbmdseSwgdWgsIGNsZXZlclxuICAvLyBoYWNrcyB0byBtYWtlIHRoYXQgbm90IHRvdGFsbHkgYnJlYWsuIExpa2UgdHJhbnNmZXJyaW5nIGVmZmVjdHMgYW5kXG4gIC8vIGRlbGV0aW9ucyBmcm9tIGhpZGRlbiB0cmVlLiBJbiBDb25jdXJyZW50IE1vZGUsIGl0J3MgbXVjaCBzaW1wbGVyLFxuICAvLyBiZWNhdXNlIHdlIGJhaWxvdXQgb24gdGhlIHByaW1hcnkgdHJlZSBjb21wbGV0ZWx5IGFuZCBsZWF2ZSBpdCBpbiBpdHMgb2xkXG4gIC8vIHN0YXRlLCBubyBlZmZlY3RzLiBTYW1lIGFzIHdoYXQgd2UgZG8gZm9yIE9mZnNjcmVlbiAoZXhjZXB0IHRoYXRcbiAgLy8gT2Zmc2NyZWVuIGRvZXNuJ3QgaGF2ZSB0aGUgZmlyc3QgcmVuZGVyIHBhc3MpLlxuICAvL1xuICAvLyBTZWNvbmQgaXMgaHlkcmF0aW9uLiBEdXJpbmcgaHlkcmF0aW9uLCB0aGUgU3VzcGVuc2UgZmliZXIgaGFzIGEgc2xpZ2h0bHlcbiAgLy8gZGlmZmVyZW50IGxheW91dCwgd2hlcmUgdGhlIGNoaWxkIHBvaW50cyB0byBhIGRlaHlkcmF0ZWQgZnJhZ21lbnQsIHdoaWNoXG4gIC8vIGNvbnRhaW5zIHRoZSBET00gcmVuZGVyZWQgYnkgdGhlIHNlcnZlci5cbiAgLy9cbiAgLy8gVGhpcmQsIGV2ZW4gaWYgeW91IHNldCBhbGwgdGhhdCBhc2lkZSwgU3VzcGVuc2UgaXMgbGlrZSBlcnJvciBib3VuZGFyaWVzIGluXG4gIC8vIHRoYXQgd2UgZmlyc3Qgd2UgdHJ5IHRvIHJlbmRlciBvbmUgdHJlZSwgYW5kIGlmIHRoYXQgZmFpbHMsIHdlIHJlbmRlciBhZ2FpblxuICAvLyBhbmQgc3dpdGNoIHRvIGEgZGlmZmVyZW50IHRyZWUuIExpa2UgYSB0cnkvY2F0Y2ggYmxvY2suIFNvIHdlIGhhdmUgdG8gdHJhY2tcbiAgLy8gd2hpY2ggYnJhbmNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcuIElkZWFsbHkgd2Ugd291bGQgbW9kZWwgdGhpcyB1c2luZ1xuICAvLyBhIHN0YWNrLlxuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSW5pdGlhbCBtb3VudFxuICAgIC8vIFNwZWNpYWwgcGF0aCBmb3IgaHlkcmF0aW9uXG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGh5ZHJhdGluZywgdHJ5IHRvIGh5ZHJhdGUgdGhpcyBib3VuZGFyeS5cbiAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgLy8gV2UgbXVzdCBwdXNoIHRoZSBzdXNwZW5zZSBoYW5kbGVyIGNvbnRleHQgKmJlZm9yZSogYXR0ZW1wdGluZyB0b1xuICAgICAgLy8gaHlkcmF0ZSwgdG8gYXZvaWQgYSBtaXNtYXRjaCBpbiBjYXNlIGl0IGVycm9ycy5cbiAgICAgIGlmIChzaG93RmFsbGJhY2spIHtcbiAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGYWxsYmFja1RyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTsgLy8gVGhpcyBjb3VsZCd2ZSBiZWVuIGEgZGVoeWRyYXRlZCBzdXNwZW5zZSBjb21wb25lbnQuXG5cbiAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlaHlkcmF0ZWQgPSBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7XG5cbiAgICAgICAgaWYgKGRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbW91bnREZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQod29ya0luUHJvZ3Jlc3MsIGRlaHlkcmF0ZWQpO1xuICAgICAgICB9XG4gICAgICB9IC8vIElmIGh5ZHJhdGlvbiBkaWRuJ3Qgc3VjY2VlZCwgZmFsbCB0aHJvdWdoIHRvIHRoZSBub3JtYWwgU3VzcGVuc2UgcGF0aC5cbiAgICAgIC8vIFRvIGF2b2lkIGEgc3RhY2sgbWlzbWF0Y2ggd2UgbmVlZCB0byBwb3AgdGhlIFN1c3BlbnNlIGhhbmRsZXIgdGhhdCB3ZVxuICAgICAgLy8gcHVzaGVkIGFib3ZlLiBUaGlzIHdpbGwgYmVjb21lIGxlc3MgYXdrd2FyZCB3aGVuIG1vdmUgdGhlIGh5ZHJhdGlvblxuICAgICAgLy8gbG9naWMgdG8gaXRzIG93biBmaWJlci5cblxuXG4gICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXh0UHJpbWFyeUNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBuZXh0RmFsbGJhY2tDaGlsZHJlbiA9IG5leHRQcm9wcy5mYWxsYmFjaztcblxuICAgIGlmIChzaG93RmFsbGJhY2spIHtcbiAgICAgIHB1c2hGYWxsYmFja1RyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdmFyIGZhbGxiYWNrRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbiwgbmV4dEZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQubWVtb2l6ZWRTdGF0ZSA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcyk7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoY3VycmVudCwgZGlkUHJpbWFyeUNoaWxkcmVuRGVmZXIsIHJlbmRlckxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuXG4gICAgICByZXR1cm4gZmFsbGJhY2tGcmFnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhbiB1cGRhdGUuXG4gICAgLy8gU3BlY2lhbCBwYXRoIGZvciBoeWRyYXRpb25cbiAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9kZWh5ZHJhdGVkID0gcHJldlN0YXRlLmRlaHlkcmF0ZWQ7XG5cbiAgICAgIGlmIChfZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdXBkYXRlRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBkaWRTdXNwZW5kLCBkaWRQcmltYXJ5Q2hpbGRyZW5EZWZlciwgbmV4dFByb3BzLCBfZGVoeWRyYXRlZCwgcHJldlN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgcHVzaEZhbGxiYWNrVHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgX25leHRGYWxsYmFja0NoaWxkcmVuID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW4sIF9uZXh0RmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3RhdGUgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGU7XG4gICAgICBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyLm1lbW9pemVkU3RhdGUgPSBwcmV2T2Zmc2NyZWVuU3RhdGUgPT09IG51bGwgPyBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIDogdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShwcmV2T2Zmc2NyZWVuU3RhdGUsIHJlbmRlckxhbmVzKTtcblxuICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50Mi5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoY3VycmVudCwgZGlkUHJpbWFyeUNoaWxkcmVuRGVmZXIsIHJlbmRlckxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciBfbmV4dFByaW1hcnlDaGlsZHJlbjIgPSBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQzID0gdXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9uZXh0UHJpbWFyeUNoaWxkcmVuMik7XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDM7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ3Zpc2libGUnLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKHByaW1hcnlDaGlsZFByb3BzLCBtb2RlKTtcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgZmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ2hpZGRlbicsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cbiAge1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKHByaW1hcnlDaGlsZFByb3BzLCBtb2RlKTtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7XG4gIH1cblxuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIob2Zmc2NyZWVuUHJvcHMsIG1vZGUsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoZSBwcm9wcyBhcmd1bWVudCB0byBgY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuYCBpcyBgYW55YCB0eXBlZCwgc28gd2UgdXNlXG4gIC8vIHRoaXMgd3JhcHBlciBmdW5jdGlvbiB0byBjb25zdHJhaW4gaXQuXG4gIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ob2Zmc2NyZWVuUHJvcHMsIG1vZGUsIE5vTGFuZXMsIG51bGwpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnQsIG9mZnNjcmVlblByb3BzKSB7XG4gIC8vIFRoZSBwcm9wcyBhcmd1bWVudCB0byBgY3JlYXRlV29ya0luUHJvZ3Jlc3NgIGlzIGBhbnlgIHR5cGVkLCBzbyB3ZSB1c2UgdGhpc1xuICAvLyB3cmFwcGVyIGZ1bmN0aW9uIHRvIGNvbnN0cmFpbiBpdC5cbiAgcmV0dXJuIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIG9mZnNjcmVlblByb3BzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHZhciBjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmc7XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHVwZGF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LCB7XG4gICAgbW9kZTogJ3Zpc2libGUnLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfSk7XG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBudWxsO1xuXG4gIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgLy8gRGVsZXRlIHRoZSBmYWxsYmFjayBjaGlsZCBmcmFnbWVudFxuICAgIHZhciBkZWxldGlvbnMgPSB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnM7XG5cbiAgICBpZiAoZGVsZXRpb25zID09PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBbY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudF07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDaGlsZERlbGV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGlvbnMucHVzaChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50KTtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCBmYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgbW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50LmNoaWxkO1xuICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ2hpZGRlbicsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG5cbiAge1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQsIHByaW1hcnlDaGlsZFByb3BzKTsgLy8gU2luY2Ugd2UncmUgcmV1c2luZyBhIGN1cnJlbnQgdHJlZSwgd2UgbmVlZCB0byByZXVzZSB0aGUgZmxhZ3MsIHRvby5cbiAgICAvLyAoV2UgZG9uJ3QgZG8gdGhpcyBpbiBsZWdhY3kgbW9kZSwgYmVjYXVzZSBpbiBsZWdhY3kgbW9kZSB3ZSBkb24ndCByZS11c2VcbiAgICAvLyB0aGUgY3VycmVudCB0cmVlOyBzZWUgcHJldmlvdXMgYnJhbmNoLilcblxuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnN1YnRyZWVGbGFncyA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zdWJ0cmVlRmxhZ3MgJiBTdGF0aWNNYXNrO1xuICB9XG5cbiAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcblxuICBpZiAoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQsIGZhbGxiYWNrQ2hpbGRyZW4pO1xuICB9IGVsc2Uge1xuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIG1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTsgLy8gTmVlZHMgYSBwbGFjZW1lbnQgZWZmZWN0IGJlY2F1c2UgdGhlIHBhcmVudCAodGhlIFN1c3BlbnNlIGJvdW5kYXJ5KSBhbHJlYWR5XG4gICAgLy8gbW91bnRlZCBidXQgdGhpcyBpcyBhIG5ldyBmaWJlci5cblxuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIH1cblxuICBmYWxsYmFja0NoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gRmFsbGluZyBiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuIEJlY2F1c2UgdGhpcyBoYXMgcGVyZm9ybWFuY2VcbiAgLy8gaW1wbGljYXRpb25zLCBpdCdzIGNvbnNpZGVyZWQgYSByZWNvdmVyYWJsZSBlcnJvciwgZXZlbiB0aG91Z2ggdGhlIHVzZXJcbiAgLy8gbGlrZWx5IHdvbid0IG9ic2VydmUgYW55dGhpbmcgd3Jvbmcgd2l0aCB0aGUgVUkuXG4gIC8vIFRoaXMgd2lsbCBhZGQgdGhlIG9sZCBmaWJlciB0byB0aGUgZGVsZXRpb24gbGlzdFxuICByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBXZSdyZSBub3cgbm90IHN1c3BlbmRlZCBub3IgZGVoeWRyYXRlZC5cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJpbWFyeUNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4pOyAvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2UgYm91bmRhcnkpIGFscmVhZHlcbiAgLy8gbW91bnRlZCBidXQgdGhpcyBpcyBhIG5ldyBmaWJlci5cblxuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VGYWxsYmFja0FmdGVyUmV0cnlXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIGZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBmaWJlck1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ3Zpc2libGUnLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKHByaW1hcnlDaGlsZFByb3BzLCBmaWJlck1vZGUpO1xuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgZmliZXJNb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7IC8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZVxuICAvLyBib3VuZGFyeSkgYWxyZWFkeSBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuXG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBmYWxsYmFja0NoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG5cbiAge1xuICAgIC8vIFdlIHdpbGwgaGF2ZSBkcm9wcGVkIHRoZSBlZmZlY3QgbGlzdCB3aGljaCBjb250YWlucyB0aGVcbiAgICAvLyBkZWxldGlvbi4gV2UgbmVlZCB0byByZWNvbmNpbGUgdG8gZGVsZXRlIHRoZSBjdXJyZW50IGNoaWxkLlxuICAgIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBtb3VudERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VJbnN0YW5jZSwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gRHVyaW5nIHRoZSBmaXJzdCBwYXNzLCB3ZSdsbCBiYWlsIG91dCBhbmQgbm90IGRyaWxsIGludG8gdGhlIGNoaWxkcmVuLlxuICAvLyBJbnN0ZWFkLCB3ZSdsbCBsZWF2ZSB0aGUgY29udGVudCBpbiBwbGFjZSBhbmQgdHJ5IHRvIGh5ZHJhdGUgaXQgbGF0ZXIuXG4gIGlmIChpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhzdXNwZW5zZUluc3RhbmNlKSkge1xuICAgIC8vIFRoaXMgaXMgYSBjbGllbnQtb25seSBib3VuZGFyeS4gU2luY2Ugd2Ugd29uJ3QgZ2V0IGFueSBjb250ZW50IGZyb20gdGhlIHNlcnZlclxuICAgIC8vIGZvciB0aGlzLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoYXQgYXQgYSBoaWdoZXIgcHJpb3JpdHkgYmFzZWQgb24gd2hlbiBpdCB3b3VsZFxuICAgIC8vIGhhdmUgdGltZWQgb3V0LiBJbiB0aGVvcnkgd2UgY291bGQgcmVuZGVyIGl0IGluIHRoaXMgcGFzcyBidXQgaXQgd291bGQgaGF2ZSB0aGVcbiAgICAvLyB3cm9uZyBwcmlvcml0eSBhc3NvY2lhdGVkIHdpdGggaXQgYW5kIHdpbGwgcHJldmVudCBoeWRyYXRpb24gb2YgcGFyZW50IHBhdGguXG4gICAgLy8gSW5zdGVhZCwgd2UnbGwgbGVhdmUgd29yayBsZWZ0IG9uIGl0IHRvIHJlbmRlciBpdCBpbiBhIHNlcGFyYXRlIGNvbW1pdC5cbiAgICAvLyBUT0RPIFRoaXMgdGltZSBzaG91bGQgYmUgdGhlIHRpbWUgYXQgd2hpY2ggdGhlIHNlcnZlciByZW5kZXJlZCByZXNwb25zZSB0aGF0IGlzXG4gICAgLy8gYSBwYXJlbnQgdG8gdGhpcyBib3VuZGFyeSB3YXMgZGlzcGxheWVkLiBIb3dldmVyLCBzaW5jZSB3ZSBjdXJyZW50bHkgZG9uJ3QgaGF2ZVxuICAgIC8vIGEgcHJvdG9jb2wgdG8gdHJhbnNmZXIgdGhhdCB0aW1lLCB3ZSdsbCBqdXN0IGVzdGltYXRlIGl0IGJ5IHVzaW5nIHRoZSBjdXJyZW50XG4gICAgLy8gdGltZS4gVGhpcyB3aWxsIG1lYW4gdGhhdCBTdXNwZW5zZSB0aW1lb3V0cyBhcmUgc2xpZ2h0bHkgc2hpZnRlZCB0byBsYXRlciB0aGFuXG4gICAgLy8gdGhleSBzaG91bGQgYmUuXG4gICAgLy8gU2NoZWR1bGUgYSBub3JtYWwgcHJpIHVwZGF0ZSB0byByZW5kZXIgdGhpcyBjb250ZW50LlxuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbGFuZVRvTGFuZXMoRGVmYXVsdEh5ZHJhdGlvbkxhbmUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlJ2xsIGNvbnRpbnVlIGh5ZHJhdGluZyB0aGUgcmVzdCBhdCBvZmZzY3JlZW4gcHJpb3JpdHkgc2luY2Ugd2UnbGwgYWxyZWFkeVxuICAgIC8vIGJlIHNob3dpbmcgdGhlIHJpZ2h0IGNvbnRlbnQgY29taW5nIGZyb20gdGhlIHNlcnZlciwgaXQgaXMgbm8gcnVzaC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGxhbmVUb0xhbmVzKE9mZnNjcmVlbkxhbmUpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZGlkU3VzcGVuZCwgZGlkUHJpbWFyeUNoaWxkcmVuRGVmZXIsIG5leHRQcm9wcywgc3VzcGVuc2VJbnN0YW5jZSwgc3VzcGVuc2VTdGF0ZSwgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKCFkaWRTdXNwZW5kKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcmVuZGVyIHBhc3MuIEF0dGVtcHQgdG8gaHlkcmF0ZS5cbiAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpOyAvLyBXZSBzaG91bGQgbmV2ZXIgYmUgaHlkcmF0aW5nIGF0IHRoaXMgcG9pbnQgYmVjYXVzZSBpdCBpcyB0aGUgZmlyc3QgcGFzcyxcbiAgICAvLyBidXQgYWZ0ZXIgd2UndmUgYWxyZWFkeSBjb21taXR0ZWQgb25jZS5cblxuICAgIHdhcm5JZkh5ZHJhdGluZygpO1xuXG4gICAgaWYgKGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKHN1c3BlbnNlSW5zdGFuY2UpKSB7XG4gICAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGluIGEgcGVybWFuZW50IGZhbGxiYWNrIHN0YXRlLiBJbiB0aGlzIGNhc2UsIHdlJ2xsIG5ldmVyXG4gICAgICAvLyBnZXQgYW4gdXBkYXRlIGFuZCB3ZSdsbCBuZXZlciBiZSBhYmxlIHRvIGh5ZHJhdGUgdGhlIGZpbmFsIGNvbnRlbnQuIExldCdzIGp1c3QgdHJ5IHRoZVxuICAgICAgLy8gY2xpZW50IHNpZGUgcmVuZGVyIGluc3RlYWQuXG4gICAgICB2YXIgZGlnZXN0O1xuICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICB2YXIgc3RhY2sgPSBudWxsO1xuICAgICAgdmFyIGNvbXBvbmVudFN0YWNrID0gbnVsbDtcblxuICAgICAge1xuICAgICAgICB2YXIgX2dldFN1c3BlbnNlSW5zdGFuY2VGID0gZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzKHN1c3BlbnNlSW5zdGFuY2UpO1xuXG4gICAgICAgIGRpZ2VzdCA9IF9nZXRTdXNwZW5zZUluc3RhbmNlRi5kaWdlc3Q7XG4gICAgICAgIG1lc3NhZ2UgPSBfZ2V0U3VzcGVuc2VJbnN0YW5jZUYubWVzc2FnZTtcbiAgICAgICAgc3RhY2sgPSBfZ2V0U3VzcGVuc2VJbnN0YW5jZUYuc3RhY2s7XG4gICAgICAgIGNvbXBvbmVudFN0YWNrID0gX2dldFN1c3BlbnNlSW5zdGFuY2VGLmNvbXBvbmVudFN0YWNrO1xuICAgICAgfSAvLyBUT0RPOiBGaWd1cmUgb3V0IGEgYmV0dGVyIHNpZ25hbCB0aGFuIGVuY29kaW5nIGEgbWFnaWMgZGlnZXN0IHZhbHVlLlxuXG5cbiAgICAgIHtcbiAgICAgICAgdmFyIGVycm9yO1xuXG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignVGhlIHNlcnZlciBjb3VsZCBub3QgZmluaXNoIHRoaXMgU3VzcGVuc2UgYm91bmRhcnksIGxpa2VseSAnICsgJ2R1ZSB0byBhbiBlcnJvciBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy4gJyArICdTd2l0Y2hlZCB0byBjbGllbnQgcmVuZGVyaW5nLicpO1xuICAgICAgICB9IC8vIFJlcGxhY2UgdGhlIHN0YWNrIHdpdGggdGhlIHNlcnZlciBzdGFja1xuXG5cbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBzdGFjayB8fCAnJztcbiAgICAgICAgZXJyb3IuZGlnZXN0ID0gZGlnZXN0O1xuICAgICAgICB2YXIgY2FwdHVyZWRWYWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVGcm9tRXJyb3IoZXJyb3IsIGNvbXBvbmVudFN0YWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcG9uZW50U3RhY2spO1xuICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKGNhcHR1cmVkVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gICAgLy8gYW55IGNvbnRleHQgaGFzIGNoYW5nZWQsIHdlIG5lZWQgdG8gdHJlYXQgaXMgYXMgaWYgdGhlIGlucHV0IG1pZ2h0IGhhdmUgY2hhbmdlZC5cblxuXG4gICAgdmFyIGhhc0NvbnRleHRDaGFuZ2VkID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgY3VycmVudC5jaGlsZExhbmVzKTtcblxuICAgIGlmIChkaWRSZWNlaXZlVXBkYXRlIHx8IGhhc0NvbnRleHRDaGFuZ2VkKSB7XG4gICAgICAvLyBUaGlzIGJvdW5kYXJ5IGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBmaXJzdCByZW5kZXIuIFRoaXMgbWVhbnMgdGhhdCB3ZSBhcmUgbm93IHVuYWJsZSB0b1xuICAgICAgLy8gaHlkcmF0ZSBpdC4gV2UgbWlnaHQgc3RpbGwgYmUgYWJsZSB0byBoeWRyYXRlIGl0IHVzaW5nIGEgaGlnaGVyIHByaW9yaXR5IGxhbmUuXG4gICAgICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuXG4gICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSA9IGdldEJ1bXBlZExhbmVGb3JIeWRyYXRpb24ocm9vdCwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICAgIGlmIChhdHRlbXB0SHlkcmF0aW9uQXRMYW5lICE9PSBOb0xhbmUgJiYgYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSAhPT0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUpIHtcbiAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IG11dGF0aW5nIHNpbmNlIHRoaXMgcmVuZGVyIHdpbGwgZ2V0IGludGVycnVwdGVkLiBUaGlzXG4gICAgICAgICAgLy8gaXMgb25lIG9mIHRoZSB2ZXJ5IHJhcmUgdGltZXMgd2hlcmUgd2UgbXV0YXRlIHRoZSBjdXJyZW50IHRyZWVcbiAgICAgICAgICAvLyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgICAgICBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSA9IGF0dGVtcHRIeWRyYXRpb25BdExhbmU7XG4gICAgICAgICAgZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGN1cnJlbnQsIGF0dGVtcHRIeWRyYXRpb25BdExhbmUpO1xuICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBjdXJyZW50LCBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lKTsgLy8gVGhyb3cgYSBzcGVjaWFsIG9iamVjdCB0aGF0IHNpZ25hbHMgdG8gdGhlIHdvcmsgbG9vcCB0aGF0IGl0IHNob3VsZFxuICAgICAgICAgIC8vIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBCZWNhdXNlIHdlJ3JlIGluc2lkZSBhIFJlYWN0LW9ubHkgZXhlY3V0aW9uIHN0YWNrLCB3ZSBkb24ndFxuICAgICAgICAgIC8vIHN0cmljdGx5IG5lZWQgdG8gdGhyb3cgaGVyZSDigJQgd2UgY291bGQgaW5zdGVhZCBtb2RpZnkgc29tZSBpbnRlcm5hbFxuICAgICAgICAgIC8vIHdvcmsgbG9vcCBzdGF0ZS4gQnV0IHVzaW5nIGFuIGV4Y2VwdGlvbiBtZWFucyB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgICAgLy8gY2hlY2sgZm9yIHRoaXMgY2FzZSBvbiBldmVyeSBpdGVyYXRpb24gb2YgdGhlIHdvcmsgbG9vcC4gU28gZG9pbmdcbiAgICAgICAgICAvLyBpdCB0aGlzIHdheSBtb3ZlcyB0aGUgY2hlY2sgb3V0IG9mIHRoZSBmYXN0IHBhdGguXG5cbiAgICAgICAgICB0aHJvdyBTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb247XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSWYgd2UgZGlkIG5vdCBzZWxlY3RpdmVseSBoeWRyYXRlLCB3ZSdsbCBjb250aW51ZSByZW5kZXJpbmcgd2l0aG91dFxuICAgICAgLy8gaHlkcmF0aW5nLiBNYXJrIHRoaXMgdHJlZSBhcyBzdXNwZW5kZWQgdG8gcHJldmVudCBpdCBmcm9tIGNvbW1pdHRpbmdcbiAgICAgIC8vIG91dHNpZGUgYSB0cmFuc2l0aW9uLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgcGF0aCBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlIGh5ZHJhdGlvbiBsYW5lIGFscmVhZHkgc3VzcGVuZGVkLlxuICAgICAgLy8gQ3VycmVudGx5LCBpdCBhbHNvIGhhcHBlbnMgZHVyaW5nIHN5bmMgdXBkYXRlcyBiZWNhdXNlIHRoZXJlIGlzIG5vXG4gICAgICAvLyBoeWRyYXRpb24gbGFuZSBmb3Igc3luYyB1cGRhdGVzLlxuICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIGlkZWFsbHkgaGF2ZSBhIHN5bmMgaHlkcmF0aW9uIGxhbmUgdGhhdCB3ZSBjYW4gYXBwbHkgdG8gZG9cbiAgICAgIC8vIGEgcGFzcyB3aGVyZSB3ZSBoeWRyYXRlIHRoaXMgc3VidHJlZSBpbiBwbGFjZSB1c2luZyB0aGUgcHJldmlvdXMgQ29udGV4dCBhbmQgdGhlblxuICAgICAgLy8gcmVhcHBseSB0aGUgdXBkYXRlIGFmdGVyd2FyZHMuXG5cblxuICAgICAgaWYgKGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoc3VzcGVuc2VJbnN0YW5jZSkpIDsgZWxzZSB7XG4gICAgICAgIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIGlmIChpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKHN1c3BlbnNlSW5zdGFuY2UpKSB7XG4gICAgICAvLyBUaGlzIGNvbXBvbmVudCBpcyBzdGlsbCBwZW5kaW5nIG1vcmUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIHNvIHdlIGNhbid0IGh5ZHJhdGUgaXRzXG4gICAgICAvLyBjb250ZW50LiBXZSB0cmVhdCBpdCBhcyBpZiB0aGlzIGNvbXBvbmVudCBzdXNwZW5kZWQgaXRzZWxmLiBJdCBtaWdodCBzZWVtIGFzIGlmXG4gICAgICAvLyB3ZSBjb3VsZCBqdXN0IHRyeSB0byByZW5kZXIgaXQgY2xpZW50LXNpZGUgaW5zdGVhZC4gSG93ZXZlciwgdGhpcyB3aWxsIHBlcmZvcm0gYVxuICAgICAgLy8gbG90IG9mIHVubmVjZXNzYXJ5IHdvcmsgYW5kIGlzIHVubGlrZWx5IHRvIGNvbXBsZXRlIHNpbmNlIGl0IG9mdGVuIHdpbGwgc3VzcGVuZFxuICAgICAgLy8gb24gbWlzc2luZyBkYXRhIGFueXdheS4gQWRkaXRpb25hbGx5LCB0aGUgc2VydmVyIG1pZ2h0IGJlIGFibGUgdG8gcmVuZGVyIG1vcmVcbiAgICAgIC8vIHRoYW4gd2UgY2FuIG9uIHRoZSBjbGllbnQgeWV0LiBJbiB0aGF0IGNhc2Ugd2UnZCBlbmQgdXAgd2l0aCBtb3JlIGZhbGxiYWNrIHN0YXRlc1xuICAgICAgLy8gb24gdGhlIGNsaWVudCB0aGFuIGlmIHdlIGp1c3QgbGVhdmUgaXQgYWxvbmUuIElmIHRoZSBzZXJ2ZXIgdGltZXMgb3V0IG9yIGVycm9yc1xuICAgICAgLy8gdGhlc2Ugc2hvdWxkIHVwZGF0ZSB0aGlzIGJvdW5kYXJ5IHRvIHRoZSBwZXJtYW5lbnQgRmFsbGJhY2sgc3RhdGUgaW5zdGVhZC5cbiAgICAgIC8vIE1hcmsgaXQgYXMgaGF2aW5nIGNhcHR1cmVkIChpLmUuIHN1c3BlbmRlZCkuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlOyAvLyBMZWF2ZSB0aGUgY2hpbGQgaW4gcGxhY2UuIEkuZS4gdGhlIGRlaHlkcmF0ZWQgZnJhZ21lbnQuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDsgLy8gUmVnaXN0ZXIgYSBjYWxsYmFjayB0byByZXRyeSB0aGlzIGJvdW5kYXJ5IG9uY2UgdGhlIHNlcnZlciBoYXMgc2VudCB0aGUgcmVzdWx0LlxuXG4gICAgICB2YXIgcmV0cnkgPSByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5LmJpbmQobnVsbCwgY3VycmVudCk7XG4gICAgICByZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeShzdXNwZW5zZUluc3RhbmNlLCByZXRyeSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgYXR0ZW1wdC5cbiAgICAgIHJlZW50ZXJIeWRyYXRpb25TdGF0ZUZyb21EZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VJbnN0YW5jZSwgc3VzcGVuc2VTdGF0ZS50cmVlQ29udGV4dCk7XG4gICAgICB2YXIgcHJpbWFyeUNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuKTsgLy8gTWFyayB0aGUgY2hpbGRyZW4gYXMgaHlkcmF0aW5nLiBUaGlzIGlzIGEgZmFzdCBwYXRoIHRvIGtub3cgd2hldGhlciB0aGlzXG4gICAgICAvLyB0cmVlIGlzIHBhcnQgb2YgYSBoeWRyYXRpbmcgdHJlZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIGNoaWxkXG4gICAgICAvLyBub2RlIGhhcyBmdWxseSBtb3VudGVkIHlldCwgYW5kIGZvciBzY2hlZHVsaW5nIGV2ZW50IHJlcGxheWluZy5cbiAgICAgIC8vIENvbmNlcHR1YWxseSB0aGlzIGlzIHNpbWlsYXIgdG8gUGxhY2VtZW50IGluIHRoYXQgYSBuZXcgc3VidHJlZSBpc1xuICAgICAgLy8gaW5zZXJ0ZWQgaW50byB0aGUgUmVhY3QgdHJlZSBoZXJlLiBJdCBqdXN0IGhhcHBlbnMgdG8gbm90IG5lZWQgRE9NXG4gICAgICAvLyBtdXRhdGlvbnMgYmVjYXVzZSBpdCBhbHJlYWR5IGV4aXN0cy5cblxuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gSHlkcmF0aW5nO1xuICAgICAgcmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzZWNvbmQgcmVuZGVyIHBhc3MuIFdlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIGh5ZHJhdGVkLCBidXRcbiAgICAvLyBzb21ldGhpbmcgZWl0aGVyIHN1c3BlbmRlZCBvciBlcnJvcmVkLlxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIEZvcmNlQ2xpZW50UmVuZGVyKSB7XG4gICAgICAvLyBTb21ldGhpbmcgZXJyb3JlZCBkdXJpbmcgaHlkcmF0aW9uLiBUcnkgYWdhaW4gd2l0aG91dCBoeWRyYXRpbmcuXG4gICAgICAvLyBUaGUgZXJyb3Igc2hvdWxkJ3ZlIGFscmVhZHkgYmVlbiBsb2dnZWQgaW4gdGhyb3dFeGNlcHRpb24uXG4gICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfkZvcmNlQ2xpZW50UmVuZGVyO1xuICAgICAgcmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkIGFuZCB3ZSBzaG91bGQgc3RpbGwgYmUgaW4gZGVoeWRyYXRlZCBtb2RlLlxuICAgICAgLy8gTGVhdmUgdGhlIGV4aXN0aW5nIGNoaWxkIGluIHBsYWNlLlxuICAgICAgLy8gUHVzaCB0byBhdm9pZCBhIG1pc21hdGNoXG4gICAgICBwdXNoRmFsbGJhY2tUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDsgLy8gVGhlIGRlaHlkcmF0ZWQgY29tcGxldGlvbiBwYXNzIGV4cGVjdHMgdGhpcyBmbGFnIHRvIGJlIHRoZXJlXG4gICAgICAvLyBidXQgdGhlIG5vcm1hbCBzdXNwZW5zZSBwYXNzIGRvZXNuJ3QuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3VzcGVuZGVkIGJ1dCB3ZSBzaG91bGQgbm8gbG9uZ2VyIGJlIGluIGRlaHlkcmF0ZWQgbW9kZS5cbiAgICAgIC8vIFRoZXJlZm9yZSB3ZSBub3cgaGF2ZSB0byByZW5kZXIgdGhlIGZhbGxiYWNrLlxuICAgICAgcHVzaEZhbGxiYWNrVHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBuZXh0RmFsbGJhY2tDaGlsZHJlbiA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlRmFsbGJhY2tBZnRlclJldHJ5V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbiwgbmV4dEZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0Lm1lbW9pemVkU3RhdGUgPSBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpO1xuICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50NC5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoY3VycmVudCwgZGlkUHJpbWFyeUNoaWxkcmVuRGVmZXIsIHJlbmRlckxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKGZpYmVyLCByZW5kZXJMYW5lcywgcHJvcGFnYXRpb25Sb290KSB7XG4gIGZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhmaWJlci5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICBhbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChmaWJlci5yZXR1cm4sIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpO1xufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGZpcnN0Q2hpbGQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIE1hcmsgYW55IFN1c3BlbnNlIGJvdW5kYXJpZXMgd2l0aCBmYWxsYmFja3MgYXMgaGF2aW5nIHdvcmsgdG8gZG8uXG4gIC8vIElmIHRoZXkgd2VyZSBwcmV2aW91c2x5IGZvcmNlZCBpbnRvIGZhbGxiYWNrcywgdGhleSBtYXkgbm93IGJlIGFibGVcbiAgLy8gdG8gdW5ibG9jay5cbiAgdmFyIG5vZGUgPSBmaXJzdENoaWxkO1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKG5vZGUsIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VMaXN0Q29tcG9uZW50KSB7XG4gICAgICAvLyBJZiB0aGUgdGFpbCBpcyBoaWRkZW4gdGhlcmUgbWlnaHQgbm90IGJlIGFuIFN1c3BlbnNlIGJvdW5kYXJpZXNcbiAgICAgIC8vIHRvIHNjaGVkdWxlIHdvcmsgb24uIEluIHRoaXMgY2FzZSB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG9uIHRoZVxuICAgICAgLy8gbGlzdCBpdHNlbGYuXG4gICAgICAvLyBXZSBkb24ndCBoYXZlIHRvIHRyYXZlcnNlIHRvIHRoZSBjaGlsZHJlbiBvZiB0aGUgbGlzdCBzaW5jZVxuICAgICAgLy8gdGhlIGxpc3Qgd2lsbCBwcm9wYWdhdGUgdGhlIGNoYW5nZSB3aGVuIGl0IHJlcmVuZGVycy5cbiAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihub2RlLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZExhc3RDb250ZW50Um93KGZpcnN0Q2hpbGQpIHtcbiAgLy8gVGhpcyBpcyBnb2luZyB0byBmaW5kIHRoZSBsYXN0IHJvdyBhbW9uZyB0aGVzZSBjaGlsZHJlbiB0aGF0IGlzIGFscmVhZHlcbiAgLy8gc2hvd2luZyBjb250ZW50IG9uIHRoZSBzY3JlZW4sIGFzIG9wcG9zZWQgdG8gYmVpbmcgaW4gZmFsbGJhY2sgc3RhdGUgb3JcbiAgLy8gbmV3LiBJZiBhIHJvdyBoYXMgbXVsdGlwbGUgU3VzcGVuc2UgYm91bmRhcmllcywgYW55IG9mIHRoZW0gYmVpbmcgaW4gdGhlXG4gIC8vIGZhbGxiYWNrIHN0YXRlLCBjb3VudHMgYXMgdGhlIHdob2xlIHJvdyBiZWluZyBpbiBhIGZhbGxiYWNrIHN0YXRlLlxuICAvLyBOb3RlIHRoYXQgdGhlIFwicm93c1wiIHdpbGwgYmUgd29ya0luUHJvZ3Jlc3MsIGJ1dCBhbnkgbmVzdGVkIGNoaWxkcmVuXG4gIC8vIHdpbGwgc3RpbGwgYmUgY3VycmVudCBzaW5jZSB3ZSBoYXZlbid0IHJlbmRlcmVkIHRoZW0geWV0LiBUaGUgbW91bnRlZFxuICAvLyBvcmRlciBtYXkgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSBuZXcgb3JkZXIuIFdlIHVzZSB0aGUgbmV3IG9yZGVyLlxuICB2YXIgcm93ID0gZmlyc3RDaGlsZDtcbiAgdmFyIGxhc3RDb250ZW50Um93ID0gbnVsbDtcblxuICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnRSb3cgPSByb3cuYWx0ZXJuYXRlOyAvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5cbiAgICBpZiAoY3VycmVudFJvdyAhPT0gbnVsbCAmJiBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudFJvdykgPT09IG51bGwpIHtcbiAgICAgIGxhc3RDb250ZW50Um93ID0gcm93O1xuICAgIH1cblxuICAgIHJvdyA9IHJvdy5zaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RDb250ZW50Um93O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJldmVhbE9yZGVyKHJldmVhbE9yZGVyKSB7XG4gIHtcbiAgICBpZiAocmV2ZWFsT3JkZXIgIT09IHVuZGVmaW5lZCAmJiByZXZlYWxPcmRlciAhPT0gJ2ZvcndhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ2JhY2t3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICd0b2dldGhlcicgJiYgIWRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSkge1xuICAgICAgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiByZXZlYWxPcmRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3dpdGNoIChyZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAndG9nZXRoZXInOlxuICAgICAgICAgIGNhc2UgJ2ZvcndhcmRzJzpcbiAgICAgICAgICBjYXNlICdiYWNrd2FyZHMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ1VzZSBsb3dlcmNhc2UgXCIlc1wiIGluc3RlYWQuJywgcmV2ZWFsT3JkZXIsIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZm9yd2FyZCc6XG4gICAgICAgICAgY2FzZSAnYmFja3dhcmQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ1JlYWN0IHVzZXMgdGhlIC1zIHN1ZmZpeCBpbiB0aGUgc3BlbGxpbmcuIFVzZSBcIiVzc1wiIGluc3RlYWQuJywgcmV2ZWFsT3JkZXIsIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JywgcmV2ZWFsT3JkZXIpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJyVzIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLCByZXZlYWxPcmRlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGFpbE9wdGlvbnModGFpbE1vZGUsIHJldmVhbE9yZGVyKSB7XG4gIHtcbiAgICBpZiAodGFpbE1vZGUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdKSB7XG4gICAgICBpZiAodGFpbE1vZGUgIT09ICdjb2xsYXBzZWQnICYmIHRhaWxNb2RlICE9PSAnaGlkZGVuJykge1xuICAgICAgICBkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHZhbHVlIGZvciB0YWlsIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwiY29sbGFwc2VkXCIgb3IgXCJoaWRkZW5cIj8nLCB0YWlsTW9kZSk7XG4gICAgICB9IGVsc2UgaWYgKHJldmVhbE9yZGVyICE9PSAnZm9yd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAnYmFja3dhcmRzJykge1xuICAgICAgICBkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCc8U3VzcGVuc2VMaXN0IHRhaWw9XCIlc1wiIC8+IGlzIG9ubHkgdmFsaWQgaWYgcmV2ZWFsT3JkZXIgaXMgJyArICdcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIi4gJyArICdEaWQgeW91IG1lYW4gdG8gc3BlY2lmeSByZXZlYWxPcmRlcj1cImZvcndhcmRzXCI/JywgdGFpbE1vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKGNoaWxkU2xvdCwgaW5kZXgpIHtcbiAge1xuICAgIHZhciBpc0FuQXJyYXkgPSBpc0FycmF5KGNoaWxkU2xvdCk7XG4gICAgdmFyIGlzSXRlcmFibGUgPSAhaXNBbkFycmF5ICYmIHR5cGVvZiBnZXRJdGVyYXRvckZuKGNoaWxkU2xvdCkgPT09ICdmdW5jdGlvbic7XG5cbiAgICBpZiAoaXNBbkFycmF5IHx8IGlzSXRlcmFibGUpIHtcbiAgICAgIHZhciB0eXBlID0gaXNBbkFycmF5ID8gJ2FycmF5JyA6ICdpdGVyYWJsZSc7XG5cbiAgICAgIGVycm9yKCdBIG5lc3RlZCAlcyB3YXMgcGFzc2VkIHRvIHJvdyAjJXMgaW4gPFN1c3BlbnNlTGlzdCAvPi4gV3JhcCBpdCBpbiAnICsgJ2FuIGFkZGl0aW9uYWwgU3VzcGVuc2VMaXN0IHRvIGNvbmZpZ3VyZSBpdHMgcmV2ZWFsT3JkZXI6ICcgKyAnPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+IC4uLiAnICsgJzxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPnslc308L1N1c3BlbnNlTGlzdD4gLi4uICcgKyAnPC9TdXNwZW5zZUxpc3Q+JywgdHlwZSwgaW5kZXgsIHR5cGUpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU3VzcGVuc2VMaXN0Q2hpbGRyZW4oY2hpbGRyZW4sIHJldmVhbE9yZGVyKSB7XG4gIHtcbiAgICBpZiAoKHJldmVhbE9yZGVyID09PSAnZm9yd2FyZHMnIHx8IHJldmVhbE9yZGVyID09PSAnYmFja3dhcmRzJykgJiYgY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiBjaGlsZHJlbiAhPT0gbnVsbCAmJiBjaGlsZHJlbiAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKGNoaWxkcmVuW2ldLCBpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5JdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG5cbiAgICAgICAgICBpZiAoY2hpbGRyZW5JdGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSBjaGlsZHJlbkl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIHZhciBfaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBzdGVwID0gY2hpbGRyZW5JdGVyYXRvci5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKHN0ZXAudmFsdWUsIF9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yKCdBIHNpbmdsZSByb3cgd2FzIHBhc3NlZCB0byBhIDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9XCIlc1wiIC8+LiAnICsgJ1RoaXMgaXMgbm90IHVzZWZ1bCBzaW5jZSBpdCBuZWVkcyBtdWx0aXBsZSByb3dzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBwYXNzIG11bHRpcGxlIGNoaWxkcmVuIG9yIGFuIGFycmF5PycsIHJldmVhbE9yZGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIGlzQmFja3dhcmRzLCB0YWlsLCBsYXN0Q29udGVudFJvdywgdGFpbE1vZGUpIHtcbiAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocmVuZGVyU3RhdGUgPT09IG51bGwpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgaXNCYWNrd2FyZHM6IGlzQmFja3dhcmRzLFxuICAgICAgcmVuZGVyaW5nOiBudWxsLFxuICAgICAgcmVuZGVyaW5nU3RhcnRUaW1lOiAwLFxuICAgICAgbGFzdDogbGFzdENvbnRlbnRSb3csXG4gICAgICB0YWlsOiB0YWlsLFxuICAgICAgdGFpbE1vZGU6IHRhaWxNb2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIG9iamVjdCBmcm9tIHByZXZpb3VzIHJlbmRlcnMuXG4gICAgcmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMgPSBpc0JhY2t3YXJkcztcbiAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsO1xuICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IDA7XG4gICAgcmVuZGVyU3RhdGUubGFzdCA9IGxhc3RDb250ZW50Um93O1xuICAgIHJlbmRlclN0YXRlLnRhaWwgPSB0YWlsO1xuICAgIHJlbmRlclN0YXRlLnRhaWxNb2RlID0gdGFpbE1vZGU7XG4gIH1cbn0gLy8gVGhpcyBjYW4gZW5kIHVwIHJlbmRlcmluZyB0aGlzIGNvbXBvbmVudCBtdWx0aXBsZSBwYXNzZXMuXG4vLyBUaGUgZmlyc3QgcGFzcyBzcGxpdHMgdGhlIGNoaWxkcmVuIGZpYmVycyBpbnRvIHR3byBzZXRzLiBBIGhlYWQgYW5kIHRhaWwuXG4vLyBXZSBmaXJzdCByZW5kZXIgdGhlIGhlYWQuIElmIGFueXRoaW5nIGlzIGluIGZhbGxiYWNrIHN0YXRlLCB3ZSBkbyBhbm90aGVyXG4vLyBwYXNzIHRocm91Z2ggYmVnaW5Xb3JrIHRvIHJlcmVuZGVyIGFsbCBjaGlsZHJlbiAoaW5jbHVkaW5nIHRoZSB0YWlsKSB3aXRoXG4vLyB0aGUgZm9yY2Ugc3VzcGVuZCBjb250ZXh0LiBJZiB0aGUgZmlyc3QgcmVuZGVyIGRpZG4ndCBoYXZlIGFueXRoaW5nIGluXG4vLyBpbiBmYWxsYmFjayBzdGF0ZS4gVGhlbiB3ZSByZW5kZXIgZWFjaCByb3cgaW4gdGhlIHRhaWwgb25lLWJ5LW9uZS5cbi8vIFRoYXQgaGFwcGVucyBpbiB0aGUgY29tcGxldGVXb3JrIHBoYXNlIHdpdGhvdXQgZ29pbmcgYmFjayB0byBiZWdpbldvcmsuXG5cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmV2ZWFsT3JkZXIgPSBuZXh0UHJvcHMucmV2ZWFsT3JkZXI7XG4gIHZhciB0YWlsTW9kZSA9IG5leHRQcm9wcy50YWlsO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhbGlkYXRlUmV2ZWFsT3JkZXIocmV2ZWFsT3JkZXIpO1xuICB2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLCByZXZlYWxPcmRlcik7XG4gIHZhbGlkYXRlU3VzcGVuc2VMaXN0Q2hpbGRyZW4obmV3Q2hpbGRyZW4sIHJldmVhbE9yZGVyKTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHZhciBzdXNwZW5zZUNvbnRleHQgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIHZhciBzaG91bGRGb3JjZUZhbGxiYWNrID0gaGFzU3VzcGVuc2VMaXN0Q29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG5cbiAgaWYgKHNob3VsZEZvcmNlRmFsbGJhY2spIHtcbiAgICBzdXNwZW5zZUNvbnRleHQgPSBzZXRTaGFsbG93U3VzcGVuc2VMaXN0Q29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IGN1cnJlbnQgIT09IG51bGwgJiYgKGN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncyQxO1xuXG4gICAgaWYgKGRpZFN1c3BlbmRCZWZvcmUpIHtcbiAgICAgIC8vIElmIHdlIHByZXZpb3VzbHkgZm9yY2VkIGEgZmFsbGJhY2ssIHdlIG5lZWQgdG8gc2NoZWR1bGUgd29ya1xuICAgICAgLy8gb24gYW55IG5lc3RlZCBib3VuZGFyaWVzIHRvIGxldCB0aGVtIGtub3cgdG8gdHJ5IHRvIHJlbmRlclxuICAgICAgLy8gYWdhaW4uIFRoaXMgaXMgdGhlIHNhbWUgYXMgY29udGV4dCB1cGRhdGluZy5cbiAgICAgIHByb3BhZ2F0ZVN1c3BlbnNlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MuY2hpbGQsIHJlbmRlckxhbmVzKTtcbiAgICB9XG5cbiAgICBzdXNwZW5zZUNvbnRleHQgPSBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlTGlzdENvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtcbiAgfVxuXG4gIHB1c2hTdXNwZW5zZUxpc3RDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUNvbnRleHQpO1xuXG4gIHtcbiAgICBzd2l0Y2ggKHJldmVhbE9yZGVyKSB7XG4gICAgICBjYXNlICdmb3J3YXJkcyc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGFzdENvbnRlbnRSb3cgPSBmaW5kTGFzdENvbnRlbnRSb3cod29ya0luUHJvZ3Jlc3MuY2hpbGQpO1xuICAgICAgICAgIHZhciB0YWlsO1xuXG4gICAgICAgICAgaWYgKGxhc3RDb250ZW50Um93ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgd2hvbGUgbGlzdCBpcyBwYXJ0IG9mIHRoZSB0YWlsLlxuICAgICAgICAgICAgLy8gVE9ETzogV2UgY291bGQgZmFzdCBwYXRoIGJ5IGp1c3QgcmVuZGVyaW5nIHRoZSB0YWlsIG5vdy5cbiAgICAgICAgICAgIHRhaWwgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgdGFpbCByb3dzIGFmdGVyIHRoZSBjb250ZW50IHJvdy5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHJlbmRlciB0aGVtIHNlcGFyYXRlbHkgbGF0ZXIuXG4gICAgICAgICAgICB0YWlsID0gbGFzdENvbnRlbnRSb3cuc2libGluZztcbiAgICAgICAgICAgIGxhc3RDb250ZW50Um93LnNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgdGFpbCwgbGFzdENvbnRlbnRSb3csIHRhaWxNb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdiYWNrd2FyZHMnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gZmluZCB0aGUgZmlyc3Qgcm93IHRoYXQgaGFzIGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgICAgICAgLy8gQXQgdGhlIHNhbWUgdGltZSB3ZSdyZSBnb2luZyB0byByZXZlcnNlIHRoZSBsaXN0IG9mIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAvLyB3ZSBwYXNzIGluIHRoZSBtZWFudGltZS4gVGhhdCdzIGdvaW5nIHRvIGJlIG91ciB0YWlsIGluIHJldmVyc2VcbiAgICAgICAgICAvLyBvcmRlci5cbiAgICAgICAgICB2YXIgX3RhaWwgPSBudWxsO1xuICAgICAgICAgIHZhciByb3cgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG5cbiAgICAgICAgICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJvdyA9IHJvdy5hbHRlcm5hdGU7IC8vIE5ldyByb3dzIGNhbid0IGJlIGNvbnRlbnQgcm93cy5cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRSb3cgIT09IG51bGwgJiYgZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnRSb3cpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgbWFpbiBjb250ZW50LlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJvdztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXh0Um93ID0gcm93LnNpYmxpbmc7XG4gICAgICAgICAgICByb3cuc2libGluZyA9IF90YWlsO1xuICAgICAgICAgICAgX3RhaWwgPSByb3c7XG4gICAgICAgICAgICByb3cgPSBuZXh0Um93O1xuICAgICAgICAgIH0gLy8gVE9ETzogSWYgd29ya0luUHJvZ3Jlc3MuY2hpbGQgaXMgbnVsbCwgd2UgY2FuIGNvbnRpbnVlIG9uIHRoZSB0YWlsIGltbWVkaWF0ZWx5LlxuXG5cbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIHRydWUsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgX3RhaWwsIG51bGwsIC8vIGxhc3RcbiAgICAgICAgICB0YWlsTW9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAndG9nZXRoZXInOlxuICAgICAgICB7XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCBmYWxzZSwgLy8gaXNCYWNrd2FyZHNcbiAgICAgICAgICBudWxsLCAvLyB0YWlsXG4gICAgICAgICAgbnVsbCwgLy8gbGFzdFxuICAgICAgICAgIHVuZGVmaW5lZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHJldmVhbCBvcmRlciBpcyB0aGUgc2FtZSBhcyBub3QgaGF2aW5nXG4gICAgICAgICAgLy8gYSBib3VuZGFyeS5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gUG9ydGFscyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdlIGRvbid0IGFwcGVuZCB0aGUgY2hpbGRyZW4gZHVyaW5nIG1vdW50XG4gICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgLy8gZmxvdyBkb2Vzbid0IGRvIGR1cmluZyBtb3VudC4gVGhpcyBkb2Vzbid0IGhhcHBlbiBhdCB0aGUgcm9vdCBiZWNhdXNlXG4gICAgLy8gdGhlIHJvb3QgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgXCJjdXJyZW50XCIgd2l0aCBhIG51bGwgY2hpbGQuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgfVxuXG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG5ld1ZhbHVlID0gbmV3UHJvcHMudmFsdWU7XG5cbiAge1xuICAgIGlmICghKCd2YWx1ZScgaW4gbmV3UHJvcHMpKSB7XG4gICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyKSB7XG4gICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignVGhlIGB2YWx1ZWAgcHJvcCBpcyByZXF1aXJlZCBmb3IgdGhlIGA8Q29udGV4dC5Qcm92aWRlcj5gLiBEaWQgeW91IG1pc3NwZWxsIGl0IG9yIGZvcmdldCB0byBwYXNzIGl0PycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgbmV3VmFsdWUpO1xuXG4gIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IG9sZFByb3BzLnZhbHVlO1xuXG4gICAgICBpZiAob2JqZWN0SXMob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgICBpZiAob2xkUHJvcHMuY2hpbGRyZW4gPT09IG5ld1Byb3BzLmNoaWxkcmVuICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGNvbnRleHQgdmFsdWUgY2hhbmdlZC4gU2VhcmNoIGZvciBtYXRjaGluZyBjb25zdW1lcnMgYW5kIHNjaGVkdWxlXG4gICAgICAgIC8vIHRoZW0gdG8gdXBkYXRlLlxuICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld0NoaWxkcmVuID0gbmV3UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHRDb25zdW1lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGNvbnRleHQ7XG5cbiAge1xuICAgIHZhciBjb25zdW1lclR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIGNvbnRleHQgPSBjb25zdW1lclR5cGUuX2NvbnRleHQ7XG4gIH1cblxuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciByZW5kZXIgPSBuZXdQcm9wcy5jaGlsZHJlbjtcblxuICB7XG4gICAgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdBIGNvbnRleHQgY29uc3VtZXIgd2FzIHJlbmRlcmVkIHdpdGggbXVsdGlwbGUgY2hpbGRyZW4sIG9yIGEgY2hpbGQgJyArIFwidGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCBcIiArICd0aGF0IGlzIGEgZnVuY3Rpb24uIElmIHlvdSBkaWQgcGFzcyBhIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdGhlcmUgJyArICdpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LicpO1xuICAgIH1cbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIHZhciBuZXdWYWx1ZSA9IHJlYWRDb250ZXh0KGNvbnRleHQpO1xuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRyZW47XG5cbiAge1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5ld0NoaWxkcmVuID0gcmVuZGVyKG5ld1ZhbHVlKTtcbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH1cblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpIHtcbiAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gUmV1c2UgcHJldmlvdXMgZGVwZW5kZW5jaWVzXG4gICAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gIH1cblxuICB7XG4gICAgLy8gRG9uJ3QgdXBkYXRlIFwiYmFzZVwiIHJlbmRlciB0aW1lcyBmb3IgYmFpbG91dHMuXG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoKTtcbiAgfVxuXG4gIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMpOyAvLyBDaGVjayBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBhbnkgcGVuZGluZyB3b3JrLlxuXG4gIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykpIHtcbiAgICAvLyBUaGUgY2hpbGRyZW4gZG9uJ3QgaGF2ZSBhbnkgd29yayBlaXRoZXIuIFdlIGNhbiBza2lwIHRoZW0uXG4gICAgLy8gVE9ETzogT25jZSB3ZSBhZGQgYmFjayByZXN1bWluZywgd2Ugc2hvdWxkIGNoZWNrIGlmIHRoZSBjaGlsZHJlbiBhcmVcbiAgICAvLyBhIHdvcmstaW4tcHJvZ3Jlc3Mgc2V0LiBJZiBzbywgd2UgbmVlZCB0byB0cmFuc2ZlciB0aGVpciBlZmZlY3RzLlxuICAgIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSAvLyBUaGlzIGZpYmVyIGRvZXNuJ3QgaGF2ZSB3b3JrLCBidXQgaXRzIHN1YnRyZWUgZG9lcy4gQ2xvbmUgdGhlIGNoaWxkXG4gIC8vIGZpYmVycyBhbmQgY29udGludWUuXG5cblxuICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiByZW1vdW50RmliZXIoY3VycmVudCwgb2xkV29ya0luUHJvZ3Jlc3MsIG5ld1dvcmtJblByb2dyZXNzKSB7XG4gIHtcbiAgICB2YXIgcmV0dXJuRmliZXIgPSBvbGRXb3JrSW5Qcm9ncmVzcy5yZXR1cm47XG5cbiAgICBpZiAocmV0dXJuRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzd2FwIHRoZSByb290IGZpYmVyLicpO1xuICAgIH0gLy8gRGlzY29ubmVjdCBmcm9tIHRoZSBvbGQgY3VycmVudC5cbiAgICAvLyBJdCB3aWxsIGdldCBkZWxldGVkLlxuXG5cbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgb2xkV29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gQ29ubmVjdCB0byB0aGUgbmV3IHRyZWUuXG5cbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5pbmRleCA9IG9sZFdvcmtJblByb2dyZXNzLmluZGV4O1xuICAgIG5ld1dvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBvbGRXb3JrSW5Qcm9ncmVzcy5zaWJsaW5nO1xuICAgIG5ld1dvcmtJblByb2dyZXNzLnJldHVybiA9IG9sZFdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5yZWYgPSBvbGRXb3JrSW5Qcm9ncmVzcy5yZWY7XG5cbiAgICB7XG4gICAgICBuZXdXb3JrSW5Qcm9ncmVzcy5fZGVidWdJbmZvID0gb2xkV29ya0luUHJvZ3Jlc3MuX2RlYnVnSW5mbztcbiAgICB9IC8vIFJlcGxhY2UgdGhlIGNoaWxkL3NpYmxpbmcgcG9pbnRlcnMgYWJvdmUgaXQuXG5cblxuICAgIGlmIChvbGRXb3JrSW5Qcm9ncmVzcyA9PT0gcmV0dXJuRmliZXIuY2hpbGQpIHtcbiAgICAgIHJldHVybkZpYmVyLmNoaWxkID0gbmV3V29ya0luUHJvZ3Jlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmV2U2libGluZyA9IHJldHVybkZpYmVyLmNoaWxkO1xuXG4gICAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwYXJlbnQgdG8gaGF2ZSBhIGNoaWxkLicpO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICB3aGlsZSAocHJldlNpYmxpbmcuc2libGluZyAhPT0gb2xkV29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIHByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuc2libGluZztcblxuICAgICAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCB0aGUgcHJldmlvdXMgc2libGluZy4nKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICBwcmV2U2libGluZy5zaWJsaW5nID0gbmV3V29ya0luUHJvZ3Jlc3M7XG4gICAgfSAvLyBEZWxldGUgdGhlIG9sZCBmaWJlciBhbmQgcGxhY2UgdGhlIG5ldyBvbmUuXG4gICAgLy8gU2luY2UgdGhlIG9sZCBmaWJlciBpcyBkaXNjb25uZWN0ZWQsIHdlIGhhdmUgdG8gc2NoZWR1bGUgaXQgbWFudWFsbHkuXG5cblxuICAgIHZhciBkZWxldGlvbnMgPSByZXR1cm5GaWJlci5kZWxldGlvbnM7XG5cbiAgICBpZiAoZGVsZXRpb25zID09PSBudWxsKSB7XG4gICAgICByZXR1cm5GaWJlci5kZWxldGlvbnMgPSBbY3VycmVudF07XG4gICAgICByZXR1cm5GaWJlci5mbGFncyB8PSBDaGlsZERlbGV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGlvbnMucHVzaChjdXJyZW50KTtcbiAgICB9XG5cbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7IC8vIFJlc3RhcnQgd29yayBmcm9tIHRoZSBuZXcgZmliZXIuXG5cbiAgICByZXR1cm4gbmV3V29ya0luUHJvZ3Jlc3M7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gQmVmb3JlIHBlcmZvcm1pbmcgYW4gZWFybHkgYmFpbG91dCwgd2UgbXVzdCBjaGVjayBpZiB0aGVyZSBhcmUgcGVuZGluZ1xuICAvLyB1cGRhdGVzIG9yIGNvbnRleHQuXG4gIHZhciB1cGRhdGVMYW5lcyA9IGN1cnJlbnQubGFuZXM7XG5cbiAgaWYgKGluY2x1ZGVzU29tZUxhbmUodXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vIHBlbmRpbmcgdXBkYXRlLCBidXQgYmVjYXVzZSBjb250ZXh0IGlzIHByb3BhZ2F0ZWQgbGF6aWx5LCB3ZSBuZWVkXG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyBmaWJlciBkb2VzIG5vdCBoYXZlIGFueSBwZW5kaW5nIHdvcmsuIEJhaWxvdXQgd2l0aG91dCBlbnRlcmluZ1xuICAvLyB0aGUgYmVnaW4gcGhhc2UuIFRoZXJlJ3Mgc3RpbGwgc29tZSBib29ra2VlcGluZyB3ZSB0aGF0IG5lZWRzIHRvIGJlIGRvbmVcbiAgLy8gaW4gdGhpcyBvcHRpbWl6ZWQgcGF0aCwgbW9zdGx5IHB1c2hpbmcgc3R1ZmYgb250byB0aGUgc3RhY2suXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICB7XG4gICAgICAgIHZhciBjYWNoZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgICAgICAgcHVzaENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGNhY2hlKTtcbiAgICAgIH1cblxuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlO1xuICAgICAgICB2YXIgY29udGV4dDtcblxuICAgICAgICB7XG4gICAgICAgICAgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIG5ld1ZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAge1xuICAgICAgICAvLyBQcm9maWxlciBzaG91bGQgb25seSBjYWxsIG9uUmVuZGVyIHdoZW4gb25lIG9mIGl0cyBkZXNjZW5kYW50cyBhY3R1YWxseSByZW5kZXJlZC5cbiAgICAgICAgdmFyIGhhc0NoaWxkV29yayA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO1xuXG4gICAgICAgIGlmIChoYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgLy8gUmVzZXQgZWZmZWN0IGR1cmF0aW9ucyBmb3IgdGhlIG5leHQgZXZlbnR1YWwgZWZmZWN0IHBoYXNlLlxuICAgICAgICAgIC8vIFRoZXNlIGFyZSByZXNldCBkdXJpbmcgcmVuZGVyIHRvIGFsbG93IHRoZSBEZXZUb29scyBjb21taXQgaG9vayBhIGNoYW5jZSB0byByZWFkIHRoZW0sXG4gICAgICAgICAgdmFyIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gV2UncmUgbm90IGdvaW5nIHRvIHJlbmRlciB0aGUgY2hpbGRyZW4sIHNvIHRoaXMgaXMganVzdCB0byBtYWludGFpblxuICAgICAgICAgICAgLy8gcHVzaC9wb3Agc3ltbWV0cnlcbiAgICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7IC8vIFdlIGtub3cgdGhhdCB0aGlzIGNvbXBvbmVudCB3aWxsIHN1c3BlbmQgYWdhaW4gYmVjYXVzZSBpZiBpdCBoYXNcbiAgICAgICAgICAgIC8vIGJlZW4gdW5zdXNwZW5kZWQgaXQgaGFzIGNvbW1pdHRlZCBhcyBhIHJlc29sdmVkIFN1c3BlbnNlIGNvbXBvbmVudC5cbiAgICAgICAgICAgIC8vIElmIGl0IG5lZWRzIHRvIGJlIHJldHJpZWQsIGl0IHNob3VsZCBoYXZlIHdvcmsgc2NoZWR1bGVkIG9uIGl0LlxuXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlOyAvLyBXZSBzaG91bGQgbmV2ZXIgcmVuZGVyIHRoZSBjaGlsZHJlbiBvZiBhIGRlaHlkcmF0ZWQgYm91bmRhcnkgdW50aWwgd2VcbiAgICAgICAgICAgIC8vIHVwZ3JhZGUgaXQuIFdlIHJldHVybiBudWxsIGluc3RlYWQgb2YgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yay5cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSAvLyBJZiB0aGlzIGJvdW5kYXJ5IGlzIGN1cnJlbnRseSB0aW1lZCBvdXQsIHdlIG5lZWQgdG8gZGVjaWRlXG4gICAgICAgICAgLy8gd2hldGhlciB0byByZXRyeSB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgb3IgdG8gc2tpcCBvdmVyIGl0IGFuZFxuICAgICAgICAgIC8vIGdvIHN0cmFpZ2h0IHRvIHRoZSBmYWxsYmFjay4gQ2hlY2sgdGhlIHByaW9yaXR5IG9mIHRoZSBwcmltYXJ5XG4gICAgICAgICAgLy8gY2hpbGQgZnJhZ21lbnQuXG5cblxuICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRMYW5lcyA9IHByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkTGFuZXM7XG5cbiAgICAgICAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgcHJpbWFyeUNoaWxkTGFuZXMpKSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gVXNlIHRoZSBub3JtYWwgcGF0aFxuICAgICAgICAgICAgLy8gdG8gYXR0ZW1wdCB0byByZW5kZXIgdGhlIHByaW1hcnkgY2hpbGRyZW4gYWdhaW4uXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIHByaW1hcnkgY2hpbGQgZnJhZ21lbnQgZG9lcyBub3QgaGF2ZSBwZW5kaW5nIHdvcmsgbWFya2VkXG4gICAgICAgICAgICAvLyBvbiBpdFxuICAgICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTsgLy8gVGhlIHByaW1hcnkgY2hpbGRyZW4gZG8gbm90IGhhdmUgcGVuZGluZyB3b3JrIHdpdGggc3VmZmljaWVudFxuICAgICAgICAgICAgLy8gcHJpb3JpdHkuIEJhaWxvdXQuXG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoZSBmYWxsYmFjayBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gU2tpcCBvdmVyIHRoZVxuICAgICAgICAgICAgICAvLyBwcmltYXJ5IGNoaWxkcmVuIGFuZCB3b3JrIG9uIHRoZSBmYWxsYmFjay5cbiAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBOb3RlOiBXZSBjYW4gcmV0dXJuIGBudWxsYCBoZXJlIGJlY2F1c2Ugd2UgYWxyZWFkeSBjaGVja2VkXG4gICAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlcmUgd2VyZSBuZXN0ZWQgY29udGV4dCBjb25zdW1lcnMsIHZpYSB0aGUgY2FsbCB0b1xuICAgICAgICAgICAgICAvLyBgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29ya2AgYWJvdmUuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSAoY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzJDE7XG5cbiAgICAgICAgdmFyIF9oYXNDaGlsZFdvcmsgPSBpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKTtcblxuICAgICAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgICAgIGlmIChfaGFzQ2hpbGRXb3JrKSB7XG4gICAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgd2FzIGluIGZhbGxiYWNrIHN0YXRlIGxhc3QgdGltZSwgYW5kIHdlIGhhdmUgYWxsIHRoZVxuICAgICAgICAgICAgLy8gc2FtZSBjaGlsZHJlbiB0aGVuIHdlJ3JlIHN0aWxsIGluIHByb2dyZXNzaXZlIGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgbWlnaHQgZ2V0IHVuYmxvY2tlZCBieSBzdGF0ZSB1cGRhdGVzIG9yIHJldHJpZXMgaW4gdGhlXG4gICAgICAgICAgICAvLyB0cmVlIHdoaWNoIHdpbGwgYWZmZWN0IHRoZSB0YWlsLiBTbyB3ZSBuZWVkIHRvIHVzZSB0aGUgbm9ybWFsXG4gICAgICAgICAgICAvLyBwYXRoIHRvIGNvbXB1dGUgdGhlIGNvcnJlY3QgdGFpbC5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB9IC8vIElmIG5vbmUgb2YgdGhlIGNoaWxkcmVuIGhhZCBhbnkgd29yaywgdGhhdCBtZWFucyB0aGF0IG5vbmUgb2ZcbiAgICAgICAgICAvLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAvLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxuXG5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICB9IC8vIElmIG5vdGhpbmcgc3VzcGVuZGVkIGJlZm9yZSBhbmQgd2UncmUgcmVuZGVyaW5nIHRoZSBzYW1lIGNoaWxkcmVuLFxuICAgICAgICAvLyB0aGVuIHRoZSB0YWlsIGRvZXNuJ3QgbWF0dGVyLiBBbnl0aGluZyBuZXcgdGhhdCBzdXNwZW5kcyB3aWxsIHdvcmtcbiAgICAgICAgLy8gaW4gdGhlIFwidG9nZXRoZXJcIiBtb2RlLCBzbyB3ZSBjYW4gY29udGludWUgZnJvbSB0aGUgc3RhdGUgd2UgaGFkLlxuXG5cbiAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICBpZiAocmVuZGVyU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBSZXNldCB0byB0aGUgXCJ0b2dldGhlclwiIG1vZGUgaW4gY2FzZSB3ZSd2ZSBzdGFydGVkIGEgZGlmZmVyZW50XG4gICAgICAgICAgLy8gdXBkYXRlIGluIHRoZSBwYXN0IGJ1dCBkaWRuJ3QgY29tcGxldGUgaXQuXG4gICAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbnVsbDtcbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbnVsbDtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2hTdXNwZW5zZUxpc3RDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuXG4gICAgICAgIGlmIChfaGFzQ2hpbGRXb3JrKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgbm9uZSBvZiB0aGUgY2hpbGRyZW4gaGFkIGFueSB3b3JrLCB0aGF0IG1lYW5zIHRoYXQgbm9uZSBvZlxuICAgICAgICAgIC8vIHRoZW0gZ290IHJldHJpZWQgc28gdGhleSdsbCBzdGlsbCBiZSBibG9ja2VkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgIC8vIGFzIGJlZm9yZS4gV2UgY2FuIGZhc3QgYmFpbCBvdXQuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBOZWVkIHRvIGNoZWNrIGlmIHRoZSB0cmVlIHN0aWxsIG5lZWRzIHRvIGJlIGRlZmVycmVkLiBUaGlzIGlzXG4gICAgICAgIC8vIGFsbW9zdCBpZGVudGljYWwgdG8gdGhlIGxvZ2ljIHVzZWQgaW4gdGhlIG5vcm1hbCB1cGRhdGUgcGF0aCxcbiAgICAgICAgLy8gc28gd2UnbGwganVzdCBlbnRlciB0aGF0LiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHdlJ2xsIGJhaWwgb3V0XG4gICAgICAgIC8vIGF0IHRoZSBuZXh0IGxldmVsIGluc3RlYWQgb2YgdGhpcyBvbmUsIGJlY2F1c2UgdGhlIGNoaWxkIHByb3BzXG4gICAgICAgIC8vIGhhdmUgbm90IGNoYW5nZWQuIFdoaWNoIGlzIGZpbmUuXG4gICAgICAgIC8vIFRPRE86IFByb2JhYmx5IHNob3VsZCByZWZhY3RvciBgYmVnaW5Xb3JrYCB0byBzcGxpdCB0aGUgYmFpbG91dFxuICAgICAgICAvLyBwYXRoIGZyb20gdGhlIG5vcm1hbCBwYXRoLiBJJ20gdGVtcHRlZCB0byBkbyBhIGxhYmVsZWQgYnJlYWsgaGVyZVxuICAgICAgICAvLyBidXQgSSB3b24ndCA6KVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IE5vTGFuZXM7XG4gICAgICAgIHJldHVybiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2NhY2hlID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlO1xuICAgICAgICAgIHB1c2hDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBfY2FjaGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ICYmIGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZXN0YXJ0IHRoZSBiZWdpbiBwaGFzZSB3aXRoIGEgbmV3IGZpYmVyLlxuICAgICAgcmV0dXJuIHJlbW91bnRGaWJlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLmtleSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciB8fCBudWxsLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCB3b3JrSW5Qcm9ncmVzcy5sYW5lcykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgaGFzQ29udGV4dENoYW5nZWQoKSB8fCAoIC8vIEZvcmNlIGEgcmUtcmVuZGVyIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIGR1ZSB0byBob3QgcmVsb2FkOlxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgIT09IGN1cnJlbnQudHlwZSApKSB7XG4gICAgICAvLyBJZiBwcm9wcyBvciBjb250ZXh0IGNoYW5nZWQsIG1hcmsgdGhlIGZpYmVyIGFzIGhhdmluZyBwZXJmb3JtZWQgd29yay5cbiAgICAgIC8vIFRoaXMgbWF5IGJlIHVuc2V0IGlmIHRoZSBwcm9wcyBhcmUgZGV0ZXJtaW5lZCB0byBiZSBlcXVhbCBsYXRlciAobWVtbykuXG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmVpdGhlciBwcm9wcyBub3IgbGVnYWN5IGNvbnRleHQgY2hhbmdlcy4gQ2hlY2sgaWYgdGhlcmUncyBhIHBlbmRpbmdcbiAgICAgIC8vIHVwZGF0ZSBvciBjb250ZXh0IGNoYW5nZS5cbiAgICAgIHZhciBoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQgPSBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcyk7XG5cbiAgICAgIGlmICghaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0ICYmIC8vIElmIHRoaXMgaXMgdGhlIHNlY29uZCBwYXNzIG9mIGFuIGVycm9yIG9yIHN1c3BlbnNlIGJvdW5kYXJ5LCB0aGVyZVxuICAgICAgLy8gbWF5IG5vdCBiZSB3b3JrIHNjaGVkdWxlZCBvbiBgY3VycmVudGAsIHNvIHdlIGNoZWNrIGZvciB0aGlzIGZsYWcuXG4gICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncyQxKSB7XG4gICAgICAgIC8vIE5vIHBlbmRpbmcgdXBkYXRlcyBvciBjb250ZXh0LiBCYWlsIG91dCBub3cuXG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoY3VycmVudC5mbGFncyAmIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzE5MjE2LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIG9uIHRoaXMgZmliZXIsIGJ1dCB0aGVyZSBhcmUgbm8gbmV3IHByb3BzXG4gICAgICAgIC8vIG5vciBsZWdhY3kgY29udGV4dC4gU2V0IHRoaXMgdG8gZmFsc2UuIElmIGFuIHVwZGF0ZSBxdWV1ZSBvciBjb250ZXh0XG4gICAgICAgIC8vIGNvbnN1bWVyIHByb2R1Y2VzIGEgY2hhbmdlZCB2YWx1ZSwgaXQgd2lsbCBzZXQgdGhpcyB0byB0cnVlLiBPdGhlcndpc2UsXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgd2lsbCBhc3N1bWUgdGhlIGNoaWxkcmVuIGhhdmUgbm90IGNoYW5nZWQgYW5kIGJhaWwgb3V0LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcblxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGlzRm9ya2VkQ2hpbGQod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGNoaWxkIGJlbG9uZ3MgdG8gYSBsaXN0IG9mIG11bGlwbGUgY2hpbGRyZW4gaW5cbiAgICAgIC8vIGl0cyBwYXJlbnQuXG4gICAgICAvL1xuICAgICAgLy8gSW4gYSB0cnVlIG11bHRpLXRocmVhZGVkIGltcGxlbWVudGF0aW9uLCB3ZSB3b3VsZCByZW5kZXIgY2hpbGRyZW4gb25cbiAgICAgIC8vIHBhcmFsbGVsIHRocmVhZHMuIFRoaXMgd291bGQgcmVwcmVzZW50IHRoZSBiZWdpbm5pbmcgb2YgYSBuZXcgcmVuZGVyXG4gICAgICAvLyB0aHJlYWQgZm9yIHRoaXMgc3VidHJlZS5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBvbmx5IHVzZSB0aGlzIGZvciBpZCBnZW5lcmF0aW9uIGR1cmluZyBoeWRyYXRpb24sIHdoaWNoIGlzIHdoeSB0aGVcbiAgICAgIC8vIGxvZ2ljIGlzIGxvY2F0ZWQgaW4gdGhpcyBzcGVjaWFsIGJyYW5jaC5cbiAgICAgIHZhciBzbG90SW5kZXggPSB3b3JrSW5Qcm9ncmVzcy5pbmRleDtcbiAgICAgIHZhciBudW1iZXJPZkZvcmtzID0gZ2V0Rm9ya3NBdExldmVsKCk7XG4gICAgICBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCBudW1iZXJPZkZvcmtzLCBzbG90SW5kZXgpO1xuICAgIH1cbiAgfSAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjbGVhciBwZW5kaW5nIHVwZGF0ZSBwcmlvcml0eS5cbiAgLy8gVE9ETzogVGhpcyBhc3N1bWVzIHRoYXQgd2UncmUgYWJvdXQgdG8gZXZhbHVhdGUgdGhlIGNvbXBvbmVudCBhbmQgcHJvY2Vzc1xuICAvLyB0aGUgdXBkYXRlIHF1ZXVlLiBIb3dldmVyLCB0aGVyZSdzIGFuIGV4Y2VwdGlvbjogU2ltcGxlTWVtb0NvbXBvbmVudFxuICAvLyBzb21ldGltZXMgYmFpbHMgb3V0IGxhdGVyIGluIHRoZSBiZWdpbiBwaGFzZS4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGRcbiAgLy8gbW92ZSB0aGlzIGFzc2lnbm1lbnQgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBhbmQgaW50byBlYWNoIGJyYW5jaC5cblxuXG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lcztcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU7XG4gICAgICAgIHJldHVybiBtb3VudExhenlDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGVsZW1lbnRUeXBlLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIHVucmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIHJlc29sdmVkUHJvcHMgPSB1bnJlc29sdmVkUHJvcHMgO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHM0ID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoX0NvbXBvbmVudCwgX3VucmVzb2x2ZWRQcm9wcyk7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfQ29tcG9uZW50LCBfcmVzb2x2ZWRQcm9wczQsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdEhvaXN0YWJsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RTaW5nbGV0b24oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RDb21wb25lbnQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHJldHVybiB1cGRhdGVIb3N0VGV4dCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHJldHVybiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHtcbiAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzNSA9IF91bnJlc29sdmVkUHJvcHMyIDtcblxuICAgICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgX3Jlc29sdmVkUHJvcHM1LCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIE1vZGU6XG4gICAgICByZXR1cm4gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHJldHVybiB1cGRhdGVQcm9maWxlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIHJldHVybiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF90eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBSZXNvbHZlIG91dGVyIHByb3BzIGZpcnN0LCB0aGVuIHJlc29sdmUgaW5uZXIgcHJvcHMuXG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzNiA9IF91bnJlc29sdmVkUHJvcHMzIDtcblxuICAgICAgICBfcmVzb2x2ZWRQcm9wczYgPSBfcmVzb2x2ZWRQcm9wczYgO1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX3R5cGUsIF9yZXNvbHZlZFByb3BzNiwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBjYXNlIEluY29tcGxldGVGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlQ2FjaGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArIHdvcmtJblByb2dyZXNzLnRhZyArIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFwiICsgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbn1cblxudmFyIHZhbHVlQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xudmFyIHJlbmRlcmVyQ3Vyc29yREVWO1xuXG57XG4gIHJlbmRlcmVyQ3Vyc29yREVWID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xufVxuXG52YXIgcmVuZGVyZXIyQ3Vyc29yREVWO1xuXG57XG4gIHJlbmRlcmVyMkN1cnNvckRFViA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbn1cblxudmFyIHJlbmRlcmVyU2lnaWw7XG5cbntcbiAgLy8gVXNlIHRoaXMgdG8gZGV0ZWN0IG11bHRpcGxlIHJlbmRlcmVycyB1c2luZyB0aGUgc2FtZSBjb250ZXh0XG4gIHJlbmRlcmVyU2lnaWwgPSB7fTtcbn1cblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbDtcbnZhciBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xudmFyIGxhc3RGdWxseU9ic2VydmVkQ29udGV4dCA9IG51bGw7XG52YXIgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IGZhbHNlO1xuZnVuY3Rpb24gcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCkge1xuICAvLyBUaGlzIGlzIGNhbGxlZCByaWdodCBiZWZvcmUgUmVhY3QgeWllbGRzIGV4ZWN1dGlvbiwgdG8gZW5zdXJlIGByZWFkQ29udGV4dGBcbiAgLy8gY2Fubm90IGJlIGNhbGxlZCBvdXRzaWRlIHRoZSByZW5kZXIgcGhhc2UuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbDtcbiAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbiAgbGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0ID0gbnVsbDtcblxuICB7XG4gICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCkge1xuICB7XG4gICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpIHtcbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyRmliZXIsIGNvbnRleHQsIG5leHRWYWx1ZSkge1xuICBpZiAoaXNQcmltYXJ5UmVuZGVyZXIpIHtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUsIHByb3ZpZGVyRmliZXIpO1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcblxuICAgIHtcbiAgICAgIHB1c2gocmVuZGVyZXJDdXJzb3JERVYsIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciwgcHJvdmlkZXJGaWJlcik7XG5cbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IG51bGwgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUyLCBwcm92aWRlckZpYmVyKTtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dFZhbHVlO1xuXG4gICAge1xuICAgICAgcHVzaChyZW5kZXJlcjJDdXJzb3JERVYsIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIsIHByb3ZpZGVyRmliZXIpO1xuXG4gICAgICBpZiAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IG51bGwgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gcmVuZGVyZXJTaWdpbCkge1xuICAgICAgICBlcnJvcignRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwb3BQcm92aWRlcihjb250ZXh0LCBwcm92aWRlckZpYmVyKSB7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB2YWx1ZUN1cnNvci5jdXJyZW50O1xuXG4gIGlmIChpc1ByaW1hcnlSZW5kZXJlcikge1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcblxuICAgIHtcbiAgICAgIHZhciBjdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlckN1cnNvckRFVi5jdXJyZW50O1xuICAgICAgcG9wKHJlbmRlcmVyQ3Vyc29yREVWLCBwcm92aWRlckZpYmVyKTtcbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IGN1cnJlbnRSZW5kZXJlcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IGN1cnJlbnRWYWx1ZTtcblxuICAgIHtcbiAgICAgIHZhciBjdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXIyQ3Vyc29yREVWLmN1cnJlbnQ7XG4gICAgICBwb3AocmVuZGVyZXIyQ3Vyc29yREVWLCBwcm92aWRlckZpYmVyKTtcbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBjdXJyZW50UmVuZGVyZXIyO1xuICAgIH1cbiAgfVxuXG4gIHBvcCh2YWx1ZUN1cnNvciwgcHJvdmlkZXJGaWJlcik7XG59XG5mdW5jdGlvbiBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKHBhcmVudCwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCkge1xuICAvLyBVcGRhdGUgdGhlIGNoaWxkIGxhbmVzIG9mIGFsbCB0aGUgYW5jZXN0b3JzLCBpbmNsdWRpbmcgdGhlIGFsdGVybmF0ZXMuXG4gIHZhciBub2RlID0gcGFyZW50O1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IG5vZGUuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKCFpc1N1YnNldE9mTGFuZXMobm9kZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgIG5vZGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobm9kZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgIWlzU3Vic2V0T2ZMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2UgO1xuXG4gICAgaWYgKG5vZGUgPT09IHByb3BhZ2F0aW9uUm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmIChub2RlICE9PSBwcm9wYWdhdGlvblJvb3QpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHRoZSBwcm9wYWdhdGlvbiByb290IHdoZW4gc2NoZWR1bGluZyBjb250ZXh0IHdvcmsuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlX2VhZ2VyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZV9lYWdlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgcmVuZGVyTGFuZXMpIHtcblxuICB2YXIgZmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICBmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0RmliZXIgPSB2b2lkIDA7IC8vIFZpc2l0IHRoaXMgZmliZXIuXG5cbiAgICB2YXIgbGlzdCA9IGZpYmVyLmRlcGVuZGVuY2llcztcblxuICAgIGlmIChsaXN0ICE9PSBudWxsKSB7XG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgIHZhciBkZXBlbmRlbmN5ID0gbGlzdC5maXJzdENvbnRleHQ7XG5cbiAgICAgIHdoaWxlIChkZXBlbmRlbmN5ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZXh0IG1hdGNoZXMuXG4gICAgICAgIGlmIChkZXBlbmRlbmN5LmNvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgICAgICAvLyBNYXRjaCEgU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoaXMgZmliZXIuXG4gICAgICAgICAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgZm9yY2UgdXBkYXRlIG9uIHRoZSB3b3JrLWluLXByb2dyZXNzLlxuICAgICAgICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlOyAvLyBUT0RPOiBCZWNhdXNlIHdlIGRvbid0IGhhdmUgYSB3b3JrLWluLXByb2dyZXNzLCB0aGlzIHdpbGwgYWRkIHRoZVxuICAgICAgICAgICAgLy8gdXBkYXRlIHRvIHRoZSBjdXJyZW50IGZpYmVyLCB0b28sIHdoaWNoIG1lYW5zIGl0IHdpbGwgcGVyc2lzdCBldmVuIGlmXG4gICAgICAgICAgICAvLyB0aGlzIHJlbmRlciBpcyB0aHJvd24gYXdheS4gU2luY2UgaXQncyBhIHJhY2UgY29uZGl0aW9uLCBub3Qgc3VyZSBpdCdzXG4gICAgICAgICAgICAvLyB3b3J0aCBmaXhpbmcuXG4gICAgICAgICAgICAvLyBJbmxpbmVkIGBlbnF1ZXVlVXBkYXRlYCB0byByZW1vdmUgaW50ZXJsZWF2ZWQgdXBkYXRlIGNoZWNrXG5cbiAgICAgICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgICBpZiAodXBkYXRlUXVldWUgPT09IG51bGwpIDsgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBzaGFyZWRRdWV1ZSA9IHVwZGF0ZVF1ZXVlLnNoYXJlZDtcbiAgICAgICAgICAgICAgdmFyIHBlbmRpbmcgPSBzaGFyZWRRdWV1ZS5wZW5kaW5nO1xuXG4gICAgICAgICAgICAgIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuICAgICAgICAgICAgICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0O1xuICAgICAgICAgICAgICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNoYXJlZFF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKGZpYmVyLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChmaWJlci5yZXR1cm4sIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyk7IC8vIE1hcmsgdGhlIHVwZGF0ZWQgbGFuZXMgb24gdGhlIGxpc3QsIHRvby5cblxuICAgICAgICAgIGxpc3QubGFuZXMgPSBtZXJnZUxhbmVzKGxpc3QubGFuZXMsIHJlbmRlckxhbmVzKTsgLy8gU2luY2Ugd2UgYWxyZWFkeSBmb3VuZCBhIG1hdGNoLCB3ZSBjYW4gc3RvcCB0cmF2ZXJzaW5nIHRoZVxuICAgICAgICAgIC8vIGRlcGVuZGVuY3kgbGlzdC5cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY3kubmV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpYmVyLnRhZyA9PT0gQ29udGV4dFByb3ZpZGVyKSB7XG4gICAgICAvLyBEb24ndCBzY2FuIGRlZXBlciBpZiB0aGlzIGlzIGEgbWF0Y2hpbmcgcHJvdmlkZXJcbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLnR5cGUgPT09IHdvcmtJblByb2dyZXNzLnR5cGUgPyBudWxsIDogZmliZXIuY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IERlaHlkcmF0ZWRGcmFnbWVudCkge1xuICAgICAgLy8gSWYgYSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGJvdW5kYXJ5IGlzIGluIHRoaXMgc3VidHJlZSwgd2UgZG9uJ3Qga25vd1xuICAgICAgLy8gaWYgaXQgd2lsbCBoYXZlIGFueSBjb250ZXh0IGNvbnN1bWVycyBpbiBpdC4gVGhlIGJlc3Qgd2UgY2FuIGRvIGlzXG4gICAgICAvLyBtYXJrIGl0IGFzIGhhdmluZyB1cGRhdGVzLlxuICAgICAgdmFyIHBhcmVudFN1c3BlbnNlID0gZmliZXIucmV0dXJuO1xuXG4gICAgICBpZiAocGFyZW50U3VzcGVuc2UgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBqdXN0IGNhbWUgZnJvbSBhIHBhcmVudCBzbyB3ZSBtdXN0IGhhdmUgaGFkIGEgcGFyZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRTdXNwZW5zZS5sYW5lcyA9IG1lcmdlTGFuZXMocGFyZW50U3VzcGVuc2UubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIHZhciBfYWx0ZXJuYXRlID0gcGFyZW50U3VzcGVuc2UuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAoX2FsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBfYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhfYWx0ZXJuYXRlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9IC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBwYXNzaW5nIHRoaXMgZmliZXIgYXMgdGhlIHBhcmVudFxuICAgICAgLy8gYmVjYXVzZSB3ZSB3YW50IHRvIHNjaGVkdWxlIHRoaXMgZmliZXIgYXMgaGF2aW5nIHdvcmtcbiAgICAgIC8vIG9uIGl0cyBjaGlsZHJlbi4gV2UnbGwgdXNlIHRoZSBjaGlsZExhbmVzIG9uXG4gICAgICAvLyB0aGlzIGZpYmVyIHRvIGluZGljYXRlIHRoYXQgYSBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuXG5cbiAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgocGFyZW50U3VzcGVuc2UsIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5zaWJsaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmF2ZXJzZSBkb3duLlxuICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgY2hpbGQgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgICBuZXh0RmliZXIucmV0dXJuID0gZmliZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNoaWxkLiBUcmF2ZXJzZSB0byBuZXh0IHNpYmxpbmcuXG4gICAgICBuZXh0RmliZXIgPSBmaWJlcjtcblxuICAgICAgd2hpbGUgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dEZpYmVyID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIC8vIFdlJ3JlIGJhY2sgdG8gdGhlIHJvb3Qgb2YgdGhpcyBzdWJ0cmVlLiBFeGl0LlxuICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2libGluZyA9IG5leHRGaWJlci5zaWJsaW5nO1xuXG4gICAgICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgc2libGluZyB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgICAgICBzaWJsaW5nLnJldHVybiA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICAgICAgbmV4dEZpYmVyID0gc2libGluZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBObyBtb3JlIHNpYmxpbmdzLiBUcmF2ZXJzZSB1cC5cblxuXG4gICAgICAgIG5leHRGaWJlciA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmliZXIgPSBuZXh0RmliZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQgPSBudWxsO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzO1xuXG4gIGlmIChkZXBlbmRlbmNpZXMgIT09IG51bGwpIHtcbiAgICB7XG4gICAgICB2YXIgZmlyc3RDb250ZXh0ID0gZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dDtcblxuICAgICAgaWYgKGZpcnN0Q29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShkZXBlbmRlbmNpZXMubGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgICAgICAgIC8vIENvbnRleHQgbGlzdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS4gTWFyayB0aGF0IHRoaXMgZmliZXIgcGVyZm9ybWVkIHdvcmsuXG4gICAgICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICAgICAgfSAvLyBSZXNldCB0aGUgd29yay1pbi1wcm9ncmVzcyBsaXN0XG5cblxuICAgICAgICBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAge1xuICAgIC8vIFRoaXMgd2FybmluZyB3b3VsZCBmaXJlIGlmIHlvdSByZWFkIGNvbnRleHQgaW5zaWRlIGEgSG9vayBsaWtlIHVzZU1lbW8uXG4gICAgLy8gVW5saWtlIHRoZSBjbGFzcyBjaGVjayBiZWxvdywgaXQncyBub3QgZW5mb3JjZWQgaW4gcHJvZHVjdGlvbiBmb3IgcGVyZi5cbiAgICBpZiAoaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVikge1xuICAgICAgZXJyb3IoJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcgKyAnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJyArICdJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJyArICdpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24oY29uc3VtZXIsIGNvbnRleHQsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9PT0gbnVsbCkge1xuICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KGNvbnN1bWVyLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXR1cm4gcmVhZENvbnRleHRGb3JDb25zdW1lcihjb25zdW1lciwgY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY29uc3VtZXIsIGNvbnRleHQpIHtcbiAgdmFyIHZhbHVlID0gaXNQcmltYXJ5UmVuZGVyZXIgPyBjb250ZXh0Ll9jdXJyZW50VmFsdWUgOiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuXG4gIGlmIChsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQgPT09IGNvbnRleHQpIDsgZWxzZSB7XG4gICAgdmFyIGNvbnRleHRJdGVtID0ge1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIG1lbW9pemVkVmFsdWU6IHZhbHVlLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdENvbnRleHREZXBlbmRlbmN5ID09PSBudWxsKSB7XG4gICAgICBpZiAoY29uc3VtZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICAgIH0gLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGVwZW5kZW5jeSBmb3IgdGhpcyBjb21wb25lbnQuIENyZWF0ZSBhIG5ldyBsaXN0LlxuXG5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHRJdGVtO1xuICAgICAgY29uc3VtZXIuZGVwZW5kZW5jaWVzID0ge1xuICAgICAgICBsYW5lczogTm9MYW5lcyxcbiAgICAgICAgZmlyc3RDb250ZXh0OiBjb250ZXh0SXRlbVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIGEgbmV3IGNvbnRleHQgaXRlbS5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dEl0ZW07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyByZXBsYWNlIGl0IHdpdGggYSBsaWdodHdlaWdodCBzaGltIHRoYXQgb25seSBoYXMgdGhlIGZlYXR1cmVzIHdlIHVzZS5cblxudmFyIEFib3J0Q29udHJvbGxlckxvY2FsID0gdHlwZW9mIEFib3J0Q29udHJvbGxlciAhPT0gJ3VuZGVmaW5lZCcgPyBBYm9ydENvbnRyb2xsZXIgOiAvLyAkRmxvd0ZpeE1lW21pc3NpbmctdGhpcy1hbm5vdF1cbi8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuZnVuY3Rpb24gQWJvcnRDb250cm9sbGVyU2hpbSgpIHtcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgc2lnbmFsID0gdGhpcy5zaWduYWwgPSB7XG4gICAgYWJvcnRlZDogZmFsc2UsXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2lnbmFsLmFib3J0ZWQgPSB0cnVlO1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgfSk7XG4gIH07XG59IDsgLy8gSW50ZW50aW9uYWxseSBub3QgbmFtZWQgaW1wb3J0cyBiZWNhdXNlIFJvbGx1cCB3b3VsZFxuLy8gdXNlIGR5bmFtaWMgZGlzcGF0Y2ggZm9yIENvbW1vbkpTIGludGVyb3AgbmFtZWQgaW1wb3J0cy5cblxudmFyIHNjaGVkdWxlQ2FsbGJhY2skMSA9IFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLFxuICAgIE5vcm1hbFByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5O1xudmFyIENhY2hlQ29udGV4dCA9IHtcbiAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgLy8gV2UgZG9uJ3QgdXNlIENvbnN1bWVyL1Byb3ZpZGVyIGZvciBDYWNoZSBjb21wb25lbnRzLiBTbyB3ZSdsbCBjaGVhdC5cbiAgQ29uc3VtZXI6IG51bGwsXG4gIFByb3ZpZGVyOiBudWxsLFxuICAvLyBXZSdsbCBpbml0aWFsaXplIHRoZXNlIGF0IHRoZSByb290LlxuICBfY3VycmVudFZhbHVlOiBudWxsLFxuICBfY3VycmVudFZhbHVlMjogbnVsbCxcbiAgX3RocmVhZENvdW50OiAwXG59IDtcblxue1xuICBDYWNoZUNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gIENhY2hlQ29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG59IC8vIENyZWF0ZXMgYSBuZXcgZW1wdHkgQ2FjaGUgaW5zdGFuY2Ugd2l0aCBhIHJlZi1jb3VudCBvZiAwLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlXG4vLyBmb3IgcmV0YWluaW5nIHRoZSBjYWNoZSBvbmNlIGl0IGlzIGluIHVzZSAocmV0YWluQ2FjaGUpLCBhbmQgcmVsZWFzaW5nIHRoZSBjYWNoZVxuLy8gb25jZSBpdCBpcyBubyBsb25nZXIgbmVlZGVkIChyZWxlYXNlQ2FjaGUpLlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXG4gIHZhciBjYWNoZSA9IHtcbiAgICBjb250cm9sbGVyOiBuZXcgQWJvcnRDb250cm9sbGVyTG9jYWwoKSxcbiAgICBkYXRhOiBuZXcgTWFwKCksXG4gICAgcmVmQ291bnQ6IDBcbiAgfTtcbiAgcmV0dXJuIGNhY2hlO1xufVxuZnVuY3Rpb24gcmV0YWluQ2FjaGUoY2FjaGUpIHtcblxuICB7XG4gICAgaWYgKGNhY2hlLmNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHdhcm4oJ0EgY2FjaGUgaW5zdGFuY2Ugd2FzIHJldGFpbmVkIGFmdGVyIGl0IHdhcyBhbHJlYWR5IGZyZWVkLiAnICsgJ1RoaXMgbGlrZWx5IGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9XG4gIH1cblxuICBjYWNoZS5yZWZDb3VudCsrO1xufSAvLyBDbGVhbnVwIGEgY2FjaGUgaW5zdGFuY2UsIHBvdGVudGlhbGx5IGZyZWVpbmcgaXQgaWYgdGhlcmUgYXJlIG5vIG1vcmUgcmVmZXJlbmNlc1xuXG5mdW5jdGlvbiByZWxlYXNlQ2FjaGUoY2FjaGUpIHtcblxuICBjYWNoZS5yZWZDb3VudC0tO1xuXG4gIHtcbiAgICBpZiAoY2FjaGUucmVmQ291bnQgPCAwKSB7XG4gICAgICB3YXJuKCdBIGNhY2hlIGluc3RhbmNlIHdhcyByZWxlYXNlZCBhZnRlciBpdCB3YXMgYWxyZWFkeSBmcmVlZC4gJyArICdUaGlzIGxpa2VseSBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNhY2hlLnJlZkNvdW50ID09PSAwKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFjayQxKE5vcm1hbFByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWNoZS5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBjYWNoZSkge1xuXG4gIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBjYWNoZSk7XG59XG5mdW5jdGlvbiBwb3BDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBjYWNoZSkge1xuXG4gIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xufVxuXG4vLyB0aGUgc2hhcmVkIGludGVybmFscyBvYmplY3QuIFRoaXMgaXMgdXNlZCBieSB0aGUgaXNvbW9ycGhpYyBpbXBsZW1lbnRhdGlvbiBvZlxuLy8gc3RhcnRUcmFuc2l0aW9uIHRvIGNvbXBvc2UgYWxsIHRoZSBzdGFydFRyYW5zaXRpb25zIHRvZ2V0aGVyLlxuLy9cbi8vICAgZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKGZuKSB7XG4vLyAgICAgcmV0dXJuIHN0YXJ0VHJhbnNpdGlvbkRPTSgoKSA9PiB7XG4vLyAgICAgICByZXR1cm4gc3RhcnRUcmFuc2l0aW9uQVJUKCgpID0+IHtcbi8vICAgICAgICAgcmV0dXJuIHN0YXJ0VHJhbnNpdGlvblRocmVlRmliZXIoKCkgPT4ge1xuLy8gICAgICAgICAgIC8vIGFuZCBzbyBvbi4uLlxuLy8gICAgICAgICAgIHJldHVybiBmbigpO1xuLy8gICAgICAgICB9KTtcbi8vICAgICAgIH0pO1xuLy8gICAgIH0pO1xuLy8gICB9XG4vL1xuLy8gQ3VycmVudGx5IHdlIG9ubHkgY29tcG9zZSB0b2dldGhlciB0aGUgY29kZSB0aGF0IHJ1bnMgYXQgdGhlIGVuZCBvZiBlYWNoXG4vLyBzdGFydFRyYW5zaXRpb24sIGJlY2F1c2UgZm9yIG5vdyB0aGF0J3Mgc3VmZmljaWVudCDigJQgdGhlIHBhcnQgdGhhdCBzZXRzXG4vLyBpc1RyYW5zaXRpb249dHJ1ZSBvbiB0aGUgc3RhY2sgdXNlcyBhIHNlcGFyYXRlIHNoYXJlZCBpbnRlcm5hbCBmaWVsZC4gQnV0XG4vLyByZWFsbHkgd2Ugc2hvdWxkIGRlbGV0ZSB0aGUgc2hhcmVkIGZpZWxkIGFuZCB0cmFjayBpc1RyYW5zaXRpb24gcGVyXG4vLyByZWNvbmNpbGVyLiBMZWF2aW5nIHRoaXMgZm9yIGEgZnV0dXJlIFBSLlxuXG52YXIgcHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcblxuUmVhY3RTaGFyZWRJbnRlcm5hbHMuUyA9IGZ1bmN0aW9uIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoRm9yUmVjb25jaWxlcih0cmFuc2l0aW9uLCByZXR1cm5WYWx1ZSkge1xuICBpZiAodHlwZW9mIHJldHVyblZhbHVlID09PSAnb2JqZWN0JyAmJiByZXR1cm5WYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRoaXMgaXMgYW4gYXN5bmMgYWN0aW9uXG4gICAgdmFyIHRoZW5hYmxlID0gcmV0dXJuVmFsdWU7XG4gICAgZW50YW5nbGVBc3luY0FjdGlvbih0cmFuc2l0aW9uLCB0aGVuYWJsZSk7XG4gIH1cblxuICBpZiAocHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICE9PSBudWxsKSB7XG4gICAgcHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCkge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbn0gLy8gV2hlbiByZXRyeWluZyBhIFN1c3BlbnNlL09mZnNjcmVlbiBib3VuZGFyeSwgd2UgcmVzdG9yZSB0aGUgY2FjaGUgdGhhdCB3YXNcbi8vIHVzZWQgZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXIgYnkgcGxhY2luZyBpdCBoZXJlLCBvbiB0aGUgc3RhY2suXG5cbnZhciByZXN1bWVkQ2FjaGUgPSBjcmVhdGVDdXJzb3IobnVsbCk7IC8vIER1cmluZyB0aGUgcmVuZGVyL3N5bmNocm9ub3VzIGNvbW1pdCBwaGFzZSwgd2UgZG9uJ3QgYWN0dWFsbHkgcHJvY2VzcyB0aGVcblxuZnVuY3Rpb24gcGVla0NhY2hlRnJvbVBvb2woKSB7XG4gIC8vIElmIHdlJ3JlIHJlbmRlcmluZyBpbnNpZGUgYSBTdXNwZW5zZSBib3VuZGFyeSB0aGF0IGlzIGN1cnJlbnRseSBoaWRkZW4sXG4gIC8vIHdlIHNob3VsZCB1c2UgdGhlIHNhbWUgY2FjaGUgdGhhdCB3ZSB1c2VkIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLCBpZlxuICAvLyBvbmUgZXhpc3RzLlxuXG5cbiAgdmFyIGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlciA9IHJlc3VtZWRDYWNoZS5jdXJyZW50O1xuXG4gIGlmIChjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXIgIT09IG51bGwpIHtcbiAgICByZXR1cm4gY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyO1xuICB9IC8vIE90aGVyd2lzZSwgY2hlY2sgdGhlIHJvb3QncyBjYWNoZSBwb29sLlxuXG5cbiAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcbiAgdmFyIGNhY2hlRnJvbVJvb3RDYWNoZVBvb2wgPSByb290LnBvb2xlZENhY2hlO1xuICByZXR1cm4gY2FjaGVGcm9tUm9vdENhY2hlUG9vbDtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdENhY2hlRnJvbVBvb2wocmVuZGVyTGFuZXMpIHtcbiAgLy8gU2ltaWxhciB0byBwcmV2aW91cyBmdW5jdGlvbiwgZXhjZXB0IGlmIHRoZXJlJ3Mgbm90IGFscmVhZHkgYSBjYWNoZSBpbiB0aGVcbiAgLy8gcG9vbCwgd2UgYWxsb2NhdGUgYSBuZXcgb25lLlxuICB2YXIgY2FjaGVGcm9tUG9vbCA9IHBlZWtDYWNoZUZyb21Qb29sKCk7XG5cbiAgaWYgKGNhY2hlRnJvbVBvb2wgIT09IG51bGwpIHtcbiAgICByZXR1cm4gY2FjaGVGcm9tUG9vbDtcbiAgfSAvLyBDcmVhdGUgYSBmcmVzaCBjYWNoZSBhbmQgYWRkIGl0IHRvIHRoZSByb290IGNhY2hlIHBvb2wuIEEgY2FjaGUgY2FuIGhhdmVcbiAgLy8gbXVsdGlwbGUgb3duZXJzOlxuICAvLyAtIEEgY2FjaGUgcG9vbCB0aGF0IGxpdmVzIG9uIHRoZSBGaWJlclJvb3QuIFRoaXMgaXMgd2hlcmUgYWxsIGZyZXNoIGNhY2hlc1xuICAvLyAgIGFyZSBvcmlnaW5hbGx5IGNyZWF0ZWQgKFRPRE86IGV4Y2VwdCBkdXJpbmcgcmVmcmVzaGVzLCB1bnRpbCB3ZSBpbXBsZW1lbnRcbiAgLy8gICB0aGlzIGNvcnJlY3RseSkuIFRoZSByb290IHRha2VzIG93bmVyc2hpcCBpbW1lZGlhdGVseSB3aGVuIHRoZSBjYWNoZSBpc1xuICAvLyAgIGNyZWF0ZWQuIENvbmNlcHR1YWxseSwgcm9vdC5wb29sZWRDYWNoZSBpcyBhbiBPcHRpb248QXJjPENhY2hlPj4gKG93bmVkKSxcbiAgLy8gICBhbmQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIGEgJkFyYzxDYWNoZT4gKGJvcnJvd2VkKS5cbiAgLy8gLSBPbmUgb2Ygc2V2ZXJhbCBmaWJlciB0eXBlczogaG9zdCByb290LCBjYWNoZSBib3VuZGFyeSwgc3VzcGVuc2VcbiAgLy8gICBjb21wb25lbnQuIFRoZXNlIHJldGFpbiBhbmQgcmVsZWFzZSBpbiB0aGUgY29tbWl0IHBoYXNlLlxuXG5cbiAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcbiAgdmFyIGZyZXNoQ2FjaGUgPSBjcmVhdGVDYWNoZSgpO1xuICByb290LnBvb2xlZENhY2hlID0gZnJlc2hDYWNoZTtcbiAgcmV0YWluQ2FjaGUoZnJlc2hDYWNoZSk7XG5cbiAgaWYgKGZyZXNoQ2FjaGUgIT09IG51bGwpIHtcbiAgICByb290LnBvb2xlZENhY2hlTGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gIH1cblxuICByZXR1cm4gZnJlc2hDYWNoZTtcbn1cbmZ1bmN0aW9uIHB1c2hUcmFuc2l0aW9uKG9mZnNjcmVlbldvcmtJblByb2dyZXNzLCBwcmV2Q2FjaGVQb29sLCBuZXdUcmFuc2l0aW9ucykge1xuICB7XG4gICAgaWYgKHByZXZDYWNoZVBvb2wgPT09IG51bGwpIHtcbiAgICAgIHB1c2gocmVzdW1lZENhY2hlLCByZXN1bWVkQ2FjaGUuY3VycmVudCwgb2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoKHJlc3VtZWRDYWNoZSwgcHJldkNhY2hlUG9vbC5wb29sLCBvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwb3BUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBjdXJyZW50KSB7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG5cbiAgICB7XG4gICAgICBwb3AocmVzdW1lZENhY2hlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRTdXNwZW5kZWRDYWNoZSgpIHtcbiAgLy8gY2FjaGUgdGhhdCB3b3VsZCBoYXZlIGJlZW4gdXNlZCB0byByZW5kZXIgZnJlc2ggZGF0YSBkdXJpbmcgdGhpcyByZW5kZXIsXG4gIC8vIGlmIHRoZXJlIHdhcyBhbnksIHNvIHRoYXQgd2UgY2FuIHJlc3VtZSByZW5kZXJpbmcgd2l0aCB0aGUgc2FtZSBjYWNoZSB3aGVuXG4gIC8vIHdlIHJlY2VpdmUgbW9yZSBkYXRhLlxuXG5cbiAgdmFyIGNhY2hlRnJvbVBvb2wgPSBwZWVrQ2FjaGVGcm9tUG9vbCgpO1xuXG4gIGlmIChjYWNoZUZyb21Qb29sID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIFdlIG11c3QgYWxzbyBzYXZlIHRoZSBwYXJlbnQsIHNvIHRoYXQgd2hlbiB3ZSByZXN1bWUgd2UgY2FuIGRldGVjdFxuICAgIC8vIGEgcmVmcmVzaC5cbiAgICBwYXJlbnQ6IGlzUHJpbWFyeVJlbmRlcmVyID8gQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUgOiBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsXG4gICAgcG9vbDogY2FjaGVGcm9tUG9vbFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0T2Zmc2NyZWVuRGVmZXJyZWRDYWNoZSgpIHtcblxuICB2YXIgY2FjaGVGcm9tUG9vbCA9IHBlZWtDYWNoZUZyb21Qb29sKCk7XG5cbiAgaWYgKGNhY2hlRnJvbVBvb2wgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gV2UgbXVzdCBhbHNvIHN0b3JlIHRoZSBwYXJlbnQsIHNvIHRoYXQgd2hlbiB3ZSByZXN1bWUgd2UgY2FuIGRldGVjdFxuICAgIC8vIGEgcmVmcmVzaC5cbiAgICBwYXJlbnQ6IGlzUHJpbWFyeVJlbmRlcmVyID8gQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUgOiBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsXG4gICAgcG9vbDogY2FjaGVGcm9tUG9vbFxuICB9O1xufVxuXG4vKipcbiAqIFRhZyB0aGUgZmliZXIgd2l0aCBhbiB1cGRhdGUgZWZmZWN0LiBUaGlzIHR1cm5zIGEgUGxhY2VtZW50IGludG9cbiAqIGEgUGxhY2VtZW50QW5kVXBkYXRlLlxuICovXG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xufVxuLyoqXG4gKiBJbiBwZXJzaXN0ZW50IG1vZGUsIHJldHVybiB3aGV0aGVyIHRoaXMgdXBkYXRlIG5lZWRzIHRvIGNsb25lIHRoZSBzdWJ0cmVlLlxuICovXG5cblxuZnVuY3Rpb24gZG9lc1JlcXVpcmVDbG9uZShjdXJyZW50LCBjb21wbGV0ZWRXb3JrKSB7XG4gIHZhciBkaWRCYWlsb3V0ID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gIGlmIChkaWRCYWlsb3V0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKChjb21wbGV0ZWRXb3JrLmZsYWdzICYgQ2hpbGREZWxldGlvbikgIT09IE5vRmxhZ3MkMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFRPRE86IElmIHdlIG1vdmUgdGhlIGBkb2VzUmVxdWlyZUNsb25lYCBjYWxsIGFmdGVyIGBidWJibGVQcm9wZXJ0aWVzYFxuICAvLyB0aGVuIHdlIG9ubHkgaGF2ZSB0byBjaGVjayB0aGUgYGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzYC5cblxuXG4gIHZhciBjaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgaWYgKChjaGlsZC5mbGFncyAmIE11dGF0aW9uTWFzaykgIT09IE5vRmxhZ3MkMSB8fCAoY2hpbGQuc3VidHJlZUZsYWdzICYgTXV0YXRpb25NYXNrKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZEFsbENoaWxkcmVuKHBhcmVudCwgd29ya0luUHJvZ3Jlc3MsIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSwgaXNIaWRkZW4pIHtcbiAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwgfHwgKHN1cHBvcnRzU2luZ2xldG9ucyA/IG5vZGUudGFnID09PSBIb3N0U2luZ2xldG9uIDogZmFsc2UpKSA7IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgdmFyIF9ub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICB3aGlsZSAoX25vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChfbm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gX25vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiYgaXNIaWRkZW4pIHtcbiAgICAgICAgICAvLyBUaGlzIGNoaWxkIGlzIGluc2lkZSBhIHRpbWVkIG91dCB0cmVlLiBIaWRlIGl0LlxuICAgICAgICAgIHZhciBwcm9wcyA9IF9ub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgdmFyIHR5cGUgPSBfbm9kZS50eXBlO1xuICAgICAgICAgIGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgaW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIGlmIChfbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UgPSBfbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJiBpc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG4gICAgICAgICAgdmFyIHRleHQgPSBfbm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIF9pbnN0YW5jZSA9IGNsb25lSGlkZGVuVGV4dEluc3RhbmNlKF9pbnN0YW5jZSwgdGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBfaW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIGlmIChfbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIDsgZWxzZSBpZiAoX25vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgJiYgX25vZGUubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgY2hpbGRyZW4gaW4gdGhpcyBib3VuZGFyeSBhcmUgaGlkZGVuLiBUb2dnbGUgdGhlaXIgdmlzaWJpbGl0eVxuICAgICAgICAvLyBiZWZvcmUgYXBwZW5kaW5nLlxuICAgICAgICB2YXIgY2hpbGQgPSBfbm9kZS5jaGlsZDtcblxuICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBjaGlsZC5yZXR1cm4gPSBfbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKHBhcmVudCwgX25vZGUsXG4gICAgICAgIC8qIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAqL1xuICAgICAgICB0cnVlLFxuICAgICAgICAvKiBpc0hpZGRlbiAqL1xuICAgICAgICB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoX25vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgX25vZGUuY2hpbGQucmV0dXJuID0gX25vZGU7XG4gICAgICAgIF9ub2RlID0gX25vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoX25vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgd2hpbGUgKF9ub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIGlmIChfbm9kZS5yZXR1cm4gPT09IG51bGwgfHwgX25vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF9ub2RlID0gX25vZGUucmV0dXJuO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICBfbm9kZS5zaWJsaW5nLnJldHVybiA9IF9ub2RlLnJldHVybjtcbiAgICAgIF9ub2RlID0gX25vZGUuc2libGluZztcbiAgICB9XG4gIH1cbn0gLy8gQW4gdW5mb3J0dW5hdGUgZm9yayBvZiBhcHBlbmRBbGxDaGlsZHJlbiBiZWNhdXNlIHdlIGhhdmUgdHdvIGRpZmZlcmVudCBwYXJlbnQgdHlwZXMuXG5cblxuZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihjb250YWluZXJDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MsIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSwgaXNIaWRkZW4pIHtcbiAgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJiBpc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG4gICAgICAgICAgdmFyIHByb3BzID0gbm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlO1xuICAgICAgICAgIGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICB2YXIgX2luc3RhbmNlMiA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiYgaXNIaWRkZW4pIHtcbiAgICAgICAgICAvLyBUaGlzIGNoaWxkIGlzIGluc2lkZSBhIHRpbWVkIG91dCB0cmVlLiBIaWRlIGl0LlxuICAgICAgICAgIHZhciB0ZXh0ID0gbm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIF9pbnN0YW5jZTIgPSBjbG9uZUhpZGRlblRleHRJbnN0YW5jZShfaW5zdGFuY2UyLCB0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgX2luc3RhbmNlMik7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBjaGlsZHJlbiBpbiB0aGlzIGJvdW5kYXJ5IGFyZSBoaWRkZW4uIFRvZ2dsZSB0aGVpciB2aXNpYmlsaXR5XG4gICAgICAgIC8vIGJlZm9yZSBhcHBlbmRpbmcuXG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgfSAvLyBJZiBPZmZzY3JlZW4gaXMgbm90IGluIG1hbnVhbCBtb2RlLCBkZXRhY2hlZCB0cmVlIGlzIGhpZGRlbiBmcm9tIHVzZXIgc3BhY2UuXG5cblxuICAgICAgICB2YXIgX25lZWRzVmlzaWJpbGl0eVRvZ2dsZSA9ICFpc09mZnNjcmVlbk1hbnVhbChub2RlKTtcblxuICAgICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKGNvbnRhaW5lckNoaWxkU2V0LCBub2RlLFxuICAgICAgICAvKiBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgKi9cbiAgICAgICAgX25lZWRzVmlzaWJpbGl0eVRvZ2dsZSxcbiAgICAgICAgLyogaXNIaWRkZW4gKi9cbiAgICAgICAgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlO1xuXG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0Q29udGFpbmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgaWYgKGRvZXNSZXF1aXJlQ2xvbmUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICB2YXIgcG9ydGFsT3JSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgdmFyIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoKTsgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuXG4gICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKG5ld0NoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIC8qIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAqL1xuICAgICAgZmFsc2UsXG4gICAgICAvKiBpc0hpZGRlbiAqL1xuICAgICAgZmFsc2UpO1xuICAgICAgcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbiA9IG5ld0NoaWxkU2V0OyAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuXG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkIHRvXG4gICAgLy8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgICAvLyBJbiBtdXRhdGlvbiBtb2RlLCB0aGlzIGlzIHN1ZmZpY2llbnQgZm9yIGEgYmFpbG91dCBiZWNhdXNlXG4gICAgICAvLyB3ZSB3b24ndCB0b3VjaCB0aGlzIG5vZGUgZXZlbiBpZiBjaGlsZHJlbiBjaGFuZ2VkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICB9IGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICB2YXIgY3VycmVudEluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgdmFyIF9vbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wczsgLy8gSWYgdGhlcmUgYXJlIG5vIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgdGhlbiBub25lIG9mIG91ciBjaGlsZHJlbiBoYWQgYW55IHVwZGF0ZXMuXG4gICAgLy8gVGhpcyBndWFyYW50ZWVzIHRoYXQgd2UgY2FuIHJldXNlIGFsbCBvZiB0aGVtLlxuXG4gICAgdmFyIHJlcXVpcmVzQ2xvbmUgPSBkb2VzUmVxdWlyZUNsb25lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmICghcmVxdWlyZXNDbG9uZSAmJiBfb2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1pZ2h0IHJlbGVhc2UgYSBwcmV2aW91cyBjbG9uZS5cbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICB2YXIgbmV3Q2hpbGRTZXQgPSBudWxsO1xuXG4gICAgaWYgKHJlcXVpcmVzQ2xvbmUgJiYgcGFzc0NoaWxkcmVuV2hlbkNsb25pbmdQZXJzaXN0ZWROb2Rlcykge1xuICAgICAgbmV3Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldCgpOyAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG5cbiAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzLFxuICAgICAgLyogbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICovXG4gICAgICBmYWxzZSxcbiAgICAgIC8qIGlzSGlkZGVuICovXG4gICAgICBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHR5cGUsIF9vbGRQcm9wcywgbmV3UHJvcHMsICFyZXF1aXJlc0Nsb25lLCBuZXdDaGlsZFNldCk7XG5cbiAgICBpZiAobmV3SW5zdGFuY2UgPT09IGN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAvLyBNYWtlIHN1cmUgc3VjaCByZW5kZXJlcnMgZ2V0IHNjaGVkdWxlZCBmb3IgbGF0ZXIgd29yay5cblxuXG4gICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKG5ld0luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbmV3SW5zdGFuY2U7XG5cbiAgICBpZiAoIXJlcXVpcmVzQ2xvbmUpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBlZmZlY3RzIGluIHRoaXMgdHJlZSwgd2UgbmVlZCB0byBmbGFnIHRoaXMgbm9kZSBhcyBoYXZpbmcgb25lLlxuICAgICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgbm90IGdvaW5nIHRvIHVzZSBpdCBmb3IgYW55dGhpbmcuXG4gICAgICAvLyBPdGhlcndpc2UgcGFyZW50cyB3b24ndCBrbm93IHRoYXQgdGhlcmUgYXJlIG5ldyBjaGlsZHJlbiB0byBwcm9wYWdhdGUgdXB3YXJkcy5cbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXdJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAvKiBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgKi9cbiAgICAgIGZhbHNlLFxuICAgICAgLyogaXNIaWRkZW4gKi9cbiAgICAgIGZhbHNlKTtcbiAgICB9XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIGNvbXBsZXRlIHBoYXNlLCBiZWNhdXNlXG4vLyBpdCBtaWdodCB0aHJvdyB0byBzdXNwZW5kLCBhbmQgaWYgdGhlIHJlc291cmNlIGltbWVkaWF0ZWx5IGxvYWRzLCB0aGUgd29ya1xuLy8gbG9vcCB3aWxsIHJlc3VtZSByZW5kZXJpbmcgYXMgaWYgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgY29tcGxldGVkLiBTbyBpdCBtdXN0XG4vLyBmdWxseSBjb21wbGV0ZS5cbi8vIFRPRE86IFRoaXMgc2hvdWxkIGlkZWFsbHkgbW92ZSB0byBiZWdpbiBwaGFzZSwgYnV0IGN1cnJlbnRseSB0aGUgaW5zdGFuY2UgaXNcbi8vIG5vdCBjcmVhdGVkIHVudGlsIHRoZSBjb21wbGV0ZSBwaGFzZS4gRm9yIG91ciBleGlzdGluZyB1c2UgY2FzZXMsIGhvc3Qgbm9kZXNcbi8vIHRoYXQgc3VzcGVuZCBkb24ndCBoYXZlIGNoaWxkcmVuLCBzbyBpdCBkb2Vzbid0IG1hdHRlci4gQnV0IHRoYXQgbWlnaHQgbm90XG4vLyBhbHdheXMgYmUgdHJ1ZSBpbiB0aGUgZnV0dXJlLlxuXG5cbmZ1bmN0aW9uIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgdHlwZSwgcHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIGlmICghbWF5U3VzcGVuZENvbW1pdCh0eXBlLCBwcm9wcykpIHtcbiAgICAvLyBJZiB0aGlzIGZsYWcgd2FzIHNldCBwcmV2aW91c2x5LCB3ZSBjYW4gcmVtb3ZlIGl0LiBUaGUgZmxhZ1xuICAgIC8vIHJlcHJlc2VudHMgd2hldGhlciB0aGlzIHBhcnRpY3VsYXIgc2V0IG9mIHByb3BzIG1pZ2h0IGV2ZXIgbmVlZCB0b1xuICAgIC8vIHN1c3BlbmQuIFRoZSBzYWZlc3QgdGhpbmcgdG8gZG8gaXMgZm9yIG1heVN1c3BlbmRDb21taXQgdG8gYWx3YXlzXG4gICAgLy8gcmV0dXJuIHRydWUsIGJ1dCBpZiB0aGUgcmVuZGVyZXIgaXMgcmVhc29uYWJseSBjb25maWRlbnQgdGhhdCB0aGVcbiAgICAvLyB1bmRlcmx5aW5nIHJlc291cmNlIHdvbid0IGJlIGV2aWN0ZWQsIGl0IGNhbiByZXR1cm4gZmFsc2UgYXMgYVxuICAgIC8vIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+TWF5U3VzcGVuZENvbW1pdDtcbiAgICByZXR1cm47XG4gIH0gLy8gTWFyayB0aGlzIGZpYmVyIHdpdGggYSBmbGFnLiBUaGlzIGdldHMgc2V0IG9uIGFsbCBob3N0IGluc3RhbmNlc1xuICAvLyB0aGF0IG1pZ2h0IHBvc3NpYmx5IHN1c3BlbmQsIGV2ZW4gaWYgdGhleSBkb24ndCBuZWVkIHRvIHN1c3BlbmRcbiAgLy8gY3VycmVudGx5LiBXZSB1c2UgdGhpcyB3aGVuIHJldmVhbGluZyBhIHByZXJlbmRlcmVkIHRyZWUsIGJlY2F1c2VcbiAgLy8gZXZlbiB0aG91Z2ggdGhlIHRyZWUgaGFzIFwibW91bnRlZFwiLCBpdHMgcmVzb3VyY2VzIG1pZ2h0IG5vdCBoYXZlXG4gIC8vIGxvYWRlZCB5ZXQuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBNYXlTdXNwZW5kQ29tbWl0OyAvLyBwcmVsb2FkIHRoZSBpbnN0YW5jZSBpZiBuZWNlc3NhcnkuIEV2ZW4gaWYgdGhpcyBpcyBhbiB1cmdlbnQgcmVuZGVyIHRoZXJlXG4gIC8vIGNvdWxkIGJlIGJlbmVmaXRzIHRvIHByZWxvYWRpbmcgZWFybHkuXG4gIC8vIEBUT0RPIHdlIHNob3VsZCBwcm9iYWJseSBkbyB0aGUgcHJlbG9hZCBpbiBiZWdpbiB3b3JrXG5cbiAgdmFyIGlzUmVhZHkgPSBwcmVsb2FkSW5zdGFuY2UodHlwZSwgcHJvcHMpO1xuXG4gIGlmICghaXNSZWFkeSkge1xuICAgIGlmIChzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuKCkpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZFN1c3BlbmRDb21taXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1c3BlbmRDb21taXQoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCByZXNvdXJjZSwgdHlwZSwgcHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgaXMgYSBmb3JrIG9mIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZCwgYnV0IGZvciByZXNvdXJjZXMuXG4gIGlmICghbWF5UmVzb3VyY2VTdXNwZW5kQ29tbWl0KHJlc291cmNlKSkge1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5NYXlTdXNwZW5kQ29tbWl0O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IE1heVN1c3BlbmRDb21taXQ7XG4gIHZhciBpc1JlYWR5ID0gcHJlbG9hZFJlc291cmNlKHJlc291cmNlKTtcblxuICBpZiAoIWlzUmVhZHkpIHtcbiAgICBpZiAoc2hvdWxkUmVtYWluT25QcmV2aW91c1NjcmVlbigpKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRTdXNwZW5kQ29tbWl0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXNwZW5kQ29tbWl0KCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHJldHJ5UXVldWUpIHtcbiAgdmFyIHdha2VhYmxlcyA9IHJldHJ5UXVldWU7XG5cbiAgaWYgKHdha2VhYmxlcyAhPT0gbnVsbCkge1xuICAgIC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggYSByZXRyeSBsaXN0ZW5lciB0byB0aGUgcHJvbWlzZS5cbiAgICAvLyBUT0RPOiBNb3ZlIHRvIHBhc3NpdmUgcGhhc2VcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBib3VuZGFyeSBzdXNwZW5kZWQsIGJ1dCBubyB3YWtlYWJsZXMgd2VyZSBhZGRlZCB0byB0aGUgcmV0cnlcbiAgICAvLyBxdWV1ZS4gQ2hlY2sgaWYgdGhlIHJlbmRlcmVyIHN1c3BlbmRlZCBjb21taXQuIElmIHNvLCB0aGlzIG1lYW5zXG4gICAgLy8gdGhhdCBvbmNlIHRoZSBmYWxsYmFjayBpcyBjb21taXR0ZWQsIHdlIGNhbiBpbW1lZGlhdGVseSByZXRyeVxuICAgIC8vIHJlbmRlcmluZyBhZ2FpbiwgYmVjYXVzZSByZW5kZXJpbmcgd2Fzbid0IGFjdHVhbGx5IGJsb2NrZWQuIE9ubHlcbiAgICAvLyB0aGUgY29tbWl0IHBoYXNlLlxuICAgIC8vIFRPRE86IENvbnNpZGVyIGEgbW9kZWwgd2hlcmUgd2UgYWx3YXlzIHNjaGVkdWxlIGFuIGltbWVkaWF0ZSByZXRyeSwgZXZlblxuICAgIC8vIGZvciBub3JtYWwgU3VzcGVuc2UuIFRoYXQgd2F5IHRoZSByZXRyeSBjYW4gcGFydGlhbGx5IHJlbmRlciB1cCB0byB0aGVcbiAgICAvLyBmaXJzdCB0aGluZyB0aGF0IHN1c3BlbmRzLlxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIFNjaGVkdWxlUmV0cnkpIHtcbiAgICAgIHZhciByZXRyeUxhbmUgPSAvLyBUT0RPOiBUaGlzIGNoZWNrIHNob3VsZCBwcm9iYWJseSBiZSBtb3ZlZCBpbnRvIGNsYWltTmV4dFJldHJ5TGFuZVxuICAgICAgLy8gSSBhbHNvIHN1c3BlY3QgdGhhdCB3ZSBuZWVkIHNvbWUgZnVydGhlciBjb25zb2xpZGF0aW9uIG9mIG9mZnNjcmVlblxuICAgICAgLy8gYW5kIHJldHJ5IGxhbmVzLlxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnICE9PSBPZmZzY3JlZW5Db21wb25lbnQgPyBjbGFpbU5leHRSZXRyeUxhbmUoKSA6IE9mZnNjcmVlbkxhbmU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIHJldHJ5TGFuZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgIC8vIElmIHRoZSB0ZXh0IGNvbnRlbnQgZGlmZmVycywgd2UnbGwgY3JlYXRlIGEgbmV3IHRleHQgaW5zdGFuY2UgZm9yIGl0LlxuICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpOyAvLyBXZSdsbCBoYXZlIHRvIG1hcmsgaXQgYXMgaGF2aW5nIGFuIGVmZmVjdCwgZXZlbiB0aG91Z2ggd2Ugd29uJ3QgdXNlIHRoZSBlZmZlY3QgZm9yIGFueXRoaW5nLlxuICAgICAgLy8gVGhpcyBsZXRzIHRoZSBwYXJlbnRzIGtub3cgdGhhdCBhdCBsZWFzdCBvbmUgb2YgdGhlaXIgY2hpbGRyZW4gaGFzIGNoYW5nZWQuXG5cbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spIHtcbiAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAvLyBJZiB3ZSdyZSBoeWRyYXRpbmcsIHdlIHNob3VsZCBjb25zdW1lIGFzIG1hbnkgaXRlbXMgYXMgd2UgY2FuXG4gICAgLy8gc28gd2UgZG9uJ3QgbGVhdmUgYW55IGJlaGluZC5cbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKHJlbmRlclN0YXRlLnRhaWxNb2RlKSB7XG4gICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgIHtcbiAgICAgICAgLy8gQW55IGluc2VydGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgdGFpbCBsaXN0IGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIGludmlzaWJsZS4gSWYgdGhlcmUgYXJlIGFscmVhZHkgbW91bnRlZCBib3VuZGFyaWVzXG4gICAgICAgIC8vIGFueXRoaW5nIGJlZm9yZSB0aGVtIGFyZSBub3QgY29uc2lkZXJlZCBmb3IgY29sbGFwc2luZy5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgdGFpbCB0byBmaW5kIGlmXG4gICAgICAgIC8vIHRoZXJlIGFyZSBhbnkuXG4gICAgICAgIHZhciB0YWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgIHZhciBsYXN0VGFpbE5vZGUgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlICh0YWlsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0YWlsTm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxhc3RUYWlsTm9kZSA9IHRhaWxOb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhaWxOb2RlID0gdGFpbE5vZGUuc2libGluZztcbiAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIHNpbXBseSBnb2luZyB0byBkZWxldGUgYWxsIGluc2VydGlvbnMgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cblxuXG4gICAgICAgIGlmIChsYXN0VGFpbE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBBbGwgcmVtYWluaW5nIGl0ZW1zIGluIHRoZSB0YWlsIGFyZSBpbnNlcnRpb25zLlxuICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERldGFjaCB0aGUgaW5zZXJ0aW9uIGFmdGVyIHRoZSBsYXN0IG5vZGUgdGhhdCB3YXMgYWxyZWFkeVxuICAgICAgICAgIC8vIGluc2VydGVkLlxuICAgICAgICAgIGxhc3RUYWlsTm9kZS5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnY29sbGFwc2VkJzpcbiAgICAgIHtcbiAgICAgICAgLy8gQW55IGluc2VydGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgdGFpbCBsaXN0IGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIGludmlzaWJsZS4gSWYgdGhlcmUgYXJlIGFscmVhZHkgbW91bnRlZCBib3VuZGFyaWVzXG4gICAgICAgIC8vIGFueXRoaW5nIGJlZm9yZSB0aGVtIGFyZSBub3QgY29uc2lkZXJlZCBmb3IgY29sbGFwc2luZy5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgdGFpbCB0byBmaW5kIGlmXG4gICAgICAgIC8vIHRoZXJlIGFyZSBhbnkuXG4gICAgICAgIHZhciBfdGFpbE5vZGUgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICB2YXIgX2xhc3RUYWlsTm9kZSA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKF90YWlsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChfdGFpbE5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfbGFzdFRhaWxOb2RlID0gX3RhaWxOb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90YWlsTm9kZSA9IF90YWlsTm9kZS5zaWJsaW5nO1xuICAgICAgICB9IC8vIE5leHQgd2UncmUgc2ltcGx5IGdvaW5nIHRvIGRlbGV0ZSBhbGwgaW5zZXJ0aW9ucyBhZnRlciB0aGVcbiAgICAgICAgLy8gbGFzdCByZW5kZXJlZCBpdGVtLlxuXG5cbiAgICAgICAgaWYgKF9sYXN0VGFpbE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBBbGwgcmVtYWluaW5nIGl0ZW1zIGluIHRoZSB0YWlsIGFyZSBpbnNlcnRpb25zLlxuICAgICAgICAgIGlmICghaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrICYmIHJlbmRlclN0YXRlLnRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlIHN1c3BlbmRlZCBkdXJpbmcgdGhlIGhlYWQuIFdlIHdhbnQgdG8gc2hvdyBhdCBsZWFzdCBvbmVcbiAgICAgICAgICAgIC8vIHJvdyBhdCB0aGUgdGFpbC4gU28gd2UnbGwga2VlcCBvbiBhbmQgY3V0IG9mZiB0aGUgcmVzdC5cbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwuc2libGluZyA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZXRhY2ggdGhlIGluc2VydGlvbiBhZnRlciB0aGUgbGFzdCBub2RlIHRoYXQgd2FzIGFscmVhZHlcbiAgICAgICAgICAvLyBpbnNlcnRlZC5cbiAgICAgICAgICBfbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnViYmxlUHJvcGVydGllcyhjb21wbGV0ZWRXb3JrKSB7XG4gIHZhciBkaWRCYWlsb3V0ID0gY29tcGxldGVkV29yay5hbHRlcm5hdGUgIT09IG51bGwgJiYgY29tcGxldGVkV29yay5hbHRlcm5hdGUuY2hpbGQgPT09IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG4gIHZhciBuZXdDaGlsZExhbmVzID0gTm9MYW5lcztcbiAgdmFyIHN1YnRyZWVGbGFncyA9IE5vRmxhZ3MkMTtcblxuICBpZiAoIWRpZEJhaWxvdXQpIHtcbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICBpZiAoKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAvLyBJbiBwcm9maWxpbmcgbW9kZSwgcmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lIGlzIGFsc28gdXNlZCB0byByZXNldFxuICAgICAgLy8gcHJvZmlsZXIgZHVyYXRpb25zLlxuICAgICAgdmFyIGFjdHVhbER1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgIHZhciB0cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoY2hpbGQubGFuZXMsIGNoaWxkLmNoaWxkTGFuZXMpKTtcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IGNoaWxkLnN1YnRyZWVGbGFncztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IGNoaWxkLmZsYWdzOyAvLyBXaGVuIGEgZmliZXIgaXMgY2xvbmVkLCBpdHMgYWN0dWFsRHVyYXRpb24gaXMgcmVzZXQgdG8gMC4gVGhpcyB2YWx1ZSB3aWxsXG4gICAgICAgIC8vIG9ubHkgYmUgdXBkYXRlZCBpZiB3b3JrIGlzIGRvbmUgb24gdGhlIGZpYmVyIChpLmUuIGl0IGRvZXNuJ3QgYmFpbG91dCkuXG4gICAgICAgIC8vIFdoZW4gd29yayBpcyBkb25lLCBpdCBzaG91bGQgYnViYmxlIHRvIHRoZSBwYXJlbnQncyBhY3R1YWxEdXJhdGlvbi4gSWZcbiAgICAgICAgLy8gdGhlIGZpYmVyIGhhcyBub3QgYmVlbiBjbG9uZWQgdGhvdWdoLCAobWVhbmluZyBubyB3b3JrIHdhcyBkb25lKSwgdGhlblxuICAgICAgICAvLyB0aGlzIHZhbHVlIHdpbGwgcmVmbGVjdCB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgd29ya2luZyBvbiBhIHByZXZpb3VzXG4gICAgICAgIC8vIHJlbmRlci4gSW4gdGhhdCBjYXNlIGl0IHNob3VsZCBub3QgYnViYmxlLiBXZSBkZXRlcm1pbmUgd2hldGhlciBpdCB3YXNcbiAgICAgICAgLy8gY2xvbmVkIGJ5IGNvbXBhcmluZyB0aGUgY2hpbGQgcG9pbnRlci5cbiAgICAgICAgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dIGFkZGl0aW9uIHdpdGggcG9zc2libGUgbnVsbC91bmRlZmluZWQgdmFsdWVcblxuICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjsgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dIGFkZGl0aW9uIHdpdGggcG9zc2libGUgbnVsbC91bmRlZmluZWQgdmFsdWVcblxuICAgICAgICB0cmVlQmFzZUR1cmF0aW9uICs9IGNoaWxkLnRyZWVCYXNlRHVyYXRpb247XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cblxuICAgICAgY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbiA9IGFjdHVhbER1cmF0aW9uO1xuICAgICAgY29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uID0gdHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChfY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhfY2hpbGQubGFuZXMsIF9jaGlsZC5jaGlsZExhbmVzKSk7XG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQuc3VidHJlZUZsYWdzO1xuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkLmZsYWdzOyAvLyBVcGRhdGUgdGhlIHJldHVybiBwb2ludGVyIHNvIHRoZSB0cmVlIGlzIGNvbnNpc3RlbnQuIFRoaXMgaXMgYSBjb2RlXG4gICAgICAgIC8vIHNtZWxsIGJlY2F1c2UgaXQgYXNzdW1lcyB0aGUgY29tbWl0IHBoYXNlIGlzIG5ldmVyIGNvbmN1cnJlbnQgd2l0aFxuICAgICAgICAvLyB0aGUgcmVuZGVyIHBoYXNlLiBXaWxsIGFkZHJlc3MgZHVyaW5nIHJlZmFjdG9yIHRvIGFsdGVybmF0ZSBtb2RlbC5cblxuICAgICAgICBfY2hpbGQucmV0dXJuID0gY29tcGxldGVkV29yaztcbiAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3MgfD0gc3VidHJlZUZsYWdzO1xuICB9IGVsc2Uge1xuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICAgIGlmICgoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgIC8vIEluIHByb2ZpbGluZyBtb2RlLCByZXNldENoaWxkRXhwaXJhdGlvblRpbWUgaXMgYWxzbyB1c2VkIHRvIHJlc2V0XG4gICAgICAvLyBwcm9maWxlciBkdXJhdGlvbnMuXG4gICAgICB2YXIgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLnNlbGZCYXNlRHVyYXRpb247XG4gICAgICB2YXIgX2NoaWxkMiA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChfY2hpbGQyICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoX2NoaWxkMi5sYW5lcywgX2NoaWxkMi5jaGlsZExhbmVzKSk7IC8vIFwiU3RhdGljXCIgZmxhZ3Mgc2hhcmUgdGhlIGxpZmV0aW1lIG9mIHRoZSBmaWJlci9ob29rIHRoZXkgYmVsb25nIHRvLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgYnViYmxlIHRob3NlIHVwIGV2ZW4gZHVyaW5nIGEgYmFpbG91dC4gQWxsIHRoZSBvdGhlclxuICAgICAgICAvLyBmbGFncyBoYXZlIGEgbGlmZXRpbWUgb25seSBvZiBhIHNpbmdsZSByZW5kZXIgKyBjb21taXQsIHNvIHdlIHNob3VsZFxuICAgICAgICAvLyBpZ25vcmUgdGhlbS5cblxuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkMi5zdWJ0cmVlRmxhZ3MgJiBTdGF0aWNNYXNrO1xuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkMi5mbGFncyAmIFN0YXRpY01hc2s7IC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXSBhZGRpdGlvbiB3aXRoIHBvc3NpYmxlIG51bGwvdW5kZWZpbmVkIHZhbHVlXG5cbiAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gKz0gX2NoaWxkMi50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICBfY2hpbGQyID0gX2NoaWxkMi5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBjb21wbGV0ZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jaGlsZDMgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkMyAhPT0gbnVsbCkge1xuICAgICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZDMubGFuZXMsIF9jaGlsZDMuY2hpbGRMYW5lcykpOyAvLyBcIlN0YXRpY1wiIGZsYWdzIHNoYXJlIHRoZSBsaWZldGltZSBvZiB0aGUgZmliZXIvaG9vayB0aGV5IGJlbG9uZyB0byxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGJ1YmJsZSB0aG9zZSB1cCBldmVuIGR1cmluZyBhIGJhaWxvdXQuIEFsbCB0aGUgb3RoZXJcbiAgICAgICAgLy8gZmxhZ3MgaGF2ZSBhIGxpZmV0aW1lIG9ubHkgb2YgYSBzaW5nbGUgcmVuZGVyICsgY29tbWl0LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaWdub3JlIHRoZW0uXG5cbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDMuc3VidHJlZUZsYWdzICYgU3RhdGljTWFzaztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDMuZmxhZ3MgJiBTdGF0aWNNYXNrOyAvLyBVcGRhdGUgdGhlIHJldHVybiBwb2ludGVyIHNvIHRoZSB0cmVlIGlzIGNvbnNpc3RlbnQuIFRoaXMgaXMgYSBjb2RlXG4gICAgICAgIC8vIHNtZWxsIGJlY2F1c2UgaXQgYXNzdW1lcyB0aGUgY29tbWl0IHBoYXNlIGlzIG5ldmVyIGNvbmN1cnJlbnQgd2l0aFxuICAgICAgICAvLyB0aGUgcmVuZGVyIHBoYXNlLiBXaWxsIGFkZHJlc3MgZHVyaW5nIHJlZmFjdG9yIHRvIGFsdGVybmF0ZSBtb2RlbC5cblxuICAgICAgICBfY2hpbGQzLnJldHVybiA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIF9jaGlsZDMgPSBfY2hpbGQzLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3MgfD0gc3VidHJlZUZsYWdzO1xuICB9XG5cbiAgY29tcGxldGVkV29yay5jaGlsZExhbmVzID0gbmV3Q2hpbGRMYW5lcztcbiAgcmV0dXJuIGRpZEJhaWxvdXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlRGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSkge1xuICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgaWYgKG5leHRTdGF0ZSAhPT0gbnVsbCAmJiBuZXh0U3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgIC8vIFdlIG1pZ2h0IGJlIGluc2lkZSBhIGh5ZHJhdGlvbiBzdGF0ZSB0aGUgZmlyc3QgdGltZSB3ZSdyZSBwaWNraW5nIHVwIHRoaXNcbiAgICAvLyBTdXNwZW5zZSBib3VuZGFyeSwgYW5kIGFsc28gYWZ0ZXIgd2UndmUgcmVlbnRlcmVkIGl0IGZvciBmdXJ0aGVyIGh5ZHJhdGlvbi5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgaWYgKCF3YXNIeWRyYXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgZGVoeWRyYXRlZCBzdXNwZW5zZSBjb21wb25lbnQgd2FzIGNvbXBsZXRlZCB3aXRob3V0IGEgaHlkcmF0ZWQgbm9kZS4gJyArICdUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuXG4gICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICB2YXIgaXNUaW1lZE91dFN1c3BlbnNlID0gbmV4dFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgICAgaWYgKGlzVGltZWRPdXRTdXNwZW5zZSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgICAgICAgICAgaWYgKHByaW1hcnlDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vICRGbG93Rml4TWVbdW5zYWZlLWFyaXRobWV0aWNdIEZsb3cgZG9lc24ndCBzdXBwb3J0IHR5cGUgY2FzdGluZyBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSAtPSBvcGVyYXRvclxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uIC09IHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncygpOyAvLyBXZSBtaWdodCBoYXZlIHJlZW50ZXJlZCB0aGlzIGJvdW5kYXJ5IHRvIGh5ZHJhdGUgaXQuIElmIHNvLCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBoeWRyYXRpb25cbiAgICAgIC8vIHN0YXRlIHNpbmNlIHdlJ3JlIG5vdyBleGl0aW5nIG91dCBvZiBpdC4gcG9wSHlkcmF0aW9uU3RhdGUgZG9lc24ndCBkbyB0aGF0IGZvciB1cy5cblxuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuXG4gICAgICBpZiAoKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAvLyBUaGlzIGJvdW5kYXJ5IGRpZCBub3Qgc3VzcGVuZCBzbyBpdCdzIG5vdyBoeWRyYXRlZCBhbmQgdW5zdXNwZW5kZWQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgfSAvLyBJZiBub3RoaW5nIHN1c3BlbmRlZCwgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBlZmZlY3QgdG8gbWFyayB0aGlzIGJvdW5kYXJ5XG4gICAgICAvLyBhcyBoYXZpbmcgaHlkcmF0ZWQgc28gZXZlbnRzIGtub3cgdGhhdCB0aGV5J3JlIGZyZWUgdG8gYmUgaW52b2tlZC5cbiAgICAgIC8vIEl0J3MgYWxzbyBhIHNpZ25hbCB0byByZXBsYXkgZXZlbnRzIGFuZCB0aGUgc3VzcGVuc2UgY2FsbGJhY2suXG4gICAgICAvLyBJZiBzb21ldGhpbmcgc3VzcGVuZGVkLCBzY2hlZHVsZSBhbiBlZmZlY3QgdG8gYXR0YWNoIHJldHJ5IGxpc3RlbmVycy5cbiAgICAgIC8vIFNvIHdlIG1pZ2h0IGFzIHdlbGwgYWx3YXlzIG1hcmsgdGhpcy5cblxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAge1xuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgIHZhciBfaXNUaW1lZE91dFN1c3BlbnNlID0gbmV4dFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgICAgaWYgKF9pc1RpbWVkT3V0U3VzcGVuc2UpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxuICAgICAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgICAgICAgICBpZiAoX3ByaW1hcnlDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vICRGbG93Rml4TWVbdW5zYWZlLWFyaXRobWV0aWNdIEZsb3cgZG9lc24ndCBzdXBwb3J0IHR5cGUgY2FzdGluZyBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSAtPSBvcGVyYXRvclxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uIC09IF9wcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgdGhpcyB0cmVlLiBJZiB0aGlzIHdhcyBhIGZvcmNlZCBjbGllbnQgcmVuZGVyLFxuICAgIC8vIHRoZXJlIG1heSBoYXZlIGJlZW4gcmVjb3ZlcmFibGUgZXJyb3JzIGR1cmluZyBmaXJzdCBoeWRyYXRpb25cbiAgICAvLyBhdHRlbXB0LiBJZiBzbywgYWRkIHRoZW0gdG8gYSBxdWV1ZSBzbyB3ZSBjYW4gbG9nIHRoZW0gaW4gdGhlXG4gICAgLy8gY29tbWl0IHBoYXNlLlxuICAgIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCk7IC8vIEZhbGwgdGhyb3VnaCB0byBub3JtYWwgU3VzcGVuc2UgcGF0aFxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7IC8vIE5vdGU6IFRoaXMgaW50ZW50aW9uYWxseSBkb2Vzbid0IGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZyBiZWNhdXNlIGNvbXBhcmluZ1xuICAvLyB0byB0aGUgY3VycmVudCB0cmVlIHByb3ZpZGVyIGZpYmVyIGlzIGp1c3QgYXMgZmFzdCBhbmQgbGVzcyBlcnJvci1wcm9uZS5cbiAgLy8gSWRlYWxseSB3ZSB3b3VsZCBoYXZlIGEgc3BlY2lhbCB2ZXJzaW9uIG9mIHRoZSB3b3JrIGxvb3Agb25seVxuICAvLyBmb3IgaHlkcmF0aW9uLlxuXG4gIHBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSW5jb21wbGV0ZUZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gRmFsbHRocm91Z2hcblxuICAgICAgfVxuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgIGNhc2UgTW9kZTpcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHZhciBmaWJlclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcmV2aW91c0NhY2hlID0gbnVsbDtcblxuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmV2aW91c0NhY2hlID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjYWNoZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGU7XG5cbiAgICAgICAgICBpZiAoY2FjaGUgIT09IHByZXZpb3VzQ2FjaGUpIHtcbiAgICAgICAgICAgIC8vIFJ1biBwYXNzaXZlIGVmZmVjdHMgdG8gcmV0YWluL3JlbGVhc2UgdGhlIGNhY2hlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGFzc2l2ZSQxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvcENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgIGlmIChmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgICAgICBmaWJlclJvb3QuY29udGV4dCA9IGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtcbiAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAvLyB0aGF0IHdlcmVuJ3QgaHlkcmF0ZWQuXG4gICAgICAgICAgdmFyIHdhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKHdhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICBlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCk7IC8vIElmIHdlIGh5ZHJhdGVkLCB0aGVuIHdlJ2xsIG5lZWQgdG8gc2NoZWR1bGUgYW4gdXBkYXRlIGZvclxuICAgICAgICAgICAgLy8gdGhlIGNvbW1pdCBzaWRlLWVmZmVjdHMgb24gdGhlIHJvb3QuXG5cbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgICAgIGlmICggLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGNsaWVudCByb290XG4gICAgICAgICAgICAgICFwcmV2U3RhdGUuaXNEZWh5ZHJhdGVkIHx8IC8vIENoZWNrIGlmIHdlIHJldmVydGVkIHRvIGNsaWVudCByZW5kZXJpbmcgKGUuZy4gZHVlIHRvIGFuIGVycm9yKVxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JjZUNsaWVudFJlbmRlcikgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBjbGVhciB0aGlzIGNvbnRhaW5lciBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dCBjb21taXQuIFRoaXMgaGFuZGxlcyB0aGUgY2FzZSBvZiBSZWFjdCByZW5kZXJpbmcgaW50byBhXG4gICAgICAgICAgICAgICAgLy8gY29udGFpbmVyIHdpdGggcHJldmlvdXMgY2hpbGRyZW4uIEl0J3MgYWxzbyBzYWZlIHRvIGRvIGZvclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgdG9vLCBiZWNhdXNlIGN1cnJlbnQuY2hpbGQgd291bGQgb25seSBiZSBudWxsIGlmIHRoZVxuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIHJlbmRlciB3YXMgbnVsbCAoc28gdGhlIGNvbnRhaW5lciB3b3VsZCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gYmUgZW1wdHkpLlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90OyAvLyBJZiB0aGlzIHdhcyBhIGZvcmNlZCBjbGllbnQgcmVuZGVyLCB0aGVyZSBtYXkgaGF2ZSBiZWVuXG4gICAgICAgICAgICAgICAgLy8gcmVjb3ZlcmFibGUgZXJyb3JzIGR1cmluZyBmaXJzdCBoeWRyYXRpb24gYXR0ZW1wdC4gSWYgc28sIGFkZFxuICAgICAgICAgICAgICAgIC8vIHRoZW0gdG8gYSBxdWV1ZSBzbyB3ZSBjYW4gbG9nIHRoZW0gaW4gdGhlIGNvbW1pdCBwaGFzZS5cblxuICAgICAgICAgICAgICAgIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgIC8vIFRoZSBicmFuY2hpbmcgaGVyZSBpcyBtb3JlIGNvbXBsaWNhdGVkIHRoYW4geW91IG1pZ2h0IGV4cGVjdCBiZWNhdXNlXG4gICAgICAgICAgLy8gYSBIb3N0SG9pc3RhYmxlIHNvbWV0aW1lcyBjb3JyZXNwb25kcyB0byBhIFJlc291cmNlIGFuZCBzb21ldGltZXNcbiAgICAgICAgICAvLyBjb3JyZXNwb25kcyB0byBhbiBJbnN0YW5jZS4gSXQgY2FuIGFsc28gc3dpdGNoIGR1cmluZyBhbiB1cGRhdGUuXG4gICAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgIHZhciBuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBtb3VudGluZyBhbmQgbXVzdCBVcGRhdGUgdGhpcyBIb2lzdGFibGUgaW4gdGhpcyBjb21taXRcbiAgICAgICAgICAgIC8vIEBUT0RPIHJlZmFjdG9yIHRoaXMgYmxvY2sgdG8gY3JlYXRlIHRoZSBpbnN0YW5jZSBoZXJlIGluIGNvbXBsZXRlXG4gICAgICAgICAgICAvLyBwaGFzZSBpZiB3ZSBhcmUgbm90IGh5ZHJhdGluZy5cbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICBpZiAobmV4dFJlc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBIb2lzdGFibGUgUmVzb3VyY2VcbiAgICAgICAgICAgICAgLy8gVGhpcyBtdXN0IGNvbWUgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBjb21wbGV0ZSBwaGFzZS5cbiAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIHByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgbmV4dFJlc291cmNlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgSG9pc3RhYmxlIEluc3RhbmNlXG4gICAgICAgICAgICAgIC8vIFRoaXMgbXVzdCBjb21lIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgY29tcGxldGUgcGhhc2UuXG4gICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSB1cGRhdGluZy5cbiAgICAgICAgICAgIHZhciBjdXJyZW50UmVzb3VyY2UgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgICAgIGlmIChuZXh0UmVzb3VyY2UgIT09IGN1cnJlbnRSZXNvdXJjZSkge1xuICAgICAgICAgICAgICAvLyBXZSBhcmUgdHJhbnNpdGlvbmluZyB0bywgZnJvbSwgb3IgYmV0d2VlbiBIb2lzdGFibGUgUmVzb3VyY2VzXG4gICAgICAgICAgICAgIC8vIGFuZCByZXF1aXJlIGFuIHVwZGF0ZVxuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5leHRSZXNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgSG9pc3RhYmxlIFJlc291cmNlXG4gICAgICAgICAgICAgIC8vIFRoaXMgbXVzdCBjb21lIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgY29tcGxldGUgcGhhc2UuXG4gICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIGlmIChuZXh0UmVzb3VyY2UgPT09IGN1cnJlbnRSZXNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5NYXlTdXNwZW5kQ29tbWl0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgbmV4dFJlc291cmNlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIEhvaXN0YWJsZSBJbnN0YW5jZVxuICAgICAgICAgICAgICAvLyBXZSBtYXkgaGF2ZSBwcm9wcyB0byB1cGRhdGUgb24gdGhlIEhvaXN0YWJsZSBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG5cbiAgICAgICAgICAgICAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSB1cGRhdGVIb3N0Q29tcG9uZW50IHBhdGggYmVjdWFzZSBpdCBwcm9kdWNlc1xuICAgICAgICAgICAgICAgIC8vIHRoZSB1cGRhdGUgcXVldWUgd2UgbmVlZCBmb3IgSG9pc3RhYmxlcy5cbiAgICAgICAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcyk7XG4gICAgICAgICAgICAgIH0gLy8gVGhpcyBtdXN0IGNvbWUgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBjb21wbGV0ZSBwaGFzZS5cblxuXG4gICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIF90eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgICB2YXIgX29sZFByb3BzMiA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgICAgICAgICAgICBpZiAoX29sZFByb3BzMiAhPT0gbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX3R5cGUsIG5ld1Byb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSAnICsgJ2NhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgICAgICAgIH0gLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cblxuXG4gICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG5cbiAgICAgICAgICAgIHZhciBfd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZTtcblxuICAgICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICAvLyBXZSBpZ25vcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGluZyB0aGVyZSBpcyBhbiB1cGRhdGVRdWV1ZSBiZWNhdXNlXG4gICAgICAgICAgICAgIC8vIGl0IGlzIHVzZWQgb25seSB0byBzZXQgdGV4dCBjaGlsZHJlbiBhbmQgSG9zdFNpbmdsZXRvbnMgZG8gbm90XG4gICAgICAgICAgICAgIC8vIHVzZSB0aGVtLlxuICAgICAgICAgICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdXJyZW50SG9zdENvbnRleHQpO1xuICAgICAgICAgICAgICBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlID0gcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlKF90eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQsIHRydWUpO1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgX3R5cGUyID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF90eXBlMiwgbmV3UHJvcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSAnICsgJ2NhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgICAgICB9IC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG5cblxuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7IC8vIFRPRE86IE1vdmUgY3JlYXRlSW5zdGFuY2UgdG8gYmVnaW5Xb3JrIGFuZCBrZWVwIGl0IG9uIGEgY29udGV4dFxuICAgICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdoZXRoZXIgd2Ugd2FudCB0byBhZGQgdGhlbSB0b3AtPmRvd24gb3JcbiAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG5cblxuICAgICAgICAgIHZhciBfd2FzSHlkcmF0ZWQyID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKF93YXNIeWRyYXRlZDIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBhbmQgY3JlYXRlSW5zdGFuY2Ugc3RlcCBpbnRvIHRoZSBiZWdpblBoYXNlXG4gICAgICAgICAgICAvLyB0byBjb25zb2xpZGF0ZS5cbiAgICAgICAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIF9jdXJyZW50SG9zdENvbnRleHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX3Jvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG5cbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UzID0gY3JlYXRlSW5zdGFuY2UoX3R5cGUyLCBuZXdQcm9wcywgX3Jvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpOyAvLyBUT0RPOiBGb3IgcGVyc2lzdGVudCByZW5kZXJlcnMsIHdlIHNob3VsZCBwYXNzIGNoaWxkcmVuIGFzIHBhcnRcbiAgICAgICAgICAgIC8vIG9mIHRoZSBpbml0aWFsIGluc3RhbmNlIGNyZWF0aW9uXG5cblxuICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4oX2luc3RhbmNlMywgd29ya0luUHJvZ3Jlc3MsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBfaW5zdGFuY2UzOyAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIHN1cHBvcnRzIGF1dG8tZm9jdXMgZm9yIGNlcnRhaW4gZWxlbWVudHMpLlxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHN1Y2ggcmVuZGVyZXJzIGdldCBzY2hlZHVsZWQgZm9yIGxhdGVyIHdvcmsuXG5cbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihfaW5zdGFuY2UzLCBfdHlwZTIsIG5ld1Byb3BzLCBfY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTsgLy8gVGhpcyBtdXN0IGNvbWUgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBjb21wbGV0ZSBwaGFzZSwgYmVjYXVzZSBpdCBtaWdodFxuICAgICAgICAvLyB0aHJvdyB0byBzdXNwZW5kLCBhbmQgaWYgdGhlIHJlc291cmNlIGltbWVkaWF0ZWx5IGxvYWRzLCB0aGUgd29yayBsb29wXG4gICAgICAgIC8vIHdpbGwgcmVzdW1lIHJlbmRlcmluZyBhcyBpZiB0aGUgd29yay1pbi1wcm9ncmVzcyBjb21wbGV0ZWQuIFNvIGl0IG11c3RcbiAgICAgICAgLy8gZnVsbHkgY29tcGxldGUuXG5cbiAgICAgICAgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHZhciBuZXdUZXh0ID0gbmV3UHJvcHM7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wczsgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWRcbiAgICAgICAgICAvLyB0byBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuXG4gICAgICAgICAgdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV3VGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSAnICsgJ2NhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgICAgICB9IC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3Jvb3RDb250YWluZXJJbnN0YW5jZTIgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQyID0gZ2V0SG9zdENvbnRleHQoKTtcblxuICAgICAgICAgIHZhciBfd2FzSHlkcmF0ZWQzID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKF93YXNIeWRyYXRlZDMpIHtcbiAgICAgICAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UyLCBfY3VycmVudEhvc3RDb250ZXh0Miwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlOyAvLyBTcGVjaWFsIHBhdGggZm9yIGRlaHlkcmF0ZWQgYm91bmRhcmllcy4gV2UgbWF5IGV2ZW50dWFsbHkgbW92ZSB0aGlzXG4gICAgICAgIC8vIHRvIGl0cyBvd24gZmliZXIgdHlwZSBzbyB0aGF0IHdlIGNhbiBhZGQgb3RoZXIga2luZHMgb2YgaHlkcmF0aW9uXG4gICAgICAgIC8vIGJvdW5kYXJpZXMgdGhhdCBhcmVuJ3QgYXNzb2NpYXRlZCB3aXRoIGEgU3VzcGVuc2UgdHJlZS4gSW4gYW50aWNpcGF0aW9uXG4gICAgICAgIC8vIG9mIHN1Y2ggYSByZWZhY3RvciwgYWxsIHRoZSBoeWRyYXRpb24gbG9naWMgaXMgY29udGFpbmVkIGluXG4gICAgICAgIC8vIHRoaXMgYnJhbmNoLlxuXG4gICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmYWxsdGhyb3VnaFRvTm9ybWFsU3VzcGVuc2VQYXRoID0gY29tcGxldGVEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFN0YXRlKTtcblxuICAgICAgICAgIGlmICghZmFsbHRocm91Z2hUb05vcm1hbFN1c3BlbnNlUGF0aCkge1xuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9yY2VDbGllbnRSZW5kZXIpIHtcbiAgICAgICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTsgLy8gU3BlY2lhbCBjYXNlLiBUaGVyZSB3ZXJlIHJlbWFpbmluZyB1bmh5ZHJhdGVkIG5vZGVzLiBXZSB0cmVhdFxuICAgICAgICAgICAgICAvLyB0aGlzIGFzIGEgbWlzbWF0Y2guIFJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlxuXG4gICAgICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7IC8vIERpZCBub3QgZmluaXNoIGh5ZHJhdGluZywgZWl0aGVyIGJlY2F1c2UgdGhpcyBpcyB0aGUgaW5pdGlhbFxuICAgICAgICAgICAgICAvLyByZW5kZXIgb3IgYmVjYXVzZSBzb21ldGhpbmcgc3VzcGVuZGVkLlxuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gQ29udGludWUgd2l0aCB0aGUgbm9ybWFsIFN1c3BlbnNlIHBhdGguXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkLiBSZS1yZW5kZXIgd2l0aCB0aGUgZmFsbGJhY2sgY2hpbGRyZW4uXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lczsgLy8gRG8gbm90IHJlc2V0IHRoZSBlZmZlY3QgbGlzdC5cblxuICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9IC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FzZS5cblxuXG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5leHREaWRUaW1lb3V0ID0gbmV4dFN0YXRlICE9PSBudWxsO1xuICAgICAgICB2YXIgcHJldkRpZFRpbWVvdXQgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQpIHtcbiAgICAgICAgICB2YXIgb2Zmc2NyZWVuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICB2YXIgX3ByZXZpb3VzQ2FjaGUgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKG9mZnNjcmVlbkZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBvZmZzY3JlZW5GaWJlci5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCAmJiBvZmZzY3JlZW5GaWJlci5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF9wcmV2aW91c0NhY2hlID0gb2Zmc2NyZWVuRmliZXIuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2w7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9jYWNoZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAob2Zmc2NyZWVuRmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCAmJiBvZmZzY3JlZW5GaWJlci5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX2NhY2hlID0gb2Zmc2NyZWVuRmliZXIubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2NhY2hlICE9PSBfcHJldmlvdXNDYWNoZSkge1xuICAgICAgICAgICAgLy8gUnVuIHBhc3NpdmUgZWZmZWN0cyB0byByZXRhaW4vcmVsZWFzZSB0aGUgY2FjaGUuXG4gICAgICAgICAgICBvZmZzY3JlZW5GaWJlci5mbGFncyB8PSBQYXNzaXZlJDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIElmIHRoZSBzdXNwZW5kZWQgc3RhdGUgb2YgdGhlIGJvdW5kYXJ5IGNoYW5nZXMsIHdlIG5lZWQgdG8gc2NoZWR1bGVcbiAgICAgICAgLy8gYSBwYXNzaXZlIGVmZmVjdCwgd2hpY2ggaXMgd2hlbiB3ZSBwcm9jZXNzIHRoZSB0cmFuc2l0aW9uc1xuXG5cbiAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0ICE9PSBwcmV2RGlkVGltZW91dCkge1xuICAgICAgICAgIC8vIGFuIGVmZmVjdCB0byB0b2dnbGUgdGhlIHN1YnRyZWUncyB2aXNpYmlsaXR5LiBXaGVuIHdlIHN3aXRjaCBmcm9tXG4gICAgICAgICAgLy8gZmFsbGJhY2sgLT4gcHJpbWFyeSwgdGhlIGlubmVyIE9mZnNjcmVlbiBmaWJlciBzY2hlZHVsZXMgdGhpcyBlZmZlY3RcbiAgICAgICAgICAvLyBhcyBwYXJ0IG9mIGl0cyBub3JtYWwgY29tcGxldGUgcGhhc2UuIEJ1dCB3aGVuIHdlIHN3aXRjaCBmcm9tXG4gICAgICAgICAgLy8gcHJpbWFyeSAtPiBmYWxsYmFjaywgdGhlIGlubmVyIE9mZnNjcmVlbiBmaWJlciBkb2VzIG5vdCBoYXZlIGEgY29tcGxldGVcbiAgICAgICAgICAvLyBwaGFzZS4gU28gd2UgbmVlZCB0byBzY2hlZHVsZSBpdHMgZWZmZWN0IGhlcmUuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBXZSBhbHNvIHVzZSB0aGlzIGZsYWcgdG8gY29ubmVjdC9kaXNjb25uZWN0IHRoZSBlZmZlY3RzLCBidXQgdGhlIHNhbWVcbiAgICAgICAgICAvLyBsb2dpYyBhcHBsaWVzOiB3aGVuIHJlLWNvbm5lY3RpbmcsIHRoZSBPZmZzY3JlZW4gZmliZXIncyBjb21wbGV0ZVxuICAgICAgICAgIC8vIHBoYXNlIHdpbGwgaGFuZGxlIHNjaGVkdWxpbmcgdGhlIGVmZmVjdC4gSXQncyBvbmx5IHdoZW4gdGhlIGZhbGxiYWNrXG4gICAgICAgICAgLy8gaXMgYWN0aXZlIHRoYXQgd2UgaGF2ZSB0byBkbyBhbnl0aGluZyBzcGVjaWFsLlxuXG5cbiAgICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQpIHtcbiAgICAgICAgICAgIHZhciBfb2Zmc2NyZWVuRmliZXIyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICBfb2Zmc2NyZWVuRmliZXIyLmZsYWdzIHw9IFZpc2liaWxpdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldHJ5UXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgcmV0cnlRdWV1ZSk7XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgICAgICAgICAgIGlmIChwcmltYXJ5Q2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vICRGbG93Rml4TWVbdW5zYWZlLWFyaXRobWV0aWNdIEZsb3cgZG9lc24ndCBzdXBwb3J0IHR5cGUgY2FzdGluZyBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSAtPSBvcGVyYXRvclxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgcHJlcGFyZVBvcnRhbE1vdW50KHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgIH1cblxuICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgLy8gUG9wIHByb3ZpZGVyIGZpYmVyXG4gICAgICB2YXIgY29udGV4dDtcblxuICAgICAge1xuICAgICAgICBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIH1cblxuICAgICAgcG9wUHJvdmlkZXIoY29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gU2FtZSBhcyBjbGFzcyBjb21wb25lbnQgY2FzZS4gSSBwdXQgaXQgZG93biBoZXJlIHNvIHRoYXQgdGhlIHRhZ3MgYXJlXG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wU3VzcGVuc2VMaXN0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKHJlbmRlclN0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UncmUgcnVubmluZyBpbiB0aGUgZGVmYXVsdCwgXCJpbmRlcGVuZGVudFwiIG1vZGUuXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgZG8gYW55dGhpbmcgaW4gdGhpcyBtb2RlLlxuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZFN1c3BlbmRBbHJlYWR5ID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MkMTtcbiAgICAgICAgdmFyIHJlbmRlcmVkVGFpbCA9IHJlbmRlclN0YXRlLnJlbmRlcmluZztcblxuICAgICAgICBpZiAocmVuZGVyZWRUYWlsID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UganVzdCByZW5kZXJlZCB0aGUgaGVhZC5cbiAgICAgICAgICBpZiAoIWRpZFN1c3BlbmRBbHJlYWR5KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBwYXNzLiBXZSBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgYW55dGhpbmcgaXMgc3RpbGxcbiAgICAgICAgICAgIC8vIHN1c3BlbmRlZCBpbiB0aGUgcmVuZGVyZWQgc2V0LlxuICAgICAgICAgICAgLy8gSWYgbmV3IGNvbnRlbnQgdW5zdXNwZW5kZWQsIGJ1dCB0aGVyZSdzIHN0aWxsIHNvbWUgY29udGVudCB0aGF0XG4gICAgICAgICAgICAvLyBkaWRuJ3QuIFRoZW4gd2UgbmVlZCB0byBkbyBhIHNlY29uZCBwYXNzIHRoYXQgZm9yY2VzIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgIC8vIHRvIGtlZXAgc2hvd2luZyB0aGVpciBmYWxsYmFja3MuXG4gICAgICAgICAgICAvLyBXZSBtaWdodCBiZSBzdXNwZW5kZWQgaWYgc29tZXRoaW5nIGluIHRoaXMgcmVuZGVyIHBhc3Mgc3VzcGVuZGVkLCBvclxuICAgICAgICAgICAgLy8gc29tZXRoaW5nIGluIHRoZSBwcmV2aW91cyBjb21taXR0ZWQgcGFzcyBzdXNwZW5kZWQuIE90aGVyd2lzZSxcbiAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gY2hhbmNlIHNvIHdlIGNhbiBza2lwIHRoZSBleHBlbnNpdmUgY2FsbCB0b1xuICAgICAgICAgICAgLy8gZmluZEZpcnN0U3VzcGVuZGVkLlxuICAgICAgICAgICAgdmFyIGNhbm5vdEJlU3VzcGVuZGVkID0gcmVuZGVySGFzTm90U3VzcGVuZGVkWWV0KCkgJiYgKGN1cnJlbnQgPT09IG51bGwgfHwgKGN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncyQxKTtcblxuICAgICAgICAgICAgaWYgKCFjYW5ub3RCZVN1c3BlbmRlZCkge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBzdXNwZW5kZWQgPSBmaW5kRmlyc3RTdXNwZW5kZWQocm93KTtcblxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5kZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gSWYgdGhpcyBpcyBhIG5ld2x5IHN1c3BlbmRlZCB0cmVlLCBpdCBtaWdodCBub3QgZ2V0IGNvbW1pdHRlZCBhc1xuICAgICAgICAgICAgICAgICAgLy8gcGFydCBvZiB0aGUgc2Vjb25kIHBhc3MuIEluIHRoYXQgY2FzZSBub3RoaW5nIHdpbGwgc3Vic2NyaWJlIHRvXG4gICAgICAgICAgICAgICAgICAvLyBpdHMgdGhlbmFibGVzLiBJbnN0ZWFkLCB3ZSdsbCB0cmFuc2ZlciBpdHMgdGhlbmFibGVzIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgLy8gU3VzcGVuc2VMaXN0IHNvIHRoYXQgaXQgY2FuIHJldHJ5IGlmIHRoZXkgcmVzb2x2ZS5cbiAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIG9mIHRoZXNlIGluIHRoZSBsaXN0IGJ1dCBzaW5jZSB3ZSdyZVxuICAgICAgICAgICAgICAgICAgLy8gZ29pbmcgdG8gd2FpdCBmb3IgYWxsIG9mIHRoZW0gYW55d2F5LCBpdCBkb2Vzbid0IHJlYWxseSBtYXR0ZXJcbiAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIG9uZXMgZ2V0cyB0byBwaW5nLiBJbiB0aGVvcnkgd2UgY291bGQgZ2V0IGNsZXZlciBhbmQga2VlcFxuICAgICAgICAgICAgICAgICAgLy8gdHJhY2sgb2YgaG93IG1hbnkgZGVwZW5kZW5jaWVzIHJlbWFpbiBidXQgaXQgZ2V0cyB0cmlja3kgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIG1lYW50aW1lLCB3ZSBjYW4gYWRkL3JlbW92ZS9jaGFuZ2UgaXRlbXMgYW5kIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJhaWwgb3V0IG9mIHRoZSBsb29wIGJlZm9yZSBmaW5kaW5nIGFueSBidXQgdGhhdFxuICAgICAgICAgICAgICAgICAgLy8gZG9lc24ndCBtYXR0ZXIgc2luY2UgdGhhdCBtZWFucyB0aGF0IHRoZSBvdGhlciBib3VuZGFyaWVzIHRoYXRcbiAgICAgICAgICAgICAgICAgIC8vIHdlIGRpZCBmaW5kIGFscmVhZHkgaGFzIHRoZWlyIGxpc3RlbmVycyBhdHRhY2hlZC5cblxuICAgICAgICAgICAgICAgICAgdmFyIF9yZXRyeVF1ZXVlID0gc3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBfcmV0cnlRdWV1ZTtcbiAgICAgICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIF9yZXRyeVF1ZXVlKTsgLy8gUmVyZW5kZXIgdGhlIHdob2xlIGxpc3QsIGJ1dCB0aGlzIHRpbWUsIHdlJ2xsIGZvcmNlIGZhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgLy8gdG8gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgZmxhZ3MgYmVmb3JlIGRvaW5nIHRoZSBzZWNvbmQgcGFzcyBzaW5jZSB0aGF0J3Mgbm93IGludmFsaWQuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgY2hpbGQgZmliZXJzIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlLlxuXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzJDE7XG4gICAgICAgICAgICAgICAgICByZXNldENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7IC8vIFNldCB1cCB0aGUgU3VzcGVuc2UgTGlzdCBDb250ZXh0IHRvIGZvcmNlIHN1c3BlbnNlIGFuZFxuICAgICAgICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHkgcmVyZW5kZXIgdGhlIGNoaWxkcmVuLlxuXG4gICAgICAgICAgICAgICAgICBwdXNoU3VzcGVuc2VMaXN0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc2V0U2hhbGxvd1N1c3BlbnNlTGlzdENvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spKTsgLy8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgaW4gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm93ID0gcm93LnNpYmxpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLnRhaWwgIT09IG51bGwgJiYgbm93JDEoKSA+IGdldFJlbmRlclRhcmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYnV0IHdlIHN0aWxsIGhhdmUgcm93c1xuICAgICAgICAgICAgICAvLyBsZWZ0IGluIHRoZSB0YWlsLiBXZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlciBhdHRlbXB0cyB0byByZW5kZXJcbiAgICAgICAgICAgICAgLy8gdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBTaW5jZSBub3RoaW5nIGFjdHVhbGx5IHN1c3BlbmRlZCwgdGhlcmUgd2lsbCBub3RoaW5nIHRvIHBpbmcgdGhpc1xuICAgICAgICAgICAgICAvLyB0byBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXNcbiAgICAgICAgICAgICAgLy8gb2YgcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyYW5zaXRpb24gb25jZSB0aGUgdHJhbnNpdGlvbiBoYXNcbiAgICAgICAgICAgICAgLy8gY29tbWl0dGVkLiBJZiBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmVcbiAgICAgICAgICAgICAgLy8gcGFpbnRlZC4gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLlxuICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGFueSBSZXRyeUxhbmUgZXZlbiBpZiBpdCdzIHRoZSBvbmUgY3VycmVudGx5IHJlbmRlcmluZ1xuICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBsZWF2aW5nIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBTb21lUmV0cnlMYW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgICB9IC8vIE5leHQgd2UncmUgZ29pbmcgdG8gcmVuZGVyIHRoZSB0YWlsLlxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQXBwZW5kIHRoZSByZW5kZXJlZCByb3cgdG8gdGhlIGNoaWxkIGxpc3QuXG4gICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgdmFyIF9zdXNwZW5kZWQgPSBmaW5kRmlyc3RTdXNwZW5kZWQocmVuZGVyZWRUYWlsKTtcblxuICAgICAgICAgICAgaWYgKF9zdXNwZW5kZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlOyAvLyBFbnN1cmUgd2UgdHJhbnNmZXIgdGhlIHVwZGF0ZSBxdWV1ZSB0byB0aGUgcGFyZW50IHNvIHRoYXQgaXQgZG9lc24ndFxuICAgICAgICAgICAgICAvLyBnZXQgbG9zdCBpZiB0aGlzIHJvdyBlbmRzIHVwIGRyb3BwZWQgZHVyaW5nIGEgc2Vjb25kIHBhc3MuXG5cbiAgICAgICAgICAgICAgdmFyIF9yZXRyeVF1ZXVlMiA9IF9zdXNwZW5kZWQudXBkYXRlUXVldWU7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gX3JldHJ5UXVldWUyO1xuICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBfcmV0cnlRdWV1ZTIpO1xuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIHRydWUpOyAvLyBUaGlzIG1pZ2h0IGhhdmUgYmVlbiBtb2RpZmllZC5cblxuICAgICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCA9PT0gbnVsbCAmJiByZW5kZXJTdGF0ZS50YWlsTW9kZSA9PT0gJ2hpZGRlbicgJiYgIXJlbmRlcmVkVGFpbC5hbHRlcm5hdGUgJiYgIWdldElzSHlkcmF0aW5nKCkgLy8gV2UgZG9uJ3QgY3V0IGl0IGlmIHdlJ3JlIGh5ZHJhdGluZy5cbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAvLyBXZSdyZSBkb25lLlxuICAgICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCAvLyBUaGUgdGltZSBpdCB0b29rIHRvIHJlbmRlciBsYXN0IHJvdyBpcyBncmVhdGVyIHRoYW4gdGhlIHJlbWFpbmluZ1xuICAgICAgICAgICAgLy8gdGltZSB3ZSBoYXZlIHRvIHJlbmRlci4gU28gcmVuZGVyaW5nIG9uZSBtb3JlIHJvdyB3b3VsZCBsaWtlbHlcbiAgICAgICAgICAgIC8vIGV4Y2VlZCBpdC5cbiAgICAgICAgICAgIG5vdyQxKCkgKiAyIC0gcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID4gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpICYmIHJlbmRlckxhbmVzICE9PSBPZmZzY3JlZW5MYW5lKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGhhdmUgbm93IHBhc3NlZCBvdXIgQ1BVIGRlYWRsaW5lIGFuZCB3ZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlclxuICAgICAgICAgICAgICAvLyBhdHRlbXB0cyB0byByZW5kZXIgdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgICAvLyBUaGUgYXNzdW1wdGlvbiBpcyB0aGF0IHRoaXMgaXMgdXN1YWxseSBmYXN0ZXIuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7IC8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzXG4gICAgICAgICAgICAgIC8vIHRvIGdldCBpdCBzdGFydGVkIGJhY2sgdXAgdG8gYXR0ZW1wdCB0aGUgbmV4dCBpdGVtLiBXaGlsZSBpbiB0ZXJtc1xuICAgICAgICAgICAgICAvLyBvZiBwcmlvcml0eSB0aGlzIHdvcmsgaGFzIHRoZSBzYW1lIHByaW9yaXR5IGFzIHRoaXMgY3VycmVudCByZW5kZXIsXG4gICAgICAgICAgICAgIC8vIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhc1xuICAgICAgICAgICAgICAvLyBjb21taXR0ZWQuIElmIGl0J3Mgc3luYywgd2Ugc3RpbGwgd2FudCB0byB5aWVsZCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgICAgICAgICAgICAvLyBwYWludGVkLiBDb25jZXB0dWFsbHksIHRoaXMgaXMgcmVhbGx5IHRoZSBzYW1lIGFzIHBpbmdpbmcuXG4gICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgYW55IFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nXG4gICAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGxlYXZpbmcgaXQgYmVoaW5kIG9uIHRoaXMgbm9kZS5cblxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IFNvbWVSZXRyeUxhbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlbmRlclN0YXRlLmlzQmFja3dhcmRzKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWZmZWN0IGxpc3Qgb2YgdGhlIGJhY2t3YXJkcyB0YWlsIHdpbGwgaGF2ZSBiZWVuIGFkZGVkXG4gICAgICAgICAgICAvLyB0byB0aGUgZW5kLiBUaGlzIGJyZWFrcyB0aGUgZ3VhcmFudGVlIHRoYXQgbGlmZS1jeWNsZXMgZmlyZSBpblxuICAgICAgICAgICAgLy8gc2libGluZyBvcmRlciBidXQgdGhhdCBpc24ndCBhIHN0cm9uZyBndWFyYW50ZWUgcHJvbWlzZWQgYnkgUmVhY3QuXG4gICAgICAgICAgICAvLyBFc3BlY2lhbGx5IHNpbmNlIHRoZXNlIG1pZ2h0IGFsc28ganVzdCBwb3AgaW4gZHVyaW5nIGZ1dHVyZSBjb21taXRzLlxuICAgICAgICAgICAgLy8gQXBwZW5kIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3QuXG4gICAgICAgICAgICByZW5kZXJlZFRhaWwuc2libGluZyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJlZFRhaWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSByZW5kZXJTdGF0ZS5sYXN0O1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHByZXZpb3VzU2libGluZy5zaWJsaW5nID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJlZFRhaWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmxhc3QgPSByZW5kZXJlZFRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlclN0YXRlLnRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBzdGlsbCBoYXZlIHRhaWwgcm93cyB0byByZW5kZXIuXG4gICAgICAgICAgLy8gUG9wIGEgcm93LlxuICAgICAgICAgIHZhciBuZXh0ID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBuZXh0O1xuICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBuZXh0LnNpYmxpbmc7XG4gICAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID0gbm93JDEoKTtcbiAgICAgICAgICBuZXh0LnNpYmxpbmcgPSBudWxsOyAvLyBSZXN0b3JlIHRoZSBjb250ZXh0LlxuICAgICAgICAgIC8vIFRPRE86IFdlIGNhbiBwcm9iYWJseSBqdXN0IGF2b2lkIHBvcHBpbmcgaXQgaW5zdGVhZCBhbmQgb25seVxuICAgICAgICAgIC8vIHNldHRpbmcgaXQgdGhlIGZpcnN0IHRpbWUgd2UgZ28gZnJvbSBub3Qgc3VzcGVuZGVkIHRvIHN1c3BlbmRlZC5cblxuICAgICAgICAgIHZhciBzdXNwZW5zZUNvbnRleHQgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG5cbiAgICAgICAgICBpZiAoZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldFNoYWxsb3dTdXNwZW5zZUxpc3RDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUxpc3RDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHVzaFN1c3BlbnNlTGlzdENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlQ29udGV4dCk7IC8vIERvIGEgcGFzcyBvdmVyIHRoZSBuZXh0IHJvdy5cbiAgICAgICAgICAvLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBpbiB0aGlzIGNhc2UuXG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBfbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIG5leHRJc0hpZGRlbiA9IF9uZXh0U3RhdGUgIT09IG51bGw7IC8vIFNjaGVkdWxlIGEgVmlzaWJpbGl0eSBlZmZlY3QgaWYgdGhlIHZpc2liaWxpdHkgaGFzIGNoYW5nZWRcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgdmFyIHByZXZJc0hpZGRlbiA9IF9wcmV2U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChwcmV2SXNIaWRkZW4gIT09IG5leHRJc0hpZGRlbikge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBWaXNpYmlsaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPbiBpbml0aWFsIG1vdW50LCB3ZSBvbmx5IG5lZWQgYSBWaXNpYmlsaXR5IGVmZmVjdCBpZiB0aGUgdHJlZVxuICAgICAgICAgICAgLy8gaXMgaGlkZGVuLlxuICAgICAgICAgICAgaWYgKG5leHRJc0hpZGRlbikge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBWaXNpYmlsaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmV4dElzSGlkZGVuIHx8ICFkaXNhYmxlTGVnYWN5TW9kZSApIHtcbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBmb3IgaGlkZGVuIGNoaWxkcmVuIHVubGVzcyB3ZSdyZSByZW5kZXJpbmdcbiAgICAgICAgICAvLyBhdCBvZmZzY3JlZW4gcHJpb3JpdHkuXG4gICAgICAgICAgaWYgKGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpICYmIC8vIEFsc28gZG9uJ3QgYnViYmxlIGlmIHRoZSB0cmVlIHN1c3BlbmRlZFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0xhbmVzKSB7XG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTsgLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGFuIGluc2VydGlvbiBvciB1cGRhdGUgaW4gdGhlIGhpZGRlbiBzdWJ0cmVlLlxuICAgICAgICAgICAgLy8gSWYgc28sIHdlIG5lZWQgdG8gaGlkZSB0aG9zZSBub2RlcyBpbiB0aGUgY29tbWl0IHBoYXNlLCBzb1xuICAgICAgICAgICAgLy8gc2NoZWR1bGUgYSB2aXNpYmlsaXR5IGVmZmVjdC5cblxuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyAmIChQbGFjZW1lbnQgfCBVcGRhdGUpKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFZpc2liaWxpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZnNjcmVlblF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG5cbiAgICAgICAgaWYgKG9mZnNjcmVlblF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9yZXRyeVF1ZXVlMyA9IG9mZnNjcmVlblF1ZXVlLnJldHJ5UXVldWU7XG4gICAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgX3JldHJ5UXVldWUzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3ByZXZpb3VzQ2FjaGUyID0gbnVsbDtcblxuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfcHJldmlvdXNDYWNoZTIgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2w7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9jYWNoZTIgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF9jYWNoZTIgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfY2FjaGUyICE9PSBfcHJldmlvdXNDYWNoZTIpIHtcbiAgICAgICAgICAgIC8vIFJ1biBwYXNzaXZlIGVmZmVjdHMgdG8gcmV0YWluL3JlbGVhc2UgdGhlIGNhY2hlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGFzc2l2ZSQxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBvcFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3ByZXZpb3VzQ2FjaGUzID0gbnVsbDtcblxuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfcHJldmlvdXNDYWNoZTMgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9jYWNoZTMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlO1xuXG4gICAgICAgICAgaWYgKF9jYWNoZTMgIT09IF9wcmV2aW91c0NhY2hlMykge1xuICAgICAgICAgICAgLy8gUnVuIHBhc3NpdmUgZWZmZWN0cyB0byByZXRhaW4vcmVsZWFzZSB0aGUgY2FjaGUuXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQYXNzaXZlJDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9wQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgKyB3b3JrSW5Qcm9ncmVzcy50YWcgKyBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBcIiArICdSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIHVud2luZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIE5vdGU6IFRoaXMgaW50ZW50aW9uYWxseSBkb2Vzbid0IGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZyBiZWNhdXNlIGNvbXBhcmluZ1xuICAvLyB0byB0aGUgY3VycmVudCB0cmVlIHByb3ZpZGVyIGZpYmVyIGlzIGp1c3QgYXMgZmFzdCBhbmQgbGVzcyBlcnJvci1wcm9uZS5cbiAgLy8gSWRlYWxseSB3ZSB3b3VsZCBoYXZlIGEgc3BlY2lhbCB2ZXJzaW9uIG9mIHRoZSB3b3JrIGxvb3Agb25seVxuICAvLyBmb3IgaHlkcmF0aW9uLlxuICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHZhciBmbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuXG4gICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcblxuICAgICAgICB7XG4gICAgICAgICAgcG9wQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBfZmxhZ3MgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoKF9mbGFncyAmIFNob3VsZENhcHR1cmUpICE9PSBOb0ZsYWdzJDEgJiYgKF9mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAvLyBUaGVyZSB3YXMgYW4gZXJyb3IgZHVyaW5nIHJlbmRlciB0aGF0IHdhc24ndCBjYXB0dXJlZCBieSBhIHN1c3BlbnNlXG4gICAgICAgICAgLy8gYm91bmRhcnkuIERvIGEgc2Vjb25kIHBhc3Mgb24gdGhlIHJvb3QgdG8gdW5tb3VudCB0aGUgY2hpbGRyZW4uXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBfZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9IC8vIFdlIHVud291bmQgdG8gdGhlIHJvb3Qgd2l0aG91dCBjb21wbGV0aW5nIGl0LiBFeGl0LlxuXG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogcG9wSHlkcmF0aW9uU3RhdGVcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCAmJiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RocmV3IGluIG5ld2x5IG1vdW50ZWQgZGVoeWRyYXRlZCBjb21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluICcgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfZmxhZ3MyID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG5cbiAgICAgICAgaWYgKF9mbGFnczIgJiBTaG91bGRDYXB0dXJlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBfZmxhZ3MyICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlOyAvLyBDYXB0dXJlZCBhIHN1c3BlbnNlIGVmZmVjdC4gUmUtcmVuZGVyIHRoZSBib3VuZGFyeS5cblxuICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUxpc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTsgLy8gU3VzcGVuc2VMaXN0IGRvZXNuJ3QgYWN0dWFsbHkgY2F0Y2ggYW55dGhpbmcuIEl0IHNob3VsZCd2ZSBiZWVuXG4gICAgICAgIC8vIGNhdWdodCBieSBhIG5lc3RlZCBib3VuZGFyeS4gSWYgbm90LCBpdCBzaG91bGQgYnViYmxlIHRocm91Z2guXG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICB2YXIgY29udGV4dDtcblxuICAgICAge1xuICAgICAgICBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIH1cblxuICAgICAgcG9wUHJvdmlkZXIoY29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpO1xuICAgICAgICB2YXIgX2ZsYWdzMyA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmIChfZmxhZ3MzICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gX2ZsYWdzMyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTsgLy8gQ2FwdHVyZWQgYSBzdXNwZW5zZSBlZmZlY3QuIFJlLXJlbmRlciB0aGUgYm91bmRhcnkuXG5cbiAgICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6XG5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCBpbnRlcnJ1cHRlZFdvcmssIHJlbmRlckxhbmVzKSB7XG4gIC8vIE5vdGU6IFRoaXMgaW50ZW50aW9uYWxseSBkb2Vzbid0IGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZyBiZWNhdXNlIGNvbXBhcmluZ1xuICAvLyB0byB0aGUgY3VycmVudCB0cmVlIHByb3ZpZGVyIGZpYmVyIGlzIGp1c3QgYXMgZmFzdCBhbmQgbGVzcyBlcnJvci1wcm9uZS5cbiAgLy8gSWRlYWxseSB3ZSB3b3VsZCBoYXZlIGEgc3BlY2lhbCB2ZXJzaW9uIG9mIHRoZSB3b3JrIGxvb3Agb25seVxuICAvLyBmb3IgaHlkcmF0aW9uLlxuICBwb3BUcmVlQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuXG4gIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuXG4gICAgICAgIHtcbiAgICAgICAgICBwb3BDYWNoZVByb3ZpZGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgIH1cbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHBvcFN1c3BlbnNlTGlzdENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICB2YXIgY29udGV4dDtcblxuICAgICAge1xuICAgICAgICBjb250ZXh0ID0gaW50ZXJydXB0ZWRXb3JrLnR5cGU7XG4gICAgICB9XG5cbiAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICBwb3BIaWRkZW5Db250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBwb3BUcmFuc2l0aW9uKGludGVycnVwdGVkV29yaywgY3VycmVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcENhY2hlUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbnVsbDtcblxue1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG5ldyBTZXQoKTtcbn0gLy8gVXNlZCBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSB0byB0cmFjayB0aGUgc3RhdGUgb2YgdGhlIE9mZnNjcmVlbiBjb21wb25lbnQgc3RhY2suXG4vLyBBbGxvd3MgdXMgdG8gYXZvaWQgdHJhdmVyc2luZyB0aGUgcmV0dXJuIHBhdGggdG8gZmluZCB0aGUgbmVhcmVzdCBPZmZzY3JlZW4gYW5jZXN0b3IuXG5cblxudmFyIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IGZhbHNlO1xudmFyIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBmYWxzZTsgLy8gVXNlZCB0byB0cmFjayBpZiBhIGZvcm0gbmVlZHMgdG8gYmUgcmVzZXQgYXQgdGhlIGVuZCBvZiB0aGUgbXV0YXRpb24gcGhhc2UuXG5cbnZhciBuZWVkc0Zvcm1SZXNldCA9IGZhbHNlO1xudmFyIFBvc3NpYmx5V2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nID8gV2Vha1NldCA6IFNldDtcbnZhciBuZXh0RWZmZWN0ID0gbnVsbDsgLy8gVXNlZCBmb3IgUHJvZmlsaW5nIGJ1aWxkcyB0byB0cmFjayB1cGRhdGVycy5cblxudmFyIGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG52YXIgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuXG5mdW5jdGlvbiBzaG91bGRQcm9maWxlKGN1cnJlbnQpIHtcbiAgcmV0dXJuIChjdXJyZW50Lm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSAmJiAoZ2V0RXhlY3V0aW9uQ29udGV4dCgpICYgQ29tbWl0Q29udGV4dCkgIT09IE5vQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyKGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoY3VycmVudC50eXBlLCBjdXJyZW50Lm1lbW9pemVkUHJvcHMpO1xuICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAoc2hvdWxkUHJvZmlsZShjdXJyZW50KSkge1xuICAgIHRyeSB7XG4gICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihjdXJyZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgfVxufSAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCB1bm1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBpbnN0YW5jZSkge1xuICB0cnkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lcihjdXJyZW50LCBpbnN0YW5jZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IG1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUF0dGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHRyeSB7XG4gICAgY29tbWl0QXR0YWNoUmVmKGN1cnJlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG4gIHZhciByZWZDbGVhbnVwID0gY3VycmVudC5yZWZDbGVhbnVwO1xuXG4gIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHJlZkNsZWFudXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzaG91bGRQcm9maWxlKGN1cnJlbnQpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgIHJlZkNsZWFudXAoKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZkNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gYHJlZkNsZWFudXBgIGhhcyBiZWVuIGNhbGxlZC4gTnVsbGlmeSBhbGwgcmVmZXJlbmNlcyB0byBpdCB0byBwcmV2ZW50IGRvdWJsZSBpbnZvY2F0aW9uLlxuICAgICAgICBjdXJyZW50LnJlZkNsZWFudXAgPSBudWxsO1xuICAgICAgICB2YXIgZmluaXNoZWRXb3JrID0gY3VycmVudC5hbHRlcm5hdGU7XG5cbiAgICAgICAgaWYgKGZpbmlzaGVkV29yayAhPSBudWxsKSB7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnJlZkNsZWFudXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShjdXJyZW50KSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICByZWYobnVsbCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWYobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSB1bmFibGUgdG8gbmFycm93IHR5cGUgdG8gUmVmT2JqZWN0XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxEZXN0cm95KGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlc3Ryb3kpIHtcbiAgdHJ5IHtcbiAgICBkZXN0cm95KCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59XG52YXIgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gZmFsc2U7XG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmlyc3RDaGlsZCkge1xuICBwcmVwYXJlRm9yQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG4gIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfYmVnaW4oKTsgLy8gV2Ugbm8gbG9uZ2VyIG5lZWQgdG8gdHJhY2sgdGhlIGFjdGl2ZSBpbnN0YW5jZSBmaWJlclxuXG4gIHZhciBzaG91bGRGaXJlID0gc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyO1xuICBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSBmYWxzZTtcbiAgcmV0dXJuIHNob3VsZEZpcmU7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbigpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0OyAvLyBUaGlzIHBoYXNlIGlzIG9ubHkgdXNlZCBmb3IgYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyLlxuXG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICBpZiAoKGZpYmVyLnN1YnRyZWVGbGFncyAmIEJlZm9yZU11dGF0aW9uTWFzaykgIT09IE5vRmxhZ3MkMSAmJiBjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgY2hpbGQucmV0dXJuID0gZmliZXI7XG4gICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfY29tcGxldGUoKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpYmVyKTtcblxuICAgIHRyeSB7XG4gICAgICBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpYmVyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nLnJldHVybiA9IGZpYmVyLnJldHVybjtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaW5pc2hlZFdvcmspO1xuICB9XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTsgLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuICAgICAgICAgICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKCFmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgJiYgISgncmVmJyBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc25hcHNob3QgPSBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShyZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhmaW5pc2hlZFdvcmsudHlwZSwgcHJldlByb3BzKSwgcHJldlN0YXRlKTtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZGlkV2FyblNldCA9IGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlO1xuXG4gICAgICAgICAgICAgIGlmIChzbmFwc2hvdCA9PT0gdW5kZWZpbmVkICYmICFkaWRXYXJuU2V0LmhhcyhmaW5pc2hlZFdvcmsudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBkaWRXYXJuU2V0LmFkZChmaW5pc2hlZFdvcmsudHlwZSk7XG5cbiAgICAgICAgICAgICAgICBlcnJvcignJXMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKTogQSBzbmFwc2hvdCB2YWx1ZSAob3IgbnVsbCkgJyArICdtdXN0IGJlIHJldHVybmVkLiBZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHNuYXBzaG90O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gZm9yIHRoZXNlIGNvbXBvbmVudCB0eXBlc1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpZiAoKGZsYWdzICYgU25hcHNob3QpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIGlmICgoZmxhZ3MgJiBTbmFwc2hvdCkgIT09IE5vRmxhZ3MkMSkge1xuICAgIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChmbGFncywgZmluaXNoZWRXb3JrLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZSAhPT0gbnVsbCA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuXG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MpIHtcbiAgICAgICAgLy8gVW5tb3VudFxuICAgICAgICB2YXIgaW5zdCA9IGVmZmVjdC5pbnN0O1xuICAgICAgICB2YXIgZGVzdHJveSA9IGluc3QuZGVzdHJveTtcblxuICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW5zdC5kZXN0cm95ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICBzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koZmluaXNoZWRXb3JrLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZXN0cm95KTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChmbGFncywgZmluaXNoZWRXb3JrKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZSAhPT0gbnVsbCA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuXG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICgoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gTW91bnRcblxuXG4gICAgICAgIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnN0ID0gZWZmZWN0Lmluc3Q7XG4gICAgICAgIHZhciBkZXN0cm95ID0gY3JlYXRlKCk7XG4gICAgICAgIGluc3QuZGVzdHJveSA9IGRlc3Ryb3k7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmICgoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICBzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChkZXN0cm95ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGRlc3Ryb3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBob29rTmFtZSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKChlZmZlY3QudGFnICYgTGF5b3V0KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgIGhvb2tOYW1lID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChlZmZlY3QudGFnICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgIGhvb2tOYW1lID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBob29rTmFtZSA9ICd1c2VFZmZlY3QnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYWRkZW5kdW0gPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChkZXN0cm95ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJyBZb3UgcmV0dXJuZWQgbnVsbC4gSWYgeW91ciBlZmZlY3QgZG9lcyBub3QgcmVxdWlyZSBjbGVhbiAnICsgJ3VwLCByZXR1cm4gdW5kZWZpbmVkIChvciBub3RoaW5nKS4nO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdHJveS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJ1xcblxcbkl0IGxvb2tzIGxpa2UgeW91IHdyb3RlICcgKyBob29rTmFtZSArICcoYXN5bmMgKCkgPT4gLi4uKSBvciByZXR1cm5lZCBhIFByb21pc2UuICcgKyAnSW5zdGVhZCwgd3JpdGUgdGhlIGFzeW5jIGZ1bmN0aW9uIGluc2lkZSB5b3VyIGVmZmVjdCAnICsgJ2FuZCBjYWxsIGl0IGltbWVkaWF0ZWx5OlxcblxcbicgKyBob29rTmFtZSArICcoKCkgPT4ge1xcbicgKyAnICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XFxuJyArICcgICAgLy8gWW91IGNhbiBhd2FpdCBoZXJlXFxuJyArICcgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBNeUFQSS5nZXREYXRhKHNvbWVJZCk7XFxuJyArICcgICAgLy8gLi4uXFxuJyArICcgIH1cXG4nICsgJyAgZmV0Y2hEYXRhKCk7XFxuJyArIFwifSwgW3NvbWVJZF0pOyAvLyBPciBbXSBpZiBlZmZlY3QgZG9lc24ndCBuZWVkIHByb3BzIG9yIHN0YXRlXFxuXFxuXCIgKyAnTGVhcm4gbW9yZSBhYm91dCBkYXRhIGZldGNoaW5nIHdpdGggSG9va3M6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaG9va3MtZGF0YS1mZXRjaGluZyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkOiAnICsgZGVzdHJveTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3IoJyVzIG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBiZXNpZGVzIGEgZnVuY3Rpb24sICcgKyAnd2hpY2ggaXMgdXNlZCBmb3IgY2xlYW4tdXAuJXMnLCBob29rTmFtZSwgYWRkZW5kdW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlZmZlY3QgPSBlZmZlY3QubmV4dDtcbiAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlRWZmZWN0RHVyYXRpb25zKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gIGlmIChnZXRFeGVjdXRpb25Db250ZXh0KCkgJiBDb21taXRDb250ZXh0KSB7XG4gICAgLy8gT25seSBQcm9maWxlcnMgd2l0aCB3b3JrIGluIHRoZWlyIHN1YnRyZWUgd2lsbCBoYXZlIGFuIFVwZGF0ZSBlZmZlY3Qgc2NoZWR1bGVkLlxuICAgIGlmICgoZmluaXNoZWRXb3JrLmZsYWdzICYgVXBkYXRlKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgICAgaWQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUuaWQsXG4gICAgICAgICAgICAgICAgb25Qb3N0Q29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplLm9uUG9zdENvbW1pdDsgLy8gVGhpcyB2YWx1ZSB3aWxsIHN0aWxsIHJlZmxlY3QgdGhlIHByZXZpb3VzIGNvbW1pdCBwaGFzZS5cbiAgICAgICAgICAgIC8vIEl0IGRvZXMgbm90IGdldCByZXNldCB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgY29tbWl0IHBoYXNlLlxuXG4gICAgICAgICAgICB2YXIgY29tbWl0VGltZSA9IGdldENvbW1pdFRpbWUoKTtcbiAgICAgICAgICAgIHZhciBwaGFzZSA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgPT09IG51bGwgPyAnbW91bnQnIDogJ3VwZGF0ZSc7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudFVwZGF0ZU5lc3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgcGhhc2UgPSAnbmVzdGVkLXVwZGF0ZSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvblBvc3RDb21taXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb25Qb3N0Q29tbWl0KGlkLCBwaGFzZSwgcGFzc2l2ZUVmZmVjdER1cmF0aW9uLCBjb21taXRUaW1lKTtcbiAgICAgICAgICAgIH0gLy8gQnViYmxlIHRpbWVzIHRvIHRoZSBuZXh0IG5lYXJlc3QgYW5jZXN0b3IgUHJvZmlsZXIuXG4gICAgICAgICAgICAvLyBBZnRlciB3ZSBwcm9jZXNzIHRoYXQgUHJvZmlsZXIsIHdlJ2xsIGJ1YmJsZSBmdXJ0aGVyIHVwLlxuXG5cbiAgICAgICAgICAgIHZhciBwYXJlbnRGaWJlciA9IGZpbmlzaGVkV29yay5yZXR1cm47XG5cbiAgICAgICAgICAgIG91dGVyOiB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICByb290LnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPSBwYXNzaXZlRWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcblxuICAgICAgICAgICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgcGFyZW50U3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPSBwYXNzaXZlRWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIucmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgaG9va0ZsYWdzKSB7XG4gIC8vIEF0IHRoaXMgcG9pbnQgbGF5b3V0IGVmZmVjdHMgaGF2ZSBhbHJlYWR5IGJlZW4gZGVzdHJveWVkIChkdXJpbmcgbXV0YXRpb24gcGhhc2UpLlxuICAvLyBUaGlzIGlzIGRvbmUgdG8gcHJldmVudCBzaWJsaW5nIGNvbXBvbmVudCBlZmZlY3RzIGZyb20gaW50ZXJmZXJpbmcgd2l0aCBlYWNoIG90aGVyLFxuICAvLyBlLmcuIGEgZGVzdHJveSBmdW5jdGlvbiBpbiBvbmUgY29tcG9uZW50IHNob3VsZCBuZXZlciBvdmVycmlkZSBhIHJlZiBzZXRcbiAgLy8gYnkgYSBjcmVhdGUgZnVuY3Rpb24gaW4gYW5vdGhlciBjb21wb25lbnQgZHVyaW5nIHRoZSBzYW1lIGNvbW1pdC5cbiAgaWYgKHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKSkge1xuICAgIHRyeSB7XG4gICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRDbGFzc0xheW91dExpZmVjeWNsZXMoZmluaXNoZWRXb3JrLCBjdXJyZW50KSB7XG4gIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuICAgIHtcbiAgICAgIGlmICghZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzICYmICEoJ3JlZicgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcbiAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZE1vdW50LiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKGZpbmlzaGVkV29yay50eXBlLCBjdXJyZW50Lm1lbW9pemVkUHJvcHMpO1xuICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG5cbiAgICB7XG4gICAgICBpZiAoIWZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyAmJiAhKCdyZWYnIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspIHtcbiAgLy8gVE9ETzogSSB0aGluayB0aGlzIGlzIG5vdyBhbHdheXMgbm9uLW51bGwgYnkgdGhlIHRpbWUgaXQgcmVhY2hlcyB0aGVcbiAgLy8gY29tbWl0IHBoYXNlLiBDb25zaWRlciByZW1vdmluZyB0aGUgdHlwZSBjaGVjay5cbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICB7XG4gICAgICBpZiAoIWZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyAmJiAhKCdyZWYnIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ3Byb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG5cbiAgICB0cnkge1xuICAgICAgY29tbWl0Q2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRIb3N0Q29tcG9uZW50TW91bnQoZmluaXNoZWRXb3JrKSB7XG4gIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gIHRyeSB7XG4gICAgY29tbWl0TW91bnQoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBmaW5pc2hlZFdvcmspO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFByb2ZpbGVyVXBkYXRlKGZpbmlzaGVkV29yaywgY3VycmVudCkge1xuICBpZiAoZ2V0RXhlY3V0aW9uQ29udGV4dCgpICYgQ29tbWl0Q29udGV4dCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgIG9uQ29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vbkNvbW1pdCxcbiAgICAgICAgICBvblJlbmRlciA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25SZW5kZXI7XG4gICAgICB2YXIgZWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uO1xuICAgICAgdmFyIGNvbW1pdFRpbWUgPSBnZXRDb21taXRUaW1lKCk7XG4gICAgICB2YXIgcGhhc2UgPSBjdXJyZW50ID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnO1xuXG4gICAgICBpZiAoZW5hYmxlUHJvZmlsZXJOZXN0ZWRVcGRhdGVQaGFzZSkge1xuICAgICAgICBpZiAoaXNDdXJyZW50VXBkYXRlTmVzdGVkKCkpIHtcbiAgICAgICAgICBwaGFzZSA9ICduZXN0ZWQtdXBkYXRlJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9uUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uUmVuZGVyKGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLmlkLCBwaGFzZSwgZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLCBmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiwgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSwgY29tbWl0VGltZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmFibGVQcm9maWxlckNvbW1pdEhvb2tzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25Db21taXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvbkNvbW1pdChmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgcGhhc2UsIGVmZmVjdER1cmF0aW9uLCBjb21taXRUaW1lKTtcbiAgICAgICAgfSAvLyBTY2hlZHVsZSBhIHBhc3NpdmUgZWZmZWN0IGZvciB0aGlzIFByb2ZpbGVyIHRvIGNhbGwgb25Qb3N0Q29tbWl0IGhvb2tzLlxuICAgICAgICAvLyBUaGlzIGVmZmVjdCBzaG91bGQgYmUgc2NoZWR1bGVkIGV2ZW4gaWYgdGhlcmUgaXMgbm8gb25Qb3N0Q29tbWl0IGNhbGxiYWNrIGZvciB0aGlzIFByb2ZpbGVyLFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBlZmZlY3QgaXMgYWxzbyB3aGVyZSB0aW1lcyBidWJibGUgdG8gcGFyZW50IFByb2ZpbGVycy5cblxuXG4gICAgICAgIGVucXVldWVQZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0KGZpbmlzaGVkV29yayk7IC8vIFByb3BhZ2F0ZSBsYXlvdXQgZWZmZWN0IGR1cmF0aW9ucyB0byB0aGUgbmV4dCBuZWFyZXN0IFByb2ZpbGVyIGFuY2VzdG9yLlxuICAgICAgICAvLyBEbyBub3QgcmVzZXQgdGhlc2UgdmFsdWVzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBzbyBEZXZUb29scyBoYXMgYSBjaGFuY2UgdG8gcmVhZCB0aGVtIGZpcnN0LlxuXG4gICAgICAgIHZhciBwYXJlbnRGaWJlciA9IGZpbmlzaGVkV29yay5yZXR1cm47XG5cbiAgICAgICAgb3V0ZXI6IHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgcm9vdC5lZmZlY3REdXJhdGlvbiArPSBlZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG5cbiAgICAgICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHBhcmVudFN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiArPSBlZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIoZmluaXNoZWRSb290LCBjdXJyZW50LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzKSB7XG4gIC8vIFdoZW4gdXBkYXRpbmcgdGhpcyBmdW5jdGlvbiwgYWxzbyB1cGRhdGUgcmVhcHBlYXJMYXlvdXRFZmZlY3RzLCB3aGljaCBkb2VzXG4gIC8vIG1vc3Qgb2YgdGhlIHNhbWUgdGhpbmdzIHdoZW4gYW4gb2Zmc2NyZWVuIHRyZWUgZ29lcyBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlLlxuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgY29tbWl0SG9va0xheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCBMYXlvdXQgfCBIYXNFZmZlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgY29tbWl0Q2xhc3NMYXlvdXRMaWZlY3ljbGVzKGZpbmlzaGVkV29yaywgY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MgJiBDYWxsYmFjaykge1xuICAgICAgICAgIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIENhbGxiYWNrKSB7XG4gICAgICAgICAgLy8gVE9ETzogSSB0aGluayB0aGlzIGlzIG5vdyBhbHdheXMgbm9uLW51bGwgYnkgdGhlIHRpbWUgaXQgcmVhY2hlcyB0aGVcbiAgICAgICAgICAvLyBjb21taXQgcGhhc2UuIENvbnNpZGVyIHJlbW92aW5nIHRoZSB0eXBlIGNoZWNrLlxuICAgICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay5jaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcblxuICAgICAgICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTsgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgIC8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbiAgICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBjb21taXRIb3N0Q29tcG9uZW50TW91bnQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7IC8vIFRPRE86IFNob3VsZCB0aGlzIGZpcmUgaW5zaWRlIGFuIG9mZnNjcmVlbiB0cmVlPyBPciBzaG91bGQgaXQgd2FpdCB0b1xuICAgICAgICAvLyBmaXJlIHdoZW4gdGhlIHRyZWUgYmVjb21lcyB2aXNpYmxlIGFnYWluLlxuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGNvbW1pdFByb2ZpbGVyVXBkYXRlKGZpbmlzaGVkV29yaywgY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaXNNb2Rlcm5Sb290ID0gZGlzYWJsZUxlZ2FjeU1vZGUgO1xuXG4gICAgICAgIGlmIChpc01vZGVyblJvb3QpIHtcbiAgICAgICAgICB2YXIgaXNIaWRkZW4gPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgICB2YXIgbmV3T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gaXNIaWRkZW4gfHwgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuXG4gICAgICAgICAgaWYgKG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbikgOyBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBPZmZzY3JlZW4gdHJlZSBpcyB2aXNpYmxlLlxuICAgICAgICAgICAgdmFyIHdhc0hpZGRlbiA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgICAgICAgICAgdmFyIG5ld09mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSB3YXNIaWRkZW4gfHwgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBuZXdPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuXG4gICAgICAgICAgICBpZiAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiAmJiAhcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcm9vdCBvZiBhIHJlYXBwZWFyaW5nIGJvdW5kYXJ5LiBBcyB3ZSBjb250aW51ZVxuICAgICAgICAgICAgICAvLyB0cmF2ZXJzaW5nIHRoZSBsYXlvdXQgZWZmZWN0cywgd2UgbXVzdCBhbHNvIHJlLW1vdW50IGxheW91dFxuICAgICAgICAgICAgICAvLyBlZmZlY3RzIHRoYXQgd2VyZSB1bm1vdW50ZWQgd2hlbiB0aGUgT2Zmc2NyZWVuIHN1YnRyZWUgd2FzXG4gICAgICAgICAgICAgIC8vIGhpZGRlbi4gU28gdGhpcyBpcyBhIHN1cGVyc2V0IG9mIHRoZSBub3JtYWwgY29tbWl0TGF5b3V0RWZmZWN0cy5cbiAgICAgICAgICAgICAgdmFyIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgPSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIExheW91dE1hc2spICE9PSBOb0ZsYWdzJDE7XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcblxuICAgICAgICAgIGlmIChwcm9wcy5tb2RlID09PSAnbWFudWFsJykge1xuICAgICAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbihmaW5pc2hlZFdvcmssIGlzSGlkZGVuKSB7XG4gIC8vIE9ubHkgaGlkZSBvciB1bmhpZGUgdGhlIHRvcC1tb3N0IGhvc3Qgbm9kZXMuXG4gIHZhciBob3N0U3VidHJlZVJvb3QgPSBudWxsO1xuXG4gIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgKHN1cHBvcnRzUmVzb3VyY2VzID8gbm9kZS50YWcgPT09IEhvc3RIb2lzdGFibGUgOiBmYWxzZSkgfHwgKHN1cHBvcnRzU2luZ2xldG9ucyA/IG5vZGUudGFnID09PSBIb3N0U2luZ2xldG9uIDogZmFsc2UpKSB7XG4gICAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgICBob3N0U3VidHJlZVJvb3QgPSBub2RlO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgaGlkZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVuaGlkZUluc3RhbmNlKG5vZGUuc3RhdGVOb2RlLCBub2RlLm1lbW9pemVkUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgaGlkZVRleHRJbnN0YW5jZShfaW5zdGFuY2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5oaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZSwgbm9kZS5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChub2RlLnRhZyA9PT0gT2Zmc2NyZWVuQ29tcG9uZW50IHx8IG5vZGUudGFnID09PSBMZWdhY3lIaWRkZW5Db21wb25lbnQpICYmIG5vZGUubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCAmJiBub2RlICE9PSBmaW5pc2hlZFdvcmspIDsgZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaG9zdFN1YnRyZWVSb290ID09PSBub2RlKSB7XG4gICAgICAgICAgaG9zdFN1YnRyZWVSb290ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGhvc3RTdWJ0cmVlUm9vdCA9PT0gbm9kZSkge1xuICAgICAgICBob3N0U3VidHJlZVJvb3QgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKSB7XG4gIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuXG4gIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgIHZhciBpbnN0YW5jZVRvVXNlO1xuXG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gaW5zdGFuY2U7XG4gICAgfSAvLyBNb3ZlZCBvdXRzaWRlIHRvIGVuc3VyZSBEQ0Ugd29ya3Mgd2l0aCB0aGlzIGZsYWdcblxuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgIGZpbmlzaGVkV29yay5yZWZDbGVhbnVwID0gcmVmKGluc3RhbmNlVG9Vc2UpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmlzaGVkV29yay5yZWZDbGVhbnVwID0gcmVmKGluc3RhbmNlVG9Vc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IFdlIHNob3VsZCBtb3ZlIHRoZXNlIHdhcm5pbmdzIHRvIGhhcHBlbiBkdXJpbmcgdGhlIHJlbmRlclxuICAgICAgICAvLyBwaGFzZSAobWFya1JlZikuXG4gICAgICAgIGlmICh0eXBlb2YgcmVmID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGVycm9yKCdTdHJpbmcgcmVmcyBhcmUgbm8gbG9uZ2VyIHN1cHBvcnRlZC4nKTtcbiAgICAgICAgfSBlbHNlIGlmICghcmVmLmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCByZWYgb2JqZWN0IHByb3ZpZGVkIGZvciAlcy4gJyArICdVc2UgZWl0aGVyIGEgcmVmLXNldHRlciBmdW5jdGlvbiBvciBSZWFjdC5jcmVhdGVSZWYoKS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykpO1xuICAgICAgICB9XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gdW5hYmxlIHRvIG5hcnJvdyB0eXBlIHRvIHRoZSBub24tZnVuY3Rpb24gY2FzZVxuXG5cbiAgICAgIHJlZi5jdXJyZW50ID0gaW5zdGFuY2VUb1VzZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoRmliZXJNdXRhdGlvbihmaWJlcikge1xuICAvLyBDdXQgb2ZmIHRoZSByZXR1cm4gcG9pbnRlciB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuXG4gIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBkZXRlY3QgYW5kIHdhcm4gYWdhaW5zdCBzdGF0ZSB1cGRhdGVzIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXG4gIC8vIEl0IGFsc28gcHJldmVudHMgZXZlbnRzIGZyb20gYnViYmxpbmcgZnJvbSB3aXRoaW4gZGlzY29ubmVjdGVkIGNvbXBvbmVudHMuXG4gIC8vXG4gIC8vIElkZWFsbHksIHdlIHNob3VsZCBhbHNvIGNsZWFyIHRoZSBjaGlsZCBwb2ludGVyIG9mIHRoZSBwYXJlbnQgYWx0ZXJuYXRlIHRvIGxldCB0aGlzXG4gIC8vIGdldCBHQzplZCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmb3Igc3VyZSB3aGljaCBwYXJlbnQgaXMgdGhlIGN1cnJlbnRcbiAgLy8gb25lIHNvIHdlJ2xsIHNldHRsZSBmb3IgR0M6aW5nIHRoZSBzdWJ0cmVlIG9mIHRoaXMgY2hpbGQuXG4gIC8vIFRoaXMgY2hpbGQgaXRzZWxmIHdpbGwgYmUgR0M6ZWQgd2hlbiB0aGUgcGFyZW50IHVwZGF0ZXMgdGhlIG5leHQgdGltZS5cbiAgLy9cbiAgLy8gTm90ZSB0aGF0IHdlIGNhbid0IGNsZWFyIGNoaWxkIG9yIHNpYmxpbmcgcG9pbnRlcnMgeWV0LlxuICAvLyBUaGV5J3JlIG5lZWRlZCBmb3IgcGFzc2l2ZSBlZmZlY3RzIGFuZCBmb3IgZmluZERPTU5vZGUuXG4gIC8vIFdlIGRlZmVyIHRob3NlIGZpZWxkcywgYW5kIGFsbCBvdGhlciBjbGVhbnVwLCB0byB0aGUgcGFzc2l2ZSBwaGFzZSAoc2VlIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKS5cbiAgLy9cbiAgLy8gRG9uJ3QgcmVzZXQgdGhlIGFsdGVybmF0ZSB5ZXQsIGVpdGhlci4gV2UgbmVlZCB0aGF0IHNvIHdlIGNhbiBkZXRhY2ggdGhlXG4gIC8vIGFsdGVybmF0ZSdzIGZpZWxkcyBpbiB0aGUgcGFzc2l2ZSBwaGFzZS4gQ2xlYXJpbmcgdGhlIHJldHVybiBwb2ludGVyIGlzXG4gIC8vIHN1ZmZpY2llbnQgZm9yIGZpbmRET01Ob2RlIHNlbWFudGljcy5cbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLnJldHVybiA9IG51bGw7XG4gIH1cblxuICBmaWJlci5yZXR1cm4gPSBudWxsO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICBmaWJlci5hbHRlcm5hdGUgPSBudWxsO1xuICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGFsdGVybmF0ZSk7XG4gIH0gLy8gQ2xlYXIgY3ljbGljYWwgRmliZXIgZmllbGRzLiBUaGlzIGxldmVsIGFsb25lIGlzIGRlc2lnbmVkIHRvIHJvdWdobHlcbiAgLy8gYXBwcm94aW1hdGUgdGhlIHBsYW5uZWQgRmliZXIgcmVmYWN0b3IuIEluIHRoYXQgd29ybGQsIGBzZXRTdGF0ZWAgd2lsbCBiZVxuICAvLyBib3VuZCB0byBhIHNwZWNpYWwgXCJpbnN0YW5jZVwiIG9iamVjdCBpbnN0ZWFkIG9mIGEgRmliZXIuIFRoZSBJbnN0YW5jZVxuICAvLyBvYmplY3Qgd2lsbCBub3QgaGF2ZSBhbnkgb2YgdGhlc2UgZmllbGRzLiBJdCB3aWxsIG9ubHkgYmUgY29ubmVjdGVkIHRvXG4gIC8vIHRoZSBmaWJlciB0cmVlIHZpYSBhIHNpbmdsZSBsaW5rIGF0IHRoZSByb290LiBTbyBpZiB0aGlzIGxldmVsIGFsb25lIGlzXG4gIC8vIHN1ZmZpY2llbnQgdG8gZml4IG1lbW9yeSBpc3N1ZXMsIHRoYXQgYm9kZXMgd2VsbCBmb3Igb3VyIHBsYW5zLlxuXG5cbiAgZmliZXIuY2hpbGQgPSBudWxsO1xuICBmaWJlci5kZWxldGlvbnMgPSBudWxsO1xuICBmaWJlci5zaWJsaW5nID0gbnVsbDsgLy8gVGhlIGBzdGF0ZU5vZGVgIGlzIGN5Y2xpY2FsIGJlY2F1c2Ugb24gaG9zdCBub2RlcyBpdCBwb2ludHMgdG8gdGhlIGhvc3RcbiAgLy8gdHJlZSwgd2hpY2ggaGFzIGl0cyBvd24gcG9pbnRlcnMgdG8gY2hpbGRyZW4sIHBhcmVudHMsIGFuZCBzaWJsaW5ncy5cbiAgLy8gVGhlIG90aGVyIGhvc3Qgbm9kZXMgYWxzbyBwb2ludCBiYWNrIHRvIGZpYmVycywgc28gd2Ugc2hvdWxkIGRldGFjaCB0aGF0XG4gIC8vIG9uZSwgdG9vLlxuXG4gIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICB2YXIgaG9zdEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgaWYgKGhvc3RJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgZGV0YWNoRGVsZXRlZEluc3RhbmNlKGhvc3RJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDtcblxuICB7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBudWxsO1xuICB9IC8vIFRoZW9yZXRpY2FsbHksIG5vdGhpbmcgaW4gaGVyZSBzaG91bGQgYmUgbmVjZXNzYXJ5LCBiZWNhdXNlIHdlIGFscmVhZHlcbiAgLy8gZGlzY29ubmVjdGVkIHRoZSBmaWJlciBmcm9tIHRoZSB0cmVlLiBTbyBldmVuIGlmIHNvbWV0aGluZyBsZWFrcyB0aGlzXG4gIC8vIHBhcnRpY3VsYXIgZmliZXIsIGl0IHdvbid0IGxlYWsgYW55dGhpbmcgZWxzZS5cblxuXG4gIGZpYmVyLnJldHVybiA9IG51bGw7XG4gIGZpYmVyLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICBmaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gbnVsbDtcbiAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDsgLy8gVE9ETzogTW92ZSB0byBgY29tbWl0UGFzc2l2ZVVubW91bnRJbnNpZGVEZWxldGVkVHJlZU9uRmliZXJgIGluc3RlYWQuXG5cbiAgZmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KSB7XG4gIGlmICghc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwb3J0YWwgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWwuY29udGFpbmVySW5mbztcbiAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldCgpO1xuICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgZW1wdHlDaGlsZFNldCk7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJyArICdpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgKHN1cHBvcnRzUmVzb3VyY2VzID8gZmliZXIudGFnID09PSBIb3N0SG9pc3RhYmxlIDogZmFsc2UpIHx8IChzdXBwb3J0c1NpbmdsZXRvbnMgPyBmaWJlci50YWcgPT09IEhvc3RTaW5nbGV0b24gOiBmYWxzZSkgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgLy8gbm9kZS4gVW5mb3J0dW5hdGVseSwgaWYgbXVsdGlwbGUgaW5zZXJ0aW9ucyBhcmUgZG9uZSBpbiBhIHJvdyB3ZSBoYXZlIHRvXG4gIC8vIHNlYXJjaCBwYXN0IHRoZW0uIFRoaXMgbGVhZHMgdG8gZXhwb25lbnRpYWwgc2VhcmNoIGZvciB0aGUgbmV4dCBzaWJsaW5nLlxuICAvLyBUT0RPOiBGaW5kIGEgbW9yZSBlZmZpY2llbnQgd2F5IHRvIGRvIHRoaXMuXG4gIHZhciBub2RlID0gZmliZXI7XG5cbiAgc2libGluZ3M6IHdoaWxlICh0cnVlKSB7XG4gICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBpc0hvc3RQYXJlbnQobm9kZS5yZXR1cm4pKSB7XG4gICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgLy8gbGFzdCBzaWJsaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcblxuICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQgJiYgKCFzdXBwb3J0c1NpbmdsZXRvbnMgPyB0cnVlIDogbm9kZS50YWcgIT09IEhvc3RTaW5nbGV0b24pICYmIG5vZGUudGFnICE9PSBEZWh5ZHJhdGVkRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIGl0IGlzIG5vdCBob3N0IG5vZGUgYW5kLCB3ZSBtaWdodCBoYXZlIGEgaG9zdCBub2RlIGluc2lkZSBpdC5cbiAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgIGlmIChub2RlLmZsYWdzICYgUGxhY2VtZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH0gLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuXG5cbiAgICAgIGlmIChub2RlLmNoaWxkID09PSBudWxsIHx8IG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIH1cbiAgICB9IC8vIENoZWNrIGlmIHRoaXMgaG9zdCBub2RlIGlzIHN0YWJsZSBvciBhYm91dCB0byBiZSBwbGFjZWQuXG5cblxuICAgIGlmICghKG5vZGUuZmxhZ3MgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAvLyBGb3VuZCBpdCFcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgaWYgKGZpbmlzaGVkV29yay50YWcgPT09IEhvc3RTaW5nbGV0b24pIHtcbiAgICAgIC8vIFNpbmdsZXRvbnMgYXJlIGFscmVhZHkgaW4gdGhlIEhvc3QgYW5kIGRvbid0IG5lZWQgdG8gYmUgcGxhY2VkXG4gICAgICAvLyBTaW5jZSB0aGV5IG9wZXJhdGUgc29tZXdoYXQgbGlrZSBQb3J0YWxzIHRob3VnaCB0aGVpciBjaGlsZHJlbiB3aWxsXG4gICAgICAvLyBoYXZlIFBsYWNlbWVudCBhbmQgd2lsbCBnZXQgcGxhY2VkIGluc2lkZSB0aGVtXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IC8vIFJlY3Vyc2l2ZWx5IGluc2VydCBhbGwgaG9zdCBub2RlcyBpbnRvIHRoZSBwYXJlbnQuXG5cblxuICB2YXIgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTtcblxuICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7IC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgICAgICAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5cbiAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKHBhcmVudEZpYmVyLmZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgICAgICAgIHJlc2V0VGV4dENvbnRlbnQoX3BhcmVudCk7IC8vIENsZWFyIENvbnRlbnRSZXNldCBmcm9tIHRoZSBlZmZlY3QgdGFnXG5cbiAgICAgICAgICBwYXJlbnRGaWJlci5mbGFncyAmPSB+Q29udGVudFJlc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9iZWZvcmUgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspOyAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gICAgICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cblxuXG4gICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShmaW5pc2hlZFdvcmssIF9iZWZvcmUsIF9wYXJlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhcmVudDIgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcblxuICAgICAgICB2YXIgX2JlZm9yZTIgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoZmluaXNoZWRXb3JrLCBfYmVmb3JlMiwgX3BhcmVudDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaG9zdCBwYXJlbnQgZmliZXIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyAnICsgJ2luIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gIHZhciB0YWcgPSBub2RlLnRhZztcbiAgdmFyIGlzSG9zdCA9IHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RUZXh0O1xuXG4gIGlmIChpc0hvc3QpIHtcbiAgICB2YXIgc3RhdGVOb2RlID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIHN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihwYXJlbnQsIHN0YXRlTm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gSG9zdFBvcnRhbCB8fCAoc3VwcG9ydHNTaW5nbGV0b25zID8gdGFnID09PSBIb3N0U2luZ2xldG9uIDogZmFsc2UpKSA7IGVsc2Uge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoY2hpbGQsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgIHZhciBzaWJsaW5nID0gY2hpbGQuc2libGluZztcblxuICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihzaWJsaW5nLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICB2YXIgdGFnID0gbm9kZS50YWc7XG4gIHZhciBpc0hvc3QgPSB0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0VGV4dDtcblxuICBpZiAoaXNIb3N0KSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudCwgc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIHN0YXRlTm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gSG9zdFBvcnRhbCB8fCAoc3VwcG9ydHNTaW5nbGV0b25zID8gdGFnID09PSBIb3N0U2luZ2xldG9uIDogZmFsc2UpKSA7IGVsc2Uge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShjaGlsZCwgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgdmFyIHNpYmxpbmcgPSBjaGlsZC5zaWJsaW5nO1xuXG4gICAgICB3aGlsZSAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoc2libGluZywgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgICBzaWJsaW5nID0gc2libGluZy5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBUaGVzZSBhcmUgdHJhY2tlZCBvbiB0aGUgc3RhY2sgYXMgd2UgcmVjdXJzaXZlbHkgdHJhdmVyc2UgYVxuLy8gZGVsZXRlZCBzdWJ0cmVlLlxuLy8gVE9ETzogVXBkYXRlIHRoZXNlIGR1cmluZyB0aGUgd2hvbGUgbXV0YXRpb24gcGhhc2UsIG5vdCBqdXN0IGR1cmluZ1xuLy8gYSBkZWxldGlvbi5cblxuXG52YXIgaG9zdFBhcmVudCA9IG51bGw7XG52YXIgaG9zdFBhcmVudElzQ29udGFpbmVyID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uRWZmZWN0cyhyb290LCByZXR1cm5GaWJlciwgZGVsZXRlZEZpYmVyKSB7XG4gIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgZGVsZXRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQsIGRldGFjaCByZWZzLCBjbGVhblxuICAgIC8vIHVwIG1vdW50ZWQgbGF5b3V0IGVmZmVjdHMsIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50LlxuICAgIC8vIFdlIG9ubHkgbmVlZCB0byByZW1vdmUgdGhlIHRvcG1vc3QgaG9zdCBjaGlsZCBpbiBlYWNoIGJyYW5jaC4gQnV0IHRoZW4gd2VcbiAgICAvLyBzdGlsbCBuZWVkIHRvIGtlZXAgdHJhdmVyc2luZyB0byB1bm1vdW50IGVmZmVjdHMsIHJlZnMsIGFuZCBjV1UuIFRPRE86IFdlXG4gICAgLy8gY291bGQgc3BsaXQgdGhpcyBpbnRvIHR3byBzZXBhcmF0ZSB0cmF2ZXJzYWxzIGZ1bmN0aW9ucywgd2hlcmUgdGhlIHNlY29uZFxuICAgIC8vIG9uZSBkb2Vzbid0IGluY2x1ZGUgYW55IHJlbW92ZUNoaWxkIGxvZ2ljLiBUaGlzIGlzIG1heWJlIHRoZSBzYW1lXG4gICAgLy8gZnVuY3Rpb24gYXMgXCJkaXNhcHBlYXJMYXlvdXRFZmZlY3RzXCIgKG9yIHdoYXRldmVyIHRoYXQgdHVybnMgaW50byBhZnRlclxuICAgIC8vIHRoZSBsYXlvdXQgcGhhc2UgaXMgcmVmYWN0b3JlZCB0byB1c2UgcmVjdXJzaW9uKS5cbiAgICAvLyBCZWZvcmUgc3RhcnRpbmcsIGZpbmQgdGhlIG5lYXJlc3QgaG9zdCBwYXJlbnQgb24gdGhlIHN0YWNrIHNvIHdlIGtub3dcbiAgICAvLyB3aGljaCBpbnN0YW5jZS9jb250YWluZXIgdG8gcmVtb3ZlIHRoZSBjaGlsZHJlbiBmcm9tLlxuICAgIC8vIFRPRE86IEluc3RlYWQgb2Ygc2VhcmNoaW5nIHVwIHRoZSBmaWJlciByZXR1cm4gcGF0aCBvbiBldmVyeSBkZWxldGlvbiwgd2VcbiAgICAvLyBjYW4gdHJhY2sgdGhlIG5lYXJlc3QgaG9zdCBjb21wb25lbnQgb24gdGhlIEpTIHN0YWNrIGFzIHdlIHRyYXZlcnNlIHRoZVxuICAgIC8vIHRyZWUgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UuIFRoaXMgd291bGQgbWFrZSBpbnNlcnRpb25zIGZhc3RlciwgdG9vLlxuICAgIHZhciBwYXJlbnQgPSByZXR1cm5GaWJlcjtcblxuICAgIGZpbmRQYXJlbnQ6IHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuICAgICAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChob3N0UGFyZW50ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5ICcgKyAnYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcik7XG4gICAgaG9zdFBhcmVudCA9IG51bGw7XG4gICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKHJvb3QsIHJldHVybkZpYmVyLCBkZWxldGVkRmliZXIpO1xuICB9XG5cbiAgZGV0YWNoRmliZXJNdXRhdGlvbihkZWxldGVkRmliZXIpO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgcGFyZW50KSB7XG4gIC8vIFRPRE86IFVzZSBhIHN0YXRpYyBmbGFnIHRvIHNraXAgdHJlZXMgdGhhdCBkb24ndCBoYXZlIHVubW91bnQgZWZmZWN0c1xuICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGNoaWxkKTtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcikge1xuICBvbkNvbW1pdFVubW91bnQoZGVsZXRlZEZpYmVyKTsgLy8gVGhlIGNhc2VzIGluIHRoaXMgb3V0ZXIgc3dpdGNoIG1vZGlmeSB0aGUgc3RhY2sgYmVmb3JlIHRoZXkgdHJhdmVyc2VcbiAgLy8gaW50byB0aGVpciBzdWJ0cmVlLiBUaGVyZSBhcmUgc2ltcGxlciBjYXNlcyBpbiB0aGUgaW5uZXIgc3dpdGNoXG4gIC8vIHRoYXQgZG9uJ3QgbW9kaWZ5IHRoZSBzdGFjay5cblxuICBzd2l0Y2ggKGRlbGV0ZWRGaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgIGlmICghb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG5cbiAgICAgICAgICBpZiAoZGVsZXRlZEZpYmVyLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgIHJlbGVhc2VSZXNvdXJjZShkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkZWxldGVkRmliZXIuc3RhdGVOb2RlKSB7XG4gICAgICAgICAgICB1bm1vdW50SG9pc3RhYmxlKGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgaWYgKCFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcHJldkhvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgICAgICAgIHZhciBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgICAgIGhvc3RQYXJlbnQgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpOyAvLyBOb3JtYWxseSB0aGlzIGlzIGNhbGxlZCBpbiBwYXNzaXZlIHVubW91bnQgZWZmZWN0IHBoYXNlIGhvd2V2ZXIgd2l0aFxuICAgICAgICAgIC8vIEhvc3RTaW5nbGV0b24gd2Ugd2FybiBpZiB5b3UgYWNxdWlyZSBvbmUgdGhhdCBpcyBhbHJlYWR5IGFzc29jaWF0ZWQgdG9cbiAgICAgICAgICAvLyBhIGRpZmZlcmVudCBmaWJlci4gVG8gaW5jcmVhc2Ugb3VyIGNoYW5jZXMgb2YgYXZvaWRpbmcgdGhpcywgc3BlY2lmaWNhbGx5XG4gICAgICAgICAgLy8gaWYgeW91IGtleWVkIGEgSG9zdFNpbmdsZXRvbiBzbyB0aGVyZSB3aWxsIGJlIGEgZGVsZXRlIGZvbGxvd2VkIGJ5IGEgUGxhY2VtZW50XG4gICAgICAgICAgLy8gd2UgdHJlYXQgZGV0YWNoIGVhZ2VybHkgaGVyZVxuXG4gICAgICAgICAgcmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlKGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgIGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudDtcbiAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBpZiAoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgfSAvLyBJbnRlbnRpb25hbCBmYWxsdGhyb3VnaCB0byBuZXh0IGJyYW5jaFxuXG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcmVtb3ZlIHRoZSBuZWFyZXN0IGhvc3QgY2hpbGQuIFNldCB0aGUgaG9zdCBwYXJlbnRcbiAgICAgICAgLy8gdG8gYG51bGxgIG9uIHRoZSBzdGFjayB0byBpbmRpY2F0ZSB0aGF0IG5lc3RlZCBjaGlsZHJlbiBkb24ndFxuICAgICAgICAvLyBuZWVkIHRvIGJlIHJlbW92ZWQuXG4gICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgdmFyIF9wcmV2SG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgICAgICAgdmFyIF9wcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgICAgIGhvc3RQYXJlbnQgPSBudWxsO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICAgIGhvc3RQYXJlbnQgPSBfcHJldkhvc3RQYXJlbnQ7XG4gICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gX3ByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG5cbiAgICAgICAgICBpZiAoaG9zdFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gTm93IHRoYXQgYWxsIHRoZSBjaGlsZCBlZmZlY3RzIGhhdmUgdW5tb3VudGVkLCB3ZSBjYW4gcmVtb3ZlIHRoZVxuICAgICAgICAgICAgLy8gbm9kZSBmcm9tIHRoZSB0cmVlLlxuICAgICAgICAgICAgaWYgKGhvc3RQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIoaG9zdFBhcmVudCwgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZW1vdmVDaGlsZChob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIERlaHlkcmF0ZWRGcmFnbWVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGJvdW5kYXJ5IGFuZCBhbGwgb2YgaXRzIGNvbnRlbnQuXG5cblxuICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgIGlmIChob3N0UGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaG9zdFBhcmVudElzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIoaG9zdFBhcmVudCwgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjbGVhclN1c3BlbnNlQm91bmRhcnkoaG9zdFBhcmVudCwgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAgIHZhciBfcHJldkhvc3RQYXJlbnQyID0gaG9zdFBhcmVudDtcbiAgICAgICAgICB2YXIgX3ByZXZIb3N0UGFyZW50SXNDb250YWluZXIyID0gaG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgICAgIGhvc3RQYXJlbnQgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICBob3N0UGFyZW50ID0gX3ByZXZIb3N0UGFyZW50MjtcbiAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBfcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW1wdHlQb3J0YWxDb250YWluZXIoZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmICghb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGRlbGV0ZWRGaWJlci51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0O1xuXG4gICAgICAgICAgICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IGVmZmVjdC50YWc7XG4gICAgICAgICAgICAgICAgdmFyIGluc3QgPSBlZmZlY3QuaW5zdDtcbiAgICAgICAgICAgICAgICB2YXIgZGVzdHJveSA9IGluc3QuZGVzdHJveTtcblxuICAgICAgICAgICAgICAgIGlmIChkZXN0cm95ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICAgICAgICBpbnN0LmRlc3Ryb3kgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0YWcgJiBMYXlvdXQpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRQcm9maWxlKGRlbGV0ZWRGaWJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaW5zdC5kZXN0cm95ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbnN0LmRlc3Ryb3kgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZXN0cm95KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgICAgICAgICAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIG9mZnNjcmVlbiBjb21wb25lbnQgaXMgaGlkZGVuLCB3ZSBhbHJlYWR5IHVubW91bnRlZCBpdC4gQmVmb3JlXG4gICAgICAgICAgLy8gZGVsZXRpbmcgdGhlIGNoaWxkcmVuLCB0cmFjayB0aGF0IGl0J3MgYWxyZWFkeSB1bm1vdW50ZWQgc28gdGhhdCB3ZVxuICAgICAgICAgIC8vIGRvbid0IGF0dGVtcHQgdG8gdW5tb3VudCB0aGUgZWZmZWN0cyBhZ2Fpbi5cbiAgICAgICAgICAvLyBUT0RPOiBJZiB0aGUgdHJlZSBpcyBoaWRkZW4sIGluIG1vc3QgY2FzZXMgd2Ugc2hvdWxkIGJlIGFibGUgdG8gc2tpcFxuICAgICAgICAgIC8vIG92ZXIgdGhlIG5lc3RlZCBjaGlsZHJlbiBlbnRpcmVseS4gQW4gZXhjZXB0aW9uIGlzIHdlIGhhdmVuJ3QgeWV0IGZvdW5kXG4gICAgICAgICAgLy8gdGhlIHRvcG1vc3QgaG9zdCBub2RlIHRvIGRlbGV0ZSwgd2hpY2ggd2UgYWxyZWFkeSB0cmFjayBvbiB0aGUgc3RhY2suXG4gICAgICAgICAgLy8gQnV0IHRoZSBvdGhlciBjYXNlIGlzIHBvcnRhbHMsIHdoaWNoIG5lZWQgdG8gYmUgZGV0YWNoZWQgbm8gbWF0dGVyIGhvd1xuICAgICAgICAgIC8vIGRlZXBseSB0aGV5IGFyZSBuZXN0ZWQuIFdlIHNob3VsZCB1c2UgYSBzdWJ0cmVlIGZsYWcgdG8gdHJhY2sgd2hldGhlciBhXG4gICAgICAgICAgLy8gc3VidHJlZSBpbmNsdWRlcyBhIG5lc3RlZCBwb3J0YWwuXG4gICAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHwgZGVsZXRlZEZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlQ2FsbGJhY2soZmluaXNoZWRXb3JrKSB7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV3U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAobmV3U3RhdGUgPT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IHByZXZTdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChzdXNwZW5zZUluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcblxuICAgICAgICAgICAgdmFyIGh5ZHJhdGlvbkNhbGxiYWNrcywgb25IeWRyYXRlZDsgaWYgKGVuYWJsZVN1c3BlbnNlQ2FsbGJhY2spIDtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJldHJ5Q2FjaGUoZmluaXNoZWRXb3JrKSB7XG4gIC8vIFRPRE86IFVuaWZ5IHRoZSBpbnRlcmZhY2UgZm9yIHRoZSByZXRyeSBjYWNoZSBzbyB3ZSBkb24ndCBoYXZlIHRvIHN3aXRjaFxuICAvLyBvbiB0aGUgdGFnIGxpa2UgdGhpcy5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChyZXRyeUNhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0cnlDYWNoZTtcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgX3JldHJ5Q2FjaGUgPSBpbnN0YW5jZS5fcmV0cnlDYWNoZTtcblxuICAgICAgICBpZiAoX3JldHJ5Q2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICBfcmV0cnlDYWNoZSA9IGluc3RhbmNlLl9yZXRyeUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha1NldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9yZXRyeUNhY2hlO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBTdXNwZW5zZSBoYW5kbGVyIHRhZyAoXCIgKyBmaW5pc2hlZFdvcmsudGFnICsgXCIpLiBUaGlzIGlzIGEgXCIgKyAnYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaE9mZnNjcmVlbkluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHZhciBmaWJlciA9IGluc3RhbmNlLl9jdXJyZW50O1xuXG4gIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyBPZmZzY3JlZW4uZGV0YWNoIGJlZm9yZSBpbnN0YW5jZSBoYW5kbGUgaGFzIGJlZW4gc2V0LicpO1xuICB9XG5cbiAgaWYgKChpbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgJiBPZmZzY3JlZW5EZXRhY2hlZCkgIT09IE5vRmxhZ3MkMSkge1xuICAgIC8vIFRoZSBpbnN0YW5jZSBpcyBhbHJlYWR5IGRldGFjaGVkLCB0aGlzIGlzIGEgbm9vcC5cbiAgICByZXR1cm47XG4gIH0gLy8gVE9ETzogVGhlcmUgaXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3B0aW1pc2UgdGhpcyBieSBub3QgZW50ZXJpbmcgY29tbWl0IHBoYXNlXG4gIC8vIGFuZCB1bm1vdW50aW5nIGVmZmVjdHMgZGlyZWN0bHkuXG5cblxuICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5IHw9IE9mZnNjcmVlbkRldGFjaGVkO1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUpO1xuICB9XG59XG5mdW5jdGlvbiBhdHRhY2hPZmZzY3JlZW5JbnN0YW5jZShpbnN0YW5jZSkge1xuICB2YXIgZmliZXIgPSBpbnN0YW5jZS5fY3VycmVudDtcblxuICBpZiAoZmliZXIgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgT2Zmc2NyZWVuLmRldGFjaCBiZWZvcmUgaW5zdGFuY2UgaGFuZGxlIGhhcyBiZWVuIHNldC4nKTtcbiAgfVxuXG4gIGlmICgoaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICYgT2Zmc2NyZWVuRGV0YWNoZWQpID09PSBOb0ZsYWdzJDEpIHtcbiAgICAvLyBUaGUgaW5zdGFuY2UgaXMgYWxyZWFkeSBhdHRhY2hlZCwgdGhpcyBpcyBhIG5vb3AuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIGluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmPSB+T2Zmc2NyZWVuRGV0YWNoZWQ7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIHdha2VhYmxlcykge1xuICAvLyBJZiB0aGlzIGJvdW5kYXJ5IGp1c3QgdGltZWQgb3V0LCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHNldCBvZiB3YWtlYWJsZXMuXG4gIC8vIEZvciBlYWNoIHdha2VhYmxlLCBhdHRhY2ggYSBsaXN0ZW5lciBzbyB0aGF0IHdoZW4gaXQgcmVzb2x2ZXMsIFJlYWN0XG4gIC8vIGF0dGVtcHRzIHRvIHJlLXJlbmRlciB0aGUgYm91bmRhcnkgaW4gdGhlIHByaW1hcnkgKHByZS10aW1lb3V0KSBzdGF0ZS5cbiAgdmFyIHJldHJ5Q2FjaGUgPSBnZXRSZXRyeUNhY2hlKGZpbmlzaGVkV29yayk7XG4gIHdha2VhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh3YWtlYWJsZSkge1xuICAgIC8vIE1lbW9pemUgdXNpbmcgdGhlIGJvdW5kYXJ5IGZpYmVyIHRvIHByZXZlbnQgcmVkdW5kYW50IGxpc3RlbmVycy5cbiAgICB2YXIgcmV0cnkgPSByZXNvbHZlUmV0cnlXYWtlYWJsZS5iaW5kKG51bGwsIGZpbmlzaGVkV29yaywgd2FrZWFibGUpO1xuXG4gICAgaWYgKCFyZXRyeUNhY2hlLmhhcyh3YWtlYWJsZSkpIHtcbiAgICAgIHJldHJ5Q2FjaGUuYWRkKHdha2VhYmxlKTtcblxuICAgICAge1xuICAgICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgICBpZiAoaW5Qcm9ncmVzc0xhbmVzICE9PSBudWxsICYmIGluUHJvZ3Jlc3NSb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgYXNzb2NpYXRlIHRoZSBvcmlnaW5hbCB1cGRhdGVycyB3aXRoIGl0LlxuICAgICAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhpblByb2dyZXNzUm9vdCwgaW5Qcm9ncmVzc0xhbmVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0V4cGVjdGVkIGZpbmlzaGVkIHJvb3QgYW5kIGxhbmVzIHRvIGJlIHNldC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2FrZWFibGUudGhlbihyZXRyeSwgcmV0cnkpO1xuICAgIH1cbiAgfSk7XG59IC8vIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB3aGVuIGEgU3VzcGVuc2UgYm91bmRhcnkgZ29lcyBmcm9tIHZpc2libGUgdG8gaGlkZGVuLlxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpIHtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG4gIGluUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaW5pc2hlZFdvcmspO1xuICBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkV29yaywgcm9vdCk7XG4gIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xuICBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xuICBpblByb2dyZXNzUm9vdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgcGFyZW50RmliZXIsIGxhbmVzKSB7XG4gIC8vIERlbGV0aW9ucyBlZmZlY3RzIGNhbiBiZSBzY2hlZHVsZWQgb24gYW55IGZpYmVyIHR5cGUuIFRoZXkgbmVlZCB0byBoYXBwZW5cbiAgLy8gYmVmb3JlIHRoZSBjaGlsZHJlbiBlZmZlY3RzIGhhZSBmaXJlZC5cbiAgdmFyIGRlbGV0aW9ucyA9IHBhcmVudEZpYmVyLmRlbGV0aW9ucztcblxuICBpZiAoZGVsZXRpb25zICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb21taXREZWxldGlvbkVmZmVjdHMocm9vdCwgcGFyZW50RmliZXIsIGNoaWxkVG9EZWxldGUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY2hpbGRUb0RlbGV0ZSwgcGFyZW50RmliZXIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcHJldkRlYnVnRmliZXIgPSBnZXRDdXJyZW50RmliZXIoKTtcblxuICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgTXV0YXRpb25NYXNrKSB7XG4gICAgdmFyIGNoaWxkID0gcGFyZW50RmliZXIuY2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoY2hpbGQpO1xuICAgICAgY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihjaGlsZCwgcm9vdCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihwcmV2RGVidWdGaWJlcik7XG59XG5cbnZhciBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IG51bGw7XG5cbmZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290LCBsYW5lcykge1xuICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFnczsgLy8gVGhlIGVmZmVjdCBmbGFnIHNob3VsZCBiZSBjaGVja2VkICphZnRlciogd2UgcmVmaW5lIHRoZSB0eXBlIG9mIGZpYmVyLFxuICAvLyBiZWNhdXNlIHRoZSBmaWJlciB0YWcgaXMgbW9yZSBzcGVjaWZpYy4gQW4gZXhjZXB0aW9uIGlzIGFueSBmbGFnIHJlbGF0ZWRcbiAgLy8gdG8gcmVjb25jaWxpYXRpb24sIGJlY2F1c2UgdGhvc2UgY2FuIGJlIHNldCBvbiBhbGwgZmliZXIgdHlwZXMuXG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KEluc2VydGlvbiB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9IC8vIExheW91dCBlZmZlY3RzIGFyZSBkZXN0cm95ZWQgZHVyaW5nIHRoZSBtdXRhdGlvbiBwaGFzZSBzbyB0aGF0IGFsbFxuICAgICAgICAgIC8vIGRlc3Ryb3kgZnVuY3Rpb25zIGZvciBhbGwgZmliZXJzIGFyZSBjYWxsZWQgYmVmb3JlIGFueSBjcmVhdGUgZnVuY3Rpb25zLlxuICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgc2libGluZyBjb21wb25lbnQgZWZmZWN0cyBmcm9tIGludGVyZmVyaW5nIHdpdGggZWFjaCBvdGhlcixcbiAgICAgICAgICAvLyBlLmcuIGEgZGVzdHJveSBmdW5jdGlvbiBpbiBvbmUgY29tcG9uZW50IHNob3VsZCBuZXZlciBvdmVycmlkZSBhIHJlZiBzZXRcbiAgICAgICAgICAvLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuXG5cbiAgICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgQ2FsbGJhY2sgJiYgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuKSB7XG4gICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZlckhpZGRlbkNhbGxiYWNrcyh1cGRhdGVRdWV1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICAvLyBXZSBjYXN0IGJlY2F1c2Ugd2UgYWx3YXlzIHNldCB0aGUgcm9vdCBhdCB0aGUgUmVhY3Qgcm9vdCBhbmQgc28gaXQgY2Fubm90IGJlXG4gICAgICAgICAgLy8gbnVsbCB3aGlsZSB3ZSBhcmUgcHJvY2Vzc2luZyBtdXRhdGlvbiBlZmZlY3RzXG4gICAgICAgICAgdmFyIGhvaXN0YWJsZVJvb3QgPSBjdXJyZW50SG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJlc291cmNlID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG4gICAgICAgICAgICB2YXIgbmV3UmVzb3VyY2UgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gV2UgYXJlIG1vdW50aW5nIGEgbmV3IEhvc3RIb2lzdGFibGUgRmliZXIuIFdlIGZvcmsgdGhlIG1vdW50XG4gICAgICAgICAgICAgIC8vIGJlaGF2aW9yIGJhc2VkIG9uIHdoZXRoZXIgdGhpcyBpbnN0YW5jZSBpcyBhIEhvaXN0YWJsZSBJbnN0YW5jZVxuICAgICAgICAgICAgICAvLyBvciBhIEhvaXN0YWJsZSBSZXNvdXJjZVxuICAgICAgICAgICAgICBpZiAobmV3UmVzb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IGh5ZHJhdGVIb2lzdGFibGUoaG9pc3RhYmxlUm9vdCwgZmluaXNoZWRXb3JrLnR5cGUsIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtb3VudEhvaXN0YWJsZShob2lzdGFibGVSb290LCBmaW5pc2hlZFdvcmsudHlwZSwgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBhY3F1aXJlUmVzb3VyY2UoaG9pc3RhYmxlUm9vdCwgbmV3UmVzb3VyY2UsIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVzb3VyY2UgIT09IG5ld1Jlc291cmNlKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGFyZSBtb3ZpbmcgdG8gb3IgZnJvbSBIb2lzdGFibGUgUmVzb3VyY2UsIG9yIGJldHdlZW4gZGlmZmVyZW50IEhvaXN0YWJsZSBSZXNvdXJjZXNcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSZXNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdW5tb3VudEhvaXN0YWJsZShjdXJyZW50LnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VSZXNvdXJjZShjdXJyZW50UmVzb3VyY2UpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG5ld1Jlc291cmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbW91bnRIb2lzdGFibGUoaG9pc3RhYmxlUm9vdCwgZmluaXNoZWRXb3JrLnR5cGUsIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjcXVpcmVSZXNvdXJjZShob2lzdGFibGVSb290LCBuZXdSZXNvdXJjZSwgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1Jlc291cmNlID09PSBudWxsICYmIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb21taXRVcGRhdGUoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSwgZmluaXNoZWRXb3JrLnR5cGUsIGN1cnJlbnQubWVtb2l6ZWRQcm9wcywgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzV29yayA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1dvcmsgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHNpbmdsZXRvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOyAvLyBUaGlzIHdhcyBhIG5ldyBtb3VudCwgd2UgbmVlZCB0byBjbGVhciBhbmQgc2V0IGluaXRpYWwgcHJvcGVydGllc1xuXG4gICAgICAgICAgICAgIGNsZWFyU2luZ2xldG9uKHNpbmdsZXRvbik7XG4gICAgICAgICAgICAgIGFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZShmaW5pc2hlZFdvcmsudHlwZSwgcHJvcHMsIHNpbmdsZXRvbiwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgIC8vIFRPRE86IENvbnRlbnRSZXNldCBnZXRzIGNsZWFyZWQgYnkgdGhlIGNoaWxkcmVuIGR1cmluZyB0aGUgY29tbWl0XG4gICAgICAgICAgLy8gcGhhc2UuIFRoaXMgaXMgYSByZWZhY3RvciBoYXphcmQgYmVjYXVzZSBpdCBtZWFucyB3ZSBtdXN0IHJlYWRcbiAgICAgICAgICAvLyBmbGFncyB0aGUgZmxhZ3MgYWZ0ZXIgYGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0c2AgaGFzIGFscmVhZHkgcnVuO1xuICAgICAgICAgIC8vIHRoZSBvcmRlciBtYXR0ZXJzLiBXZSBzaG91bGQgcmVmYWN0b3Igc28gdGhhdCBDb250ZW50UmVzZXQgZG9lcyBub3RcbiAgICAgICAgICAvLyByZWx5IG9uIG11dGF0aW5nIHRoZSBmbGFnIGR1cmluZyBjb21taXQuIExpa2UgYnkgc2V0dGluZyBhIGZsYWdcbiAgICAgICAgICAvLyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSBpbnN0ZWFkLlxuICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc2V0VGV4dENvbnRlbnQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlMiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICAgIGlmIChfaW5zdGFuY2UyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gQ29tbWl0IHRoZSB3b3JrIHByZXBhcmVkIGVhcmxpZXIuXG4gICAgICAgICAgICAgIHZhciBuZXdQcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOyAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAgICAgICAvLyB0aGlzIGNhc2UuXG5cbiAgICAgICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1Byb3BzO1xuICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29tbWl0VXBkYXRlKF9pbnN0YW5jZTIsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmbGFncyAmIEZvcm1SZXNldCkge1xuICAgICAgICAgICAgbmVlZHNGb3JtUmVzZXQgPSB0cnVlO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSAhPT0gJ2Zvcm0nKSB7XG4gICAgICAgICAgICAgICAgLy8gUGFyYW5vaWQgY29kaW5nLiBJbiBjYXNlIHdlIGFjY2lkZW50YWxseSBzdGFydCB1c2luZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBGb3JtUmVzZXQgYml0IGZvciBzb21ldGhpbmcgZWxzZS5cbiAgICAgICAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCBob3N0IGNvbXBvbmVudCB0eXBlLiBFeHBlY3RlZCBhIGZvcm0uIFRoaXMgaXMgYSAnICsgJ2J1ZyBpbiBSZWFjdC4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBuZXdUZXh0ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAgICAgLy8gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdUZXh0O1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICBwcmVwYXJlVG9Db21taXRIb2lzdGFibGVzKCk7XG4gICAgICAgICAgdmFyIHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IHByZXZpb3VzSG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbiAmJiBzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZSb290U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgICAgICAgaWYgKHByZXZSb290U3RhdGUuaXNEZWh5ZHJhdGVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVySW5mbyA9IHJvb3QuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHZhciBwZW5kaW5nQ2hpbGRyZW4gPSByb290LnBlbmRpbmdDaGlsZHJlbjtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIHBlbmRpbmdDaGlsZHJlbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVlZHNGb3JtUmVzZXQpIHtcbiAgICAgICAgICAvLyBBIGZvcm0gY29tcG9uZW50IHJlcXVlc3RlZCB0byBiZSByZXNldCBkdXJpbmcgdGhpcyBjb21taXQuIFdlIGRvIHRoaXNcbiAgICAgICAgICAvLyBhZnRlciBhbGwgbXV0YXRpb25zIGluIHRoZSByZXN0IG9mIHRoZSB0cmVlIHNvIHRoYXQgYGRlZmF1bHRWYWx1ZWBcbiAgICAgICAgICAvLyB3aWxsIGFscmVhZHkgYmUgdXBkYXRlZC4gVGhpcyB3YXkgeW91IGNhbiB1cGRhdGUgYGRlZmF1bHRWYWx1ZWAgdXNpbmdcbiAgICAgICAgICAvLyBkYXRhIHNlbnQgYnkgdGhlIHNlcnZlciBhcyBhIHJlc3VsdCBvZiB0aGUgZm9ybSBzdWJtaXNzaW9uLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVGhlb3JldGljYWxseSB3ZSBjb3VsZCBjaGVjayBmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgRm9ybVJlc2V0LFxuICAgICAgICAgIC8vIGJ1dCB0aGUgRm9ybVJlc2V0IGJpdCBpcyBvdmVybG9hZGVkIHdpdGggb3RoZXIgZmxhZ3MgdXNlZCBieSBvdGhlclxuICAgICAgICAgIC8vIGZpYmVyIHR5cGVzLiBTbyB0aGlzIGV4dHJhIHZhcmlhYmxlIGxldHMgdXMgc2tpcCB0cmF2ZXJzaW5nIHRoZSB0cmVlXG4gICAgICAgICAgLy8gZXhjZXB0IHdoZW4gYSBmb3JtIHdhcyBhY3R1YWxseSBzdWJtaXR0ZWQuXG4gICAgICAgICAgbmVlZHNGb3JtUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICByZWN1cnNpdmVseVJlc2V0Rm9ybXMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgdmFyIF9wcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBjdXJyZW50SG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGdldEhvaXN0YWJsZVJvb3QoZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBfcHJldmlvdXNIb2lzdGFibGVSb290O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICB2YXIgcG9ydGFsID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBfY29udGFpbmVySW5mbyA9IHBvcnRhbC5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgdmFyIF9wZW5kaW5nQ2hpbGRyZW4gPSBwb3J0YWwucGVuZGluZ0NoaWxkcmVuO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oX2NvbnRhaW5lckluZm8sIF9wZW5kaW5nQ2hpbGRyZW4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTsgLy8gVE9ETzogV2Ugc2hvdWxkIG1hcmsgYSBmbGFnIG9uIHRoZSBTdXNwZW5zZSBmaWJlciBpdHNlbGYsIHJhdGhlciB0aGFuXG4gICAgICAgIC8vIHJlbHlpbmcgb24gdGhlIE9mZnNjcmVlbiBmaWJlciBoYXZpbmcgYSBmbGFnIGFsc28gYmVpbmcgbWFya2VkLiBUaGVcbiAgICAgICAgLy8gcmVhc29uIGlzIHRoYXQgdGhpcyBvZmZzY3JlZW4gZmliZXIgbWlnaHQgbm90IGJlIHBhcnQgb2YgdGhlIHdvcmstaW4tXG4gICAgICAgIC8vIHByb2dyZXNzIHRyZWUhIEl0IGNvdWxkIGhhdmUgYmVlbiByZXVzZWQgZnJvbSBhIHByZXZpb3VzIHJlbmRlci4gVGhpc1xuICAgICAgICAvLyBkb2Vzbid0IGxlYWQgdG8gaW5jb3JyZWN0IGJlaGF2aW9yIGJlY2F1c2Ugd2UgZG9uJ3QgcmVseSBvbiB0aGUgZmxhZ1xuICAgICAgICAvLyBjaGVjayBhbG9uZTsgd2UgYWxzbyBjb21wYXJlIHRoZSBzdGF0ZXMgZXhwbGljaXRseSBiZWxvdy4gQnV0IGZvclxuICAgICAgICAvLyBtb2RlbGluZyBwdXJwb3Nlcywgd2UgX3Nob3VsZF8gYmUgYWJsZSB0byByZWx5IG9uIHRoZSBmbGFnIGNoZWNrIGFsb25lLlxuICAgICAgICAvLyBTbyB0aGlzIGlzIGEgYml0IGZyYWdpbGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFsc28sIGFsbCB0aGlzIGxvZ2ljIGNvdWxkL3Nob3VsZCBtb3ZlIHRvIHRoZSBwYXNzaXZlIHBoYXNlIHNvIGl0XG4gICAgICAgIC8vIGRvZXNuJ3QgYmxvY2sgcGFpbnQuXG5cbiAgICAgICAgdmFyIG9mZnNjcmVlbkZpYmVyID0gZmluaXNoZWRXb3JrLmNoaWxkO1xuXG4gICAgICAgIGlmIChvZmZzY3JlZW5GaWJlci5mbGFncyAmIFZpc2liaWxpdHkpIHtcbiAgICAgICAgICAvLyBUaHJvdHRsZSB0aGUgYXBwZWFyYW5jZSBhbmQgZGlzYXBwZWFyYW5jZSBvZiBTdXNwZW5zZSBmYWxsYmFja3MuXG4gICAgICAgICAgdmFyIGlzU2hvd2luZ0ZhbGxiYWNrID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG4gICAgICAgICAgdmFyIHdhc1Nob3dpbmdGYWxsYmFjayA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGlzU2hvd2luZ0ZhbGxiYWNrICE9PSB3YXNTaG93aW5nRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgLy8gQSBmYWxsYmFjayBpcyBlaXRoZXIgYXBwZWFyaW5nIG9yIGRpc2FwcGVhcmluZy5cbiAgICAgICAgICAgICAgbWFya0NvbW1pdFRpbWVPZkZhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdFN1c3BlbnNlQ2FsbGJhY2soZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJldHJ5UXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAocmV0cnlRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCByZXRyeVF1ZXVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IG5ld1N0YXRlICE9PSBudWxsO1xuICAgICAgICB2YXIgd2FzSGlkZGVuID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAge1xuICAgICAgICAgIC8vIEJlZm9yZSBjb21taXR0aW5nIHRoZSBjaGlsZHJlbiwgdHJhY2sgb24gdGhlIHN0YWNrIHdoZXRoZXIgdGhpc1xuICAgICAgICAgIC8vIG9mZnNjcmVlbiBzdWJ0cmVlIHdhcyBhbHJlYWR5IGhpZGRlbiwgc28gdGhhdCB3ZSBkb24ndCB1bm1vdW50IHRoZVxuICAgICAgICAgIC8vIGVmZmVjdHMgYWdhaW4uXG4gICAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIHx8IGlzSGlkZGVuO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fCB3YXNIaWRkZW47XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHZhciBvZmZzY3JlZW5JbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7IC8vIFRPRE86IEFkZCBleHBsaWNpdCBlZmZlY3QgZmxhZyB0byBzZXQgX2N1cnJlbnQuXG5cbiAgICAgICAgb2Zmc2NyZWVuSW5zdGFuY2UuX2N1cnJlbnQgPSBmaW5pc2hlZFdvcms7IC8vIE9mZnNjcmVlbiBzdG9yZXMgcGVuZGluZyBjaGFuZ2VzIHRvIHZpc2liaWxpdHkgaW4gYF9wZW5kaW5nVmlzaWJpbGl0eWAuIFRoaXMgaXNcbiAgICAgICAgLy8gdG8gc3VwcG9ydCBiYXRjaGluZyBvZiBgYXR0YWNoYCBhbmQgYGRldGFjaGAgY2FsbHMuXG5cbiAgICAgICAgb2Zmc2NyZWVuSW5zdGFuY2UuX3Zpc2liaWxpdHkgJj0gfk9mZnNjcmVlbkRldGFjaGVkO1xuICAgICAgICBvZmZzY3JlZW5JbnN0YW5jZS5fdmlzaWJpbGl0eSB8PSBvZmZzY3JlZW5JbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgJiBPZmZzY3JlZW5EZXRhY2hlZDtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBWaXNpYmlsaXR5KSB7XG4gICAgICAgICAgLy8gVHJhY2sgdGhlIGN1cnJlbnQgc3RhdGUgb24gdGhlIE9mZnNjcmVlbiBpbnN0YW5jZSBzbyB3ZSBjYW5cbiAgICAgICAgICAvLyByZWFkIGl0IGR1cmluZyBhbiBldmVudFxuICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgb2Zmc2NyZWVuSW5zdGFuY2UuX3Zpc2liaWxpdHkgJj0gfk9mZnNjcmVlblZpc2libGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNjcmVlbkluc3RhbmNlLl92aXNpYmlsaXR5IHw9IE9mZnNjcmVlblZpc2libGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgICB2YXIgaXNVcGRhdGUgPSBjdXJyZW50ICE9PSBudWxsO1xuICAgICAgICAgICAgdmFyIHdhc0hpZGRlbkJ5QW5jZXN0b3JPZmZzY3JlZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gfHwgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjsgLy8gT25seSB0cmlnZ2VyIGRpc2FwcGVyIGxheW91dCBlZmZlY3RzIGlmOlxuICAgICAgICAgICAgLy8gICAtIFRoaXMgaXMgYW4gdXBkYXRlLCBub3QgZmlyc3QgbW91bnQuXG4gICAgICAgICAgICAvLyAgIC0gVGhpcyBPZmZzY3JlZW4gd2FzIG5vdCBoaWRkZW4gYmVmb3JlLlxuICAgICAgICAgICAgLy8gICAtIEFuY2VzdG9yIE9mZnNjcmVlbiB3YXMgbm90IGhpZGRlbiBpbiBwcmV2aW91cyBjb21taXQuXG5cbiAgICAgICAgICAgIGlmIChpc1VwZGF0ZSAmJiAhd2FzSGlkZGVuICYmICF3YXNIaWRkZW5CeUFuY2VzdG9yT2Zmc2NyZWVuKSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBEaXNhcHBlYXIgdGhlIGxheW91dCBlZmZlY3RzIG9mIGFsbCB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBPZmZzY3JlZW4gd2l0aCBtYW51YWwgbW9kZSBtYW5hZ2VzIHZpc2liaWxpdHkgbWFudWFsbHkuXG5cblxuICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uICYmICFpc09mZnNjcmVlbk1hbnVhbChmaW5pc2hlZFdvcmspKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBUaGlzIG5lZWRzIHRvIHJ1biB3aGVuZXZlciB0aGVyZSdzIGFuIGluc2VydGlvbiBvciB1cGRhdGVcbiAgICAgICAgICAgIC8vIGluc2lkZSBhIGhpZGRlbiBPZmZzY3JlZW4gdHJlZS5cbiAgICAgICAgICAgIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKGZpbmlzaGVkV29yaywgaXNIaWRkZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUT0RPOiBNb3ZlIHRvIHBhc3NpdmUgcGhhc2VcblxuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHZhciBvZmZzY3JlZW5RdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgIGlmIChvZmZzY3JlZW5RdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9yZXRyeVF1ZXVlID0gb2Zmc2NyZWVuUXVldWUucmV0cnlRdWV1ZTtcblxuICAgICAgICAgICAgaWYgKF9yZXRyeVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIG9mZnNjcmVlblF1ZXVlLnJldHJ5UXVldWUgPSBudWxsO1xuICAgICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgX3JldHJ5UXVldWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHZhciBfcmV0cnlRdWV1ZTIgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAoX3JldHJ5UXVldWUyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIF9yZXRyeVF1ZXVlMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yaykge1xuICAvLyBQbGFjZW1lbnQgZWZmZWN0cyAoaW5zZXJ0aW9ucywgcmVvcmRlcnMpIGNhbiBiZSBzY2hlZHVsZWQgb24gYW55IGZpYmVyXG4gIC8vIHR5cGUuIFRoZXkgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHRoZSBjaGlsZHJlbiBlZmZlY3RzIGhhdmUgZmlyZWQsIGJ1dFxuICAvLyBiZWZvcmUgdGhlIGVmZmVjdHMgb24gdGhpcyBmaWJlciBoYXZlIGZpcmVkLlxuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgaWYgKGZsYWdzICYgUGxhY2VtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICB9IC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzXG4gICAgLy8gaW5zZXJ0ZWQsIGJlZm9yZSBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkIGRvZXNcbiAgICAvLyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlIHRvIGtpbGwgdGhpcy5cblxuXG4gICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IH5QbGFjZW1lbnQ7XG4gIH1cblxuICBpZiAoZmxhZ3MgJiBIeWRyYXRpbmcpIHtcbiAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gfkh5ZHJhdGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVJlc2V0Rm9ybXMocGFyZW50RmliZXIpIHtcbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIEZvcm1SZXNldCkge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICByZXNldEZvcm1PbkZpYmVyKGNoaWxkKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRGb3JtT25GaWJlcihmaWJlcikge1xuICByZWN1cnNpdmVseVJlc2V0Rm9ybXMoZmliZXIpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgJiYgZmliZXIuZmxhZ3MgJiBGb3JtUmVzZXQpIHtcbiAgICB2YXIgZm9ybUluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHJlc2V0Rm9ybUluc3RhbmNlKGZvcm1JbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIHJvb3QsIGNvbW1pdHRlZExhbmVzKSB7XG4gIGluUHJvZ3Jlc3NMYW5lcyA9IGNvbW1pdHRlZExhbmVzO1xuICBpblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmluaXNoZWRXb3JrKTtcbiAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKHJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yayk7XG4gIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xuICBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xuICBpblByb2dyZXNzUm9vdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKHJvb3QsIHBhcmVudEZpYmVyLCBsYW5lcykge1xuICB2YXIgcHJldkRlYnVnRmliZXIgPSBnZXRDdXJyZW50RmliZXIoKTtcblxuICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgTGF5b3V0TWFzaykge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGNoaWxkKTtcbiAgICAgIHZhciBjdXJyZW50ID0gY2hpbGQuYWx0ZXJuYXRlO1xuICAgICAgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihyb290LCBjdXJyZW50LCBjaGlsZCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihwcmV2RGVidWdGaWJlcik7XG59XG5cbmZ1bmN0aW9uIGRpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgTGF5b3V0U3RhdGljXG4gICAgICAgIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiBSZWZTdGF0aWNcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgUmVmU3RhdGljXG4gICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIFJlZlN0YXRpY1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgdmFyIGlzSGlkZGVuID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGlzSGlkZGVuKSA7IGVsc2Uge1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKHBhcmVudEZpYmVyKSB7XG4gIC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgKFJlZlN0YXRpYyB8IExheW91dFN0YXRpYylcbiAgdmFyIGNoaWxkID0gcGFyZW50RmliZXIuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhjaGlsZCk7XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yaywgLy8gVGhpcyBmdW5jdGlvbiB2aXNpdHMgYm90aCBuZXdseSBmaW5pc2hlZCB3b3JrIGFuZCBub2RlcyB0aGF0IHdlcmUgcmUtdXNlZFxuLy8gZnJvbSBhIHByZXZpb3VzbHkgY29tbWl0dGVkIHRyZWUuIFdlIGNhbm5vdCBjaGVjayBub24tc3RhdGljIGZsYWdzIGlmIHRoZVxuLy8gbm9kZSB3YXMgcmV1c2VkLlxuaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cykge1xuICAvLyBUdXJuIG9uIGxheW91dCBlZmZlY3RzIGluIGEgdHJlZSB0aGF0IHByZXZpb3VzbHkgZGlzYXBwZWFyZWQuXG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpOyAvLyBUT0RPOiBDaGVjayBmbGFncyAmIExheW91dFN0YXRpY1xuXG4gICAgICAgIGNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgTGF5b3V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTsgLy8gVE9ETzogQ2hlY2sgZm9yIExheW91dFN0YXRpYyBmbGFnXG5cbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDb21taXQgYW55IGNhbGxiYWNrcyB0aGF0IHdvdWxkIGhhdmUgZmlyZWQgd2hpbGUgdGhlIGNvbXBvbmVudFxuICAgICAgICAvLyB3YXMgaGlkZGVuLlxuXG5cbiAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdEhpZGRlbkNhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgaW5zdGFuY2UpO1xuICAgICAgICB9IC8vIElmIHRoaXMgaXMgbmV3bHkgZmluaXNoZWQgd29yaywgY2hlY2sgZm9yIHNldFN0YXRlIGNhbGxiYWNrc1xuXG5cbiAgICAgICAgaWYgKGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgZmxhZ3MgJiBDYWxsYmFjaykge1xuICAgICAgICAgIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0gLy8gVE9ETzogQ2hlY2sgZmxhZ3MgJiBSZWZTdGF0aWNcblxuXG4gICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAvLyBVbmxpa2UgY29tbWl0TGF5b3V0RWZmZWN0c09uRmliZXIsIHdlIGRvbid0IG5lZWQgdG8gaGFuZGxlIEhvc3RSb290XG4gICAgLy8gYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIG9ubHkgdmlzaXRzIG5vZGVzIHRoYXQgYXJlIGluc2lkZSBhblxuICAgIC8vIE9mZnNjcmVlbiBmaWJlci5cbiAgICAvLyBjYXNlIEhvc3RSb290OiB7XG4gICAgLy8gIC4uLlxuICAgIC8vIH1cblxuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTsgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgIC8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbiAgICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG5cbiAgICAgICAgaWYgKGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgY3VycmVudCA9PT0gbnVsbCAmJiBmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGNvbW1pdEhvc3RDb21wb25lbnRNb3VudChmaW5pc2hlZFdvcmspO1xuICAgICAgICB9IC8vIFRPRE86IENoZWNrIGZsYWdzICYgUmVmXG5cblxuICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTsgLy8gVE9ETzogRmlndXJlIG91dCBob3cgUHJvZmlsZXIgdXBkYXRlcyBzaG91bGQgd29yayB3aXRoIE9mZnNjcmVlblxuXG4gICAgICAgIGlmIChpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgY29tbWl0UHJvZmlsZXJVcGRhdGUoZmluaXNoZWRXb3JrLCBjdXJyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7IC8vIFRPRE86IEZpZ3VyZSBvdXQgaG93IFN1c3BlbnNlIGh5ZHJhdGlvbiBjYWxsYmFja3Mgc2hvdWxkIHdvcmtcbiAgICAgICAgLy8gd2l0aCBPZmZzY3JlZW4uXG5cbiAgICAgICAgaWYgKGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgb2Zmc2NyZWVuU3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIGlzSGlkZGVuID0gb2Zmc2NyZWVuU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGlzSGlkZGVuKSA7IGVsc2Uge1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpO1xuICAgICAgICB9IC8vIFRPRE86IENoZWNrIGZsYWdzICYgUmVmXG5cblxuICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIHBhcmVudEZpYmVyLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdmlzaXRzIGJvdGggbmV3bHkgZmluaXNoZWQgd29yayBhbmQgbm9kZXMgdGhhdCB3ZXJlIHJlLXVzZWRcbiAgLy8gZnJvbSBhIHByZXZpb3VzbHkgY29tbWl0dGVkIHRyZWUuIFdlIGNhbm5vdCBjaGVjayBub24tc3RhdGljIGZsYWdzIGlmIHRoZVxuICAvLyBub2RlIHdhcyByZXVzZWQuXG4gIHZhciBjaGlsZFNob3VsZEluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgPSBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBMYXlvdXRNYXNrKSAhPT0gTm9GbGFncyQxOyAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIChSZWZTdGF0aWMgfCBMYXlvdXRTdGF0aWMpXG5cbiAgdmFyIHByZXZEZWJ1Z0ZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7XG4gIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50ID0gY2hpbGQuYWx0ZXJuYXRlO1xuICAgIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGNoaWxkLCBjaGlsZFNob3VsZEluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxuXG4gIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYocHJldkRlYnVnRmliZXIpO1xufVxuXG5mdW5jdGlvbiBjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIGhvb2tGbGFncykge1xuICBpZiAoc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspKSB7XG4gICAgc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTtcblxuICAgIHRyeSB7XG4gICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhjdXJyZW50LCBmaW5pc2hlZFdvcmssIGluc3RhbmNlKSB7XG4gIHtcbiAgICB2YXIgcHJldmlvdXNDYWNoZSA9IG51bGw7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAhPT0gbnVsbCkge1xuICAgICAgcHJldmlvdXNDYWNoZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbDtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENhY2hlID0gbnVsbDtcblxuICAgIGlmIChmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCAmJiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgIT09IG51bGwpIHtcbiAgICAgIG5leHRDYWNoZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sO1xuICAgIH0gLy8gUmV0YWluL3JlbGVhc2UgdGhlIGNhY2hlIHVzZWQgZm9yIHBlbmRpbmcgKHN1c3BlbmRlZCkgbm9kZXMuXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgb25seSByZWFjaGVkIGluIHRoZSBub24tc3VzcGVuZGVkL3Zpc2libGUgY2FzZTpcbiAgICAvLyB3aGVuIHRoZSBjb250ZW50IGlzIHN1c3BlbmRlZC9oaWRkZW4sIHRoZSByZXRhaW4vcmVsZWFzZSBvY2N1cnNcbiAgICAvLyB2aWEgdGhlIHBhcmVudCBTdXNwZW5zZSBjb21wb25lbnQgKHNlZSBjYXNlIGFib3ZlKS5cblxuXG4gICAgaWYgKG5leHRDYWNoZSAhPT0gcHJldmlvdXNDYWNoZSkge1xuICAgICAgaWYgKG5leHRDYWNoZSAhPSBudWxsKSB7XG4gICAgICAgIHJldGFpbkNhY2hlKG5leHRDYWNoZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2aW91c0NhY2hlICE9IG51bGwpIHtcbiAgICAgICAgcmVsZWFzZUNhY2hlKHByZXZpb3VzQ2FjaGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAge1xuICAgIHZhciBwcmV2aW91c0NhY2hlID0gbnVsbDtcblxuICAgIGlmIChmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICBwcmV2aW91c0NhY2hlID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlO1xuICAgIH1cblxuICAgIHZhciBuZXh0Q2FjaGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZTsgLy8gUmV0YWluL3JlbGVhc2UgdGhlIGNhY2hlLiBJbiB0aGVvcnkgdGhlIGNhY2hlIGNvbXBvbmVudFxuICAgIC8vIGNvdWxkIGJlIFwiYm9ycm93aW5nXCIgYSBjYWNoZSBpbnN0YW5jZSBvd25lZCBieSBzb21lIHBhcmVudCxcbiAgICAvLyBpbiB3aGljaCBjYXNlIHdlIGNvdWxkIGF2b2lkIHJldGFpbmluZy9yZWxlYXNpbmcuIEJ1dCBpdFxuICAgIC8vIGlzIG5vbi10cml2aWFsIHRvIGRldGVybWluZSB3aGVuIHRoYXQgaXMgdGhlIGNhc2UsIHNvIHdlXG4gICAgLy8gYWx3YXlzIHJldGFpbi9yZWxlYXNlLlxuXG4gICAgaWYgKG5leHRDYWNoZSAhPT0gcHJldmlvdXNDYWNoZSkge1xuICAgICAgcmV0YWluQ2FjaGUobmV4dENhY2hlKTtcblxuICAgICAgaWYgKHByZXZpb3VzQ2FjaGUgIT0gbnVsbCkge1xuICAgICAgICByZWxlYXNlQ2FjaGUocHJldmlvdXNDYWNoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpIHtcbiAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaW5pc2hlZFdvcmspO1xuICBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKHJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKTtcbiAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKHJvb3QsIHBhcmVudEZpYmVyLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpIHtcbiAgdmFyIHByZXZEZWJ1Z0ZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7XG5cbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIFBhc3NpdmVNYXNrKSB7XG4gICAgdmFyIGNoaWxkID0gcGFyZW50RmliZXIuY2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoY2hpbGQpO1xuICAgICAgY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlcihyb290LCBjaGlsZCwgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cblxuICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHByZXZEZWJ1Z0ZpYmVyKTtcbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlcihmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKSB7XG4gIC8vIFdoZW4gdXBkYXRpbmcgdGhpcyBmdW5jdGlvbiwgYWxzbyB1cGRhdGUgcmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMsIHdoaWNoIGRvZXNcbiAgLy8gbW9zdCBvZiB0aGUgc2FtZSB0aGluZ3Mgd2hlbiBhbiBvZmZzY3JlZW4gdHJlZSBnb2VzIGZyb20gaGlkZGVuIC0+IHZpc2libGUsXG4gIC8vIG9yIHdoZW4gdG9nZ2xpbmcgZWZmZWN0cyBpbnNpZGUgYSBoaWRkZW4gdHJlZS5cbiAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUGFzc2l2ZSQxKSB7XG4gICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBQYXNzaXZlIHwgSGFzRWZmZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUGFzc2l2ZSQxKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzQ2FjaGUgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwcmV2aW91c0NhY2hlID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV4dENhY2hlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGU7IC8vIFJldGFpbi9yZWxlYXNlIHRoZSByb290IGNhY2hlLlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IG9uIGluaXRpYWwgbW91bnQsIHByZXZpb3VzQ2FjaGUgYW5kIG5leHRDYWNoZSB3aWxsIGJlIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyBhbmQgdGhpcyByZXRhaW4gd29uJ3Qgb2NjdXIuIFRvIGNvdW50ZXIgdGhpcywgd2UgaW5zdGVhZCByZXRhaW4gdGhlIEhvc3RSb290J3NcbiAgICAgICAgICAgIC8vIGluaXRpYWwgY2FjaGUgd2hlbiBjcmVhdGluZyB0aGUgcm9vdCBpdHNlbGYgKHNlZSBjcmVhdGVGaWJlclJvb3QoKSBpblxuICAgICAgICAgICAgLy8gUmVhY3RGaWJlclJvb3QuanMpLiBTdWJzZXF1ZW50IHVwZGF0ZXMgdGhhdCBjaGFuZ2UgdGhlIGNhY2hlIGFyZSByZWZsZWN0ZWRcbiAgICAgICAgICAgIC8vIGhlcmUsIHN1Y2ggdGhhdCBwcmV2aW91cy9uZXh0IGNhY2hlcyBhcmUgcmV0YWluZWQgY29ycmVjdGx5LlxuXG4gICAgICAgICAgICBpZiAobmV4dENhY2hlICE9PSBwcmV2aW91c0NhY2hlKSB7XG4gICAgICAgICAgICAgIHJldGFpbkNhY2hlKG5leHRDYWNoZSk7XG5cbiAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQ2FjaGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VDYWNoZShwcmV2aW91c0NhY2hlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogUGFzcyBgY3VycmVudGAgYXMgYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvblxuICAgICAgICB2YXIgX2luc3RhbmNlMyA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIGlzSGlkZGVuID0gbmV4dFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgIGlmIChfaW5zdGFuY2UzLl92aXNpYmlsaXR5ICYgT2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlZmZlY3RzIGFyZSBjdXJyZW50bHkgY29ubmVjdGVkLiBVcGRhdGUgdGhlbS5cbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIFRoZSBlZmZlY3RzIGFyZSBjdXJyZW50bHkgZGlzY29ubmVjdGVkLiBTaW5jZSB0aGUgdHJlZSBpcyBoaWRkZW4sXG4gICAgICAgICAgICAgIC8vIGRvbid0IGNvbm5lY3QgdGhlbS4gVGhpcyBhbHNvIGFwcGxpZXMgdG8gdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gXCJBdG9taWNcIiBlZmZlY3RzIGFyZSBvbmVzIHRoYXQgbmVlZCB0byBmaXJlIG9uIGV2ZXJ5IGNvbW1pdCxcbiAgICAgICAgICAgICAgICAvLyBldmVuIGR1cmluZyBwcmUtcmVuZGVyaW5nLiBBbiBleGFtcGxlIGlzIHVwZGF0aW5nIHRoZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAvLyBjb3VudCBvbiBjYWNoZSBpbnN0YW5jZXMuXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUcmVlIGlzIHZpc2libGVcbiAgICAgICAgICBpZiAoX2luc3RhbmNlMy5fdmlzaWJpbGl0eSAmIE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWZmZWN0cyBhcmUgY3VycmVudGx5IGNvbm5lY3RlZC4gVXBkYXRlIHRoZW0uXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBkaXNjb25uZWN0ZWQuIFJlY29ubmVjdCB0aGVtLCB3aGlsZSBhbHNvXG4gICAgICAgICAgICAvLyBmaXJpbmcgZWZmZWN0cyBpbnNpZGUgbmV3bHkgbW91bnRlZCB0cmVlcy4gVGhpcyBhbHNvIGFwcGxpZXMgdG9cbiAgICAgICAgICAgIC8vIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAgICAgICAgIF9pbnN0YW5jZTMuX3Zpc2liaWxpdHkgfD0gT2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQ7XG4gICAgICAgICAgICB2YXIgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spICE9PSBOb0ZsYWdzJDE7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUGFzc2l2ZSQxKSB7XG4gICAgICAgICAgdmFyIF9jdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKF9jdXJyZW50LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBQYXNzaXZlJDEpIHtcbiAgICAgICAgICAvLyBUT0RPOiBQYXNzIGBjdXJyZW50YCBhcyBhcmd1bWVudCB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgdmFyIF9jdXJyZW50MiA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoX2N1cnJlbnQyLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgcGFyZW50RmliZXIsIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIHZpc2l0cyBib3RoIG5ld2x5IGZpbmlzaGVkIHdvcmsgYW5kIG5vZGVzIHRoYXQgd2VyZSByZS11c2VkXG4gIC8vIGZyb20gYSBwcmV2aW91c2x5IGNvbW1pdHRlZCB0cmVlLiBXZSBjYW5ub3QgY2hlY2sgbm9uLXN0YXRpYyBmbGFncyBpZiB0aGVcbiAgLy8gbm9kZSB3YXMgcmV1c2VkLlxuICB2YXIgY2hpbGRTaG91bGRJbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID0gaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spICE9PSBOb0ZsYWdzJDE7IC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgKFJlZlN0YXRpYyB8IExheW91dFN0YXRpYylcblxuICB2YXIgcHJldkRlYnVnRmliZXIgPSBnZXRDdXJyZW50RmliZXIoKTtcbiAgdmFyIGNoaWxkID0gcGFyZW50RmliZXIuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgcmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBjaGlsZCwgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zLCBjaGlsZFNob3VsZEluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxuXG4gIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYocHJldkRlYnVnRmliZXIpO1xufVxuXG5mdW5jdGlvbiByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zLCAvLyBUaGlzIGZ1bmN0aW9uIHZpc2l0cyBib3RoIG5ld2x5IGZpbmlzaGVkIHdvcmsgYW5kIG5vZGVzIHRoYXQgd2VyZSByZS11c2VkXG4vLyBmcm9tIGEgcHJldmlvdXNseSBjb21taXR0ZWQgdHJlZS4gV2UgY2Fubm90IGNoZWNrIG5vbi1zdGF0aWMgZmxhZ3MgaWYgdGhlXG4vLyBub2RlIHdhcyByZXVzZWQuXG5pbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKSB7XG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTsgLy8gVE9ETzogQ2hlY2sgZm9yIFBhc3NpdmVTdGF0aWMgZmxhZ1xuXG4gICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaywgUGFzc2l2ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIFVubGlrZSBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyLCB3ZSBkb24ndCBuZWVkIHRvIGhhbmRsZSBIb3N0Um9vdFxuICAgIC8vIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBvbmx5IHZpc2l0cyBub2RlcyB0aGF0IGFyZSBpbnNpZGUgYW5cbiAgICAvLyBPZmZzY3JlZW4gZmliZXIuXG4gICAgLy8gY2FzZSBIb3N0Um9vdDoge1xuICAgIC8vICAuLi5cbiAgICAvLyB9XG5cbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX2luc3RhbmNlNCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIGlzSGlkZGVuID0gbmV4dFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgIGlmIChfaW5zdGFuY2U0Ll92aXNpYmlsaXR5ICYgT2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlZmZlY3RzIGFyZSBjdXJyZW50bHkgY29ubmVjdGVkLiBVcGRhdGUgdGhlbS5cbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBUaGUgZWZmZWN0cyBhcmUgY3VycmVudGx5IGRpc2Nvbm5lY3RlZC4gU2luY2UgdGhlIHRyZWUgaXMgaGlkZGVuLFxuICAgICAgICAgICAgICAvLyBkb24ndCBjb25uZWN0IHRoZW0uIFRoaXMgYWxzbyBhcHBsaWVzIHRvIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFwiQXRvbWljXCIgZWZmZWN0cyBhcmUgb25lcyB0aGF0IG5lZWQgdG8gZmlyZSBvbiBldmVyeSBjb21taXQsXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBkdXJpbmcgcHJlLXJlbmRlcmluZy4gQW4gZXhhbXBsZSBpcyB1cGRhdGluZyB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgLy8gY291bnQgb24gY2FjaGUgaW5zdGFuY2VzLlxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVHJlZSBpcyB2aXNpYmxlXG4gICAgICAgICAgLy8gU2luY2Ugd2UncmUgYWxyZWFkeSBpbnNpZGUgYSByZWNvbm5lY3RpbmcgdHJlZSwgaXQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgICAvLyB3aGV0aGVyIHRoZSBlZmZlY3RzIGFyZSBjdXJyZW50bHkgY29ubmVjdGVkLiBJbiBlaXRoZXIgY2FzZSwgd2UnbGxcbiAgICAgICAgICAvLyBjb250aW51ZSB0cmF2ZXJzaW5nIHRoZSB0cmVlIGFuZCBmaXJpbmcgYWxsIHRoZSBlZmZlY3RzLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gV2UgZG8gbmVlZCB0byBzZXQgdGhlIFwiY29ubmVjdGVkXCIgZmxhZyBvbiB0aGUgaW5zdGFuY2UsIHRob3VnaC5cbiAgICAgICAgICBfaW5zdGFuY2U0Ll92aXNpYmlsaXR5IHw9IE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIGZsYWdzICYgUGFzc2l2ZSQxKSB7XG4gICAgICAgICAgLy8gVE9ETzogUGFzcyBgY3VycmVudGAgYXMgYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvblxuICAgICAgICAgIHZhciBfY3VycmVudDMgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoX2N1cnJlbnQzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7XG5cbiAgICAgICAgaWYgKGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgZmxhZ3MgJiBQYXNzaXZlJDEpIHtcbiAgICAgICAgICAvLyBUT0RPOiBQYXNzIGBjdXJyZW50YCBhcyBhcmd1bWVudCB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgdmFyIF9jdXJyZW50NCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoX2N1cnJlbnQ0LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIHBhcmVudEZpYmVyLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpIHtcbiAgLy8gXCJBdG9taWNcIiBlZmZlY3RzIGFyZSBvbmVzIHRoYXQgbmVlZCB0byBmaXJlIG9uIGV2ZXJ5IGNvbW1pdCwgZXZlbiBkdXJpbmdcbiAgLy8gcHJlLXJlbmRlcmluZy4gV2UgY2FsbCB0aGlzIGZ1bmN0aW9uIHdoZW4gdHJhdmVyc2luZyBhIGhpZGRlbiB0cmVlIHdob3NlXG4gIC8vIHJlZ3VsYXIgZWZmZWN0cyBhcmUgY3VycmVudGx5IGRpc2Nvbm5lY3RlZC5cbiAgdmFyIHByZXZEZWJ1Z0ZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7IC8vIFRPRE86IEFkZCBzcGVjaWFsIGZsYWcgZm9yIGF0b21pYyBlZmZlY3RzXG5cbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIFBhc3NpdmVNYXNrKSB7XG4gICAgdmFyIGNoaWxkID0gcGFyZW50RmliZXIuY2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoY2hpbGQpO1xuICAgICAgY29tbWl0QXRvbWljUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBjaGlsZCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihwcmV2RGVidWdGaWJlcik7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpIHtcbiAgLy8gXCJBdG9taWNcIiBlZmZlY3RzIGFyZSBvbmVzIHRoYXQgbmVlZCB0byBmaXJlIG9uIGV2ZXJ5IGNvbW1pdCwgZXZlbiBkdXJpbmdcbiAgLy8gcHJlLXJlbmRlcmluZy4gV2UgY2FsbCB0aGlzIGZ1bmN0aW9uIHdoZW4gdHJhdmVyc2luZyBhIGhpZGRlbiB0cmVlIHdob3NlXG4gIC8vIHJlZ3VsYXIgZWZmZWN0cyBhcmUgY3VycmVudGx5IGRpc2Nvbm5lY3RlZC5cbiAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFBhc3NpdmUkMSkge1xuICAgICAgICAgIC8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhjdXJyZW50LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFBhc3NpdmUkMSkge1xuICAgICAgICAgIC8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICB2YXIgX2N1cnJlbnQ1ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChfY3VycmVudDUsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspIHtcbiAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaW5pc2hlZFdvcmspO1xuICBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIoZmluaXNoZWRXb3JrKTtcbiAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG59IC8vIElmIHdlJ3JlIGluc2lkZSBhIGJyYW5kIG5ldyB0cmVlLCBvciBhIHRyZWUgdGhhdCB3YXMgYWxyZWFkeSB2aXNpYmxlLCB0aGVuIHdlXG4vLyBzaG91bGQgb25seSBzdXNwZW5kIGhvc3QgY29tcG9uZW50cyB0aGF0IGhhdmUgYSBTaG91bGRTdXNwZW5kQ29tbWl0IGZsYWcuXG4vLyBDb21wb25lbnRzIHdpdGhvdXQgaXQgaGF2ZW4ndCBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGNvbW1pdCwgc28gd2UgY2FuIHNraXBcbi8vIG92ZXIgdGhvc2UuXG4vL1xuLy8gV2hlbiB3ZSBlbnRlciBhIHRyZWUgdGhhdCBpcyBiZWluZyByZXZlYWxlZCAoZ29pbmcgZnJvbSBoaWRkZW4gLT4gdmlzaWJsZSksXG4vLyB3ZSBuZWVkIHRvIHN1c3BlbmQgX2FueV8gY29tcG9uZW50IHRoYXQgX21heV8gc3VzcGVuZC4gRXZlbiBpZiB0aGV5J3JlXG4vLyBhbHJlYWR5IGluIHRoZSBcImN1cnJlbnRcIiB0cmVlLiBCZWNhdXNlIHRoZWlyIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQsIHRoZVxuLy8gYnJvd3NlciBtYXkgbm90IGhhdmUgcHJlcmVuZGVyZWQgdGhlbSB5ZXQuIFNvIHdlIGNoZWNrIHRoZSBNYXlTdXNwZW5kQ29tbWl0XG4vLyBmbGFnIGluc3RlYWQuXG5cbnZhciBzdXNwZW5zZXlDb21taXRGbGFnID0gU2hvdWxkU3VzcGVuZENvbW1pdDtcbmZ1bmN0aW9uIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmluaXNoZWRXb3JrKSB7XG4gIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKGZpbmlzaGVkV29yayk7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChwYXJlbnRGaWJlcikge1xuICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgc3VzcGVuc2V5Q29tbWl0RmxhZykge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihjaGlsZCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuXG4gICAgICAgIGlmIChmaWJlci5mbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcpIHtcbiAgICAgICAgICBpZiAoZmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3VzcGVuZFJlc291cmNlKCAvLyBUaGlzIHNob3VsZCBhbHdheXMgYmUgc2V0IGJ5IHZpc2l0aW5nIEhvc3RSb290IGZpcnN0XG4gICAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCwgZmliZXIubWVtb2l6ZWRTdGF0ZSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBzdXNwZW5kSW5zdGFuY2UodHlwZSwgcHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuXG4gICAgICAgIGlmIChmaWJlci5mbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcpIHtcbiAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgIHZhciBfcHJvcHMgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIHN1c3BlbmRJbnN0YW5jZShfdHlwZSwgX3Byb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgIHZhciBwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBjdXJyZW50SG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KGNvbnRhaW5lcik7XG4gICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IHByZXZpb3VzSG9pc3RhYmxlUm9vdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGlzSGlkZGVuID0gZmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICBpZiAoaXNIaWRkZW4pIDsgZWxzZSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICAgICAgdmFyIHdhc0hpZGRlbiA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgICAgaWYgKHdhc0hpZGRlbikge1xuICAgICAgICAgICAgLy8gVGhpcyB0cmVlIGlzIGJlaW5nIHJldmVhbGVkLiBWaXNpdCBhbGwgbmV3bHkgdmlzaWJsZSBzdXNwZW5zZXlcbiAgICAgICAgICAgIC8vIGluc3RhbmNlcywgZXZlbiBpZiB0aGV5J3JlIGluIHRoZSBjdXJyZW50IHRyZWUuXG4gICAgICAgICAgICB2YXIgcHJldkZsYWdzID0gc3VzcGVuc2V5Q29tbWl0RmxhZztcbiAgICAgICAgICAgIHN1c3BlbnNleUNvbW1pdEZsYWcgPSBNYXlTdXNwZW5kQ29tbWl0O1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgICAgIHN1c3BlbnNleUNvbW1pdEZsYWcgPSBwcmV2RmxhZ3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKSB7XG4gIC8vIEEgZmliZXIgd2FzIGRlbGV0ZWQgZnJvbSB0aGlzIHBhcmVudCBmaWJlciwgYnV0IGl0J3Mgc3RpbGwgcGFydCBvZiB0aGVcbiAgLy8gcHJldmlvdXMgKGFsdGVybmF0ZSkgcGFyZW50IGZpYmVyJ3MgbGlzdCBvZiBjaGlsZHJlbi4gQmVjYXVzZSBjaGlsZHJlblxuICAvLyBhcmUgYSBsaW5rZWQgbGlzdCwgYW4gZWFybGllciBzaWJsaW5nIHRoYXQncyBzdGlsbCBhbGl2ZSB3aWxsIGJlXG4gIC8vIGNvbm5lY3RlZCB0byB0aGUgZGVsZXRlZCBmaWJlciB2aWEgaXRzIGBhbHRlcm5hdGVgOlxuICAvL1xuICAvLyAgIGxpdmUgZmliZXIgLS1hbHRlcm5hdGUtLT4gcHJldmlvdXMgbGl2ZSBmaWJlciAtLXNpYmxpbmctLT4gZGVsZXRlZFxuICAvLyAgIGZpYmVyXG4gIC8vXG4gIC8vIFdlIGNhbid0IGRpc2Nvbm5lY3QgYGFsdGVybmF0ZWAgb24gbm9kZXMgdGhhdCBoYXZlbid0IGJlZW4gZGVsZXRlZCB5ZXQsXG4gIC8vIGJ1dCB3ZSBjYW4gZGlzY29ubmVjdCB0aGUgYHNpYmxpbmdgIGFuZCBgY2hpbGRgIHBvaW50ZXJzLlxuICB2YXIgcHJldmlvdXNGaWJlciA9IHBhcmVudEZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAocHJldmlvdXNGaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBkZXRhY2hlZENoaWxkID0gcHJldmlvdXNGaWJlci5jaGlsZDtcblxuICAgIGlmIChkZXRhY2hlZENoaWxkICE9PSBudWxsKSB7XG4gICAgICBwcmV2aW91c0ZpYmVyLmNoaWxkID0gbnVsbDtcblxuICAgICAgZG8ge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgdmFyIGRldGFjaGVkU2libGluZyA9IGRldGFjaGVkQ2hpbGQuc2libGluZzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cbiAgICAgICAgZGV0YWNoZWRDaGlsZC5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgZGV0YWNoZWRDaGlsZCA9IGRldGFjaGVkU2libGluZztcbiAgICAgIH0gd2hpbGUgKGRldGFjaGVkQ2hpbGQgIT09IG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaywgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgaG9va0ZsYWdzKSB7XG4gIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpIHtcbiAgICBzdGFydFBhc3NpdmVFZmZlY3RUaW1lcigpO1xuICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yaywgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gIH0gZWxzZSB7XG4gICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKHBhcmVudEZpYmVyKSB7XG4gIC8vIERlbGV0aW9ucyBlZmZlY3RzIGNhbiBiZSBzY2hlZHVsZWQgb24gYW55IGZpYmVyIHR5cGUuIFRoZXkgbmVlZCB0byBoYXBwZW5cbiAgLy8gYmVmb3JlIHRoZSBjaGlsZHJlbiBlZmZlY3RzIGhhdmUgZmlyZWQuXG4gIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG5cbiAgaWYgKChwYXJlbnRGaWJlci5mbGFncyAmIENoaWxkRGVsZXRpb24pICE9PSBOb0ZsYWdzJDEpIHtcbiAgICBpZiAoZGVsZXRpb25zICE9PSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXTsgLy8gVE9ETzogQ29udmVydCB0aGlzIHRvIHVzZSByZWN1cnNpb25cblxuICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihjaGlsZFRvRGVsZXRlLCBwYXJlbnRGaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MocGFyZW50RmliZXIpO1xuICB9XG5cbiAgdmFyIHByZXZEZWJ1Z0ZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7IC8vIFRPRE86IFNwbGl0IFBhc3NpdmVNYXNrIGludG8gc2VwYXJhdGUgbWFza3MgZm9yIG1vdW50IGFuZCB1bm1vdW50P1xuXG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBQYXNzaXZlTWFzaykge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGNoaWxkKTtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihjaGlsZCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihwcmV2RGVidWdGaWJlcik7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihmaW5pc2hlZFdvcmspIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIFBhc3NpdmUkMSkge1xuICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBQYXNzaXZlIHwgSGFzRWZmZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIGlzSGlkZGVuID0gbmV4dFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgIGlmIChpc0hpZGRlbiAmJiBpbnN0YW5jZS5fdmlzaWJpbGl0eSAmIE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkICYmICggLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBkb24ndCB1bm1vdW50IHdoZW4gYSB0cmVlIHN1c3BlbmRzLiBJblxuICAgICAgICAvLyB0aGUgZnV0dXJlIHdlIG1heSBjaGFuZ2UgdGhpcyB0byB1bm1vdW50IGFmdGVyIGEgZGVsYXkuXG4gICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4gPT09IG51bGwgfHwgZmluaXNoZWRXb3JrLnJldHVybi50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSkge1xuICAgICAgICAgIC8vIFRoZSBlZmZlY3RzIGFyZSBjdXJyZW50bHkgY29ubmVjdGVkLiBEaXNjb25uZWN0IHRoZW0uXG4gICAgICAgICAgLy8gVE9ETzogQWRkIG9wdGlvbiBvciBoZXVyaXN0aWMgdG8gZGVsYXkgYmVmb3JlIGRpc2Nvbm5lY3RpbmcgdGhlXG4gICAgICAgICAgLy8gZWZmZWN0cy4gVGhlbiBpZiB0aGUgdHJlZSByZWFwcGVhcnMgYmVmb3JlIHRoZSBkZWxheSBoYXMgZWxhcHNlZCwgd2VcbiAgICAgICAgICAvLyBjYW4gc2tpcCB0b2dnbGluZyB0aGUgZWZmZWN0cyBlbnRpcmVseS5cbiAgICAgICAgICBpbnN0YW5jZS5fdmlzaWJpbGl0eSAmPSB+T2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQ7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKHBhcmVudEZpYmVyKSB7XG4gIC8vIERlbGV0aW9ucyBlZmZlY3RzIGNhbiBiZSBzY2hlZHVsZWQgb24gYW55IGZpYmVyIHR5cGUuIFRoZXkgbmVlZCB0byBoYXBwZW5cbiAgLy8gYmVmb3JlIHRoZSBjaGlsZHJlbiBlZmZlY3RzIGhhdmUgZmlyZWQuXG4gIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG5cbiAgaWYgKChwYXJlbnRGaWJlci5mbGFncyAmIENoaWxkRGVsZXRpb24pICE9PSBOb0ZsYWdzJDEpIHtcbiAgICBpZiAoZGVsZXRpb25zICE9PSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXTsgLy8gVE9ETzogQ29udmVydCB0aGlzIHRvIHVzZSByZWN1cnNpb25cblxuICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihjaGlsZFRvRGVsZXRlLCBwYXJlbnRGaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MocGFyZW50RmliZXIpO1xuICB9XG5cbiAgdmFyIHByZXZEZWJ1Z0ZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7IC8vIFRPRE86IENoZWNrIFBhc3NpdmVTdGF0aWMgZmxhZ1xuXG4gIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoY2hpbGQpO1xuICAgIGRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0KGNoaWxkKTtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cblxuICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHByZXZEZWJ1Z0ZpYmVyKTtcbn1cblxuZnVuY3Rpb24gZGlzY29ubmVjdFBhc3NpdmVFZmZlY3QoZmluaXNoZWRXb3JrKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogQ2hlY2sgUGFzc2l2ZVN0YXRpYyBmbGFnXG4gICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBQYXNzaXZlKTsgLy8gV2hlbiBkaXNjb25uZWN0aW5nIHBhc3NpdmUgZWZmZWN0cywgd2UgZmlyZSB0aGUgZWZmZWN0cyBpbiB0aGUgc2FtZVxuICAgICAgICAvLyBvcmRlciBhcyBkdXJpbmcgYSBkZWxldGlvbmc6IHBhcmVudCBiZWZvcmUgY2hpbGRcblxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlLl92aXNpYmlsaXR5ICYgT2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQpIHtcbiAgICAgICAgICBpbnN0YW5jZS5fdmlzaWJpbGl0eSAmPSB+T2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQ7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oZGVsZXRlZFN1YnRyZWVSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDsgLy8gRGVsZXRpb24gZWZmZWN0cyBmaXJlIGluIHBhcmVudCAtPiBjaGlsZCBvcmRlclxuICAgIC8vIFRPRE86IENoZWNrIGlmIGZpYmVyIGhhcyBhIFBhc3NpdmVTdGF0aWMgZmxhZ1xuXG4gICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaWJlcik7XG4gICAgY29tbWl0UGFzc2l2ZVVubW91bnRJbnNpZGVEZWxldGVkVHJlZU9uRmliZXIoZmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkOyAvLyBUT0RPOiBPbmx5IHRyYXZlcnNlIHN1YnRyZWUgaWYgaXQgaGFzIGEgUGFzc2l2ZVN0YXRpYyBmbGFnLlxuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBjaGlsZC5yZXR1cm4gPSBmaWJlcjtcbiAgICAgIG5leHRFZmZlY3QgPSBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9jb21wbGV0ZShkZWxldGVkU3VidHJlZVJvb3QpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2NvbXBsZXRlKGRlbGV0ZWRTdWJ0cmVlUm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG4gICAgdmFyIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nO1xuICAgIHZhciByZXR1cm5GaWJlciA9IGZpYmVyLnJldHVybjsgLy8gUmVjdXJzaXZlbHkgdHJhdmVyc2UgdGhlIGVudGlyZSBkZWxldGVkIHRyZWUgYW5kIGNsZWFuIHVwIGZpYmVyIGZpZWxkcy5cbiAgICAvLyBUaGlzIGlzIG1vcmUgYWdncmVzc2l2ZSB0aGFuIGlkZWFsLCBhbmQgdGhlIGxvbmcgdGVybSBnb2FsIGlzIHRvIG9ubHlcbiAgICAvLyBoYXZlIHRvIGRldGFjaCB0aGUgZGVsZXRlZCB0cmVlIGF0IHRoZSByb290LlxuXG4gICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpO1xuXG4gICAgaWYgKGZpYmVyID09PSBkZWxldGVkU3VidHJlZVJvb3QpIHtcbiAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IHJldHVybkZpYmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgc3dpdGNoIChjdXJyZW50LnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBQYXNzaXZlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gVE9ETzogcnVuIHBhc3NpdmUgdW5tb3VudCBlZmZlY3RzIHdoZW4gdW5tb3VudGluZyBhIHJvb3QuXG4gICAgLy8gQmVjYXVzZSBwYXNzaXZlIHVubW91bnQgZWZmZWN0cyBhcmUgbm90IGN1cnJlbnRseSBydW4sXG4gICAgLy8gdGhlIGNhY2hlIGluc3RhbmNlIG93bmVkIGJ5IHRoZSByb290IHdpbGwgbmV2ZXIgYmUgZnJlZWQuXG4gICAgLy8gV2hlbiBlZmZlY3RzIGFyZSBydW4sIHRoZSBjYWNoZSBzaG91bGQgYmUgZnJlZWQgaGVyZTpcbiAgICAvLyBjYXNlIEhvc3RSb290OiB7XG4gICAgLy8gICBpZiAoZW5hYmxlQ2FjaGUpIHtcbiAgICAvLyAgICAgY29uc3QgY2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgLy8gICAgIHJlbGVhc2VDYWNoZShjYWNoZSk7XG4gICAgLy8gICB9XG4gICAgLy8gICBicmVhaztcbiAgICAvLyB9XG5cbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sOyAvLyBSZXRhaW4vcmVsZWFzZSB0aGUgY2FjaGUgdXNlZCBmb3IgcGVuZGluZyAoc3VzcGVuZGVkKSBub2Rlcy5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIG9ubHkgcmVhY2hlZCBpbiB0aGUgbm9uLXN1c3BlbmRlZC92aXNpYmxlIGNhc2U6XG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBjb250ZW50IGlzIHN1c3BlbmRlZC9oaWRkZW4sIHRoZSByZXRhaW4vcmVsZWFzZSBvY2N1cnNcbiAgICAgICAgICAgIC8vIHZpYSB0aGUgcGFyZW50IFN1c3BlbnNlIGNvbXBvbmVudCAoc2VlIGNhc2UgYWJvdmUpLlxuXG4gICAgICAgICAgICBpZiAoY2FjaGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXRhaW5DYWNoZShjYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfY2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgICAgICAgcmVsZWFzZUNhY2hlKF9jYWNoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDYWNoZUZvclR5cGUocmVzb3VyY2VUeXBlKSB7XG5cbiAgdmFyIGNhY2hlID0gcmVhZENvbnRleHQoQ2FjaGVDb250ZXh0KTtcbiAgdmFyIGNhY2hlRm9yVHlwZSA9IGNhY2hlLmRhdGEuZ2V0KHJlc291cmNlVHlwZSk7XG5cbiAgaWYgKGNhY2hlRm9yVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FjaGVGb3JUeXBlID0gcmVzb3VyY2VUeXBlKCk7XG4gICAgY2FjaGUuZGF0YS5zZXQocmVzb3VyY2VUeXBlLCBjYWNoZUZvclR5cGUpO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlRm9yVHlwZTtcbn1cblxudmFyIERlZmF1bHRBc3luY0Rpc3BhdGNoZXIgPSB7XG4gIGdldENhY2hlRm9yVHlwZTogZ2V0Q2FjaGVGb3JUeXBlXG59O1xuXG57XG4gIERlZmF1bHRBc3luY0Rpc3BhdGNoZXIuZ2V0T3duZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH07XG59XG5cbnZhciBDT01QT05FTlRfVFlQRSA9IDA7XG52YXIgSEFTX1BTRVVET19DTEFTU19UWVBFID0gMTtcbnZhciBST0xFX1RZUEUgPSAyO1xudmFyIFRFU1RfTkFNRV9UWVBFID0gMztcbnZhciBURVhUX1RZUEUgPSA0O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBDT01QT05FTlRfVFlQRSA9IHN5bWJvbEZvcignc2VsZWN0b3IuY29tcG9uZW50Jyk7XG4gIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IHN5bWJvbEZvcignc2VsZWN0b3IuaGFzX3BzZXVkb19jbGFzcycpO1xuICBST0xFX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLnJvbGUnKTtcbiAgVEVTVF9OQU1FX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLnRlc3RfaWQnKTtcbiAgVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci50ZXh0Jyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yKGNvbXBvbmVudCkge1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBDT01QT05FTlRfVFlQRSxcbiAgICB2YWx1ZTogY29tcG9uZW50XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yKHNlbGVjdG9ycykge1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBIQVNfUFNFVURPX0NMQVNTX1RZUEUsXG4gICAgdmFsdWU6IHNlbGVjdG9yc1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUm9sZVNlbGVjdG9yKHJvbGUpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUk9MRV9UWVBFLFxuICAgIHZhbHVlOiByb2xlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0U2VsZWN0b3IodGV4dCkge1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBURVhUX1RZUEUsXG4gICAgdmFsdWU6IHRleHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRlc3ROYW1lU2VsZWN0b3IoaWQpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogVEVTVF9OQU1FX1RZUEUsXG4gICAgdmFsdWU6IGlkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCkge1xuICB2YXIgbWF5YmVGaWJlciA9IGdldEluc3RhbmNlRnJvbU5vZGUoaG9zdFJvb3QpO1xuXG4gIGlmIChtYXliZUZpYmVyICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIG1heWJlRmliZXIubWVtb2l6ZWRQcm9wc1snZGF0YS10ZXN0bmFtZSddICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvc3Qgcm9vdCBzcGVjaWZpZWQuIFNob3VsZCBiZSBlaXRoZXIgYSBSZWFjdCBjb250YWluZXIgb3IgYSBub2RlIHdpdGggYSB0ZXN0bmFtZSBhdHRyaWJ1dGUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlRmliZXI7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpYmVyUm9vdCA9IGZpbmRGaWJlclJvb3QoaG9zdFJvb3QpO1xuXG4gICAgaWYgKGZpYmVyUm9vdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBSZWFjdCBjb250YWluZXIgd2l0aGluIHNwZWNpZmllZCBob3N0IHN1YnRyZWUuJyk7XG4gICAgfSAvLyBUaGUgRmxvdyB0eXBlIGZvciBGaWJlclJvb3QgaXMgYSBsaXR0bGUgZnVua3kuXG4gICAgLy8gY3JlYXRlRmliZXJSb290KCkgY2hlYXRzIHRoaXMgYnkgdHJlYXRpbmcgdGhlIHJvb3QgYXMgOmFueSBhbmQgYWRkaW5nIHN0YXRlTm9kZSBsYXppbHkuXG5cblxuICAgIHJldHVybiBmaWJlclJvb3Quc3RhdGVOb2RlLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hTZWxlY3RvcihmaWJlciwgc2VsZWN0b3IpIHtcbiAgdmFyIHRhZyA9IGZpYmVyLnRhZztcblxuICBzd2l0Y2ggKHNlbGVjdG9yLiQkdHlwZW9mKSB7XG4gICAgY2FzZSBDT01QT05FTlRfVFlQRTpcbiAgICAgIGlmIChmaWJlci50eXBlID09PSBzZWxlY3Rvci52YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEhBU19QU0VVRE9fQ0xBU1NfVFlQRTpcbiAgICAgIHJldHVybiBoYXNNYXRjaGluZ1BhdGhzKGZpYmVyLCBzZWxlY3Rvci52YWx1ZSk7XG5cbiAgICBjYXNlIFJPTEVfVFlQRTpcbiAgICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbikge1xuICAgICAgICB2YXIgbm9kZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAobWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZShub2RlLCBzZWxlY3Rvci52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVEVYVF9UWVBFOlxuICAgICAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RUZXh0IHx8IHRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCB0YWcgPT09IEhvc3RTaW5nbGV0b24pIHtcbiAgICAgICAgdmFyIHRleHRDb250ZW50ID0gZ2V0VGV4dENvbnRlbnQoZmliZXIpO1xuXG4gICAgICAgIGlmICh0ZXh0Q29udGVudCAhPT0gbnVsbCAmJiB0ZXh0Q29udGVudC5pbmRleE9mKHNlbGVjdG9yLnZhbHVlKSA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRFU1RfTkFNRV9UWVBFOlxuICAgICAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RIb2lzdGFibGUgfHwgdGFnID09PSBIb3N0U2luZ2xldG9uKSB7XG4gICAgICAgIHZhciBkYXRhVGVzdElEID0gZmliZXIubWVtb2l6ZWRQcm9wc1snZGF0YS10ZXN0bmFtZSddO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVRlc3RJRCA9PT0gJ3N0cmluZycgJiYgZGF0YVRlc3RJRC50b0xvd2VyQ2FzZSgpID09PSBzZWxlY3Rvci52YWx1ZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHR5cGUgc3BlY2lmaWVkLicpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RvclRvU3RyaW5nKHNlbGVjdG9yKSB7XG4gIHN3aXRjaCAoc2VsZWN0b3IuJCR0eXBlb2YpIHtcbiAgICBjYXNlIENPTVBPTkVOVF9UWVBFOlxuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHNlbGVjdG9yLnZhbHVlKSB8fCAnVW5rbm93bic7XG4gICAgICByZXR1cm4gXCI8XCIgKyBkaXNwbGF5TmFtZSArIFwiPlwiO1xuXG4gICAgY2FzZSBIQVNfUFNFVURPX0NMQVNTX1RZUEU6XG4gICAgICByZXR1cm4gXCI6aGFzKFwiICsgKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpIHx8ICcnKSArIFwiKVwiO1xuXG4gICAgY2FzZSBST0xFX1RZUEU6XG4gICAgICByZXR1cm4gXCJbcm9sZT1cXFwiXCIgKyBzZWxlY3Rvci52YWx1ZSArIFwiXFxcIl1cIjtcblxuICAgIGNhc2UgVEVYVF9UWVBFOlxuICAgICAgcmV0dXJuIFwiXFxcIlwiICsgc2VsZWN0b3IudmFsdWUgKyBcIlxcXCJcIjtcblxuICAgIGNhc2UgVEVTVF9OQU1FX1RZUEU6XG4gICAgICByZXR1cm4gXCJbZGF0YS10ZXN0bmFtZT1cXFwiXCIgKyBzZWxlY3Rvci52YWx1ZSArIFwiXFxcIl1cIjtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3IgdHlwZSBzcGVjaWZpZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFBhdGhzKHJvb3QsIHNlbGVjdG9ycykge1xuICB2YXIgbWF0Y2hpbmdGaWJlcnMgPSBbXTtcbiAgdmFyIHN0YWNrID0gW3Jvb3QsIDBdO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIHdoaWxlIChpbmRleCA8IHN0YWNrLmxlbmd0aCkge1xuICAgIHZhciBmaWJlciA9IHN0YWNrW2luZGV4KytdO1xuICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG4gICAgdmFyIHNlbGVjdG9ySW5kZXggPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG5cbiAgICBpZiAoKHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RIb2lzdGFibGUgfHwgdGFnID09PSBIb3N0U2luZ2xldG9uKSAmJiBpc0hpZGRlblN1YnRyZWUoZmliZXIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHNlbGVjdG9yICE9IG51bGwgJiYgbWF0Y2hTZWxlY3RvcihmaWJlciwgc2VsZWN0b3IpKSB7XG4gICAgICAgIHNlbGVjdG9ySW5kZXgrKztcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdG9ySW5kZXggPT09IHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgIG1hdGNoaW5nRmliZXJzLnB1c2goZmliZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIHN0YWNrLnB1c2goY2hpbGQsIHNlbGVjdG9ySW5kZXgpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoaW5nRmliZXJzO1xufSAvLyBTYW1lIGFzIGZpbmRQYXRocyBidXQgd2l0aCBlYWdlciBiYWlsb3V0IG9uIGZpcnN0IG1hdGNoXG5cblxuZnVuY3Rpb24gaGFzTWF0Y2hpbmdQYXRocyhyb290LCBzZWxlY3RvcnMpIHtcbiAgdmFyIHN0YWNrID0gW3Jvb3QsIDBdO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIHdoaWxlIChpbmRleCA8IHN0YWNrLmxlbmd0aCkge1xuICAgIHZhciBmaWJlciA9IHN0YWNrW2luZGV4KytdO1xuICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG4gICAgdmFyIHNlbGVjdG9ySW5kZXggPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG5cbiAgICBpZiAoKHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RIb2lzdGFibGUgfHwgdGFnID09PSBIb3N0U2luZ2xldG9uKSAmJiBpc0hpZGRlblN1YnRyZWUoZmliZXIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHNlbGVjdG9yICE9IG51bGwgJiYgbWF0Y2hTZWxlY3RvcihmaWJlciwgc2VsZWN0b3IpKSB7XG4gICAgICAgIHNlbGVjdG9ySW5kZXgrKztcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdG9ySW5kZXggPT09IHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIHN0YWNrLnB1c2goY2hpbGQsIHNlbGVjdG9ySW5kZXgpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLicpO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpO1xuICB2YXIgbWF0Y2hpbmdGaWJlcnMgPSBmaW5kUGF0aHMocm9vdCwgc2VsZWN0b3JzKTtcbiAgdmFyIGluc3RhbmNlUm9vdHMgPSBbXTtcbiAgdmFyIHN0YWNrID0gQXJyYXkuZnJvbShtYXRjaGluZ0ZpYmVycyk7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgdGFnID0gbm9kZS50YWc7XG5cbiAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCB0YWcgPT09IEhvc3RTaW5nbGV0b24pIHtcbiAgICAgIGlmIChpc0hpZGRlblN1YnRyZWUobm9kZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlUm9vdHMucHVzaChub2RlLnN0YXRlTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBzdGFjay5wdXNoKGNoaWxkKTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZVJvb3RzO1xufVxuZnVuY3Rpb24gZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uKGhvc3RSb290LCBzZWxlY3RvcnMpIHtcbiAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci4nKTtcbiAgfVxuXG4gIHZhciByb290ID0gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KTtcbiAgdmFyIG1heFNlbGVjdG9ySW5kZXggPSAwO1xuICB2YXIgbWF0Y2hlZE5hbWVzID0gW107IC8vIFRoZSBsb2dpYyBvZiB0aGlzIGxvb3Agc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIGZpbmRQYXRocygpXG5cbiAgdmFyIHN0YWNrID0gW3Jvb3QsIDBdO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIHdoaWxlIChpbmRleCA8IHN0YWNrLmxlbmd0aCkge1xuICAgIHZhciBmaWJlciA9IHN0YWNrW2luZGV4KytdO1xuICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG4gICAgdmFyIHNlbGVjdG9ySW5kZXggPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG5cbiAgICBpZiAoKHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RIb2lzdGFibGUgfHwgdGFnID09PSBIb3N0U2luZ2xldG9uKSAmJiBpc0hpZGRlblN1YnRyZWUoZmliZXIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSkge1xuICAgICAgbWF0Y2hlZE5hbWVzLnB1c2goc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcikpO1xuICAgICAgc2VsZWN0b3JJbmRleCsrO1xuXG4gICAgICBpZiAoc2VsZWN0b3JJbmRleCA+IG1heFNlbGVjdG9ySW5kZXgpIHtcbiAgICAgICAgbWF4U2VsZWN0b3JJbmRleCA9IHNlbGVjdG9ySW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdG9ySW5kZXggPCBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIHN0YWNrLnB1c2goY2hpbGQsIHNlbGVjdG9ySW5kZXgpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG1heFNlbGVjdG9ySW5kZXggPCBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgdmFyIHVubWF0Y2hlZE5hbWVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gbWF4U2VsZWN0b3JJbmRleDsgaSA8IHNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdW5tYXRjaGVkTmFtZXMucHVzaChzZWxlY3RvclRvU3RyaW5nKHNlbGVjdG9yc1tpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiAnZmluZEFsbE5vZGVzIHdhcyBhYmxlIHRvIG1hdGNoIHBhcnQgb2YgdGhlIHNlbGVjdG9yOlxcbicgKyAoXCIgIFwiICsgbWF0Y2hlZE5hbWVzLmpvaW4oJyA+ICcpICsgXCJcXG5cXG5cIikgKyAnTm8gbWF0Y2hpbmcgY29tcG9uZW50IHdhcyBmb3VuZCBmb3I6XFxuJyArIChcIiAgXCIgKyB1bm1hdGNoZWROYW1lcy5qb2luKCcgPiAnKSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRCb3VuZGluZ1JlY3RzKGhvc3RSb290LCBzZWxlY3RvcnMpIHtcbiAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci4nKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZVJvb3RzID0gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICB2YXIgYm91bmRpbmdSZWN0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdGFuY2VSb290cy5sZW5ndGg7IGkrKykge1xuICAgIGJvdW5kaW5nUmVjdHMucHVzaChnZXRCb3VuZGluZ1JlY3QoaW5zdGFuY2VSb290c1tpXSkpO1xuICB9XG5cbiAgZm9yICh2YXIgX2kgPSBib3VuZGluZ1JlY3RzLmxlbmd0aCAtIDE7IF9pID4gMDsgX2ktLSkge1xuICAgIHZhciB0YXJnZXRSZWN0ID0gYm91bmRpbmdSZWN0c1tfaV07XG4gICAgdmFyIHRhcmdldExlZnQgPSB0YXJnZXRSZWN0Lng7XG4gICAgdmFyIHRhcmdldFJpZ2h0ID0gdGFyZ2V0TGVmdCArIHRhcmdldFJlY3Qud2lkdGg7XG4gICAgdmFyIHRhcmdldFRvcCA9IHRhcmdldFJlY3QueTtcbiAgICB2YXIgdGFyZ2V0Qm90dG9tID0gdGFyZ2V0VG9wICsgdGFyZ2V0UmVjdC5oZWlnaHQ7XG5cbiAgICBmb3IgKHZhciBqID0gX2kgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgaWYgKF9pICE9PSBqKSB7XG4gICAgICAgIHZhciBvdGhlclJlY3QgPSBib3VuZGluZ1JlY3RzW2pdO1xuICAgICAgICB2YXIgb3RoZXJMZWZ0ID0gb3RoZXJSZWN0Lng7XG4gICAgICAgIHZhciBvdGhlclJpZ2h0ID0gb3RoZXJMZWZ0ICsgb3RoZXJSZWN0LndpZHRoO1xuICAgICAgICB2YXIgb3RoZXJUb3AgPSBvdGhlclJlY3QueTtcbiAgICAgICAgdmFyIG90aGVyQm90dG9tID0gb3RoZXJUb3AgKyBvdGhlclJlY3QuaGVpZ2h0OyAvLyBNZXJnaW5nIGFsbCByZWN0cyB0byB0aGUgbWluaW11bXMgc2V0IHdvdWxkIGJlIGNvbXBsaWNhdGVkLFxuICAgICAgICAvLyBidXQgd2UgY2FuIGhhbmRsZSB0aGUgbW9zdCBjb21tb24gY2FzZXM6XG4gICAgICAgIC8vIDEuIGNvbXBsZXRlbHkgb3ZlcmxhcHBpbmcgcmVjdHNcbiAgICAgICAgLy8gMi4gYWRqYWNlbnQgcmVjdHMgdGhhdCBhcmUgdGhlIHNhbWUgd2lkdGggb3IgaGVpZ2h0IChlLmcuIGl0ZW1zIGluIGEgbGlzdClcbiAgICAgICAgLy9cbiAgICAgICAgLy8gRXZlbiBnaXZlbiB0aGUgYWJvdmUgY29uc3RyYWludHMsXG4gICAgICAgIC8vIHdlIHN0aWxsIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBmZXdlc3QgcG9zc2libGUgcmVjdHMgd2l0aG91dCBkb2luZyBtdWx0aXBsZSBwYXNzZXMsXG4gICAgICAgIC8vIGJ1dCBpdCdzIGdvb2QgZW5vdWdoIGZvciB0aGlzIHB1cnBvc2UuXG5cbiAgICAgICAgaWYgKHRhcmdldExlZnQgPj0gb3RoZXJMZWZ0ICYmIHRhcmdldFRvcCA+PSBvdGhlclRvcCAmJiB0YXJnZXRSaWdodCA8PSBvdGhlclJpZ2h0ICYmIHRhcmdldEJvdHRvbSA8PSBvdGhlckJvdHRvbSkge1xuICAgICAgICAgIC8vIENvbXBsZXRlIG92ZXJsYXBwaW5nIHJlY3RzOyByZW1vdmUgdGhlIGlubmVyIG9uZS5cbiAgICAgICAgICBib3VuZGluZ1JlY3RzLnNwbGljZShfaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0TGVmdCA9PT0gb3RoZXJMZWZ0ICYmIHRhcmdldFJlY3Qud2lkdGggPT09IG90aGVyUmVjdC53aWR0aCAmJiAhKG90aGVyQm90dG9tIDwgdGFyZ2V0VG9wKSAmJiAhKG90aGVyVG9wID4gdGFyZ2V0Qm90dG9tKSkge1xuICAgICAgICAgIC8vIEFkamFjZW50IHZlcnRpY2FsIHJlY3RzOyBtZXJnZSB0aGVtLlxuICAgICAgICAgIGlmIChvdGhlclRvcCA+IHRhcmdldFRvcCkge1xuICAgICAgICAgICAgb3RoZXJSZWN0LmhlaWdodCArPSBvdGhlclRvcCAtIHRhcmdldFRvcDtcbiAgICAgICAgICAgIG90aGVyUmVjdC55ID0gdGFyZ2V0VG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvdGhlckJvdHRvbSA8IHRhcmdldEJvdHRvbSkge1xuICAgICAgICAgICAgb3RoZXJSZWN0LmhlaWdodCA9IHRhcmdldEJvdHRvbSAtIG90aGVyVG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJvdW5kaW5nUmVjdHMuc3BsaWNlKF9pLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRUb3AgPT09IG90aGVyVG9wICYmIHRhcmdldFJlY3QuaGVpZ2h0ID09PSBvdGhlclJlY3QuaGVpZ2h0ICYmICEob3RoZXJSaWdodCA8IHRhcmdldExlZnQpICYmICEob3RoZXJMZWZ0ID4gdGFyZ2V0UmlnaHQpKSB7XG4gICAgICAgICAgLy8gQWRqYWNlbnQgaG9yaXpvbnRhbCByZWN0czsgbWVyZ2UgdGhlbS5cbiAgICAgICAgICBpZiAob3RoZXJMZWZ0ID4gdGFyZ2V0TGVmdCkge1xuICAgICAgICAgICAgb3RoZXJSZWN0LndpZHRoICs9IG90aGVyTGVmdCAtIHRhcmdldExlZnQ7XG4gICAgICAgICAgICBvdGhlclJlY3QueCA9IHRhcmdldExlZnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG90aGVyUmlnaHQgPCB0YXJnZXRSaWdodCkge1xuICAgICAgICAgICAgb3RoZXJSZWN0LndpZHRoID0gdGFyZ2V0UmlnaHQgLSBvdGhlckxlZnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYm91bmRpbmdSZWN0cy5zcGxpY2UoX2ksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJvdW5kaW5nUmVjdHM7XG59XG5mdW5jdGlvbiBmb2N1c1dpdGhpbihob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG4gIHZhciBtYXRjaGluZ0ZpYmVycyA9IGZpbmRQYXRocyhyb290LCBzZWxlY3RvcnMpO1xuICB2YXIgc3RhY2sgPSBBcnJheS5mcm9tKG1hdGNoaW5nRmliZXJzKTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgZmliZXIgPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuXG4gICAgaWYgKGlzSGlkZGVuU3VidHJlZShmaWJlcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbikge1xuICAgICAgdmFyIG5vZGUgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChzZXRGb2N1c0lmRm9jdXNhYmxlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBzdGFjay5wdXNoKGNoaWxkKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgY29tbWl0SG9va3MgPSBbXTtcbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdCgpIHtcbiAgaWYgKHN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuICAgIGNvbW1pdEhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGNvbW1pdEhvb2spIHtcbiAgICAgIHJldHVybiBjb21taXRIb29rKCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9ic2VydmVWaXNpYmxlUmVjdHMoaG9zdFJvb3QsIHNlbGVjdG9ycywgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci4nKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZVJvb3RzID0gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuXG4gIHZhciBfc2V0dXBJbnRlcnNlY3Rpb25PYnMgPSBzZXR1cEludGVyc2VjdGlvbk9ic2VydmVyKGluc3RhbmNlUm9vdHMsIGNhbGxiYWNrLCBvcHRpb25zKSxcbiAgICAgIGRpc2Nvbm5lY3QgPSBfc2V0dXBJbnRlcnNlY3Rpb25PYnMuZGlzY29ubmVjdCxcbiAgICAgIG9ic2VydmUgPSBfc2V0dXBJbnRlcnNlY3Rpb25PYnMub2JzZXJ2ZSxcbiAgICAgIHVub2JzZXJ2ZSA9IF9zZXR1cEludGVyc2VjdGlvbk9icy51bm9ic2VydmU7IC8vIFdoZW4gUmVhY3QgbXV0YXRlcyB0aGUgaG9zdCBlbnZpcm9ubWVudCwgd2UgbWF5IG5lZWQgdG8gY2hhbmdlIHdoYXQgd2UncmUgbGlzdGVuaW5nIHRvLlxuXG5cbiAgdmFyIGNvbW1pdEhvb2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5leHRJbnN0YW5jZVJvb3RzID0gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICAgIGluc3RhbmNlUm9vdHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBpZiAobmV4dEluc3RhbmNlUm9vdHMuaW5kZXhPZih0YXJnZXQpIDwgMCkge1xuICAgICAgICB1bm9ic2VydmUodGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBuZXh0SW5zdGFuY2VSb290cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGlmIChpbnN0YW5jZVJvb3RzLmluZGV4T2YodGFyZ2V0KSA8IDApIHtcbiAgICAgICAgb2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGNvbW1pdEhvb2tzLnB1c2goY29tbWl0SG9vayk7XG4gIHJldHVybiB7XG4gICAgZGlzY29ubmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gU3RvcCBsaXN0ZW5pbmcgZm9yIFJlYWN0IG11dGF0aW9uczpcbiAgICAgIHZhciBpbmRleCA9IGNvbW1pdEhvb2tzLmluZGV4T2YoY29tbWl0SG9vayk7XG5cbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGNvbW1pdEhvb2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9IC8vIERpc2Nvbm5lY3QgdGhlIGhvc3Qgb2JzZXJ2ZXI6XG5cblxuICAgICAgZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSB7XG4gIHtcbiAgICB2YXIgaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsID0gLy8gJEZsb3dGaXhNZVtjYW5ub3QtcmVzb2x2ZS1uYW1lXSBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgZ2xvYmFsXG4gICAgdHlwZW9mIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCAhPT0gJ3VuZGVmaW5lZCcgPyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC1yZXNvbHZlLW5hbWVdXG4gICAgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKCFpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgJiYgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IEluY2x1ZGUgbGluayB0byByZWxldmFudCBkb2N1bWVudGF0aW9uIHBhZ2UuXG4gICAgICBlcnJvcignVGhlIGN1cnJlbnQgdGVzdGluZyBlbnZpcm9ubWVudCBpcyBub3QgY29uZmlndXJlZCB0byBzdXBwb3J0ICcgKyAnYWN0KC4uLiknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsO1xuICB9XG59XG5cbnZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG52YXIgTm9Db250ZXh0ID1cbi8qICAgICAgICAgICAgICovXG4wO1xudmFyIEJhdGNoZWRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgUmVuZGVyQ29udGV4dCA9XG4vKiAgICAgICAgICovXG4yO1xudmFyIENvbW1pdENvbnRleHQgPVxuLyogICAgICAgICAqL1xuNDtcbnZhciBSb290SW5Qcm9ncmVzcyA9IDA7XG52YXIgUm9vdEZhdGFsRXJyb3JlZCA9IDE7XG52YXIgUm9vdEVycm9yZWQgPSAyO1xudmFyIFJvb3RTdXNwZW5kZWQgPSAzO1xudmFyIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgPSA0O1xudmFyIFJvb3RDb21wbGV0ZWQgPSA1O1xudmFyIFJvb3REaWROb3RDb21wbGV0ZSA9IDY7IC8vIERlc2NyaWJlcyB3aGVyZSB3ZSBhcmUgaW4gdGhlIFJlYWN0IGV4ZWN1dGlvbiBzdGFja1xuXG52YXIgZXhlY3V0aW9uQ29udGV4dCA9IE5vQ29udGV4dDsgLy8gVGhlIHJvb3Qgd2UncmUgd29ya2luZyBvblxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDsgLy8gVGhlIGZpYmVyIHdlJ3JlIHdvcmtpbmcgb25cblxudmFyIHdvcmtJblByb2dyZXNzID0gbnVsbDsgLy8gVGhlIGxhbmVzIHdlJ3JlIHJlbmRlcmluZ1xuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xudmFyIE5vdFN1c3BlbmRlZCA9IDA7XG52YXIgU3VzcGVuZGVkT25FcnJvciA9IDE7XG52YXIgU3VzcGVuZGVkT25EYXRhID0gMjtcbnZhciBTdXNwZW5kZWRPbkltbWVkaWF0ZSA9IDM7XG52YXIgU3VzcGVuZGVkT25JbnN0YW5jZSA9IDQ7XG52YXIgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZSA9IDU7XG52YXIgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlID0gNjtcbnZhciBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWUgPSA3O1xudmFyIFN1c3BlbmRlZE9uSHlkcmF0aW9uID0gODsgLy8gV2hlbiB0aGlzIGlzIHRydWUsIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyIGp1c3Qgc3VzcGVuZGVkIChvciBlcnJvcmVkKSBhbmRcbi8vIHdlJ3ZlIHlldCB0byB1bndpbmQgdGhlIHN0YWNrLiBJbiBzb21lIGNhc2VzLCB3ZSBtYXkgeWllbGQgdG8gdGhlIG1haW4gdGhyZWFkXG4vLyBhZnRlciB0aGlzIGhhcHBlbnMuIElmIHRoZSBmaWJlciBpcyBwaW5nZWQgYmVmb3JlIHdlIHJlc3VtZSwgd2UgY2FuIHJldHJ5XG4vLyBpbW1lZGlhdGVseSBpbnN0ZWFkIG9mIHVud2luZGluZyB0aGUgc3RhY2suXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbnZhciB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDsgLy8gV2hldGhlciBhIHBpbmcgbGlzdGVuZXIgd2FzIGF0dGFjaGVkIGR1cmluZyB0aGlzIHJlbmRlci4gVGhpcyBpcyBzbGlnaHRseVxuLy8gZGlmZmVyZW50IHRoYXQgd2hldGhlciBzb21ldGhpbmcgc3VzcGVuZGVkLCBiZWNhdXNlIHdlIGRvbid0IGFkZCBtdWx0aXBsZVxuLy8gbGlzdGVuZXJzIHRvIGEgcHJvbWlzZSB3ZSd2ZSBhbHJlYWR5IHNlZW4gKHBlciByb290IGFuZCBsYW5lKS5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9IGZhbHNlOyAvLyBBIGNvbnRleHR1YWwgdmVyc2lvbiBvZiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcy4gSXQgaXMgYSBzdXBlcnNldCBvZlxuLy8gdGhlIGxhbmVzIHRoYXQgd2Ugc3RhcnRlZCB3b3JraW5nIG9uIGF0IHRoZSByb290LiBXaGVuIHdlIGVudGVyIGEgc3VidHJlZVxuLy8gdGhhdCBpcyBjdXJyZW50bHkgaGlkZGVuLCB3ZSBhZGQgdGhlIGxhbmVzIHRoYXQgd291bGQgaGF2ZSBjb21taXR0ZWQgaWZcbi8vIHRoZSBoaWRkZW4gdHJlZSBoYWRuJ3QgYmVlbiBkZWZlcnJlZC4gVGhpcyBpcyBtb2RpZmllZCBieSB0aGVcbi8vIEhpZGRlbkNvbnRleHQgbW9kdWxlLlxuLy9cbi8vIE1vc3QgdGhpbmdzIGluIHRoZSB3b3JrIGxvb3Agc2hvdWxkIGRlYWwgd2l0aCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcy5cbi8vIE1vc3QgdGhpbmdzIGluIGJlZ2luL2NvbXBsZXRlIHBoYXNlcyBzaG91bGQgZGVhbCB3aXRoIGVudGFuZ2xlZFJlbmRlckxhbmVzLlxuXG52YXIgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSBOb0xhbmVzOyAvLyBXaGV0aGVyIHRvIHJvb3QgY29tcGxldGVkLCBlcnJvcmVkLCBzdXNwZW5kZWQsIGV0Yy5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290SW5Qcm9ncmVzczsgLy8gVGhlIHdvcmsgbGVmdCBvdmVyIGJ5IGNvbXBvbmVudHMgdGhhdCB3ZXJlIHZpc2l0ZWQgZHVyaW5nIHRoaXMgcmVuZGVyLiBPbmx5XG4vLyBpbmNsdWRlcyB1bnByb2Nlc3NlZCB1cGRhdGVzLCBub3Qgd29yayBpbiBiYWlsZWQgb3V0IGNoaWxkcmVuLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gTm9MYW5lczsgLy8gTGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgKGluIGFuIGludGVybGVhdmVkIGV2ZW50KSBkdXJpbmcgdGhpcyByZW5kZXIuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9IE5vTGFuZXM7IC8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlICgqbm90KiBhbiBpbnRlcmxlYXZlZCBldmVudCkuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IE5vTGFuZXM7IC8vIElmIHRoaXMgbGFuZSBzY2hlZHVsZWQgZGVmZXJyZWQgd29yaywgdGhpcyBpcyB0aGUgbGFuZSBvZiB0aGUgZGVmZXJyZWQgdGFzay5cblxudmFyIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID0gTm9MYW5lOyAvLyBFcnJvcnMgdGhhdCBhcmUgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGw7IC8vIFRoZXNlIGFyZSBlcnJvcnMgdGhhdCB3ZSByZWNvdmVyZWQgZnJvbSB3aXRob3V0IHN1cmZhY2luZyB0aGVtIHRvIHRoZSBVSS5cbi8vIFdlIHdpbGwgbG9nIHRoZW0gb25jZSB0aGUgdHJlZSBjb21taXRzLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsOyAvLyBUcmFja3Mgd2hlbiBhbiB1cGRhdGUgb2NjdXJzIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSA9IGZhbHNlOyAvLyBUaGFja3Mgd2hlbiBhbiB1cGRhdGUgb2NjdXJzIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLiBJdCdzIGEgc2VwYXJhdGVcbi8vIHZhcmlhYmxlIGZyb20gdGhlIG9uZSBmb3IgcmVuZGVycyBiZWNhdXNlIHRoZSBjb21taXQgcGhhc2UgbWF5IHJ1blxuLy8gY29uY3VycmVudGx5IHRvIGEgcmVuZGVyIHBoYXNlLlxuXG52YXIgZGlkSW5jbHVkZUNvbW1pdFBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIFRoZSBtb3N0IHJlY2VudCB0aW1lIHdlIGVpdGhlciBjb21taXR0ZWQgYSBmYWxsYmFjaywgb3Igd2hlbiBhIGZhbGxiYWNrIHdhc1xuLy8gZmlsbGVkIGluIHdpdGggdGhlIHJlc29sdmVkIFVJLiBUaGlzIGxldHMgdXMgdGhyb3R0bGUgdGhlIGFwcGVhcmFuY2Ugb2YgbmV3XG4vLyBjb250ZW50IGFzIGl0IHN0cmVhbXMgaW4sIHRvIG1pbmltaXplIGphbmsuXG4vLyBUT0RPOiBUaGluayBvZiBhIGJldHRlciBuYW1lIGZvciB0aGlzIHZhcmlhYmxlP1xuXG52YXIgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IDA7XG52YXIgRkFMTEJBQ0tfVEhST1RUTEVfTVMgPSAzMDA7IC8vIFRoZSBhYnNvbHV0ZSB0aW1lIGZvciB3aGVuIHdlIHNob3VsZCBzdGFydCBnaXZpbmcgdXAgb24gcmVuZGVyaW5nXG4vLyBtb3JlIGFuZCBwcmVmZXIgQ1BVIHN1c3BlbnNlIGhldXJpc3RpY3MgaW5zdGVhZC5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBJbmZpbml0eTsgLy8gSG93IGxvbmcgYSByZW5kZXIgaXMgc3VwcG9zZWQgdG8gdGFrZSBiZWZvcmUgd2Ugc3RhcnQgZm9sbG93aW5nIENQVVxuLy8gc3VzcGVuc2UgaGV1cmlzdGljcyBhbmQgb3B0IG91dCBvZiByZW5kZXJpbmcgbW9yZSBjb250ZW50LlxuXG52YXIgUkVOREVSX1RJTUVPVVRfTVMgPSA1MDA7XG52YXIgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc2V0UmVuZGVyVGltZXIoKSB7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3ckMSgpICsgUkVOREVSX1RJTUVPVVRfTVM7XG59XG5cbmZ1bmN0aW9uIGdldFJlbmRlclRhcmdldFRpbWUoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lO1xufVxudmFyIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbnZhciByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xudmFyIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDtcbnZhciBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IE5vTGFuZXM7XG52YXIgcGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHMgPSBbXTtcbnZhciBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IE5vTGFuZXM7XG52YXIgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IG51bGw7IC8vIFVzZSB0aGVzZSB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3Agb2YgbmVzdGVkIHVwZGF0ZXNcblxudmFyIE5FU1RFRF9VUERBVEVfTElNSVQgPSA1MDtcbnZhciBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG52YXIgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbDtcbnZhciBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbnZhciBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG52YXIgTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcbnZhciByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbDtcbnZhciBpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSBmYWxzZTtcbmZ1bmN0aW9uIGdldFdvcmtJblByb2dyZXNzUm9vdCgpIHtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdDtcbn1cbmZ1bmN0aW9uIGdldFdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG59XG5mdW5jdGlvbiBpc1dvcmtMb29wU3VzcGVuZGVkT25EYXRhKCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGF0YTtcbn1cbmZ1bmN0aW9uIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKSB7XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dCAmJiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIC8vIFRoaXMgaXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlLiBUaGVzZSBhcmUgbm90IG9mZmljaWFsbHkgc3VwcG9ydGVkLiBUaGVcbiAgICAvLyBvbGQgYmVoYXZpb3IgaXMgdG8gZ2l2ZSB0aGlzIHRoZSBzYW1lIFwidGhyZWFkXCIgKGxhbmVzKSBhc1xuICAgIC8vIHdoYXRldmVyIGlzIGN1cnJlbnRseSByZW5kZXJpbmcuIFNvIGlmIHlvdSBjYWxsIGBzZXRTdGF0ZWAgb24gYSBjb21wb25lbnRcbiAgICAvLyB0aGF0IGhhcHBlbnMgbGF0ZXIgaW4gdGhlIHNhbWUgcmVuZGVyLCBpdCB3aWxsIGZsdXNoLiBJZGVhbGx5LCB3ZSB3YW50IHRvXG4gICAgLy8gcmVtb3ZlIHRoZSBzcGVjaWFsIGNhc2UgYW5kIHRyZWF0IHRoZW0gYXMgaWYgdGhleSBjYW1lIGZyb20gYW5cbiAgICAvLyBpbnRlcmxlYXZlZCBldmVudC4gUmVnYXJkbGVzcywgdGhpcyBwYXR0ZXJuIGlzIG5vdCBvZmZpY2lhbGx5IHN1cHBvcnRlZC5cbiAgICAvLyBUaGlzIGJlaGF2aW9yIGlzIG9ubHkgYSBmYWxsYmFjay4gVGhlIGZsYWcgb25seSBleGlzdHMgdW50aWwgd2UgY2FuIHJvbGxcbiAgICAvLyBvdXQgdGhlIHNldFN0YXRlIHdhcm5pbmcsIHNpbmNlIGV4aXN0aW5nIGNvZGUgbWlnaHQgYWNjaWRlbnRhbGx5IHJlbHkgb25cbiAgICAvLyB0aGUgY3VycmVudCBiZWhhdmlvci5cbiAgICByZXR1cm4gcGlja0FyYml0cmFyeUxhbmUod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb24gPSByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKTtcblxuICBpZiAodHJhbnNpdGlvbiAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGlmICghdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycykge1xuICAgICAgICB0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICB0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmFkZChmaWJlcik7XG4gICAgfVxuXG4gICAgdmFyIGFjdGlvblNjb3BlTGFuZSA9IHBlZWtFbnRhbmdsZWRBY3Rpb25MYW5lKCk7XG4gICAgcmV0dXJuIGFjdGlvblNjb3BlTGFuZSAhPT0gTm9MYW5lID8gLy8gV2UncmUgaW5zaWRlIGFuIGFzeW5jIGFjdGlvbiBzY29wZS4gUmV1c2UgdGhlIHNhbWUgbGFuZS5cbiAgICBhY3Rpb25TY29wZUxhbmUgOiAvLyBXZSBtYXkgb3IgbWF5IG5vdCBiZSBpbnNpZGUgYW4gYXN5bmMgYWN0aW9uIHNjb3BlLiBJZiB3ZSBhcmUsIHRoaXNcbiAgICAvLyBpcyB0aGUgZmlyc3QgdXBkYXRlIGluIHRoYXQgc2NvcGUuIEVpdGhlciB3YXksIHdlIG5lZWQgdG8gZ2V0IGFcbiAgICAvLyBmcmVzaCB0cmFuc2l0aW9uIGxhbmUuXG4gICAgcmVxdWVzdFRyYW5zaXRpb25MYW5lKCk7XG4gIH1cblxuICByZXR1cm4gZXZlbnRQcmlvcml0eVRvTGFuZShyZXNvbHZlVXBkYXRlUHJpb3JpdHkoKSk7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RSZXRyeUxhbmUoZmliZXIpIHtcblxuICByZXR1cm4gY2xhaW1OZXh0UmV0cnlMYW5lKCk7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3REZWZlcnJlZExhbmUoKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9PT0gTm9MYW5lKSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIHVzZURlZmVycmVkVmFsdWUgaG9va3MgaW4gdGhlIHNhbWUgcmVuZGVyLCB0aGVcbiAgICAvLyB0YXNrcyB0aGF0IHRoZXkgc3Bhd24gc2hvdWxkIGFsbCBiZSBiYXRjaGVkIHRvZ2V0aGVyLCBzbyB0aGV5IHNob3VsZCBhbGxcbiAgICAvLyByZWNlaXZlIHRoZSBzYW1lIGxhbmUuXG4gICAgLy8gQ2hlY2sgdGhlIHByaW9yaXR5IG9mIHRoZSBjdXJyZW50IHJlbmRlciB0byBkZWNpZGUgdGhlIHByaW9yaXR5IG9mIHRoZVxuICAgIC8vIGRlZmVycmVkIHRhc2suXG4gICAgLy8gT2Zmc2NyZWVuTGFuZSBpcyB1c2VkIGZvciBwcmVyZW5kZXJpbmcsIGJ1dCB3ZSBhbHNvIHVzZSBPZmZzY3JlZW5MYW5lXG4gICAgLy8gZm9yIGluY3JlbWVudGFsIGh5ZHJhdGlvbi4gSXQncyBnaXZlbiB0aGUgbG93ZXN0IHByaW9yaXR5IGJlY2F1c2UgdGhlXG4gICAgLy8gaW5pdGlhbCBIVE1MIGlzIHRoZSBzYW1lIGFzIHRoZSBmaW5hbCBVSS4gQnV0IHVzZURlZmVycmVkVmFsdWUgZHVyaW5nXG4gICAgLy8gaHlkcmF0aW9uIGlzIGFuIGV4Y2VwdGlvbiDigJQgd2UgbmVlZCB0byB1cGdyYWRlIHRoZSBVSSB0byB0aGUgZmluYWxcbiAgICAvLyB2YWx1ZS4gU28gaWYgd2UncmUgY3VycmVudGx5IGh5ZHJhdGluZywgd2UgdHJlYXQgaXQgbGlrZSBhIHRyYW5zaXRpb24uXG4gICAgdmFyIGlzUHJlcmVuZGVyaW5nID0gaW5jbHVkZXNTb21lTGFuZSh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgT2Zmc2NyZWVuTGFuZSkgJiYgIWdldElzSHlkcmF0aW5nKCk7XG5cbiAgICBpZiAoaXNQcmVyZW5kZXJpbmcpIHtcbiAgICAgIC8vIFRoZXJlJ3Mgb25seSBvbmUgT2Zmc2NyZWVuTGFuZSwgc28gaWYgaXQgY29udGFpbnMgZGVmZXJyZWQgd29yaywgd2VcbiAgICAgIC8vIHNob3VsZCBqdXN0IHJlc2NoZWR1bGUgdXNpbmcgdGhlIHNhbWUgbGFuZS5cbiAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID0gT2Zmc2NyZWVuTGFuZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXZlcnl0aGluZyBlbHNlIGlzIHNwYXduZWQgYXMgYSB0cmFuc2l0aW9uLlxuICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPSBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpO1xuICAgIH1cbiAgfSAvLyBNYXJrIHRoZSBwYXJlbnQgU3VzcGVuc2UgYm91bmRhcnkgc28gaXQga25vd3MgdG8gc3Bhd24gdGhlIGRlZmVycmVkIGxhbmUuXG5cblxuICB2YXIgc3VzcGVuc2VIYW5kbGVyID0gZ2V0U3VzcGVuc2VIYW5kbGVyKCk7XG5cbiAgaWYgKHN1c3BlbnNlSGFuZGxlciAhPT0gbnVsbCkge1xuICAgIC8vIFRPRE86IEFzIGFuIG9wdGltaXphdGlvbiwgd2Ugc2hvdWxkbid0IGVudGFuZ2xlIHRoZSBsYW5lcyBhdCB0aGUgcm9vdDsgd2VcbiAgICAvLyBjYW4gZW50YW5nbGUgdGhlbSB1c2luZyB0aGUgYmFzZUxhbmVzIG9mIHRoZSBTdXNwZW5zZSBib3VuZGFyeSBpbnN0ZWFkLlxuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBkbyBzb21ldGhpbmcgc3BlY2lhbCBpZiB0aGVyZSdzIG5vIFN1c3BlbnNlIGJvdW5kYXJ5LlxuICAgIHN1c3BlbnNlSGFuZGxlci5mbGFncyB8PSBEaWREZWZlcjtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZTtcbn1cbmZ1bmN0aW9uIHBlZWtEZWZlcnJlZExhbmUoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZTtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSkge1xuICB7XG4gICAgaWYgKGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCkge1xuICAgICAgZXJyb3IoJ3VzZUluc2VydGlvbkVmZmVjdCBtdXN0IG5vdCBzY2hlZHVsZSB1cGRhdGVzLicpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzKSB7XG4gICAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcbiAgICB9XG4gIH0gLy8gQ2hlY2sgaWYgdGhlIHdvcmsgbG9vcCBpcyBjdXJyZW50bHkgc3VzcGVuZGVkIGFuZCB3YWl0aW5nIGZvciBkYXRhIHRvXG4gIC8vIGZpbmlzaCBsb2FkaW5nLlxuXG5cbiAgaWYgKCAvLyBTdXNwZW5kZWQgcmVuZGVyIHBoYXNlXG4gIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJiB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhIHx8IC8vIFN1c3BlbmRlZCBjb21taXQgcGhhc2VcbiAgcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIGluY29taW5nIHVwZGF0ZSBtaWdodCB1bmJsb2NrIHRoZSBjdXJyZW50IHJlbmRlci4gSW50ZXJydXB0IHRoZVxuICAgIC8vIGN1cnJlbnQgYXR0ZW1wdCBhbmQgcmVzdGFydCBmcm9tIHRoZSB0b3AuXG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgfSAvLyBNYXJrIHRoYXQgdGhlIHJvb3QgaGFzIGEgcGVuZGluZyB1cGRhdGUuXG5cblxuICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgbGFuZSk7XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vTGFuZXMgJiYgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB7XG4gICAgLy8gVGhpcyB1cGRhdGUgd2FzIGRpc3BhdGNoZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIFRoaXMgaXMgYSBtaXN0YWtlXG4gICAgLy8gaWYgdGhlIHVwZGF0ZSBvcmlnaW5hdGVzIGZyb20gdXNlciBzcGFjZSAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIGxvY2FsXG4gICAgLy8gaG9vayB1cGRhdGVzLCB3aGljaCBhcmUgaGFuZGxlZCBkaWZmZXJlbnRseSBhbmQgZG9uJ3QgcmVhY2ggdGhpc1xuICAgIC8vIGZ1bmN0aW9uKSwgYnV0IHRoZXJlIGFyZSBzb21lIGludGVybmFsIFJlYWN0IGZlYXR1cmVzIHRoYXQgdXNlIHRoaXMgYXNcbiAgICAvLyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwsIGxpa2Ugc2VsZWN0aXZlIGh5ZHJhdGlvbi5cbiAgICB3YXJuQWJvdXRSZW5kZXJQaGFzZVVwZGF0ZXNJbkRFVihmaWJlcik7IC8vIFRyYWNrIGxhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlXG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIG5vcm1hbCB1cGRhdGUsIHNjaGVkdWxlZCBmcm9tIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS4gRm9yXG4gICAgLy8gZXhhbXBsZSwgZHVyaW5nIGFuIGlucHV0IGV2ZW50LlxuICAgIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFVihmaWJlcik7XG5cbiAgICBpZiAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB7XG4gICAgICAvLyBSZWNlaXZlZCBhbiB1cGRhdGUgdG8gYSB0cmVlIHRoYXQncyBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlcmluZy4gTWFya1xuICAgICAgLy8gdGhhdCB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgdXBkYXRlIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgPT09IE5vQ29udGV4dCkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMsIGxhbmUpO1xuICAgICAgfVxuXG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSkge1xuICAgICAgICAvLyBUaGUgcm9vdCBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHdoaWNoIG1lYW5zIHRoaXMgcmVuZGVyXG4gICAgICAgIC8vIGRlZmluaXRlbHkgd29uJ3QgZmluaXNoLiBTaW5jZSB3ZSBoYXZlIGEgbmV3IHVwZGF0ZSwgbGV0J3MgbWFyayBpdCBhc1xuICAgICAgICAvLyBzdXNwZW5kZWQgbm93LCByaWdodCBiZWZvcmUgbWFya2luZyB0aGUgaW5jb21pbmcgdXBkYXRlLiBUaGlzIGhhcyB0aGVcbiAgICAgICAgLy8gZWZmZWN0IG9mIGludGVycnVwdGluZyB0aGUgY3VycmVudCByZW5kZXIgYW5kIHN3aXRjaGluZyB0byB0aGUgdXBkYXRlLlxuICAgICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgdGhpcyBkb2Vzbid0IG92ZXJyaWRlIHBpbmdzIHRoYXQgaGFwcGVuIHdoaWxlIHdlJ3ZlXG4gICAgICAgIC8vIGFscmVhZHkgc3RhcnRlZCByZW5kZXJpbmcuXG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuXG4gICAgaWYgKGxhbmUgPT09IFN5bmNMYW5lICYmIGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCAmJiAhZGlzYWJsZUxlZ2FjeU1vZGUgJiYgKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgaWYgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmlzQmF0Y2hpbmdMZWdhY3kpIDsgZWxzZSB7XG4gICAgICAgIC8vIEZsdXNoIHRoZSBzeW5jaHJvbm91cyB3b3JrIG5vdywgdW5sZXNzIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvciBpbnNpZGVcbiAgICAgICAgLy8gYSBiYXRjaC4gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGluc2lkZSBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgaW5zdGVhZCBvZlxuICAgICAgICAvLyBzY2hlZHVsZUNhbGxiYWNrRm9yRmliZXIgdG8gcHJlc2VydmUgdGhlIGFiaWxpdHkgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAvLyB3aXRob3V0IGltbWVkaWF0ZWx5IGZsdXNoaW5nIGl0LiBXZSBvbmx5IGRvIHRoaXMgZm9yIHVzZXItaW5pdGlhdGVkXG4gICAgICAgIC8vIHVwZGF0ZXMsIHRvIHByZXNlcnZlIGhpc3RvcmljYWwgYmVoYXZpb3Igb2YgbGVnYWN5IG1vZGUuXG4gICAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNjaGVkdWxlSW5pdGlhbEh5ZHJhdGlvbk9uUm9vdChyb290LCBsYW5lKSB7XG4gIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGZvcmsgb2Ygc2NoZWR1bGVVcGRhdGVPbkZpYmVyIHRoYXQgaXMgb25seSB1c2VkIHRvXG4gIC8vIHNjaGVkdWxlIHRoZSBpbml0aWFsIGh5ZHJhdGlvbiBvZiBhIHJvb3QgdGhhdCBoYXMganVzdCBiZWVuIGNyZWF0ZWQuIE1vc3RcbiAgLy8gb2YgdGhlIHN0dWZmIGluIHNjaGVkdWxlVXBkYXRlT25GaWJlciBjYW4gYmUgc2tpcHBlZC5cbiAgLy9cbiAgLy8gVGhlIG1haW4gcmVhc29uIGZvciB0aGlzIHNlcGFyYXRlIHBhdGgsIHRob3VnaCwgaXMgdG8gZGlzdGluZ3Vpc2ggdGhlXG4gIC8vIGluaXRpYWwgY2hpbGRyZW4gZnJvbSBzdWJzZXF1ZW50IHVwZGF0ZXMuIEluIGZ1bGx5IGNsaWVudC1yZW5kZXJlZCByb290c1xuICAvLyAoY3JlYXRlUm9vdCBpbnN0ZWFkIG9mIGh5ZHJhdGVSb290KSwgYWxsIHRvcC1sZXZlbCByZW5kZXJzIGFyZSBtb2RlbGVkIGFzXG4gIC8vIHVwZGF0ZXMsIGJ1dCBoeWRyYXRpb24gcm9vdHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB0aGUgaW5pdGlhbCByZW5kZXIgbXVzdFxuICAvLyBtYXRjaCB3aGF0IHdhcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyLlxuICB2YXIgY3VycmVudCA9IHJvb3QuY3VycmVudDtcbiAgY3VycmVudC5sYW5lcyA9IGxhbmU7XG4gIG1hcmtSb290VXBkYXRlZChyb290LCBsYW5lKTtcbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xufVxuZnVuY3Rpb24gaXNVbnNhZmVDbGFzc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSB7XG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlLiBPbmx5IGNhbGxlZCBieSBjbGFzcyBjb21wb25lbnRzLFxuICAvLyB3aGljaCBzcGVjaWFsIChkZXByZWNhdGVkKSBiZWhhdmlvciBmb3IgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlIHByb3BzLlxuICByZXR1cm4gKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0O1xufSAvLyBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgZXZlcnkgY29uY3VycmVudCB0YXNrLCBpLmUuIGFueXRoaW5nIHRoYXRcbi8vIGdvZXMgdGhyb3VnaCBTY2hlZHVsZXIuXG5cbmZ1bmN0aW9uIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdChyb290LCBkaWRUaW1lb3V0KSB7XG4gIHtcbiAgICByZXNldE5lc3RlZFVwZGF0ZUZsYWcoKTtcbiAgfVxuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLicpO1xuICB9IC8vIEZsdXNoIGFueSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyBiZWZvcmUgZGVjaWRpbmcgd2hpY2ggbGFuZXMgdG8gd29yayBvbixcbiAgLy8gaW4gY2FzZSB0aGV5IHNjaGVkdWxlIGFkZGl0aW9uYWwgd29yay5cblxuXG4gIHZhciBvcmlnaW5hbENhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuICB2YXIgZGlkRmx1c2hQYXNzaXZlRWZmZWN0cyA9IGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcblxuICBpZiAoZGlkRmx1c2hQYXNzaXZlRWZmZWN0cykge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGUgcGFzc2l2ZSBlZmZlY3QgcGhhc2UgbWF5IGhhdmUgY2FuY2VsZWQgdGhlIGN1cnJlbnQgdGFzay5cbiAgICAvLyBDaGVjayBpZiB0aGUgdGFzayBub2RlIGZvciB0aGlzIHJvb3Qgd2FzIGNoYW5nZWQuXG4gICAgaWYgKHJvb3QuY2FsbGJhY2tOb2RlICE9PSBvcmlnaW5hbENhbGxiYWNrTm9kZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgdGFzayB3YXMgY2FuY2VsZWQuIEV4aXQuIFdlIGRvbid0IG5lZWQgdG8gY2FsbFxuICAgICAgLy8gYGVuc3VyZVJvb3RJc1NjaGVkdWxlZGAgYmVjYXVzZSB0aGUgY2hlY2sgYWJvdmUgaW1wbGllcyBlaXRoZXIgdGhhdFxuICAgICAgLy8gdGhlcmUncyBhIG5ldyB0YXNrLCBvciB0aGF0IHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IC8vIERldGVybWluZSB0aGUgbmV4dCBsYW5lcyB0byB3b3JrIG9uLCB1c2luZyB0aGUgZmllbGRzIHN0b3JlZFxuICAvLyBvbiB0aGUgcm9vdC5cbiAgLy8gVE9ETzogVGhpcyB3YXMgYWxyZWFkeSBjb21wdXRlZCBpbiB0aGUgY2FsbGVyLiBQYXNzIGl0IGFzIGFuIGFyZ3VtZW50LlxuXG5cbiAgdmFyIGxhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCA/IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIDogTm9MYW5lcyk7XG5cbiAgaWYgKGxhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gVGhpcyBpcyBuZXZlciBleHBlY3RlZCB0byBoYXBwZW4uXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gV2UgZGlzYWJsZSB0aW1lLXNsaWNpbmcgaW4gc29tZSBjYXNlczogaWYgdGhlIHdvcmsgaGFzIGJlZW4gQ1BVLWJvdW5kXG4gIC8vIGZvciB0b28gbG9uZyAoXCJleHBpcmVkXCIgd29yaywgdG8gcHJldmVudCBzdGFydmF0aW9uKSwgb3Igd2UncmUgaW5cbiAgLy8gc3luYy11cGRhdGVzLWJ5LWRlZmF1bHQgbW9kZS5cbiAgLy8gVE9ETzogV2Ugb25seSBjaGVjayBgZGlkVGltZW91dGAgZGVmZW5zaXZlbHksIHRvIGFjY291bnQgZm9yIGEgU2NoZWR1bGVyXG4gIC8vIGJ1ZyB3ZSdyZSBzdGlsbCBpbnZlc3RpZ2F0aW5nLiBPbmNlIHRoZSBidWcgaW4gU2NoZWR1bGVyIGlzIGZpeGVkLFxuICAvLyB3ZSBjYW4gcmVtb3ZlIHRoaXMsIHNpbmNlIHdlIHRyYWNrIGV4cGlyYXRpb24gb3Vyc2VsdmVzLlxuXG5cbiAgdmFyIHNob3VsZFRpbWVTbGljZSA9ICFpbmNsdWRlc0Jsb2NraW5nTGFuZShyb290LCBsYW5lcykgJiYgIWluY2x1ZGVzRXhwaXJlZExhbmUocm9vdCwgbGFuZXMpICYmICghZGlkVGltZW91dCk7XG4gIHZhciBleGl0U3RhdHVzID0gc2hvdWxkVGltZVNsaWNlID8gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIDogcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuXG4gIGlmIChleGl0U3RhdHVzICE9PSBSb290SW5Qcm9ncmVzcykge1xuICAgIHZhciByZW5kZXJXYXNDb25jdXJyZW50ID0gc2hvdWxkVGltZVNsaWNlO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3REaWROb3RDb21wbGV0ZSkge1xuICAgICAgICAvLyBUaGUgcmVuZGVyIHVud291bmQgd2l0aG91dCBjb21wbGV0aW5nIHRoZSB0cmVlLiBUaGlzIGhhcHBlbnMgaW4gc3BlY2lhbFxuICAgICAgICAvLyBjYXNlcyB3aGVyZSBuZWVkIHRvIGV4aXQgdGhlIGN1cnJlbnQgcmVuZGVyIHdpdGhvdXQgcHJvZHVjaW5nIGFcbiAgICAgICAgLy8gY29uc2lzdGVudCB0cmVlIG9yIGNvbW1pdHRpbmcuXG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCBOb0xhbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHJlbmRlciBjb21wbGV0ZWQuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgcmVuZGVyIG1heSBoYXZlIHlpZWxkZWQgdG8gYSBjb25jdXJyZW50IGV2ZW50LCBhbmQgaWYgc28sXG4gICAgICAgIC8vIGNvbmZpcm0gdGhhdCBhbnkgbmV3bHkgcmVuZGVyZWQgc3RvcmVzIGFyZSBjb25zaXN0ZW50LlxuICAgICAgICAvLyBUT0RPOiBJdCdzIHBvc3NpYmxlIHRoYXQgZXZlbiBhIGNvbmN1cnJlbnQgcmVuZGVyIG1heSBuZXZlciBoYXZlIHlpZWxkZWRcbiAgICAgICAgLy8gdG8gdGhlIG1haW4gdGhyZWFkLCBpZiBpdCB3YXMgZmFzdCBlbm91Z2gsIG9yIGlmIGl0IGV4cGlyZWQuIFdlIGNvdWxkXG4gICAgICAgIC8vIHNraXAgdGhlIGNvbnNpc3RlbmN5IGNoZWNrIGluIHRoYXQgY2FzZSwgdG9vLlxuICAgICAgICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTtcblxuICAgICAgICBpZiAocmVuZGVyV2FzQ29uY3VycmVudCAmJiAhaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yaykpIHtcbiAgICAgICAgICAvLyBBIHN0b3JlIHdhcyBtdXRhdGVkIGluIGFuIGludGVybGVhdmVkIGV2ZW50LiBSZW5kZXIgYWdhaW4sXG4gICAgICAgICAgLy8gc3luY2hyb25vdXNseSwgdG8gYmxvY2sgZnVydGhlciBtdXRhdGlvbnMuXG4gICAgICAgICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTsgLy8gV2UgYXNzdW1lIHRoZSB0cmVlIGlzIG5vdyBjb25zaXN0ZW50IGJlY2F1c2Ugd2UgZGlkbid0IHlpZWxkIHRvIGFueVxuICAgICAgICAgIC8vIGNvbmN1cnJlbnQgZXZlbnRzLlxuXG4gICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9IGZhbHNlOyAvLyBOZWVkIHRvIGNoZWNrIHRoZSBleGl0IHN0YXR1cyBhZ2Fpbi5cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIENoZWNrIGlmIHNvbWV0aGluZyB0aHJld1xuXG5cbiAgICAgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgICAgICAgdmFyIGxhbmVzVGhhdEp1c3RFcnJvcmVkID0gbGFuZXM7XG4gICAgICAgICAgdmFyIGVycm9yUmV0cnlMYW5lcyA9IGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QsIGxhbmVzVGhhdEp1c3RFcnJvcmVkKTtcblxuICAgICAgICAgIGlmIChlcnJvclJldHJ5TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICAgICAgZXhpdFN0YXR1cyA9IHJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsIGxhbmVzVGhhdEp1c3RFcnJvcmVkLCBlcnJvclJldHJ5TGFuZXMpO1xuICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9IGZhbHNlOyAvLyBOZWVkIHRvIGNoZWNrIHRoZSBleGl0IHN0YXR1cyBhZ2Fpbi5cblxuICAgICAgICAgICAgaWYgKGV4aXRTdGF0dXMgIT09IFJvb3RFcnJvcmVkKSB7XG4gICAgICAgICAgICAgIC8vIFRoZSByb290IGRpZCBub3QgZXJyb3IgdGhpcyB0aW1lLiBSZXN0YXJ0IHRoZSBleGl0IGFsZ29yaXRobVxuICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICAgICAgICAgIC8vIFRPRE86IFJlZmFjdG9yIHRoZSBleGl0IGFsZ29yaXRobSB0byBiZSBsZXNzIGNvbmZ1c2luZy4gTWF5YmVcbiAgICAgICAgICAgICAgLy8gbW9yZSBicmFuY2hlcyArIHJlY3Vyc2lvbiBpbnN0ZWFkIG9mIGEgbG9vcC4gSSB0aGluayB0aGUgb25seVxuICAgICAgICAgICAgICAvLyB0aGluZyB0aGF0IGNhdXNlcyBpdCB0byBiZSBhIGxvb3AgaXMgdGhlIFJvb3REaWROb3RDb21wbGV0ZVxuICAgICAgICAgICAgICAvLyBjaGVjay4gSWYgdGhhdCdzIHRydWUsIHRoZW4gd2UgZG9uJ3QgbmVlZCBhIGxvb3AvcmVjdXJzaW9uXG4gICAgICAgICAgICAgIC8vIGF0IGFsbC5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgTm9MYW5lKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBXZSBub3cgaGF2ZSBhIGNvbnNpc3RlbnQgdHJlZS4gVGhlIG5leHQgc3RlcCBpcyBlaXRoZXIgdG8gY29tbWl0IGl0LFxuICAgICAgICAvLyBvciwgaWYgc29tZXRoaW5nIHN1c3BlbmRlZCwgd2FpdCB0byBjb21taXQgaXQgYWZ0ZXIgYSB0aW1lb3V0LlxuXG5cbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICAgICAgICBmaW5pc2hDb25jdXJyZW50UmVuZGVyKHJvb3QsIGV4aXRTdGF0dXMsIGZpbmlzaGVkV29yaywgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9IHdoaWxlICh0cnVlKTtcbiAgfVxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgcmV0dXJuIGdldENvbnRpbnVhdGlvbkZvclJvb3Qocm9vdCwgb3JpZ2luYWxDYWxsYmFja05vZGUpO1xufVxuXG5mdW5jdGlvbiByZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LCBvcmlnaW5hbGx5QXR0ZW1wdGVkTGFuZXMsIGVycm9yUmV0cnlMYW5lcykge1xuICAvLyBJZiBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgaHlkcmF0aW9uLCBkaXNjYXJkIHNlcnZlciByZXNwb25zZSBhbmQgZmFsbFxuICAvLyBiYWNrIHRvIGNsaWVudCBzaWRlIHJlbmRlci5cbiAgLy8gQmVmb3JlIHJlbmRlcmluZyBhZ2Fpbiwgc2F2ZSB0aGUgZXJyb3JzIGZyb20gdGhlIHByZXZpb3VzIGF0dGVtcHQuXG4gIHZhciBlcnJvcnNGcm9tRmlyc3RBdHRlbXB0ID0gd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycztcbiAgdmFyIHdhc1Jvb3REZWh5ZHJhdGVkID0gc3VwcG9ydHNIeWRyYXRpb24gJiYgaXNSb290RGVoeWRyYXRlZChyb290KTtcblxuICBpZiAod2FzUm9vdERlaHlkcmF0ZWQpIHtcbiAgICAvLyBUaGUgc2hlbGwgZmFpbGVkIHRvIGh5ZHJhdGUuIFNldCBhIGZsYWcgdG8gZm9yY2UgYSBjbGllbnQgcmVuZGVyaW5nXG4gICAgLy8gZHVyaW5nIHRoZSBuZXh0IGF0dGVtcHQuIFRvIGRvIHRoaXMsIHdlIGNhbGwgcHJlcGFyZUZyZXNoU3RhY2sgbm93XG4gICAgLy8gdG8gY3JlYXRlIHRoZSByb290IHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIFRoaXMgaXMgYSBiaXQgd2VpcmQgaW4gdGVybXNcbiAgICAvLyBvZiBmYWN0b3JpbmcsIGJlY2F1c2UgaXQgcmVsaWVzIG9uIHJlbmRlclJvb3RTeW5jIG5vdCBjYWxsaW5nXG4gICAgLy8gcHJlcGFyZUZyZXNoU3RhY2sgYWdhaW4gaW4gdGhlIGNhbGwgYmVsb3csIHdoaWNoIGhhcHBlbnMgYmVjYXVzZSB0aGVcbiAgICAvLyByb290IGFuZCBsYW5lcyBoYXZlbid0IGNoYW5nZWQuXG4gICAgLy9cbiAgICAvLyBUT0RPOiBJIHRoaW5rIHdoYXQgd2Ugc2hvdWxkIGRvIGlzIHNldCBGb3JjZUNsaWVudFJlbmRlciBpbnNpZGVcbiAgICAvLyB0aHJvd0V4Y2VwdGlvbiwgbGlrZSB3ZSBkbyBmb3IgbmVzdGVkIFN1c3BlbnNlIGJvdW5kYXJpZXMuIFRoZSByZWFzb25cbiAgICAvLyBpdCdzIGhlcmUgaW5zdGVhZCBpcyBzbyB3ZSBjYW4gc3dpdGNoIHRvIHRoZSBzeW5jaHJvbm91cyB3b3JrIGxvb3AsIHRvby5cbiAgICAvLyBTb21ldGhpbmcgdG8gY29uc2lkZXIgZm9yIGEgZnV0dXJlIHJlZmFjdG9yLlxuICAgIHZhciByb290V29ya0luUHJvZ3Jlc3MgPSBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBlcnJvclJldHJ5TGFuZXMpO1xuICAgIHJvb3RXb3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcbiAgfVxuXG4gIHZhciBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgZXJyb3JSZXRyeUxhbmVzKTtcblxuICBpZiAoZXhpdFN0YXR1cyAhPT0gUm9vdEVycm9yZWQpIHtcbiAgICAvLyBTdWNjZXNzZnVsbHkgZmluaXNoZWQgcmVuZGVyaW5nIG9uIHJldHJ5XG4gICAgaWYgKHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciAmJiAhd2FzUm9vdERlaHlkcmF0ZWQpIHtcbiAgICAgIC8vIER1cmluZyB0aGUgc3luY2hyb25vdXMgcmVuZGVyLCB3ZSBhdHRhY2hlZCBhZGRpdGlvbmFsIHBpbmcgbGlzdGVuZXJzLlxuICAgICAgLy8gVGhpcyBpcyBoaWdobHkgc3VnZ2VzdGl2ZSBvZiBhbiB1bmNhY2hlZCBwcm9taXNlICh0aG91Z2ggaXQncyBub3QgdGhlXG4gICAgICAvLyBvbmx5IHJlYXNvbiB0aGlzIHdvdWxkIGhhcHBlbikuIElmIGl0IHdhcyBhbiB1bmNhY2hlZCBwcm9taXNlLCB0aGVuXG4gICAgICAvLyBpdCBtYXkgaGF2ZSBtYXNrZWQgYSBkb3duc3RyZWFtIGVycm9yIGZyb20gb2N1cnJpbmcgd2l0aG91dCBhY3R1YWxseVxuICAgICAgLy8gZml4aW5nIGl0LiBFeGFtcGxlOlxuICAgICAgLy9cbiAgICAgIC8vICAgIHVzZShQcm9taXNlLnJlc29sdmUoJ3VuY2FjaGVkJykpXG4gICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoJ09vcHMhJylcbiAgICAgIC8vXG4gICAgICAvLyBXaGVuIHRoaXMgaGFwcGVucywgdGhlcmUncyBhIGNvbmZsaWN0IGJldHdlZW4gYmxvY2tpbmcgcG90ZW50aWFsXG4gICAgICAvLyBjb25jdXJyZW50IGRhdGEgcmFjZXMgYW5kIHVud3JhcHBpbmcgdW5jYWNoZWQgcHJvbWlzZSB2YWx1ZXMuIFdlXG4gICAgICAvLyBoYXZlIHRvIGNob29zZSBvbmUgb3IgdGhlIG90aGVyLiBCZWNhdXNlIHRoZSBkYXRhIHJhY2UgcmVjb3ZlcnkgaXNcbiAgICAgIC8vIGEgbGFzdCBkaXRjaCBlZmZvcnQsIHdlJ2xsIGRpc2FibGUgaXQuXG4gICAgICByb290LmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzID0gbWVyZ2VMYW5lcyhyb290LmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzLCBvcmlnaW5hbGx5QXR0ZW1wdGVkTGFuZXMpOyAvLyBNYXJrIHRoZSBjdXJyZW50IHJlbmRlciBhcyBzdXNwZW5kZWQgYW5kIGZvcmNlIGl0IHRvIHJlc3RhcnQuIE9uY2VcbiAgICAgIC8vIHRoZXNlIGxhbmVzIGZpbmlzaCBzdWNjZXNzZnVsbHksIHdlJ2xsIHJlLWVuYWJsZSB0aGUgZXJyb3IgcmVjb3ZlcnlcbiAgICAgIC8vIG1lY2hhbmlzbSBmb3Igc3Vic2VxdWVudCB1cGRhdGVzLlxuXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyB8PSBvcmlnaW5hbGx5QXR0ZW1wdGVkTGFuZXM7XG4gICAgICByZXR1cm4gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTtcbiAgICB9IC8vIFRoZSBlcnJvcnMgZnJvbSB0aGUgZmFpbGVkIGZpcnN0IGF0dGVtcHQgaGF2ZSBiZWVuIHJlY292ZXJlZC4gQWRkXG4gICAgLy8gdGhlbSB0byB0aGUgY29sbGVjdGlvbiBvZiByZWNvdmVyYWJsZSBlcnJvcnMuIFdlJ2xsIGxvZyB0aGVtIGluIHRoZVxuICAgIC8vIGNvbW1pdCBwaGFzZS5cblxuXG4gICAgdmFyIGVycm9yc0Zyb21TZWNvbmRBdHRlbXB0ID0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvcnNGcm9tRmlyc3RBdHRlbXB0OyAvLyBUaGUgZXJyb3JzIGZyb20gdGhlIHNlY29uZCBhdHRlbXB0IHNob3VsZCBiZSBxdWV1ZWQgYWZ0ZXIgdGhlIGVycm9yc1xuICAgIC8vIGZyb20gdGhlIGZpcnN0IGF0dGVtcHQsIHRvIHByZXNlcnZlIHRoZSBjYXVzYWwgc2VxdWVuY2UuXG5cbiAgICBpZiAoZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQgIT09IG51bGwpIHtcbiAgICAgIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleGl0U3RhdHVzO1xufVxuXG5mdW5jdGlvbiBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9ycykge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPT09IG51bGwpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGVycm9ycztcbiAgfSBlbHNlIHtcbiAgICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMucHVzaC5hcHBseSh3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgZXJyb3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hDb25jdXJyZW50UmVuZGVyKHJvb3QsIGV4aXRTdGF0dXMsIGZpbmlzaGVkV29yaywgbGFuZXMpIHtcbiAgLy8gVE9ETzogVGhlIGZhY3QgdGhhdCBtb3N0IG9mIHRoZXNlIGJyYW5jaGVzIGFyZSBpZGVudGljYWwgc3VnZ2VzdHMgdGhhdCBzb21lXG4gIC8vIG9mIHRoZSBleGl0IHN0YXR1c2VzIGFyZSBub3QgYmVzdCBtb2RlbGVkIGFzIGV4aXQgc3RhdHVzZXMgYW5kIHNob3VsZCBiZVxuICAvLyB0cmFja2VkIG9ydGhvZ29uYWxseS5cbiAgc3dpdGNoIChleGl0U3RhdHVzKSB7XG4gICAgY2FzZSBSb290SW5Qcm9ncmVzczpcbiAgICBjYXNlIFJvb3RGYXRhbEVycm9yZWQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vdCBkaWQgbm90IGNvbXBsZXRlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuXG4gICAgY2FzZSBSb290U3VzcGVuZGVkV2l0aERlbGF5OlxuICAgICAge1xuICAgICAgICBpZiAoaW5jbHVkZXNPbmx5VHJhbnNpdGlvbnMobGFuZXMpKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIHRyYW5zaXRpb24sIHNvIHdlIHNob3VsZCBleGl0IHdpdGhvdXQgY29tbWl0dGluZyBhXG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIgYW5kIHdpdGhvdXQgc2NoZWR1bGluZyBhIHRpbWVvdXQuIERlbGF5IGluZGVmaW5pdGVseVxuICAgICAgICAgIC8vIHVudGlsIHdlIHJlY2VpdmUgbW9yZSBkYXRhLlxuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIENvbW1pdCB0aGUgcGxhY2Vob2xkZXIuXG5cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUm9vdEVycm9yZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRoaXMgcmVuZGVyIGVycm9yZWQuIElnbm9yZSBhbnkgcmVjb3ZlcmFibGUgZXJyb3JzIGJlY2F1c2Ugd2Ugd2VyZW4ndCBhY3R1YWxseVxuICAgICAgICAvLyBhYmxlIHRvIHJlY292ZXIuIEluc3RlYWQsIHdoYXRldmVyIHRoZSBmaW5hbCBlcnJvcnMgd2VyZSBpcyB0aGUgb25lcyB3ZSBsb2cuXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHdlIG9ubHkgbG9nIHRoZSBhY3R1YWwgY2xpZW50IHNpZGUgZXJyb3IgaWYgaXQncyBqdXN0IGEgcGxhaW5cbiAgICAgICAgLy8gZXJyb3IgdGhyb3duIGZyb20gYSBjb21wb25lbnQgb24gdGhlIHNlcnZlciBhbmQgdGhlIGNsaWVudC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUm9vdFN1c3BlbmRlZDpcbiAgICBjYXNlIFJvb3RDb21wbGV0ZWQ6XG4gICAgICB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHJvb3QgZXhpdCBzdGF0dXMuJyk7XG4gICAgICB9XG4gIH1cblxuICBpZiAoc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkpIHtcbiAgICAvLyBXZSdyZSBpbnNpZGUgYW4gYGFjdGAgc2NvcGUuIENvbW1pdCBpbW1lZGlhdGVseS5cbiAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLCB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLCB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpICYmIChhbHdheXNUaHJvdHRsZVJldHJpZXMgKSkge1xuICAgICAgLy8gVGhpcyByZW5kZXIgb25seSBpbmNsdWRlZCByZXRyaWVzLCBubyB1cGRhdGVzLiBUaHJvdHRsZSBjb21taXR0aW5nXG4gICAgICAvLyByZXRyaWVzIHNvIHRoYXQgd2UgZG9uJ3Qgc2hvdyB0b28gbWFueSBsb2FkaW5nIHN0YXRlcyB0b28gcXVpY2tseS5cbiAgICAgIHZhciBtc1VudGlsVGltZW91dCA9IGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgKyBGQUxMQkFDS19USFJPVFRMRV9NUyAtIG5vdyQxKCk7IC8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuXG4gICAgICBpZiAobXNVbnRpbFRpbWVvdXQgPiAxMCkge1xuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICAgICAgICB2YXIgbmV4dExhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIE5vTGFuZXMpO1xuXG4gICAgICAgIGlmIChuZXh0TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAvLyBUaGVyZSdzIGFkZGl0aW9uYWwgd29yayB3ZSBjYW4gZG8gb24gdGhpcyByb290LiBXZSBtaWdodCBhcyB3ZWxsXG4gICAgICAgICAgLy8gYXR0ZW1wdCB0byB3b3JrIG9uIHRoYXQgd2hpbGUgd2UncmUgc3VzcGVuZGVkLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBUaGUgcmVuZGVyIGlzIHN1c3BlbmRlZCwgaXQgaGFzbid0IHRpbWVkIG91dCwgYW5kIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgd29yayB0byBkby4gSW5zdGVhZCBvZiBjb21taXR0aW5nIHRoZSBmYWxsYmFja1xuICAgICAgICAvLyBpbW1lZGlhdGVseSwgd2FpdCBmb3IgbW9yZSBkYXRhIHRvIGFycml2ZS5cbiAgICAgICAgLy8gVE9ETzogQ29tYmluZSByZXRyeSB0aHJvdHRsaW5nIHdpdGggU3VzcGVuc2V5IGNvbW1pdHMuIFJpZ2h0IG5vdyB0aGV5XG4gICAgICAgIC8vIHJ1biBvbmUgYWZ0ZXIgdGhlIG90aGVyLlxuXG5cbiAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3RXaGVuUmVhZHkuYmluZChudWxsLCByb290LCBmaW5pc2hlZFdvcmssIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLCB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLCBsYW5lcywgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpLCBtc1VudGlsVGltZW91dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21taXRSb290V2hlblJlYWR5KHJvb3QsIGZpbmlzaGVkV29yaywgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsIGxhbmVzLCB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdFdoZW5SZWFkeShyb290LCBmaW5pc2hlZFdvcmssIHJlY292ZXJhYmxlRXJyb3JzLCB0cmFuc2l0aW9ucywgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLCBsYW5lcywgc3Bhd25lZExhbmUpIHtcbiAgLy8gVE9ETzogQ29tYmluZSByZXRyeSB0aHJvdHRsaW5nIHdpdGggU3VzcGVuc2V5IGNvbW1pdHMuIFJpZ2h0IG5vdyB0aGV5IHJ1blxuICAvLyBvbmUgYWZ0ZXIgdGhlIG90aGVyLlxuICB2YXIgQm90aFZpc2liaWxpdHlBbmRNYXlTdXNwZW5kQ29tbWl0ID0gVmlzaWJpbGl0eSB8IE1heVN1c3BlbmRDb21taXQ7XG4gIHZhciBzdWJ0cmVlRmxhZ3MgPSBmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzO1xuXG4gIGlmIChzdWJ0cmVlRmxhZ3MgJiBTaG91bGRTdXNwZW5kQ29tbWl0IHx8IChzdWJ0cmVlRmxhZ3MgJiBCb3RoVmlzaWJpbGl0eUFuZE1heVN1c3BlbmRDb21taXQpID09PSBCb3RoVmlzaWJpbGl0eUFuZE1heVN1c3BlbmRDb21taXQpIHtcbiAgICAvLyBCZWZvcmUgY29tbWl0dGluZywgYXNrIHRoZSByZW5kZXJlciB3aGV0aGVyIHRoZSBob3N0IHRyZWUgaXMgcmVhZHkuXG4gICAgLy8gSWYgaXQncyBub3QsIHdlJ2xsIHdhaXQgdW50aWwgaXQgbm90aWZpZXMgdXMuXG4gICAgc3RhcnRTdXNwZW5kaW5nQ29tbWl0KCk7IC8vIFRoaXMgd2lsbCB3YWxrIHRoZSBjb21wbGV0ZWQgZmliZXIgdHJlZSBhbmQgYXR0YWNoIGxpc3RlbmVycyB0byBhbGxcbiAgICAvLyB0aGUgc3VzcGVuc2V5IHJlc291cmNlcy4gVGhlIHJlbmRlcmVyIGlzIHJlc3BvbnNpYmxlIGZvciBhY2N1bXVsYXRpbmdcbiAgICAvLyBhbGwgdGhlIGxvYWQgZXZlbnRzLiBUaGlzIGFsbCBoYXBwZW5zIGluIGEgc2luZ2xlIHN5bmNocm9ub3VzXG4gICAgLy8gdHJhbnNhY3Rpb24sIHNvIGl0IHRyYWNrIHN0YXRlIGluIGl0cyBvd24gbW9kdWxlIHNjb3BlLlxuXG4gICAgYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaW5pc2hlZFdvcmspOyAvLyBBdCB0aGUgZW5kLCBhc2sgdGhlIHJlbmRlcmVyIGlmIGl0J3MgcmVhZHkgdG8gY29tbWl0LCBvciBpZiB3ZSBzaG91bGRcbiAgICAvLyBzdXNwZW5kLiBJZiBpdCdzIG5vdCByZWFkeSwgaXQgd2lsbCByZXR1cm4gYSBjYWxsYmFjayB0byBzdWJzY3JpYmUgdG9cbiAgICAvLyBhIHJlYWR5IGV2ZW50LlxuXG4gICAgdmFyIHNjaGVkdWxlUGVuZGluZ0NvbW1pdCA9IHdhaXRGb3JDb21taXRUb0JlUmVhZHkoKTtcblxuICAgIGlmIChzY2hlZHVsZVBlbmRpbmdDb21taXQgIT09IG51bGwpIHtcbiAgICAgIC8vIE5PVEU6IHdhaXRGb3JDb21taXRUb0JlUmVhZHkgcmV0dXJucyBhIHN1YnNjcmliZSBmdW5jdGlvbiBzbyB0aGF0IHdlXG4gICAgICAvLyBvbmx5IGFsbG9jYXRlIGEgZnVuY3Rpb24gaWYgdGhlIGNvbW1pdCBpc24ndCByZWFkeSB5ZXQuIFRoZSBvdGhlclxuICAgICAgLy8gcGF0dGVybiB3b3VsZCBiZSB0byBhbHdheXMgcGFzcyBhIGNhbGxiYWNrIHRvIHdhaXRGb3JDb21taXRUb0JlUmVhZHkuXG4gICAgICAvLyBOb3QgeWV0IHJlYWR5IHRvIGNvbW1pdC4gRGVsYXkgdGhlIGNvbW1pdCB1bnRpbCB0aGUgcmVuZGVyZXIgbm90aWZpZXNcbiAgICAgIC8vIHVzIHRoYXQgaXQncyByZWFkeS4gVGhpcyB3aWxsIGJlIGNhbmNlbGVkIGlmIHdlIHN0YXJ0IHdvcmsgb24gdGhlXG4gICAgICAvLyByb290IGFnYWluLlxuICAgICAgcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gc2NoZWR1bGVQZW5kaW5nQ29tbWl0KGNvbW1pdFJvb3QuYmluZChudWxsLCByb290LCByZWNvdmVyYWJsZUVycm9ycywgdHJhbnNpdGlvbnMsIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSkpO1xuICAgICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgbGFuZXMsIHNwYXduZWRMYW5lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gLy8gT3RoZXJ3aXNlLCBjb21taXQgaW1tZWRpYXRlbHkuXG5cblxuICBjb21taXRSb290KHJvb3QsIHJlY292ZXJhYmxlRXJyb3JzLCB0cmFuc2l0aW9ucywgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLCBzcGF3bmVkTGFuZSk7XG59XG5cbmZ1bmN0aW9uIGlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3JlcyhmaW5pc2hlZFdvcmspIHtcbiAgLy8gU2VhcmNoIHRoZSByZW5kZXJlZCB0cmVlIGZvciBleHRlcm5hbCBzdG9yZSByZWFkcywgYW5kIGNoZWNrIHdoZXRoZXIgdGhlXG4gIC8vIHN0b3JlcyB3ZXJlIG11dGF0ZWQgaW4gYSBjb25jdXJyZW50IGV2ZW50LiBJbnRlbnRpb25hbGx5IHVzaW5nIGFuIGl0ZXJhdGl2ZVxuICAvLyBsb29wIGluc3RlYWQgb2YgcmVjdXJzaW9uIHNvIHdlIGNhbiBleGl0IGVhcmx5LlxuICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLmZsYWdzICYgU3RvcmVDb25zaXN0ZW5jeSkge1xuICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gbm9kZS51cGRhdGVRdWV1ZTtcblxuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBjaGVja3MgPSB1cGRhdGVRdWV1ZS5zdG9yZXM7XG5cbiAgICAgICAgaWYgKGNoZWNrcyAhPT0gbnVsbCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hlY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hlY2sgPSBjaGVja3NbaV07XG4gICAgICAgICAgICB2YXIgZ2V0U25hcHNob3QgPSBjaGVjay5nZXRTbmFwc2hvdDtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZFZhbHVlID0gY2hlY2sudmFsdWU7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghb2JqZWN0SXMoZ2V0U25hcHNob3QoKSwgcmVuZGVyZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCBhbiBpbmNvbnNpc3RlbnQgc3RvcmUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAvLyBJZiBgZ2V0U25hcHNob3RgIHRocm93cywgcmV0dXJuIGBmYWxzZWAuIFRoaXMgd2lsbCBzY2hlZHVsZVxuICAgICAgICAgICAgICAvLyBhIHJlLXJlbmRlciwgYW5kIHRoZSBlcnJvciB3aWxsIGJlIHJldGhyb3duIGR1cmluZyByZW5kZXIuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgaWYgKG5vZGUuc3VidHJlZUZsYWdzICYgU3RvcmVDb25zaXN0ZW5jeSAmJiBjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH0gLy8gRmxvdyBkb2Vzbid0IGtub3cgdGhpcyBpcyB1bnJlYWNoYWJsZSwgYnV0IGVzbGludCBkb2VzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuXG5cbiAgcmV0dXJuIHRydWU7XG59IC8vIFRoZSBleHRyYSBpbmRpcmVjdGlvbnMgYXJvdW5kIG1hcmtSb290VXBkYXRlZCBhbmQgbWFya1Jvb3RTdXNwZW5kZWQgaXNcbi8vIG5lZWRlZCB0byBhdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGlzIG1vZHVsZSBhbmRcbi8vIFJlYWN0RmliZXJMYW5lLiBUaGVyZSdzIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0byBzcGxpdCB1cCB0aGVzZSBtb2R1bGVzIGFuZFxuLy8gYXZvaWQgdGhpcyBwcm9ibGVtLiBQZXJoYXBzIGFsbCB0aGUgcm9vdC1tYXJraW5nIGZ1bmN0aW9ucyBzaG91bGQgbW92ZSBpbnRvXG4vLyB0aGUgd29yayBsb29wLlxuXG5cbmZ1bmN0aW9uIG1hcmtSb290VXBkYXRlZChyb290LCB1cGRhdGVkTGFuZXMpIHtcbiAgbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgdXBkYXRlZExhbmVzKTtcblxuICB7XG4gICAgLy8gQ2hlY2sgZm9yIHJlY3Vyc2l2ZSB1cGRhdGVzXG4gICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGV4ZWN1dGlvbkNvbnRleHQgJiBDb21taXRDb250ZXh0KSB7XG4gICAgICBkaWRJbmNsdWRlQ29tbWl0UGhhc2VVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRocm93SWZJbmZpbml0ZVVwZGF0ZUxvb3BEZXRlY3RlZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtSb290UGluZ2VkKHJvb3QsIHBpbmdlZExhbmVzKSB7XG4gIG1hcmtSb290UGluZ2VkJDEocm9vdCwgcGluZ2VkTGFuZXMpO1xuXG4gIHtcbiAgICAvLyBDaGVjayBmb3IgcmVjdXJzaXZlIHBpbmdzLiBQaW5ncyBhcmUgY29uY2VwdHVhbGx5IGRpZmZlcmVudCBmcm9tIHVwZGF0ZXMgaW5cbiAgICAvLyBvdGhlciBjb250ZXh0cyBidXQgd2UgY2FsbCBpdCBhbiBcInVwZGF0ZVwiIGluIHRoaXMgY29udGV4dCBiZWNhdXNlXG4gICAgLy8gcmVwZWF0ZWRseSBwaW5naW5nIGEgc3VzcGVuZGVkIHJlbmRlciBjYW4gY2F1c2UgYSByZWN1cnNpdmUgcmVuZGVyIGxvb3AuXG4gICAgLy8gVGhlIHJlbGV2YW50IHByb3BlcnR5IGlzIHRoYXQgaXQgY2FuIHJlc3VsdCBpbiBhIG5ldyByZW5kZXIgYXR0ZW1wdFxuICAgIC8vIGJlaW5nIHNjaGVkdWxlZC5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZXhlY3V0aW9uQ29udGV4dCAmIENvbW1pdENvbnRleHQpIHtcbiAgICAgIGRpZEluY2x1ZGVDb21taXRQaGFzZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhyb3dJZkluZmluaXRlVXBkYXRlTG9vcERldGVjdGVkKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgc3VzcGVuZGVkTGFuZXMsIHNwYXduZWRMYW5lKSB7XG4gIC8vIFdoZW4gc3VzcGVuZGluZywgd2Ugc2hvdWxkIGFsd2F5cyBleGNsdWRlIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgb3IgKG1vcmVcbiAgLy8gcmFyZWx5LCBzaW5jZSB3ZSB0cnkgdG8gYXZvaWQgaXQpIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gIHN1c3BlbmRlZExhbmVzID0gcmVtb3ZlTGFuZXMoc3VzcGVuZGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzKTtcbiAgc3VzcGVuZGVkTGFuZXMgPSByZW1vdmVMYW5lcyhzdXNwZW5kZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMpO1xuXG4gIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgc3VzcGVuZGVkTGFuZXMsIHNwYXduZWRMYW5lKTtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHN5bmNocm9ub3VzIHRhc2tzIHRoYXQgZG9uJ3QgZ29cbi8vIHRocm91Z2ggU2NoZWR1bGVyXG5cblxuZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QsIGxhbmVzKSB7XG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLicpO1xuICB9XG5cbiAgdmFyIGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMgPSBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG5cbiAgaWYgKGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAvLyBJZiBwYXNzaXZlIGVmZmVjdHMgd2VyZSBmbHVzaGVkLCBleGl0IHRvIHRoZSBvdXRlciB3b3JrIGxvb3AgaW4gdGhlIHJvb3RcbiAgICAvLyBzY2hlZHVsZXIsIHNvIHdlIGNhbiByZWNvbXB1dGUgdGhlIHByaW9yaXR5LlxuICAgIC8vIFRPRE86IFdlIGRvbid0IGFjdHVhbGx5IG5lZWQgdGhpcyBgZW5zdXJlUm9vdElzU2NoZWR1bGVkYCBjYWxsIGJlY2F1c2VcbiAgICAvLyB0aGlzIHBhdGggaXMgb25seSByZWFjaGFibGUgaWYgdGhlIHJvb3QgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzY2hlZHVsZS5cbiAgICAvLyBJJ20gaW5jbHVkaW5nIGl0IG9ubHkgZm9yIGNvbnNpc3RlbmN5IHdpdGggdGhlIG90aGVyIGV4aXQgcG9pbnRzIGZyb21cbiAgICAvLyB0aGlzIGZ1bmN0aW9uLiBDYW4gYWRkcmVzcyBpbiBhIHN1YnNlcXVlbnQgcmVmYWN0b3IuXG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIHN5bmNOZXN0ZWRVcGRhdGVGbGFnKCk7XG4gIH1cblxuICB2YXIgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTtcblxuICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEVycm9yZWQpIHtcbiAgICAvLyBJZiBzb21ldGhpbmcgdGhyZXcgYW4gZXJyb3IsIHRyeSByZW5kZXJpbmcgb25lIG1vcmUgdGltZS4gV2UnbGwgcmVuZGVyXG4gICAgLy8gc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGwgaW5jbHVkZXNcbiAgICAvLyBhbGwgcGVuZGluZyB1cGRhdGVzIGFyZSBpbmNsdWRlZC4gSWYgaXQgc3RpbGwgZmFpbHMgYWZ0ZXIgdGhlIHNlY29uZFxuICAgIC8vIGF0dGVtcHQsIHdlJ2xsIGdpdmUgdXAgYW5kIGNvbW1pdCB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgdmFyIG9yaWdpbmFsbHlBdHRlbXB0ZWRMYW5lcyA9IGxhbmVzO1xuICAgIHZhciBlcnJvclJldHJ5TGFuZXMgPSBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290LCBvcmlnaW5hbGx5QXR0ZW1wdGVkTGFuZXMpO1xuXG4gICAgaWYgKGVycm9yUmV0cnlMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgbGFuZXMgPSBlcnJvclJldHJ5TGFuZXM7XG4gICAgICBleGl0U3RhdHVzID0gcmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3Iocm9vdCwgb3JpZ2luYWxseUF0dGVtcHRlZExhbmVzLCBlcnJvclJldHJ5TGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChleGl0U3RhdHVzID09PSBSb290RmF0YWxFcnJvcmVkKSB7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgbGFuZXMsIE5vTGFuZSk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3REaWROb3RDb21wbGV0ZSkge1xuICAgIC8vIFRoZSByZW5kZXIgdW53b3VuZCB3aXRob3V0IGNvbXBsZXRpbmcgdGhlIHRyZWUuIFRoaXMgaGFwcGVucyBpbiBzcGVjaWFsXG4gICAgLy8gY2FzZXMgd2hlcmUgbmVlZCB0byBleGl0IHRoZSBjdXJyZW50IHJlbmRlciB3aXRob3V0IHByb2R1Y2luZyBhXG4gICAgLy8gY29uc2lzdGVudCB0cmVlIG9yIGNvbW1pdHRpbmcuXG4gICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgbGFuZXMsIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gV2Ugbm93IGhhdmUgYSBjb25zaXN0ZW50IHRyZWUuIEJlY2F1c2UgdGhpcyBpcyBhIHN5bmMgcmVuZGVyLCB3ZVxuICAvLyB3aWxsIGNvbW1pdCBpdCBldmVuIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQuXG5cblxuICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLCB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLCB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSk7IC8vIEJlZm9yZSBleGl0aW5nLCBtYWtlIHN1cmUgdGhlcmUncyBhIGNhbGxiYWNrIHNjaGVkdWxlZCBmb3IgdGhlIG5leHRcbiAgLy8gcGVuZGluZyBsZXZlbC5cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmx1c2hSb290KHJvb3QsIGxhbmVzKSB7XG4gIGlmIChsYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHVwZ3JhZGVQZW5kaW5nTGFuZXNUb1N5bmMocm9vdCwgbGFuZXMpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcblxuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTsgLy8gVE9ETzogRm9yIGhpc3RvcmljYWwgcmVhc29ucyB0aGlzIGZsdXNoZXMgYWxsIHN5bmMgd29yayBhY3Jvc3MgYWxsXG4gICAgICAvLyByb290cy4gSXQgc2hvdWxkbid0IHJlYWxseSBtYXR0ZXIgZWl0aGVyIHdheSwgYnV0IHdlIGNvdWxkIGNoYW5nZSB0aGlzXG4gICAgICAvLyB0byBvbmx5IGZsdXNoIHRoZSBnaXZlbiByb290LlxuXG4gICAgICBmbHVzaFN5bmNXb3JrT25BbGxSb290cygpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RXhlY3V0aW9uQ29udGV4dCgpIHtcbiAgcmV0dXJuIGV4ZWN1dGlvbkNvbnRleHQ7XG59XG5mdW5jdGlvbiBkZWZlcnJlZFVwZGF0ZXMoZm4pIHtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcblxuICB0cnkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEZWZhdWx0RXZlbnRQcmlvcml0eSk7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoZm4sIGEpIHtcbiAge1xuICAgIC8vIGJhdGNoZWRVcGRhdGVzIGlzIGEgbm8tb3Agbm93LCBidXQgdGhlcmUncyBzdGlsbCBzb21lIGludGVybmFsIHJlYWN0LWRvbVxuICAgIC8vIGNvZGUgY2FsbGluZyBpdCwgdGhhdCB3ZSBjYW4ndCByZW1vdmUgdW50aWwgd2UgcmVtb3ZlIGxlZ2FjeSBtb2RlLlxuICAgIHJldHVybiBmbihhKTtcbiAgfVxufVxuZnVuY3Rpb24gZGlzY3JldGVVcGRhdGVzKGZuLCBhLCBiLCBjLCBkKSB7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgdHJ5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgICByZXR1cm4gZm4oYSwgYiwgYywgZCk7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbjtcblxuICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICB9XG4gIH1cbn0gLy8gT3ZlcmxvYWQgdGhlIGRlZmluaXRpb24gdG8gdGhlIHR3byB2YWxpZCBzaWduYXR1cmVzLlxuLy8gV2FybmluZywgdGhpcyBvcHRzLW91dCBvZiBjaGVja2luZyB0aGUgZnVuY3Rpb24gYm9keS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBmbHVzaFN5bmNGcm9tUmVjb25jaWxlcihmbikge1xuICAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgZmx1c2ggcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGVcbiAgLy8gbmV4dCBldmVudCwgbm90IGF0IHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIG9uZS5cbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsICYmICFkaXNhYmxlTGVnYWN5TW9kZSAmJiByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cy50YWcgPT09IExlZ2FjeVJvb3QgJiYgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSB7XG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB9XG5cbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBCYXRjaGVkQ29udGV4dDtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcblxuICB0cnkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuXG4gICAgaWYgKGZuKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbjtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7IC8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2guXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgd2lsbCBoYXBwZW4gZXZlbiBpZiBiYXRjaGVkVXBkYXRlcyBpcyBoaWdoZXIgdXBcbiAgICAvLyB0aGUgc3RhY2suXG5cbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSB7XG4gICAgICBmbHVzaFN5bmNXb3JrT25BbGxSb290cygpO1xuICAgIH1cbiAgfVxufSAvLyBJZiBjYWxsZWQgb3V0c2lkZSBvZiBhIHJlbmRlciBvciBjb21taXQgd2lsbCBmbHVzaCBhbGwgc3luYyB3b3JrIG9uIGFsbCByb290c1xuLy8gUmV0dXJucyB3aGV0aGVyIHRoZSB0aGUgY2FsbCB3YXMgZHVyaW5nIGEgcmVuZGVyIG9yIG5vdFxuXG5mdW5jdGlvbiBmbHVzaFN5bmNXb3JrKCkge1xuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSB7XG4gICAgZmx1c2hTeW5jV29ya09uQWxsUm9vdHMoKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzQWxyZWFkeVJlbmRlcmluZygpIHtcbiAgLy8gVXNlZCBieSB0aGUgcmVuZGVyZXIgdG8gcHJpbnQgYSB3YXJuaW5nIGlmIGNlcnRhaW4gQVBJcyBhcmUgY2FsbGVkIGZyb21cbiAgLy8gdGhlIHdyb25nIGNvbnRleHQuXG4gIHJldHVybiAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQ7XG59XG4vLyBoaWRkZW4gc3VidHJlZS4gVGhlIHN0YWNrIGxvZ2ljIGlzIG1hbmFnZWQgdGhlcmUgYmVjYXVzZSB0aGF0J3MgdGhlIG9ubHlcbi8vIHBsYWNlIHRoYXQgZXZlciBtb2RpZmllcyBpdC4gV2hpY2ggbW9kdWxlIGl0IGxpdmVzIGluIGRvZXNuJ3QgbWF0dGVyIGZvclxuLy8gcGVyZm9ybWFuY2UgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIHdpbGwgZ2V0IGlubGluZWQgcmVnYXJkbGVzc1xuXG5mdW5jdGlvbiBzZXRFbnRhbmdsZWRSZW5kZXJMYW5lcyhuZXdFbnRhbmdsZWRSZW5kZXJMYW5lcykge1xuICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IG5ld0VudGFuZ2xlZFJlbmRlckxhbmVzO1xufVxuZnVuY3Rpb24gZ2V0RW50YW5nbGVkUmVuZGVyTGFuZXMoKSB7XG4gIHJldHVybiBlbnRhbmdsZWRSZW5kZXJMYW5lcztcbn1cblxuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IG51bGwpIHJldHVybjtcbiAgdmFyIGludGVycnVwdGVkV29yaztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IE5vdFN1c3BlbmRlZCkge1xuICAgIC8vIE5vcm1hbCBjYXNlLiBXb3JrLWluLXByb2dyZXNzIGhhc24ndCBzdGFydGVkIHlldC4gVW53aW5kIGFsbFxuICAgIC8vIGl0cyBwYXJlbnRzLlxuICAgIGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgfSBlbHNlIHtcbiAgICAvLyBXb3JrLWluLXByb2dyZXNzIGlzIGluIHN1c3BlbmRlZCBzdGF0ZS4gUmVzZXQgdGhlIHdvcmsgbG9vcCBhbmQgdW53aW5kXG4gICAgLy8gYm90aCB0aGUgc3VzcGVuZGVkIGZpYmVyIGFuZCBhbGwgaXRzIHBhcmVudHMuXG4gICAgcmVzZXRTdXNwZW5kZWRXb3JrTG9vcE9uVW53aW5kKHdvcmtJblByb2dyZXNzKTtcbiAgICBpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuXG4gIHdoaWxlIChpbnRlcnJ1cHRlZFdvcmsgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudCA9IGludGVycnVwdGVkV29yay5hbHRlcm5hdGU7XG4gICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIGludGVycnVwdGVkV29yayk7XG4gICAgaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrLnJldHVybjtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpIHtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuICB2YXIgdGltZW91dEhhbmRsZSA9IHJvb3QudGltZW91dEhhbmRsZTtcblxuICBpZiAodGltZW91dEhhbmRsZSAhPT0gbm9UaW1lb3V0KSB7XG4gICAgLy8gVGhlIHJvb3QgcHJldmlvdXMgc3VzcGVuZGVkIGFuZCBzY2hlZHVsZWQgYSB0aW1lb3V0IHRvIGNvbW1pdCBhIGZhbGxiYWNrXG4gICAgLy8gc3RhdGUuIE5vdyB0aGF0IHdlIGhhdmUgYWRkaXRpb25hbCB3b3JrLCBjYW5jZWwgdGhlIHRpbWVvdXQuXG4gICAgcm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0OyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXSBDb21wbGFpbnMgbm9UaW1lb3V0IGlzIG5vdCBhIFRpbWVvdXRJRCwgZGVzcGl0ZSB0aGUgY2hlY2sgYWJvdmVcblxuICAgIGNhbmNlbFRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gIH1cblxuICB2YXIgY2FuY2VsUGVuZGluZ0NvbW1pdCA9IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdDtcblxuICBpZiAoY2FuY2VsUGVuZGluZ0NvbW1pdCAhPT0gbnVsbCkge1xuICAgIHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCA9IG51bGw7XG4gICAgY2FuY2VsUGVuZGluZ0NvbW1pdCgpO1xuICB9XG5cbiAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gIHdvcmtJblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gIHZhciByb290V29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhyb290LmN1cnJlbnQsIG51bGwpO1xuICB3b3JrSW5Qcm9ncmVzcyA9IHJvb3RXb3JrSW5Qcm9ncmVzcztcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBsYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSBmYWxzZTtcbiAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBOb0xhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPSBOb0xhbmU7XG4gIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUgPSBmYWxzZTsgLy8gR2V0IHRoZSBsYW5lcyB0aGF0IGFyZSBlbnRhbmdsZWQgd2l0aCB3aGF0ZXZlciB3ZSdyZSBhYm91dCB0byByZW5kZXIuIFdlXG4gIC8vIHRyYWNrIHRoZXNlIHNlcGFyYXRlbHkgc28gd2UgY2FuIGRpc3Rpbmd1aXNoIHRoZSBwcmlvcml0eSBvZiB0aGUgcmVuZGVyXG4gIC8vIHRhc2sgZnJvbSB0aGUgcHJpb3JpdHkgb2YgdGhlIGxhbmVzIGl0IGlzIGVudGFuZ2xlZCB3aXRoLiBGb3IgZXhhbXBsZSwgYVxuICAvLyB0cmFuc2l0aW9uIG1heSBub3QgYmUgYWxsb3dlZCB0byBmaW5pc2ggdW5sZXNzIGl0IGluY2x1ZGVzIHRoZSBTeW5jIGxhbmUsXG4gIC8vIHdoaWNoIGlzIGN1cnJlbnRseSBzdXNwZW5kZWQuIFdlIHNob3VsZCBiZSBhYmxlIHRvIHJlbmRlciB0aGUgVHJhbnNpdGlvblxuICAvLyBhbmQgU3luYyBsYW5lIGluIHRoZSBzYW1lIGJhdGNoLCBidXQgYXQgVHJhbnNpdGlvbiBwcmlvcml0eSwgYmVjYXVzZSB0aGVcbiAgLy8gU3luYyBsYW5lIGFscmVhZHkgc3VzcGVuZGVkLlxuXG4gIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gZ2V0RW50YW5nbGVkTGFuZXMocm9vdCwgbGFuZXMpO1xuICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7XG5cbiAge1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmRpc2NhcmRQZW5kaW5nV2FybmluZ3MoKTtcbiAgfVxuXG4gIHJldHVybiByb290V29ya0luUHJvZ3Jlc3M7XG59XG5cbmZ1bmN0aW9uIHJlc2V0U3VzcGVuZGVkV29ya0xvb3BPblVud2luZChmaWJlcikge1xuICAvLyBSZXNldCBtb2R1bGUtbGV2ZWwgc3RhdGUgdGhhdCB3YXMgc2V0IGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgcmVzZXRIb29rc09uVW53aW5kKGZpYmVyKTtcbiAgcmVzZXRDaGlsZFJlY29uY2lsZXJPblVud2luZCgpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSkge1xuICAvLyBBIGNvbXBvbmVudCB0aHJldyBhbiBleGNlcHRpb24uIFVzdWFsbHkgdGhpcyBpcyBiZWNhdXNlIGl0IHN1c3BlbmRlZCwgYnV0XG4gIC8vIGl0IGFsc28gaW5jbHVkZXMgcmVndWxhciBwcm9ncmFtIGVycm9ycy5cbiAgLy9cbiAgLy8gV2UncmUgZWl0aGVyIGdvaW5nIHRvIHVud2luZCB0aGUgc3RhY2sgdG8gc2hvdyBhIFN1c3BlbnNlIG9yIGVycm9yXG4gIC8vIGJvdW5kYXJ5LCBvciB3ZSdyZSBnb2luZyB0byByZXBsYXkgdGhlIGNvbXBvbmVudCBhZ2Fpbi4gTGlrZSBhZnRlciBhXG4gIC8vIHByb21pc2UgcmVzb2x2ZXMuXG4gIC8vXG4gIC8vIFVudGlsIHdlIGRlY2lkZSB3aGV0aGVyIHdlJ3JlIGdvaW5nIHRvIHVud2luZCBvciByZXBsYXksIHdlIHNob3VsZCBwcmVzZXJ2ZVxuICAvLyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgd29yayBsb29wIHdpdGhvdXQgcmVzZXR0aW5nIGFueXRoaW5nLlxuICAvL1xuICAvLyBJZiB3ZSBkbyBkZWNpZGUgdG8gdW53aW5kIHRoZSBzdGFjaywgbW9kdWxlLWxldmVsIHZhcmlhYmxlcyB3aWxsIGJlIHJlc2V0XG4gIC8vIGluIHJlc2V0U3VzcGVuZGVkV29ya0xvb3BPblVud2luZC5cbiAgLy8gVGhlc2Ugc2hvdWxkIGJlIHJlc2V0IGltbWVkaWF0ZWx5IGJlY2F1c2UgdGhleSdyZSBvbmx5IHN1cHBvc2VkIHRvIGJlIHNldFxuICAvLyB3aGVuIFJlYWN0IGlzIGV4ZWN1dGluZyB1c2VyIGNvZGUuXG4gIHJlc2V0SG9va3NBZnRlclRocm93KCk7XG5cbiAge1xuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIH1cblxuICBpZiAodGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uKSB7XG4gICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgdHlwZSBvZiBleGNlcHRpb24gdXNlZCBmb3IgU3VzcGVuc2UuIEZvciBoaXN0b3JpY2FsXG4gICAgLy8gcmVhc29ucywgdGhlIHJlc3Qgb2YgdGhlIFN1c3BlbnNlIGltcGxlbWVudGF0aW9uIGV4cGVjdHMgdGhlIHRocm93biB2YWx1ZVxuICAgIC8vIHRvIGJlIGEgdGhlbmFibGUsIGJlY2F1c2UgYmVmb3JlIGB1c2VgIGV4aXN0ZWQgdGhhdCB3YXMgdGhlICh1bnN0YWJsZSlcbiAgICAvLyBBUEkgZm9yIHN1c3BlbmRpbmcuIFRoaXMgaW1wbGVtZW50YXRpb24gZGV0YWlsIGNhbiBjaGFuZ2UgbGF0ZXIsIG9uY2Ugd2VcbiAgICAvLyBkZXByZWNhdGUgdGhlIG9sZCBBUEkgaW4gZmF2b3Igb2YgYHVzZWAuXG4gICAgdGhyb3duVmFsdWUgPSBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpO1xuICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gc2hvdWxkUmVtYWluT25QcmV2aW91c1NjcmVlbigpICYmIC8vIENoZWNrIGlmIHRoZXJlIGFyZSBvdGhlciBwZW5kaW5nIHVwZGF0ZXMgdGhhdCBtaWdodCBwb3NzaWJseSB1bmJsb2NrIHRoaXNcbiAgICAvLyBjb21wb25lbnQgZnJvbSBzdXNwZW5kaW5nLiBUaGlzIG1pcnJvcnMgdGhlIGNoZWNrIGluXG4gICAgLy8gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZS4gV2Ugc2hvdWxkIGF0dGVtcHQgdG8gdW5pZnkgdGhlbSBzb21laG93LlxuICAgIC8vIFRPRE86IENvbnNpZGVyIHVud2luZGluZyBpbW1lZGlhdGVseSwgdXNpbmcgdGhlXG4gICAgLy8gU3VzcGVuZGVkT25IeWRyYXRpb24gbWVjaGFuaXNtLlxuICAgICFpbmNsdWRlc05vbklkbGVXb3JrKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcykgJiYgIWluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMpID8gLy8gU3VzcGVuZCB3b3JrIGxvb3AgdW50aWwgZGF0YSByZXNvbHZlc1xuICAgIFN1c3BlbmRlZE9uRGF0YSA6IC8vIERvbid0IHN1c3BlbmQgd29yayBsb29wLCBleGNlcHQgdG8gY2hlY2sgaWYgdGhlIGRhdGEgaGFzXG4gICAgLy8gaW1tZWRpYXRlbHkgcmVzb2x2ZWQgKGkuZS4gaW4gYSBtaWNyb3Rhc2spLiBPdGhlcndpc2UsIHRyaWdnZXIgdGhlXG4gICAgLy8gbmVhcmVzdCBTdXNwZW5zZSBmYWxsYmFjay5cbiAgICBTdXNwZW5kZWRPbkltbWVkaWF0ZTtcbiAgfSBlbHNlIGlmICh0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uKSB7XG4gICAgdGhyb3duVmFsdWUgPSBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpO1xuICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkT25JbnN0YW5jZTtcbiAgfSBlbHNlIGlmICh0aHJvd25WYWx1ZSA9PT0gU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uKSB7XG4gICAgLy8gQW4gdXBkYXRlIGZsb3dlZCBpbnRvIGEgZGVoeWRyYXRlZCBib3VuZGFyeS4gQmVmb3JlIHdlIGNhbiBhcHBseSB0aGVcbiAgICAvLyB1cGRhdGUsIHdlIG5lZWQgdG8gZmluaXNoIGh5ZHJhdGluZy4gSW50ZXJydXB0IHRoZSB3b3JrLWluLXByb2dyZXNzXG4gICAgLy8gcmVuZGVyIHNvIHdlIGNhbiByZXN0YXJ0IGF0IHRoZSBoeWRyYXRpb24gbGFuZS5cbiAgICAvL1xuICAgIC8vIFRoZSBpZGVhbCBpbXBsZW1lbnRhdGlvbiB3b3VsZCBiZSBhYmxlIHRvIHN3aXRjaCBjb250ZXh0cyB3aXRob3V0XG4gICAgLy8gdW53aW5kaW5nIHRoZSBjdXJyZW50IHN0YWNrLlxuICAgIC8vXG4gICAgLy8gV2UgY291bGQgbmFtZSB0aGlzIHNvbWV0aGluZyBtb3JlIGdlbmVyYWwgYnV0IGFzIG9mIG5vdyBpdCdzIHRoZSBvbmx5XG4gICAgLy8gY2FzZSB3aGVyZSB3ZSB0aGluayB0aGlzIHNob3VsZCBoYXBwZW4uXG4gICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBTdXNwZW5kZWRPbkh5ZHJhdGlvbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVndWxhciBlcnJvci5cbiAgICB2YXIgaXNXYWtlYWJsZSA9IHRocm93blZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB0aHJvd25WYWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRocm93blZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG4gICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBpc1dha2VhYmxlID8gLy8gQSB3YWtlYWJsZSBvYmplY3Qgd2FzIHRocm93biBieSBhIGxlZ2FjeSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAvLyBUaGlzIGhhcyBzbGlnaHRseSBkaWZmZXJlbnQgYmVoYXZpb3IgdGhhbiBzdXNwZW5kaW5nIHdpdGggYHVzZWAuXG4gICAgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlIDogLy8gVGhpcyBpcyBhIHJlZ3VsYXIgZXJyb3IuIElmIHNvbWV0aGluZyBlYXJsaWVyIGluIHRoZSBjb21wb25lbnQgYWxyZWFkeVxuICAgIC8vIHN1c3BlbmRlZCwgd2UgbXVzdCBjbGVhciB0aGUgdGhlbmFibGUgc3RhdGUgdG8gdW5ibG9jayB0aGUgd29yayBsb29wLlxuICAgIFN1c3BlbmRlZE9uRXJyb3I7XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gdGhyb3duVmFsdWU7XG4gIHZhciBlcnJvcmVkV29yayA9IHdvcmtJblByb2dyZXNzO1xuXG4gIGlmIChlcnJvcmVkV29yayA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgYSBmYXRhbCBlcnJvclxuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RmF0YWxFcnJvcmVkO1xuICAgIGxvZ1VuY2F1Z2h0RXJyb3Iocm9vdCwgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodGhyb3duVmFsdWUsIHJvb3QuY3VycmVudCkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlcnJvcmVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAvLyBSZWNvcmQgdGhlIHRpbWUgc3BlbnQgcmVuZGVyaW5nIGJlZm9yZSBhbiBlcnJvciB3YXMgdGhyb3duLiBUaGlzXG4gICAgLy8gYXZvaWRzIGluYWNjdXJhdGUgUHJvZmlsZXIgZHVyYXRpb25zIGluIHRoZSBjYXNlIG9mIGFcbiAgICAvLyBzdXNwZW5kZWQgcmVuZGVyLlxuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZXJyb3JlZFdvcmssIHRydWUpO1xuICB9XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSB7XG4gICAgICBjYXNlIFN1c3BlbmRlZE9uRXJyb3I6XG4gICAgICAgIHtcbiAgICAgICAgICBtYXJrQ29tcG9uZW50RXJyb3JlZChlcnJvcmVkV29yaywgdGhyb3duVmFsdWUsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFN1c3BlbmRlZE9uRGF0YTpcbiAgICAgIGNhc2UgU3VzcGVuZGVkT25JbW1lZGlhdGU6XG4gICAgICBjYXNlIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZTpcbiAgICAgIGNhc2UgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHdha2VhYmxlID0gdGhyb3duVmFsdWU7XG4gICAgICAgICAgbWFya0NvbXBvbmVudFN1c3BlbmRlZChlcnJvcmVkV29yaywgd2FrZWFibGUsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuKCkge1xuICAvLyBUaGlzIGlzIGFza2luZyB3aGV0aGVyIGl0J3MgYmV0dGVyIHRvIHN1c3BlbmQgdGhlIHRyYW5zaXRpb24gYW5kIHJlbWFpblxuICAvLyBvbiB0aGUgcHJldmlvdXMgc2NyZWVuLCB2ZXJzdXMgc2hvd2luZyBhIGZhbGxiYWNrIGFzIHNvb24gYXMgcG9zc2libGUuIEl0XG4gIC8vIHRha2VzIGludG8gYWNjb3VudCBib3RoIHRoZSBwcmlvcml0eSBvZiByZW5kZXIgYW5kIGFsc28gd2hldGhlciBzaG93aW5nIGFcbiAgLy8gZmFsbGJhY2sgd291bGQgcHJvZHVjZSBhIGRlc2lyYWJsZSB1c2VyIGV4cGVyaWVuY2UuXG4gIHZhciBoYW5kbGVyID0gZ2V0U3VzcGVuc2VIYW5kbGVyKCk7XG5cbiAgaWYgKGhhbmRsZXIgPT09IG51bGwpIHtcbiAgICAvLyBUaGVyZSdzIG5vIFN1c3BlbnNlIGJvdW5kYXJ5IHRoYXQgY2FuIHByb3ZpZGUgYSBmYWxsYmFjay4gV2UgaGF2ZSBub1xuICAgIC8vIGNob2ljZSBidXQgdG8gcmVtYWluIG9uIHRoZSBwcmV2aW91cyBzY3JlZW4uXG4gICAgLy8gTk9URTogV2UgZG8gdGhpcyBldmVuIGZvciBzeW5jIHVwZGF0ZXMsIGZvciBsYWNrIG9mIGFueSBiZXR0ZXIgb3B0aW9uLiBJblxuICAgIC8vIHRoZSBmdXR1cmUsIHdlIG1heSBjaGFuZ2UgaG93IHdlIGhhbmRsZSB0aGlzLCBsaWtlIGJ5IHB1dHRpbmcgdGhlIHdob2xlXG4gICAgLy8gcm9vdCBpbnRvIGEgXCJkZXRhY2hlZFwiIG1vZGUuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVE9ETzogT25jZSBgdXNlYCBoYXMgZnVsbHkgcmVwbGFjZWQgdGhlIGB0aHJvdyBwcm9taXNlYCBwYXR0ZXJuLCB3ZSBzaG91bGRcbiAgLy8gYmUgYWJsZSB0byByZW1vdmUgdGhlIGVxdWl2YWxlbnQgY2hlY2sgaW4gZmluaXNoQ29uY3VycmVudFJlbmRlciwgYW5kIHJlbHlcbiAgLy8ganVzdCBvbiB0aGlzIG9uZS5cblxuXG4gIGlmIChpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcykpIHtcbiAgICBpZiAoZ2V0U2hlbGxCb3VuZGFyeSgpID09PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSByZW5kZXJpbmcgaW5zaWRlIHRoZSBcInNoZWxsXCIgb2YgdGhlIGFwcC4gQWN0aXZhdGluZyB0aGUgbmVhcmVzdFxuICAgICAgLy8gZmFsbGJhY2sgd291bGQgY2F1c2UgdmlzaWJsZSBjb250ZW50IHRvIGRpc2FwcGVhci4gSXQncyBiZXR0ZXIgdG9cbiAgICAgIC8vIHN1c3BlbmQgdGhlIHRyYW5zaXRpb24gYW5kIHJlbWFpbiBvbiB0aGUgcHJldmlvdXMgc2NyZWVuLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlJ3JlIHJlbmRlcmluZyBjb250ZW50IHRoYXQgd2Fzbid0IHBhcnQgb2YgdGhlIHByZXZpb3VzIHNjcmVlbi5cbiAgICAgIC8vIFJhdGhlciB0aGFuIGJsb2NrIHRoZSB0cmFuc2l0aW9uLCBpdCdzIGJldHRlciB0byBzaG93IGEgZmFsbGJhY2sgYXNcbiAgICAgIC8vIHNvb24gYXMgcG9zc2libGUuIFRoZSBhcHBlYXJhbmNlIG9mIGFueSBuZXN0ZWQgZmFsbGJhY2tzIHdpbGwgYmVcbiAgICAgIC8vIHRocm90dGxlZCB0byBhdm9pZCBqYW5rLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbmNsdWRlc09ubHlSZXRyaWVzKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSB8fCAvLyBJbiB0aGlzIGNvbnRleHQsIGFuIE9mZnNjcmVlbkxhbmUgY291bnRzIGFzIGEgUmV0cnlcbiAgLy8gVE9ETzogSXQncyBiZWNvbWUgaW5jcmVhc2luZ2x5IGNsZWFyIHRoYXQgUmV0cmllcyBhbmQgT2Zmc2NyZWVuIGFyZVxuICAvLyBkZWVwbHkgY29ubmVjdGVkLiBUaGV5IHByb2JhYmx5IGNhbiBiZSB1bmlmaWVkIGZ1cnRoZXIuXG4gIGluY2x1ZGVzU29tZUxhbmUod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpKSB7XG4gICAgLy8gRHVyaW5nIGEgcmV0cnksIHdlIGNhbiBzdXNwZW5kIHJlbmRlcmluZyBpZiB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeVxuICAgIC8vIGlzIHRoZSBib3VuZGFyeSBvZiB0aGUgXCJzaGVsbFwiLCBiZWNhdXNlIHdlJ3JlIGd1YXJhbnRlZWQgbm90IHRvIGJsb2NrXG4gICAgLy8gYW55IG5ldyBjb250ZW50IGZyb20gYXBwZWFyaW5nLlxuICAgIC8vXG4gICAgLy8gVGhlIHJlYXNvbiB3ZSBtdXN0IGNoZWNrIGlmIHRoaXMgaXMgYSByZXRyeSBpcyBiZWNhdXNlIGl0IGd1YXJhbnRlZXNcbiAgICAvLyB0aGF0IHN1c3BlbmRpbmcgdGhlIHdvcmsgbG9vcCB3b24ndCBibG9jayBhbiBhY3R1YWwgdXBkYXRlLCBiZWNhdXNlXG4gICAgLy8gcmV0cmllcyBkb24ndCBcInVwZGF0ZVwiIGFueXRoaW5nOyB0aGV5IGZpbGwgaW4gZmFsbGJhY2tzIHRoYXQgd2VyZSBsZWZ0XG4gICAgLy8gYmVoaW5kIGJ5IGEgcHJldmlvdXMgdHJhbnNpdGlvbi5cbiAgICByZXR1cm4gaGFuZGxlciA9PT0gZ2V0U2hlbGxCb3VuZGFyeSgpO1xuICB9IC8vIEZvciBhbGwgb3RoZXIgTGFuZXMgYmVzaWRlcyBUcmFuc2l0aW9ucyBhbmQgUmV0cmllcywgd2Ugc2hvdWxkIG5vdCB3YWl0XG4gIC8vIGZvciB0aGUgZGF0YSB0byBsb2FkLlxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwdXNoRGlzcGF0Y2hlcihjb250YWluZXIpIHtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICBpZiAocHJldkRpc3BhdGNoZXIgPT09IG51bGwpIHtcbiAgICAvLyBUaGUgUmVhY3QgaXNvbW9ycGhpYyBwYWNrYWdlIGRvZXMgbm90IGluY2x1ZGUgYSBkZWZhdWx0IGRpc3BhdGNoZXIuXG4gICAgLy8gSW5zdGVhZCB0aGUgZmlyc3QgcmVuZGVyZXIgd2lsbCBsYXppbHkgYXR0YWNoIG9uZSwgaW4gb3JkZXIgdG8gZ2l2ZVxuICAgIC8vIG5pY2VyIGVycm9yIG1lc3NhZ2VzLlxuICAgIHJldHVybiBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZXZEaXNwYXRjaGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpIHtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xufVxuXG5mdW5jdGlvbiBwdXNoQXN5bmNEaXNwYXRjaGVyKCkge1xuICB7XG4gICAgdmFyIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyO1xuICAgIHJldHVybiBwcmV2QXN5bmNEaXNwYXRjaGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcEFzeW5jRGlzcGF0Y2hlcihwcmV2QXN5bmNEaXNwYXRjaGVyKSB7XG4gIHtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gcHJldkFzeW5jRGlzcGF0Y2hlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQ29tbWl0VGltZU9mRmFsbGJhY2soKSB7XG4gIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSBub3ckMSgpO1xufVxuZnVuY3Rpb24gbWFya1NraXBwZWRVcGRhdGVMYW5lcyhsYW5lKSB7XG4gIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IG1lcmdlTGFuZXMobGFuZSwgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmQoKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcykge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCkge1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTsgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIHVwZGF0ZXMgdGhhdCB3ZSBza2lwcGVkIHRyZWUgdGhhdCBtaWdodCBoYXZlIHVuYmxvY2tlZFxuICAvLyB0aGlzIHJlbmRlci5cblxuICBpZiAoKGluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzKSB8fCBpbmNsdWRlc05vbklkbGVXb3JrKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzKSkgJiYgd29ya0luUHJvZ3Jlc3NSb290ICE9PSBudWxsKSB7XG4gICAgLy8gTWFyayB0aGUgY3VycmVudCByZW5kZXIgYXMgc3VzcGVuZGVkIHNvIHRoYXQgd2Ugc3dpdGNoIHRvIHdvcmtpbmcgb25cbiAgICAvLyB0aGUgdXBkYXRlcyB0aGF0IHdlcmUgc2tpcHBlZC4gVXN1YWxseSB3ZSBvbmx5IHN1c3BlbmQgYXQgdGhlIGVuZCBvZlxuICAgIC8vIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IGFsd2F5cyBtYXJrIHRoZSByb290IGFzIHN1c3BlbmRlZCBpbW1lZGlhdGVseVxuICAgIC8vIChpbnNpZGUgdGhpcyBmdW5jdGlvbiksIHNpbmNlIGJ5IHN1c3BlbmRpbmcgYXQgdGhlIGVuZCBvZiB0aGUgcmVuZGVyXG4gICAgLy8gcGhhc2UgaW50cm9kdWNlcyBhIHBvdGVudGlhbCBtaXN0YWtlIHdoZXJlIHdlIHN1c3BlbmQgbGFuZXMgdGhhdCB3ZXJlXG4gICAgLy8gcGluZ2VkIG9yIHVwZGF0ZWQgd2hpbGUgd2Ugd2VyZSByZW5kZXJpbmcuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgdW53aW5kaW5nIGltbWVkaWF0ZWx5LCB1c2luZyB0aGVcbiAgICAvLyBTdXNwZW5kZWRPbkh5ZHJhdGlvbiBtZWNoYW5pc20uXG4gICAgbWFya1Jvb3RTdXNwZW5kZWQod29ya0luUHJvZ3Jlc3NSb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXJEaWRFcnJvcigpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgIT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEVycm9yZWQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlQ29uY3VycmVudEVycm9yKGVycm9yKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IFtlcnJvcl07XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycy5wdXNoKGVycm9yKTtcbiAgfVxufSAvLyBDYWxsZWQgZHVyaW5nIHJlbmRlciB0byBkZXRlcm1pbmUgaWYgYW55dGhpbmcgaGFzIHN1c3BlbmRlZC5cbi8vIFJldHVybnMgZmFsc2UgaWYgd2UncmUgbm90IHN1cmUuXG5cbmZ1bmN0aW9uIHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGVycm9yZWQgb3IgY29tcGxldGVkLCB3ZSBjYW4ndCByZWFsbHkgYmUgc3VyZSxcbiAgLy8gc28gdGhvc2UgYXJlIGZhbHNlLlxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3M7XG59IC8vIFRPRE86IE92ZXIgdGltZSwgdGhpcyBmdW5jdGlvbiBhbmQgcmVuZGVyUm9vdENvbmN1cnJlbnQgaGF2ZSBiZWNvbWUgbW9yZVxuLy8gYW5kIG1vcmUgc2ltaWxhci4gTm90IHN1cmUgaXQgbWFrZXMgc2Vuc2UgdG8gbWFpbnRhaW4gZm9ya2VkIHBhdGhzLiBDb25zaWRlclxuLy8gdW5pZnlpbmcgdGhlbSBhZ2Fpbi5cblxuZnVuY3Rpb24gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZW5kZXJDb250ZXh0O1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpO1xuICB2YXIgcHJldkFzeW5jRGlzcGF0Y2hlciA9IHB1c2hBc3luY0Rpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4gIC8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgICAgICAgaWYgKG1lbW9pemVkVXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgbW92ZSBGaWJlcnMgdGhhdCBzY2hlZHVsZWQgdGhlIHVwY29taW5nIHdvcmsgZnJvbSB0aGUgTWFwIHRvIHRoZSBTZXQuXG4gICAgICAgIC8vIElmIHdlIGJhaWxvdXQgb24gdGhpcyB3b3JrLCB3ZSdsbCBtb3ZlIHRoZW0gYmFjayAobGlrZSBhYm92ZSkuXG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIG1vdmUgdGhlbSBub3cgaW4gY2FzZSB0aGUgd29yayBzcGF3bnMgbW9yZSB3b3JrIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGggZGlmZmVyZW50IHVwZGF0ZXJzLlxuICAgICAgICAvLyBUaGF0IHdheSB3ZSBjYW4ga2VlcCB0aGUgY3VycmVudCB1cGRhdGUgYW5kIGZ1dHVyZSB1cGRhdGVzIHNlcGFyYXRlLlxuXG5cbiAgICAgICAgbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gZ2V0VHJhbnNpdGlvbnNGb3JMYW5lcygpO1xuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gIH1cblxuICB2YXIgZGlkU3VzcGVuZEluU2hlbGwgPSBmYWxzZTtcblxuICBvdXRlcjogZG8ge1xuICAgIHRyeSB7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gIT09IE5vdFN1c3BlbmRlZCAmJiB3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgd29yayBsb29wIGlzIHN1c3BlbmRlZC4gRHVyaW5nIGEgc3luY2hyb25vdXMgcmVuZGVyLCB3ZSBkb24ndFxuICAgICAgICAvLyB5aWVsZCB0byB0aGUgbWFpbiB0aHJlYWQuIEltbWVkaWF0ZWx5IHVud2luZCB0aGUgc3RhY2suIFRoaXMgd2lsbFxuICAgICAgICAvLyB0cmlnZ2VyIGVpdGhlciBhIGZhbGxiYWNrIG9yIGFuIGVycm9yIGJvdW5kYXJ5LlxuICAgICAgICAvLyBUT0RPOiBGb3IgZGlzY3JldGUgYW5kIFwiZGVmYXVsdFwiIHVwZGF0ZXMgKGFueXRoaW5nIHRoYXQncyBub3RcbiAgICAgICAgLy8gZmx1c2hTeW5jKSwgd2Ugd2FudCB0byB3YWl0IGZvciB0aGUgbWljcm90YXNrcyB0aGUgZmx1c2ggYmVmb3JlXG4gICAgICAgIC8vIHVud2luZGluZy4gV2lsbCBwcm9iYWJseSBpbXBsZW1lbnQgdGhpcyB1c2luZyByZW5kZXJSb290Q29uY3VycmVudCxcbiAgICAgICAgLy8gb3IgbWVyZ2UgcmVuZGVyUm9vdFN5bmMgYW5kIHJlbmRlclJvb3RDb25jdXJyZW50IGludG8gdGhlIHNhbWVcbiAgICAgICAgLy8gZnVuY3Rpb24gYW5kIGZvcmsgdGhlIGJlaGF2aW9yIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICB2YXIgdW5pdE9mV29yayA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICB2YXIgdGhyb3duVmFsdWUgPSB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlO1xuXG4gICAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pIHtcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSHlkcmF0aW9uOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBTZWxlY3RpdmUgaHlkcmF0aW9uLiBBbiB1cGRhdGUgZmxvd2VkIGludG8gYSBkZWh5ZHJhdGVkIHRyZWUuXG4gICAgICAgICAgICAgIC8vIEludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIgc28gdGhlIHdvcmsgbG9vcCBjYW4gc3dpdGNoIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBoeWRyYXRpb24gbGFuZS5cbiAgICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RGlkTm90Q29tcGxldGU7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkltbWVkaWF0ZTpcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGF0YTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKCFkaWRTdXNwZW5kSW5TaGVsbCAmJiBnZXRTdXNwZW5zZUhhbmRsZXIoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpZFN1c3BlbmRJblNoZWxsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSAvLyBJbnRlbnRpb25hbCBmYWxsdGhyb3VnaFxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBVbndpbmQgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBub3JtYWwgd29yayBsb29wLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3b3JrTG9vcFN5bmMoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSk7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTsgLy8gQ2hlY2sgaWYgc29tZXRoaW5nIHN1c3BlbmRlZCBpbiB0aGUgc2hlbGwuIFdlIHVzZSB0aGlzIHRvIGRldGVjdCBhblxuICAvLyBpbmZpbml0ZSBwaW5nIGxvb3AgY2F1c2VkIGJ5IGFuIHVuY2FjaGVkIHByb21pc2UuXG4gIC8vXG4gIC8vIE9ubHkgaW5jcmVtZW50IHRoaXMgY291bnRlciBvbmNlIHBlciBzeW5jaHJvbm91cyByZW5kZXIgYXR0ZW1wdCBhY3Jvc3MgdGhlXG4gIC8vIHdob2xlIHRyZWUuIEV2ZW4gaWYgdGhlcmUgYXJlIG1hbnkgc2libGluZyBjb21wb25lbnRzIHRoYXQgc3VzcGVuZCwgdGhpc1xuICAvLyBjb3VudGVyIG9ubHkgZ2V0cyBpbmNyZW1lbnRlZCBvbmNlLlxuXG5cbiAgaWYgKGRpZFN1c3BlbmRJblNoZWxsKSB7XG4gICAgcm9vdC5zaGVsbFN1c3BlbmRDb3VudGVyKys7XG4gIH1cblxuICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtcbiAgcG9wQXN5bmNEaXNwYXRjaGVyKHByZXZBc3luY0Rpc3BhdGNoZXIpO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgYSBzeW5jIHJlbmRlciwgc28gd2Ugc2hvdWxkIGhhdmUgZmluaXNoZWQgdGhlIHdob2xlIHRyZWUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tbWl0IGFuIGluY29tcGxldGUgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgJyArICdidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAge1xuICAgIG1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gIH0gLy8gU2V0IHRoaXMgdG8gbnVsbCB0byBpbmRpY2F0ZSB0aGVyZSdzIG5vIGluLXByb2dyZXNzIHJlbmRlci5cblxuXG4gIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gSXQncyBzYWZlIHRvIHByb2Nlc3MgdGhlIHF1ZXVlIG5vdyB0aGF0IHRoZSByZW5kZXIgcGhhc2UgaXMgY29tcGxldGUuXG5cbiAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbn0gLy8gVGhlIHdvcmsgbG9vcCBpcyBhbiBleHRyZW1lbHkgaG90IHBhdGguIFRlbGwgQ2xvc3VyZSBub3QgdG8gaW5saW5lIGl0LlxuXG4vKiogQG5vaW5saW5lICovXG5cblxuZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICAvLyBQZXJmb3JtIHdvcmsgd2l0aG91dCBjaGVja2luZyBpZiB3ZSBuZWVkIHRvIHlpZWxkIGJldHdlZW4gZmliZXIuXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcykge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCk7XG4gIHZhciBwcmV2QXN5bmNEaXNwYXRjaGVyID0gcHVzaEFzeW5jRGlzcGF0Y2hlcigpOyAvLyBJZiB0aGUgcm9vdCBvciBsYW5lcyBoYXZlIGNoYW5nZWQsIHRocm93IG91dCB0aGUgZXhpc3Rpbmcgc3RhY2tcbiAgLy8gYW5kIHByZXBhcmUgYSBmcmVzaCBvbmUuIE90aGVyd2lzZSB3ZSdsbCBjb250aW51ZSB3aGVyZSB3ZSBsZWZ0IG9mZi5cblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ICE9PSByb290IHx8IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICE9PSBsYW5lcykge1xuICAgIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcblxuICAgICAgICBpZiAobWVtb2l6ZWRVcGRhdGVycy5zaXplID4gMCkge1xuICAgICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuY2xlYXIoKTtcbiAgICAgICAgfSAvLyBBdCB0aGlzIHBvaW50LCBtb3ZlIEZpYmVycyB0aGF0IHNjaGVkdWxlZCB0aGUgdXBjb21pbmcgd29yayBmcm9tIHRoZSBNYXAgdG8gdGhlIFNldC5cbiAgICAgICAgLy8gSWYgd2UgYmFpbG91dCBvbiB0aGlzIHdvcmssIHdlJ2xsIG1vdmUgdGhlbSBiYWNrIChsaWtlIGFib3ZlKS5cbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gbW92ZSB0aGVtIG5vdyBpbiBjYXNlIHRoZSB3b3JrIHNwYXducyBtb3JlIHdvcmsgYXQgdGhlIHNhbWUgcHJpb3JpdHkgd2l0aCBkaWZmZXJlbnQgdXBkYXRlcnMuXG4gICAgICAgIC8vIFRoYXQgd2F5IHdlIGNhbiBrZWVwIHRoZSBjdXJyZW50IHVwZGF0ZSBhbmQgZnV0dXJlIHVwZGF0ZXMgc2VwYXJhdGUuXG5cblxuICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBnZXRUcmFuc2l0aW9uc0ZvckxhbmVzKCk7XG4gICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gIH1cblxuICBvdXRlcjogZG8ge1xuICAgIHRyeSB7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gIT09IE5vdFN1c3BlbmRlZCAmJiB3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgd29yayBsb29wIGlzIHN1c3BlbmRlZC4gV2UgbmVlZCB0byBlaXRoZXIgdW53aW5kIHRoZSBzdGFjayBvclxuICAgICAgICAvLyByZXBsYXkgdGhlIHN1c3BlbmRlZCBjb21wb25lbnQuXG4gICAgICAgIHZhciB1bml0T2ZXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIHZhciB0aHJvd25WYWx1ZSA9IHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWU7XG5cbiAgICAgICAgcmVzdW1lT3JVbndpbmQ6IHN3aXRjaCAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pIHtcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRXJyb3I6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIFVud2luZCB0aGVuIGNvbnRpbnVlIHdpdGggdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChyb290LCB1bml0T2ZXb3JrLCB0aHJvd25WYWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRhdGE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciB0aGVuYWJsZSA9IHRocm93blZhbHVlO1xuXG4gICAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlUmVzb2x2ZWQodGhlbmFibGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRhdGEgcmVzb2x2ZWQuIFRyeSByZW5kZXJpbmcgdGhlIGNvbXBvbmVudCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrKHVuaXRPZldvcmspO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IC8vIFRoZSB3b3JrIGxvb3AgaXMgc3VzcGVuZGVkIG9uIGRhdGEuIFdlIHNob3VsZCB3YWl0IGZvciBpdCB0b1xuICAgICAgICAgICAgICAvLyByZXNvbHZlIGJlZm9yZSBjb250aW51aW5nIHRvIHJlbmRlci5cbiAgICAgICAgICAgICAgLy8gVE9ETzogSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBwcm9taXNlIHJlc29sdmVzIHN5bmNocm9ub3VzbHkuXG4gICAgICAgICAgICAgIC8vIFVzdWFsbHkgdGhpcyBpcyBoYW5kbGVkIHdoZW4gd2UgaW5zdHJ1bWVudCB0aGUgcHJvbWlzZSB0byBhZGQgYVxuICAgICAgICAgICAgICAvLyBgc3RhdHVzYCBmaWVsZCwgYnV0IGlmIHRoZSBwcm9taXNlIGFscmVhZHkgaGFzIGEgc3RhdHVzLCB3ZSB3b24ndFxuICAgICAgICAgICAgICAvLyBoYXZlIGFkZGVkIGEgbGlzdGVuZXIgdW50aWwgcmlnaHQgaGVyZS5cblxuXG4gICAgICAgICAgICAgIHZhciBvblJlc29sdXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJvb3QgaXMgc3RpbGwgc3VzcGVuZGVkIG9uIHRoaXMgcHJvbWlzZS5cbiAgICAgICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGF0YSAmJiB3b3JrSW5Qcm9ncmVzc1Jvb3QgPT09IHJvb3QpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hcmsgdGhlIHJvb3QgYXMgcmVhZHkgdG8gY29udGludWUgcmVuZGVyaW5nLlxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWU7XG4gICAgICAgICAgICAgICAgfSAvLyBFbnN1cmUgdGhlIHJvb3QgaXMgc2NoZWR1bGVkLiBXZSBzaG91bGQgZG8gdGhpcyBldmVuIGlmIHdlJ3JlXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudGx5IHdvcmtpbmcgb24gYSBkaWZmZXJlbnQgcm9vdCwgc28gdGhhdCB3ZSByZXN1bWVcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJpbmcgbGF0ZXIuXG5cblxuICAgICAgICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB0aGVuYWJsZS50aGVuKG9uUmVzb2x1dGlvbiwgb25SZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBJZiB0aGlzIGZpYmVyIGp1c3Qgc3VzcGVuZGVkLCBpdCdzIHBvc3NpYmxlIHRoZSBkYXRhIGlzIGFscmVhZHlcbiAgICAgICAgICAgICAgLy8gY2FjaGVkLiBZaWVsZCB0byB0aGUgbWFpbiB0aHJlYWQgdG8gZ2l2ZSBpdCBhIGNoYW5jZSB0byBwaW5nLiBJZlxuICAgICAgICAgICAgICAvLyBpdCBkb2VzLCB3ZSBjYW4gcmV0cnkgaW1tZWRpYXRlbHkgd2l0aG91dCB1bndpbmRpbmcgdGhlIHN0YWNrLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2U6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIF90aGVuYWJsZSA9IHRocm93blZhbHVlO1xuXG4gICAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlUmVzb2x2ZWQoX3RoZW5hYmxlKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkYXRhIHJlc29sdmVkLiBUcnkgcmVuZGVyaW5nIHRoZSBjb21wb25lbnQgYWdhaW4uXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHVud2luZCB0aGVuIGNvbnRpbnVlIHdpdGggdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChyb290LCB1bml0T2ZXb3JrLCB0aHJvd25WYWx1ZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHJlc291cmNlID0gbnVsbDtcblxuICAgICAgICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5cbiAgICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBCZWZvcmUgdW53aW5kaW5nIHRoZSBzdGFjaywgY2hlY2sgb25lIG1vcmUgdGltZSBpZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UgaXMgcmVhZHkuIEl0IG1heSBoYXZlIGxvYWRlZCB3aGVuIFJlYWN0IHlpZWxkZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1haW4gdGhyZWFkLlxuICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ25pbmcgdGhpcyB0byBhIGNvbnN0YW50IHNvIEZsb3cga25vd3MgdGhlIGJpbmRpbmcgd29uJ3RcbiAgICAgICAgICAgICAgICAgICAgLy8gYmUgbXV0YXRlZCBieSBgcHJlbG9hZEluc3RhbmNlYC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGhvc3RGaWJlci50eXBlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBob3N0RmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSZWFkeSA9IHJlc291cmNlID8gcHJlbG9hZFJlc291cmNlKHJlc291cmNlKSA6IHByZWxvYWRJbnN0YW5jZSh0eXBlLCBwcm9wcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGF0YSByZXNvbHZlZC4gUmVzdW1lIHRoZSB3b3JrIGxvb3AgYXMgaWYgbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIHN1c3BlbmRlZC4gVW5saWtlIHdoZW4gYSB1c2VyIGNvbXBvbmVudCBzdXNwZW5kcywgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIHRvIHJlcGxheSBhbnl0aGluZyBiZWNhdXNlIHRoZSBob3N0IGZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBjb21wbGV0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBob3N0RmliZXIuc2libGluZztcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5GaWJlciA9IGhvc3RGaWJlci5yZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVVuaXRPZldvcmsocmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJlc3VtZU9yVW53aW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgZmFpbCBncmFjZWZ1bGx5IGJ1dCBpdCdzIG5vdCBjb3JyZWN0LCBzbyBsb2cgYVxuICAgICAgICAgICAgICAgICAgICAvLyB3YXJuaW5nIGluIGRldi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCB0eXBlIG9mIGZpYmVyIHRyaWdnZXJlZCBhIHN1c3BlbnNleSBjb21taXQuICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IC8vIE90aGVyd2lzZSwgdW53aW5kIHRoZW4gY29udGludWUgd2l0aCB0aGUgbm9ybWFsIHdvcmsgbG9vcC5cblxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChyb290LCB1bml0T2ZXb3JrLCB0aHJvd25WYWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2U6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIFN1c3BlbmRlZCBieSBhbiBvbGQgaW1wbGVtZW50YXRpb24gdGhhdCB1c2VzIHRoZSBgdGhyb3cgcHJvbWlzZWBcbiAgICAgICAgICAgICAgLy8gcGF0dGVybi4gVGhlIG5ld2VyIHJlcGxheWluZyBiZWhhdmlvciBjYW4gY2F1c2Ugc3VidGxlIGlzc3Vlc1xuICAgICAgICAgICAgICAvLyBsaWtlIGluZmluaXRlIHBpbmcgbG9vcHMuIFNvIHdlIG1haW50YWluIHRoZSBvbGQgYmVoYXZpb3IgYW5kXG4gICAgICAgICAgICAgIC8vIGFsd2F5cyB1bndpbmQuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChyb290LCB1bml0T2ZXb3JrLCB0aHJvd25WYWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkh5ZHJhdGlvbjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gU2VsZWN0aXZlIGh5ZHJhdGlvbi4gQW4gdXBkYXRlIGZsb3dlZCBpbnRvIGEgZGVoeWRyYXRlZCB0cmVlLlxuICAgICAgICAgICAgICAvLyBJbnRlcnJ1cHQgdGhlIGN1cnJlbnQgcmVuZGVyIHNvIHRoZSB3b3JrIGxvb3AgY2FuIHN3aXRjaCB0byB0aGVcbiAgICAgICAgICAgICAgLy8gaHlkcmF0aW9uIGxhbmUuXG4gICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdERpZE5vdENvbXBsZXRlO1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBTdXNwZW5kZWRSZWFzb24uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRydWUgJiYgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gYGFjdGAgc3BlY2lhbCBjYXNlOiBJZiB3ZSdyZSBpbnNpZGUgYW4gYGFjdGAgc2NvcGUsIGRvbid0IGNvbnN1bHRcbiAgICAgICAgLy8gYHNob3VsZFlpZWxkYC4gQWx3YXlzIGtlZXAgd29ya2luZyB1bnRpbCB0aGUgcmVuZGVyIGlzIGNvbXBsZXRlLlxuICAgICAgICAvLyBUaGlzIGlzIG5vdCBqdXN0IGFuIG9wdGltaXphdGlvbjogaW4gYSB1bml0IHRlc3QgZW52aXJvbm1lbnQsIHdlXG4gICAgICAgIC8vIGNhbid0IHRydXN0IHRoZSByZXN1bHQgb2YgYHNob3VsZFlpZWxkYCwgYmVjYXVzZSB0aGUgaG9zdCBJL08gaXNcbiAgICAgICAgLy8gbGlrZWx5IG1vY2tlZC5cbiAgICAgICAgd29ya0xvb3BTeW5jKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3b3JrTG9vcENvbmN1cnJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlKTtcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtcbiAgcG9wQXN5bmNEaXNwYXRjaGVyKHByZXZBc3luY0Rpc3BhdGNoZXIpO1xuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cblxuICBpZiAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICAvLyBTdGlsbCB3b3JrIHJlbWFpbmluZy5cbiAgICB7XG4gICAgICBtYXJrUmVuZGVyWWllbGRlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBSb290SW5Qcm9ncmVzcztcbiAgfSBlbHNlIHtcbiAgICAvLyBDb21wbGV0ZWQgdGhlIHRyZWUuXG4gICAge1xuICAgICAgbWFya1JlbmRlclN0b3BwZWQoKTtcbiAgICB9IC8vIFNldCB0aGlzIHRvIG51bGwgdG8gaW5kaWNhdGUgdGhlcmUncyBubyBpbi1wcm9ncmVzcyByZW5kZXIuXG5cblxuICAgIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBOb0xhbmVzOyAvLyBJdCdzIHNhZmUgdG8gcHJvY2VzcyB0aGUgcXVldWUgbm93IHRoYXQgdGhlIHJlbmRlciBwaGFzZSBpcyBjb21wbGV0ZS5cblxuICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTsgLy8gUmV0dXJuIHRoZSBmaW5hbCBleGl0IHN0YXR1cy5cblxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICB9XG59XG4vKiogQG5vaW5saW5lICovXG5cblxuZnVuY3Rpb24gd29ya0xvb3BDb25jdXJyZW50KCkge1xuICAvLyBQZXJmb3JtIHdvcmsgdW50aWwgU2NoZWR1bGVyIGFza3MgdXMgdG8geWllbGRcbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuIElkZWFsbHlcbiAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuICB2YXIgY3VycmVudCA9IHVuaXRPZldvcmsuYWx0ZXJuYXRlO1xuICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHVuaXRPZldvcmspO1xuICB2YXIgbmV4dDtcblxuICBpZiAoKHVuaXRPZldvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspO1xuICAgIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCwgdW5pdE9mV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpO1xuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEodW5pdE9mV29yaywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50LCB1bml0T2ZXb3JrLCBlbnRhbmdsZWRSZW5kZXJMYW5lcyk7XG4gIH1cblxuICB7XG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgfVxuXG4gIHVuaXRPZldvcmsubWVtb2l6ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gIC8vIFRoaXMgaXMgYSBmb3JrIG9mIHBlcmZvcm1Vbml0T2ZXb3JrIHNwZWNpZmNhbGx5IGZvciByZXBsYXlpbmcgYSBmaWJlciB0aGF0XG4gIC8vIGp1c3Qgc3VzcGVuZGVkLlxuICAvL1xuICB2YXIgY3VycmVudCA9IHVuaXRPZldvcmsuYWx0ZXJuYXRlO1xuICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHVuaXRPZldvcmspO1xuICB2YXIgbmV4dDtcbiAgdmFyIGlzUHJvZmlsaW5nTW9kZSA9ICh1bml0T2ZXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZTtcblxuICBpZiAoaXNQcm9maWxpbmdNb2RlKSB7XG4gICAgc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspO1xuICB9XG5cbiAgc3dpdGNoICh1bml0T2ZXb3JrLnRhZykge1xuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBSZXNvbHZlIGBkZWZhdWx0UHJvcHNgLiBUaGlzIGxvZ2ljIGlzIGNvcGllZCBmcm9tIGBiZWdpbldvcmtgLlxuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBtb3ZpbmcgdGhpcyBzd2l0Y2ggc3RhdGVtZW50IGludG8gdGhhdCBtb2R1bGUuIEFsc28sXG4gICAgICAgIC8vIGNvdWxkIG1heWJlIHVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHNheSBgdXNlYCBkb2Vzbid0IHdvcmsgd2l0aFxuICAgICAgICAvLyBgZGVmYXVsdFByb3BzYCA6KVxuICAgICAgICB2YXIgQ29tcG9uZW50ID0gdW5pdE9mV29yay50eXBlO1xuICAgICAgICB2YXIgdW5yZXNvbHZlZFByb3BzID0gdW5pdE9mV29yay5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciByZXNvbHZlZFByb3BzID0gdW5yZXNvbHZlZFByb3BzIDtcbiAgICAgICAgdmFyIGNvbnRleHQ7XG5cbiAgICAgICAgbmV4dCA9IHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHVuaXRPZldvcmssIHJlc29sdmVkUHJvcHMsIENvbXBvbmVudCwgY29udGV4dCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHtcbiAgICAgICAgLy8gUmVzb2x2ZSBgZGVmYXVsdFByb3BzYC4gVGhpcyBsb2dpYyBpcyBjb3BpZWQgZnJvbSBgYmVnaW5Xb3JrYC5cbiAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgbW92aW5nIHRoaXMgc3dpdGNoIHN0YXRlbWVudCBpbnRvIHRoYXQgbW9kdWxlLiBBbHNvLFxuICAgICAgICAvLyBjb3VsZCBtYXliZSB1c2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBzYXkgYHVzZWAgZG9lc24ndCB3b3JrIHdpdGhcbiAgICAgICAgLy8gYGRlZmF1bHRQcm9wc2AgOilcbiAgICAgICAgdmFyIF9Db21wb25lbnQgPSB1bml0T2ZXb3JrLnR5cGUucmVuZGVyO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wcyA9IF91bnJlc29sdmVkUHJvcHMgO1xuXG4gICAgICAgIG5leHQgPSByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB1bml0T2ZXb3JrLCBfcmVzb2x2ZWRQcm9wcywgX0NvbXBvbmVudCwgdW5pdE9mV29yay5yZWYsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFNvbWUgaG9zdCBjb21wb25lbnRzIGFyZSBzdGF0ZWZ1bCAodGhhdCdzIGhvdyB3ZSBpbXBsZW1lbnQgZm9ybVxuICAgICAgICAvLyBhY3Rpb25zKSBidXQgd2UgZG9uJ3QgYm90aGVyIHRvIHJldXNlIHRoZSBtZW1vaXplZCBzdGF0ZSBiZWNhdXNlIGl0J3NcbiAgICAgICAgLy8gbm90IHdvcnRoIHRoZSBleHRyYSBjb2RlLiBUaGUgbWFpbiByZWFzb24gdG8gcmV1c2UgdGhlIHByZXZpb3VzIGhvb2tzXG4gICAgICAgIC8vIGlzIHRvIHJldXNlIHVuY2FjaGVkIHByb21pc2VzLCBidXQgd2UgaGFwcGVuIHRvIGtub3cgdGhhdCB0aGUgb25seVxuICAgICAgICAvLyBwcm9taXNlcyB0aGF0IGEgaG9zdCBjb21wb25lbnQgbWlnaHQgc3VzcGVuZCBvbiBhcmUgZGVmaW5pdGVseSBjYWNoZWRcbiAgICAgICAgLy8gYmVjYXVzZSB0aGV5IGFyZSBjb250cm9sbGVkIGJ5IHVzLiBTbyBkb24ndCBib3RoZXIuXG4gICAgICAgIHJlc2V0SG9va3NPblVud2luZCh1bml0T2ZXb3JrKTsgLy8gRmFsbHRocm91Z2ggdG8gdGhlIG5leHQgYnJhbmNoLlxuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgLy8gT3RoZXIgdHlwZXMgYmVzaWRlcyBmdW5jdGlvbiBjb21wb25lbnRzIGFyZSByZXNldCBjb21wbGV0ZWx5IGJlZm9yZVxuICAgICAgICAvLyBiZWluZyByZXBsYXllZC4gQ3VycmVudGx5IHRoaXMgb25seSBoYXBwZW5zIHdoZW4gYSBVc2FibGUgdHlwZSBpc1xuICAgICAgICAvLyByZWNvbmNpbGVkIOKAlCB0aGUgcmVjb25jaWxlciB3aWxsIHN1c3BlbmQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIHJlc2V0IHRoZSBmaWJlciBiYWNrIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZTsgaG93ZXZlciwgdGhpcyBpc24ndFxuICAgICAgICAvLyBhIGZ1bGwgXCJ1bndpbmRcIiBiZWNhdXNlIHdlJ3JlIGdvaW5nIHRvIHJldXNlIHRoZSBwcm9taXNlcyB0aGF0IHdlcmVcbiAgICAgICAgLy8gcmVjb25jaWxlZCBwcmV2aW91c2x5LiBTbyBpdCdzIGludGVudGlvbmFsIHRoYXQgd2UgZG9uJ3QgY2FsbFxuICAgICAgICAvLyByZXNldFN1c3BlbmRlZFdvcmtMb29wT25VbndpbmQgaGVyZS5cbiAgICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIHVuaXRPZldvcmspO1xuICAgICAgICB1bml0T2ZXb3JrID0gd29ya0luUHJvZ3Jlc3MgPSByZXNldFdvcmtJblByb2dyZXNzKHVuaXRPZldvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKTtcbiAgICAgICAgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50LCB1bml0T2ZXb3JrLCBlbnRhbmdsZWRSZW5kZXJMYW5lcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKGlzUHJvZmlsaW5nTW9kZSkge1xuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEodW5pdE9mV29yaywgdHJ1ZSk7XG4gIH0gLy8gVGhlIGJlZ2luIHBoYXNlIGZpbmlzaGVkIHN1Y2Nlc3NmdWxseSB3aXRob3V0IHN1c3BlbmRpbmcuIFJldHVybiB0byB0aGVcbiAgLy8gbm9ybWFsIHdvcmsgbG9vcC5cblxuXG4gIHtcbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG5cbiAgdW5pdE9mV29yay5tZW1vaXplZFByb3BzID0gdW5pdE9mV29yay5wZW5kaW5nUHJvcHM7XG5cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlKSB7XG4gIC8vIFRoaXMgaXMgYSBmb3JrIG9mIHBlcmZvcm1Vbml0T2ZXb3JrIHNwZWNpZmNhbGx5IGZvciB1bndpbmRpbmcgYSBmaWJlclxuICAvLyB0aGF0IHRocmV3IGFuIGV4Y2VwdGlvbi5cbiAgLy9cbiAgLy8gUmV0dXJuIHRvIHRoZSBub3JtYWwgd29yayBsb29wLiBUaGlzIHdpbGwgdW53aW5kIHRoZSBzdGFjaywgYW5kIHBvdGVudGlhbGx5XG4gIC8vIHJlc3VsdCBpbiBzaG93aW5nIGEgZmFsbGJhY2suXG4gIHJlc2V0U3VzcGVuZGVkV29ya0xvb3BPblVud2luZCh1bml0T2ZXb3JrKTtcbiAgdmFyIHJldHVybkZpYmVyID0gdW5pdE9mV29yay5yZXR1cm47XG5cbiAgdHJ5IHtcbiAgICAvLyBGaW5kIGFuZCBtYXJrIHRoZSBuZWFyZXN0IFN1c3BlbnNlIG9yIGVycm9yIGJvdW5kYXJ5IHRoYXQgY2FuIGhhbmRsZVxuICAgIC8vIHRoaXMgXCJleGNlcHRpb25cIi5cbiAgICB2YXIgZGlkRmF0YWwgPSB0aHJvd0V4Y2VwdGlvbihyb290LCByZXR1cm5GaWJlciwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcblxuICAgIGlmIChkaWRGYXRhbCkge1xuICAgICAgcGFuaWNPblJvb3RFcnJvcihyb290LCB0aHJvd25WYWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFdlIGhhZCB0cm91YmxlIHByb2Nlc3NpbmcgdGhlIGVycm9yLiBBbiBleGFtcGxlIG9mIHRoaXMgaGFwcGVuaW5nIGlzXG4gICAgLy8gd2hlbiBhY2Nlc3NpbmcgdGhlIGBjb21wb25lbnREaWRDYXRjaGAgcHJvcGVydHkgb2YgYW4gZXJyb3IgYm91bmRhcnlcbiAgICAvLyB0aHJvd3MgYW4gZXJyb3IuIEEgd2VpcmQgZWRnZSBjYXNlLiBUaGVyZSdzIGEgcmVncmVzc2lvbiB0ZXN0IGZvciB0aGlzLlxuICAgIC8vIFRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCwgYnViYmxlIHRoZSBlcnJvciB1cCB0byB0aGUgbmV4dCBwYXJlbnQuXG4gICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhbmljT25Sb290RXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bml0T2ZXb3JrLmZsYWdzICYgSW5jb21wbGV0ZSkge1xuICAgIC8vIFVud2luZCB0aGUgc3RhY2sgdW50aWwgd2UgcmVhY2ggdGhlIG5lYXJlc3QgYm91bmRhcnkuXG4gICAgdW53aW5kVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBbHRob3VnaCB0aGUgZmliZXIgc3VzcGVuZGVkLCB3ZSdyZSBpbnRlbnRpb25hbGx5IGdvaW5nIHRvIGNvbW1pdCBpdCBpblxuICAgIC8vIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2UgY2FuIGRvIHRoaXMgc2FmZWx5IGluIGNhc2VzIHdoZXJlIHdlIGtub3cgdGhlXG4gICAgLy8gaW5jb25zaXN0ZW50IHRyZWUgd2lsbCBiZSBoaWRkZW4uXG4gICAgLy9cbiAgICAvLyBUaGlzIGN1cnJlbnRseSBvbmx5IGFwcGxpZXMgdG8gTGVnYWN5IFN1c3BlbnNlIGltcGxlbWVudGF0aW9uLCBidXQgd2UgbWF5XG4gICAgLy8gcG9ydCBhIHZlcnNpb24gb2YgdGhpcyB0byBjb25jdXJyZW50IHJvb3RzLCB0b28sIHdoZW4gcGVyZm9ybWluZyBhXG4gICAgLy8gc3luY2hyb25vdXMgcmVuZGVyLiBCZWNhdXNlIHRoYXQgd2lsbCBhbGxvdyB1cyB0byBtdXRhdGUgdGhlIHRyZWUgYXMgd2VcbiAgICAvLyBnbyBpbnN0ZWFkIG9mIGJ1ZmZlcmluZyBtdXRhdGlvbnMgdW50aWwgdGhlIGVuZC4gVGhvdWdoIGl0J3MgdW5jbGVhciBpZlxuICAgIC8vIHRoaXMgcGFydGljdWxhciBwYXRoIGlzIGhvdyB0aGF0IHdvdWxkIGJlIGltcGxlbWVudGVkLlxuICAgIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYW5pY09uUm9vdEVycm9yKHJvb3QsIGVycm9yKSB7XG4gIC8vIFRoZXJlJ3Mgbm8gYW5jZXN0b3IgdGhhdCBjYW4gaGFuZGxlIHRoaXMgZXhjZXB0aW9uLiBUaGlzIHNob3VsZCBuZXZlclxuICAvLyBoYXBwZW4gYmVjYXVzZSB0aGUgcm9vdCBpcyBzdXBwb3NlZCB0byBjYXB0dXJlIGFsbCBlcnJvcnMgdGhhdCB3ZXJlbid0XG4gIC8vIGNhdWdodCBieSBhbiBlcnJvciBib3VuZGFyeS4gVGhpcyBpcyBhIGZhdGFsIGVycm9yLCBvciBwYW5pYyBjb25kaXRpb24sXG4gIC8vIGJlY2F1c2Ugd2UndmUgcnVuIG91dCBvZiB3YXlzIHRvIHJlY292ZXIuXG4gIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RmF0YWxFcnJvcmVkO1xuICBsb2dVbmNhdWdodEVycm9yKHJvb3QsIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCByb290LmN1cnJlbnQpKTsgLy8gU2V0IGB3b3JrSW5Qcm9ncmVzc2AgdG8gbnVsbC4gVGhpcyByZXByZXNlbnRzIGFkdmFuY2luZyB0byB0aGUgbmV4dFxuICAvLyBzaWJsaW5nLCBvciB0aGUgcGFyZW50IGlmIHRoZXJlIGFyZSBubyBzaWJsaW5ncy4gQnV0IHNpbmNlIHRoZSByb290XG4gIC8vIGhhcyBubyBzaWJsaW5ncyBub3IgYSBwYXJlbnQsIHdlIHNldCBpdCB0byBudWxsLiBVc3VhbGx5IHRoaXMgaXNcbiAgLy8gaGFuZGxlZCBieSBgY29tcGxldGVVbml0T2ZXb3JrYCBvciBgdW53aW5kV29ya2AsIGJ1dCBzaW5jZSB3ZSdyZVxuICAvLyBpbnRlbnRpb25hbGx5IG5vdCBjYWxsaW5nIHRob3NlLCB3ZSBuZWVkIHNldCBpdCBoZXJlLlxuICAvLyBUT0RPOiBDb25zaWRlciBjYWxsaW5nIGB1bndpbmRXb3JrYCB0byBwb3AgdGhlIGNvbnRleHRzLlxuXG4gIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gQXR0ZW1wdCB0byBjb21wbGV0ZSB0aGUgY3VycmVudCB1bml0IG9mIHdvcmssIHRoZW4gbW92ZSB0byB0aGUgbmV4dFxuICAvLyBzaWJsaW5nLiBJZiB0aGVyZSBhcmUgbm8gbW9yZSBzaWJsaW5ncywgcmV0dXJuIHRvIHRoZSBwYXJlbnQgZmliZXIuXG4gIHZhciBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcblxuICBkbyB7XG4gICAge1xuICAgICAgaWYgKChjb21wbGV0ZWRXb3JrLmZsYWdzICYgSW5jb21wbGV0ZSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAvLyBOT1RFOiBJZiB3ZSByZS1lbmFibGUgc2libGluZyBwcmVyZW5kZXJpbmcgaW4gc29tZSBjYXNlcywgdGhpcyBicmFuY2hcbiAgICAgICAgLy8gaXMgd2hlcmUgd2Ugd291bGQgc3dpdGNoIHRvIHRoZSB1bndpbmRpbmcgcGF0aC5cbiAgICAgICAgZXJyb3IoJ0ludGVybmFsIFJlYWN0IGVycm9yOiBFeHBlY3RlZCB0aGlzIGZpYmVyIHRvIGJlIGNvbXBsZXRlLCBidXQgJyArIFwiaXQgaXNuJ3QuIEl0IHNob3VsZCBoYXZlIGJlZW4gdW53b3VuZC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICB9XG4gICAgfSAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLiBJZGVhbGx5XG4gICAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG5cblxuICAgIHZhciBjdXJyZW50ID0gY29tcGxldGVkV29yay5hbHRlcm5hdGU7XG4gICAgdmFyIHJldHVybkZpYmVyID0gY29tcGxldGVkV29yay5yZXR1cm47XG4gICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihjb21wbGV0ZWRXb3JrKTtcbiAgICB2YXIgbmV4dCA9IHZvaWQgMDtcblxuICAgIGlmICgoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgY29tcGxldGVkV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFByb2ZpbGVyVGltZXIoY29tcGxldGVkV29yayk7XG4gICAgICBuZXh0ID0gY29tcGxldGVXb3JrKGN1cnJlbnQsIGNvbXBsZXRlZFdvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKTsgLy8gVXBkYXRlIHJlbmRlciBkdXJhdGlvbiBhc3N1bWluZyB3ZSBkaWRuJ3QgZXJyb3IuXG5cbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoY29tcGxldGVkV29yaywgZmFsc2UpO1xuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xuXG4gICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgIC8vIENvbXBsZXRpbmcgdGhpcyBmaWJlciBzcGF3bmVkIG5ldyB3b3JrLiBXb3JrIG9uIHRoYXQgbmV4dC5cbiAgICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2libGluZ0ZpYmVyID0gY29tcGxldGVkV29yay5zaWJsaW5nO1xuXG4gICAgaWYgKHNpYmxpbmdGaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB3b3JrIHRvIGRvIGluIHRoaXMgcmV0dXJuRmliZXIsIGRvIHRoYXQgbmV4dC5cbiAgICAgIHdvcmtJblByb2dyZXNzID0gc2libGluZ0ZpYmVyO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gT3RoZXJ3aXNlLCByZXR1cm4gdG8gdGhlIHBhcmVudFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIHdlIGJhaWwgb3V0IHdoZW4gd2UgZ2V0IGEgbnVsbFxuXG5cbiAgICBjb21wbGV0ZWRXb3JrID0gcmV0dXJuRmliZXI7IC8vIFVwZGF0ZSB0aGUgbmV4dCB0aGluZyB3ZSdyZSB3b3JraW5nIG9uIGluIGNhc2Ugc29tZXRoaW5nIHRocm93cy5cblxuICAgIHdvcmtJblByb2dyZXNzID0gY29tcGxldGVkV29yaztcbiAgfSB3aGlsZSAoY29tcGxldGVkV29yayAhPT0gbnVsbCk7IC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3QuXG5cblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdENvbXBsZXRlZDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndpbmRVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgdmFyIGluY29tcGxldGVXb3JrID0gdW5pdE9mV29yaztcblxuICBkbyB7XG4gICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAgIC8vIG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0XG4gICAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gaW5jb21wbGV0ZVdvcmsuYWx0ZXJuYXRlOyAvLyBUaGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUgYmVjYXVzZSBzb21ldGhpbmcgdGhyZXcuIFBvcCB2YWx1ZXMgb2ZmXG4gICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgZW50ZXJpbmcgdGhlIGNvbXBsZXRlIHBoYXNlLiBJZiB0aGlzIGlzIGEgYm91bmRhcnksXG4gICAgLy8gY2FwdHVyZSB2YWx1ZXMgaWYgcG9zc2libGUuXG5cbiAgICB2YXIgbmV4dCA9IHVud2luZFdvcmsoY3VycmVudCwgaW5jb21wbGV0ZVdvcmspOyAvLyBCZWNhdXNlIHRoaXMgZmliZXIgZGlkIG5vdCBjb21wbGV0ZSwgZG9uJ3QgcmVzZXQgaXRzIGxhbmVzLlxuXG4gICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgIC8vIEZvdW5kIGEgYm91bmRhcnkgdGhhdCBjYW4gaGFuZGxlIHRoaXMgZXhjZXB0aW9uLiBSZS1yZW50ZXIgdGhlXG4gICAgICAvLyBiZWdpbiBwaGFzZS4gVGhpcyBicmFuY2ggd2lsbCByZXR1cm4gdXMgdG8gdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG4gICAgICAvL1xuICAgICAgLy8gU2luY2Ugd2UncmUgcmVzdGFydGluZywgcmVtb3ZlIGFueXRoaW5nIHRoYXQgaXMgbm90IGEgaG9zdCBlZmZlY3RcbiAgICAgIC8vIGZyb20gdGhlIGVmZmVjdCB0YWcuXG4gICAgICBuZXh0LmZsYWdzICY9IEhvc3RFZmZlY3RNYXNrO1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gS2VlcCB1bndpbmRpbmcgdW50aWwgd2UgcmVhY2ggZWl0aGVyIGEgYm91bmRhcnkgb3IgdGhlIHJvb3QuXG5cblxuICAgIGlmICgoaW5jb21wbGV0ZVdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJlbmRlciBkdXJhdGlvbiBmb3IgdGhlIGZpYmVyIHRoYXQgZXJyb3JlZC5cbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoaW5jb21wbGV0ZVdvcmssIGZhbHNlKTsgLy8gSW5jbHVkZSB0aGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGZhaWxlZCBjaGlsZHJlbiBiZWZvcmUgY29udGludWluZy5cblxuICAgICAgdmFyIGFjdHVhbER1cmF0aW9uID0gaW5jb21wbGV0ZVdvcmsuYWN0dWFsRHVyYXRpb247XG4gICAgICB2YXIgY2hpbGQgPSBpbmNvbXBsZXRlV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXSBhZGRpdGlvbiB3aXRoIHBvc3NpYmxlIG51bGwvdW5kZWZpbmVkIHZhbHVlXG4gICAgICAgIGFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGluY29tcGxldGVXb3JrLmFjdHVhbER1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgfSAvLyBUT0RPOiBPbmNlIHdlIHN0b3AgcHJlcmVuZGVyaW5nIHNpYmxpbmdzLCBpbnN0ZWFkIG9mIHJlc2V0dGluZyB0aGUgcGFyZW50XG4gICAgLy8gb2YgdGhlIG5vZGUgYmVpbmcgdW53b3VuZCwgd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVzZXQgbm9kZSBpdHNlbGYgYXMgd2VcbiAgICAvLyB1bndpbmQgdGhlIHN0YWNrLiBTYXZlcyBhbiBhZGRpdGlvbmFsIG51bGwgY2hlY2suXG5cblxuICAgIHZhciByZXR1cm5GaWJlciA9IGluY29tcGxldGVXb3JrLnJldHVybjtcblxuICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gTWFyayB0aGUgcGFyZW50IGZpYmVyIGFzIGluY29tcGxldGUgYW5kIGNsZWFyIGl0cyBzdWJ0cmVlIGZsYWdzLlxuICAgICAgLy8gVE9ETzogT25jZSB3ZSBzdG9wIHByZXJlbmRlcmluZyBzaWJsaW5ncywgd2UgbWF5IGJlIGFibGUgdG8gZ2V0IHJpZCBvZlxuICAgICAgLy8gdGhlIEluY29tcGxldGUgZmxhZyBiZWNhdXNlIHVud2luZGluZyB0byB0aGUgbmVhcmVzdCBib3VuZGFyeSB3aWxsXG4gICAgICAvLyBoYXBwZW4gc3luY2hyb25vdXNseS5cbiAgICAgIHJldHVybkZpYmVyLmZsYWdzIHw9IEluY29tcGxldGU7XG4gICAgICByZXR1cm5GaWJlci5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzJDE7XG4gICAgICByZXR1cm5GaWJlci5kZWxldGlvbnMgPSBudWxsO1xuICAgIH0gLy8gTk9URTogSWYgd2UgcmUtZW5hYmxlIHNpYmxpbmcgcHJlcmVuZGVyaW5nIGluIHNvbWUgY2FzZXMsIGhlcmUgd2VcbiAgICAvLyB3b3VsZCBzd2l0Y2ggdG8gdGhlIG5vcm1hbCBjb21wbGV0aW9uIHBhdGg6IGNoZWNrIGlmIGEgc2libGluZ1xuICAgIC8vIGV4aXN0cywgYW5kIGlmIHNvLCBiZWdpbiB3b3JrIG9uIGl0LlxuICAgIC8vIE90aGVyd2lzZSwgcmV0dXJuIHRvIHRoZSBwYXJlbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgaW5jb21wbGV0ZVdvcmsgPSByZXR1cm5GaWJlcjsgLy8gVXBkYXRlIHRoZSBuZXh0IHRoaW5nIHdlJ3JlIHdvcmtpbmcgb24gaW4gY2FzZSBzb21ldGhpbmcgdGhyb3dzLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBpbmNvbXBsZXRlV29yaztcbiAgfSB3aGlsZSAoaW5jb21wbGV0ZVdvcmsgIT09IG51bGwpOyAvLyBXZSd2ZSB1bndvdW5kIGFsbCB0aGUgd2F5IHRvIHRoZSByb290LlxuXG5cbiAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRSb290KHJvb3QsIHJlY292ZXJhYmxlRXJyb3JzLCB0cmFuc2l0aW9ucywgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLCBzcGF3bmVkTGFuZSkge1xuICAvLyBUT0RPOiBUaGlzIG5vIGxvbmdlciBtYWtlcyBhbnkgc2Vuc2UuIFdlIGFscmVhZHkgd3JhcCB0aGUgbXV0YXRpb24gYW5kXG4gIC8vIGxheW91dCBwaGFzZXMuIFNob3VsZCBiZSBhYmxlIHRvIHJlbW92ZS5cbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgdmFyIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgdHJ5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgICBjb21taXRSb290SW1wbChyb290LCByZWNvdmVyYWJsZUVycm9ycywgdHJhbnNpdGlvbnMsIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSwgcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHksIHNwYXduZWRMYW5lKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRSb290SW1wbChyb290LCByZWNvdmVyYWJsZUVycm9ycywgdHJhbnNpdGlvbnMsIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSwgcmVuZGVyUHJpb3JpdHlMZXZlbCwgc3Bhd25lZExhbmUpIHtcbiAgZG8ge1xuICAgIC8vIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCB3aWxsIGNhbGwgYGZsdXNoU3luY1VwZGF0ZVF1ZXVlYCBhdCB0aGUgZW5kLCB3aGljaFxuICAgIC8vIG1lYW5zIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCB3aWxsIHNvbWV0aW1lcyByZXN1bHQgaW4gYWRkaXRpb25hbFxuICAgIC8vIHBhc3NpdmUgZWZmZWN0cy4gU28gd2UgbmVlZCB0byBrZWVwIGZsdXNoaW5nIGluIGEgbG9vcCB1bnRpbCB0aGVyZSBhcmVcbiAgICAvLyBubyBtb3JlIHBlbmRpbmcgZWZmZWN0cy5cbiAgICAvLyBUT0RPOiBNaWdodCBiZSBiZXR0ZXIgaWYgYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIGRpZCBub3QgYXV0b21hdGljYWxseVxuICAgIC8vIGZsdXNoIHN5bmNocm9ub3VzIHdvcmsgYXQgdGhlIGVuZCwgdG8gYXZvaWQgZmFjdG9yaW5nIGhhemFyZHMgbGlrZSB0aGlzLlxuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgfSB3aGlsZSAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgIT09IG51bGwpO1xuXG4gIGZsdXNoUmVuZGVyUGhhc2VTdHJpY3RNb2RlV2FybmluZ3NJbkRFVigpO1xuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLicpO1xuICB9XG5cbiAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICB2YXIgbGFuZXMgPSByb290LmZpbmlzaGVkTGFuZXM7XG5cbiAge1xuICAgIG1hcmtDb21taXRTdGFydGVkKGxhbmVzKTtcbiAgfVxuXG4gIGlmIChmaW5pc2hlZFdvcmsgPT09IG51bGwpIHtcblxuICAgIHtcbiAgICAgIG1hcmtDb21taXRTdG9wcGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaWYgKGxhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgICAgIGVycm9yKCdyb290LmZpbmlzaGVkTGFuZXMgc2hvdWxkIG5vdCBiZSBlbXB0eSBkdXJpbmcgYSBjb21taXQuIFRoaXMgaXMgYSAnICsgJ2J1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKGZpbmlzaGVkV29yayA9PT0gcm9vdC5jdXJyZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgJyArICdhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH0gLy8gY29tbWl0Um9vdCBuZXZlciByZXR1cm5zIGEgY29udGludWF0aW9uOyBpdCBhbHdheXMgZmluaXNoZXMgc3luY2hyb25vdXNseS5cbiAgLy8gU28gd2UgY2FuIGNsZWFyIHRoZXNlIG5vdyB0byBhbGxvdyBhIG5ldyBjYWxsYmFjayB0byBiZSBzY2hlZHVsZWQuXG5cblxuICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IE5vTGFuZTtcbiAgcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gbnVsbDsgLy8gQ2hlY2sgd2hpY2ggbGFuZXMgbm8gbG9uZ2VyIGhhdmUgYW55IHdvcmsgc2NoZWR1bGVkIG9uIHRoZW0sIGFuZCBtYXJrXG4gIC8vIHRob3NlIGFzIGZpbmlzaGVkLlxuXG4gIHZhciByZW1haW5pbmdMYW5lcyA9IG1lcmdlTGFuZXMoZmluaXNoZWRXb3JrLmxhbmVzLCBmaW5pc2hlZFdvcmsuY2hpbGRMYW5lcyk7IC8vIE1ha2Ugc3VyZSB0byBhY2NvdW50IGZvciBsYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBieSBhIGNvbmN1cnJlbnQgZXZlbnRcbiAgLy8gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2U7IGRvbid0IG1hcmsgdGhlbSBhcyBmaW5pc2hlZC5cblxuICB2YXIgY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gZ2V0Q29uY3VycmVudGx5VXBkYXRlZExhbmVzKCk7XG4gIHJlbWFpbmluZ0xhbmVzID0gbWVyZ2VMYW5lcyhyZW1haW5pbmdMYW5lcywgY29uY3VycmVudGx5VXBkYXRlZExhbmVzKTtcbiAgbWFya1Jvb3RGaW5pc2hlZChyb290LCByZW1haW5pbmdMYW5lcywgc3Bhd25lZExhbmUpOyAvLyBSZXNldCB0aGlzIGJlZm9yZSBmaXJpbmcgc2lkZSBlZmZlY3RzIHNvIHdlIGNhbiBkZXRlY3QgcmVjdXJzaXZlIHVwZGF0ZXMuXG5cbiAgZGlkSW5jbHVkZUNvbW1pdFBoYXNlVXBkYXRlID0gZmFsc2U7XG5cbiAgaWYgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuICAgIC8vIFdlIGNhbiByZXNldCB0aGVzZSBub3cgdGhhdCB0aGV5IGFyZSBmaW5pc2hlZC5cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIH0gLy8gSWYgdGhlcmUgYXJlIHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzLCBzY2hlZHVsZSBhIGNhbGxiYWNrIHRvIHByb2Nlc3MgdGhlbS5cbiAgLy8gRG8gdGhpcyBhcyBlYXJseSBhcyBwb3NzaWJsZSwgc28gaXQgaXMgcXVldWVkIGJlZm9yZSBhbnl0aGluZyBlbHNlIHRoYXRcbiAgLy8gbWlnaHQgZ2V0IHNjaGVkdWxlZCBpbiB0aGUgY29tbWl0IHBoYXNlLiAoU2VlICMxNjcxNC4pXG4gIC8vIFRPRE86IERlbGV0ZSBhbGwgb3RoZXIgcGxhY2VzIHRoYXQgc2NoZWR1bGUgdGhlIHBhc3NpdmUgZWZmZWN0IGNhbGxiYWNrXG4gIC8vIFRoZXkncmUgcmVkdW5kYW50LlxuXG5cbiAgaWYgKChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spICE9PSBOb0ZsYWdzJDEgfHwgKGZpbmlzaGVkV29yay5mbGFncyAmIFBhc3NpdmVNYXNrKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgaWYgKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSByZW1haW5pbmdMYW5lczsgLy8gd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyBtaWdodCBiZSBvdmVyd3JpdHRlbiwgc28gd2Ugd2FudFxuICAgICAgLy8gdG8gc3RvcmUgaXQgaW4gcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyB1bnRpbCB0aGV5IGdldCBwcm9jZXNzZWRcbiAgICAgIC8vIFdlIG5lZWQgdG8gcGFzcyB0aGlzIHRocm91Z2ggYXMgYW4gYXJndW1lbnQgdG8gY29tbWl0Um9vdFxuICAgICAgLy8gYmVjYXVzZSB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zIG1pZ2h0IGhhdmUgY2hhbmdlZCBiZXR3ZWVuXG4gICAgICAvLyB0aGUgcHJldmlvdXMgcmVuZGVyIGFuZCBjb21taXQgaWYgd2UgdGhyb3R0bGUgdGhlIGNvbW1pdFxuICAgICAgLy8gd2l0aCBzZXRUaW1lb3V0XG5cbiAgICAgIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2soTm9ybWFsUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7IC8vIFRoaXMgcmVuZGVyIHRyaWdnZXJlZCBwYXNzaXZlIGVmZmVjdHM6IHJlbGVhc2UgdGhlIHJvb3QgY2FjaGUgcG9vbFxuICAgICAgICAvLyAqYWZ0ZXIqIHBhc3NpdmUgZWZmZWN0cyBmaXJlIHRvIGF2b2lkIGZyZWVpbmcgYSBjYWNoZSBwb29sIHRoYXQgbWF5XG4gICAgICAgIC8vIGJlIHJlZmVyZW5jZWQgYnkgYSBub2RlIGluIHRoZSB0cmVlIChIb3N0Um9vdCwgQ2FjaGUgYm91bmRhcnkgZXRjKVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgZWZmZWN0cyBpbiB0aGUgd2hvbGUgdHJlZS5cbiAgLy8gVE9ETzogVGhpcyBpcyBsZWZ0IG92ZXIgZnJvbSB0aGUgZWZmZWN0IGxpc3QgaW1wbGVtZW50YXRpb24sIHdoZXJlIHdlIGhhZFxuICAvLyB0byBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBgZmlyc3RFZmZlY3RgIHRvIHNhdGlzZnkgRmxvdy4gSSB0aGluayB0aGVcbiAgLy8gb25seSBvdGhlciByZWFzb24gdGhpcyBvcHRpbWl6YXRpb24gZXhpc3RzIGlzIGJlY2F1c2UgaXQgYWZmZWN0cyBwcm9maWxpbmcuXG4gIC8vIFJlY29uc2lkZXIgd2hldGhlciB0aGlzIGlzIG5lY2Vzc2FyeS5cblxuXG4gIHZhciBzdWJ0cmVlSGFzRWZmZWN0cyA9IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgKEJlZm9yZU11dGF0aW9uTWFzayB8IE11dGF0aW9uTWFzayB8IExheW91dE1hc2sgfCBQYXNzaXZlTWFzaykpICE9PSBOb0ZsYWdzJDE7XG4gIHZhciByb290SGFzRWZmZWN0ID0gKGZpbmlzaGVkV29yay5mbGFncyAmIChCZWZvcmVNdXRhdGlvbk1hc2sgfCBNdXRhdGlvbk1hc2sgfCBMYXlvdXRNYXNrIHwgUGFzc2l2ZU1hc2spKSAhPT0gTm9GbGFncyQxO1xuXG4gIGlmIChzdWJ0cmVlSGFzRWZmZWN0cyB8fCByb290SGFzRWZmZWN0KSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0OyAvLyBUaGUgY29tbWl0IHBoYXNlIGlzIGJyb2tlbiBpbnRvIHNldmVyYWwgc3ViLXBoYXNlcy4gV2UgZG8gYSBzZXBhcmF0ZSBwYXNzXG4gICAgLy8gb2YgdGhlIGVmZmVjdCBsaXN0IGZvciBlYWNoIHBoYXNlOiBhbGwgbXV0YXRpb24gZWZmZWN0cyBjb21lIGJlZm9yZSBhbGxcbiAgICAvLyBsYXlvdXQgZWZmZWN0cywgYW5kIHNvIG9uLlxuICAgIC8vIFRoZSBmaXJzdCBwaGFzZSBhIFwiYmVmb3JlIG11dGF0aW9uXCIgcGhhc2UuIFdlIHVzZSB0aGlzIHBoYXNlIHRvIHJlYWQgdGhlXG4gICAgLy8gc3RhdGUgb2YgdGhlIGhvc3QgdHJlZSByaWdodCBiZWZvcmUgd2UgbXV0YXRlIGl0LiBUaGlzIGlzIHdoZXJlXG4gICAgLy8gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgaXMgY2FsbGVkLlxuXG4gICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG5cbiAgICB7XG4gICAgICAvLyBNYXJrIHRoZSBjdXJyZW50IGNvbW1pdCB0aW1lIHRvIGJlIHNoYXJlZCBieSBhbGwgUHJvZmlsZXJzIGluIHRoaXNcbiAgICAgIC8vIGJhdGNoLiBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH0gLy8gVGhlIG5leHQgcGhhc2UgaXMgdGhlIG11dGF0aW9uIHBoYXNlLCB3aGVyZSB3ZSBtdXRhdGUgdGhlIGhvc3QgdHJlZS5cblxuXG4gICAgY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgbGFuZXMpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pOyAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyB0cmVlIGlzIG5vdyB0aGUgY3VycmVudCB0cmVlLiBUaGlzIG11c3QgY29tZSBhZnRlclxuICAgIC8vIHRoZSBtdXRhdGlvbiBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbCBjdXJyZW50IGR1cmluZ1xuICAgIC8vIGNvbXBvbmVudFdpbGxVbm1vdW50LCBidXQgYmVmb3JlIHRoZSBsYXlvdXQgcGhhc2UsIHNvIHRoYXQgdGhlIGZpbmlzaGVkXG4gICAgLy8gd29yayBpcyBjdXJyZW50IGR1cmluZyBjb21wb25lbnREaWRNb3VudC9VcGRhdGUuXG5cbiAgICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7IC8vIFRoZSBuZXh0IHBoYXNlIGlzIHRoZSBsYXlvdXQgcGhhc2UsIHdoZXJlIHdlIGNhbGwgZWZmZWN0cyB0aGF0IHJlYWRcblxuICAgIHtcbiAgICAgIG1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuXG4gICAgY29tbWl0TGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIHJvb3QsIGxhbmVzKTtcblxuICAgIHtcbiAgICAgIG1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO1xuICAgIH0gLy8gVGVsbCBTY2hlZHVsZXIgdG8geWllbGQgYXQgdGhlIGVuZCBvZiB0aGUgZnJhbWUsIHNvIHRoZSBicm93c2VyIGhhcyBhblxuICAgIC8vIG9wcG9ydHVuaXR5IHRvIHBhaW50LlxuXG5cbiAgICByZXF1ZXN0UGFpbnQoKTtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7IC8vIFJlc2V0IHRoZSBwcmlvcml0eSB0byB0aGUgcHJldmlvdXMgbm9uLXN5bmMgdmFsdWUuXG5cbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vIGVmZmVjdHMuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBNZWFzdXJlIHRoZXNlIGFueXdheSBzbyB0aGUgZmxhbWVncmFwaCBleHBsaWNpdGx5IHNob3dzIHRoYXQgdGhlcmUgd2VyZVxuICAgIC8vIG5vIGVmZmVjdHMuXG4gICAgLy8gVE9ETzogTWF5YmUgdGhlcmUncyBhIGJldHRlciB3YXkgdG8gcmVwb3J0IHRoaXMuXG5cbiAgICB7XG4gICAgICByZWNvcmRDb21taXRUaW1lKCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMgPSByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cztcblxuICBpZiAocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAvLyBUaGlzIGNvbW1pdCBoYXMgcGFzc2l2ZSBlZmZlY3RzLiBTdGFzaCBhIHJlZmVyZW5jZSB0byB0aGVtLiBCdXQgZG9uJ3RcbiAgICAvLyBzY2hlZHVsZSBhIGNhbGxiYWNrIHVudGlsIGFmdGVyIGZsdXNoaW5nIGxheW91dCB3b3JrLlxuICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG4gICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSByb290O1xuICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gbGFuZXM7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlcmUgd2VyZSBubyBwYXNzaXZlIGVmZmVjdHMsIHNvIHdlIGNhbiBpbW1lZGlhdGVseSByZWxlYXNlIHRoZSBjYWNoZVxuICAgIC8vIHBvb2wgZm9yIHRoaXMgcmVuZGVyLlxuICAgIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpO1xuXG4gICAge1xuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcbiAgICAgIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsO1xuICAgIH1cbiAgfSAvLyBSZWFkIHRoaXMgYWdhaW4sIHNpbmNlIGFuIGVmZmVjdCBtaWdodCBoYXZlIHVwZGF0ZWQgaXRcblxuXG4gIHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7IC8vIENoZWNrIGlmIHRoZXJlJ3MgcmVtYWluaW5nIHdvcmsgb24gdGhpcyByb290XG4gIC8vIFRPRE86IFRoaXMgaXMgcGFydCBvZiB0aGUgYGNvbXBvbmVudERpZENhdGNoYCBpbXBsZW1lbnRhdGlvbi4gSXRzIHB1cnBvc2VcbiAgLy8gaXMgdG8gZGV0ZWN0IHdoZXRoZXIgc29tZXRoaW5nIG1pZ2h0IGhhdmUgY2FsbGVkIHNldFN0YXRlIGluc2lkZVxuICAvLyBgY29tcG9uZW50RGlkQ2F0Y2hgLiBUaGUgbWVjaGFuaXNtIGlzIGtub3duIHRvIGJlIGZsYXdlZCBiZWNhdXNlIGBzZXRTdGF0ZWBcbiAgLy8gaW5zaWRlIGBjb21wb25lbnREaWRDYXRjaGAgaXMgaXRzZWxmIGZsYXdlZCDigJQgdGhhdCdzIHdoeSB3ZSByZWNvbW1lbmRcbiAgLy8gYGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcmAgaW5zdGVhZC4gSG93ZXZlciwgaXQgY291bGQgYmUgaW1wcm92ZWQgYnlcbiAgLy8gY2hlY2tpbmcgaWYgcmVtYWluaW5nTGFuZXMgaW5jbHVkZXMgU3luYyB3b3JrLCBpbnN0ZWFkIG9mIHdoZXRoZXIgdGhlcmUnc1xuICAvLyBhbnkgd29yayByZW1haW5pbmcgYXQgYWxsICh3aGljaCB3b3VsZCBhbHNvIGluY2x1ZGUgc3R1ZmYgbGlrZSBTdXNwZW5zZVxuICAvLyByZXRyaWVzIG9yIHRyYW5zaXRpb25zKS4gSXQncyBiZWVuIGxpa2UgdGhpcyBmb3IgYSB3aGlsZSwgdGhvdWdoLCBzbyBmaXhpbmdcbiAgLy8gaXQgcHJvYmFibHkgaXNuJ3QgdGhhdCB1cmdlbnQuXG5cbiAgaWYgKHJlbWFpbmluZ0xhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyByZW1haW5pbmcgd29yaywgd2UgY2FuIGNsZWFyIHRoZSBzZXQgb2YgYWxyZWFkeSBmYWlsZWRcbiAgICAvLyBlcnJvciBib3VuZGFyaWVzLlxuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAoIXJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290KTtcbiAgICB9XG4gIH1cblxuICBvbkNvbW1pdFJvb3QkMShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLCByZW5kZXJQcmlvcml0eUxldmVsKTtcblxuICB7XG4gICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICByb290Lm1lbW9pemVkVXBkYXRlcnMuY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgb25Db21taXRSb290KCk7XG4gIH0gLy8gQWx3YXlzIGNhbGwgdGhpcyBiZWZvcmUgZXhpdGluZyBgY29tbWl0Um9vdGAsIHRvIGVuc3VyZSB0aGF0IGFueVxuICAvLyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290IGlzIHNjaGVkdWxlZC5cblxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcblxuICBpZiAocmVjb3ZlcmFibGVFcnJvcnMgIT09IG51bGwpIHtcbiAgICAvLyBUaGVyZSB3ZXJlIGVycm9ycyBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCByZWNvdmVyZWQgZnJvbSB0aGVtIHdpdGhvdXRcbiAgICAvLyBuZWVkaW5nIHRvIHN1cmZhY2UgaXQgdG8gdGhlIFVJLiBXZSBsb2cgdGhlbSBoZXJlLlxuICAgIHZhciBvblJlY292ZXJhYmxlRXJyb3IgPSByb290Lm9uUmVjb3ZlcmFibGVFcnJvcjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb3ZlcmFibGVFcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZWNvdmVyYWJsZUVycm9yID0gcmVjb3ZlcmFibGVFcnJvcnNbaV07XG4gICAgICB2YXIgZXJyb3JJbmZvID0gbWFrZUVycm9ySW5mbyhyZWNvdmVyYWJsZUVycm9yLnN0YWNrKTtcbiAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYocmVjb3ZlcmFibGVFcnJvci5zb3VyY2UpO1xuICAgICAgb25SZWNvdmVyYWJsZUVycm9yKHJlY292ZXJhYmxlRXJyb3IudmFsdWUsIGVycm9ySW5mbyk7XG4gICAgICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcbiAgICB9XG4gIH0gLy8gSWYgdGhlIHBhc3NpdmUgZWZmZWN0cyBhcmUgdGhlIHJlc3VsdCBvZiBhIGRpc2NyZXRlIHJlbmRlciwgZmx1c2ggdGhlbVxuICAvLyBzeW5jaHJvbm91c2x5IGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgdGFzayBzbyB0aGF0IHRoZSByZXN1bHQgaXNcbiAgLy8gaW1tZWRpYXRlbHkgb2JzZXJ2YWJsZS4gT3RoZXJ3aXNlLCB3ZSBhc3N1bWUgdGhhdCB0aGV5IGFyZSBub3RcbiAgLy8gb3JkZXItZGVwZW5kZW50IGFuZCBkbyBub3QgbmVlZCB0byBiZSBvYnNlcnZlZCBieSBleHRlcm5hbCBzeXN0ZW1zLCBzbyB3ZVxuICAvLyBjYW4gd2FpdCB1bnRpbCBhZnRlciBwYWludC5cbiAgLy8gVE9ETzogV2UgY2FuIG9wdGltaXplIHRoaXMgYnkgbm90IHNjaGVkdWxpbmcgdGhlIGNhbGxiYWNrIGVhcmxpZXIuIFNpbmNlIHdlXG4gIC8vIGN1cnJlbnRseSBzY2hlZHVsZSB0aGUgY2FsbGJhY2sgaW4gbXVsdGlwbGUgcGxhY2VzLCB3aWxsIHdhaXQgdW50aWwgdGhvc2VcbiAgLy8gYXJlIGNvbnNvbGlkYXRlZC5cblxuXG4gIGlmIChpbmNsdWRlc1N5bmNMYW5lKHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzKSAmJiAoZGlzYWJsZUxlZ2FjeU1vZGUgKSkge1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgfSAvLyBSZWFkIHRoaXMgYWdhaW4sIHNpbmNlIGEgcGFzc2l2ZSBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzOyAvLyBDaGVjayBpZiB0aGlzIHJlbmRlciBzY2hlZHVsZWQgYSBjYXNjYWRpbmcgc3luY2hyb25vdXMgdXBkYXRlLiBUaGlzIGlzIGFcbiAgLy8gaGV1cnN0aWMgdG8gZGV0ZWN0IGluZmluaXRlIHVwZGF0ZSBsb29wcy4gV2UgYXJlIGludGVudGlvbmFsbHkgZXhjbHVkaW5nXG4gIC8vIGh5ZHJhdGlvbiBsYW5lcyBpbiB0aGlzIGNoZWNrLCBiZWNhdXNlIHJlbmRlciB0cmlnZ2VyZWQgYnkgc2VsZWN0aXZlXG4gIC8vIGh5ZHJhdGlvbiBpcyBjb25jZXB0dWFsbHkgbm90IGFuIHVwZGF0ZS5cblxuICBpZiAoIC8vIENoZWNrIGlmIHRoZXJlIHdhcyBhIHJlY3Vyc2l2ZSB1cGRhdGUgc3Bhd25lZCBieSB0aGlzIHJlbmRlciwgaW4gZWl0aGVyXG4gIC8vIHRoZSByZW5kZXIgcGhhc2Ugb3IgdGhlIGNvbW1pdCBwaGFzZS4gV2UgdHJhY2sgdGhlc2UgZXhwbGljaXRseSBiZWNhdXNlXG4gIC8vIHdlIGNhbid0IGluZmVyIGZyb20gdGhlIHJlbWFpbmluZyBsYW5lcyBhbG9uZS5cbiAgKGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSB8fCBkaWRJbmNsdWRlQ29tbWl0UGhhc2VVcGRhdGUpIHx8IC8vIFdhcyB0aGUgZmluaXNoZWQgcmVuZGVyIHRoZSByZXN1bHQgb2YgYW4gdXBkYXRlIChub3QgaHlkcmF0aW9uKT9cbiAgaW5jbHVkZXNTb21lTGFuZShsYW5lcywgVXBkYXRlTGFuZXMpICYmIC8vIERpZCBpdCBzY2hlZHVsZSBhIHN5bmMgdXBkYXRlP1xuICBpbmNsdWRlc1NvbWVMYW5lKHJlbWFpbmluZ0xhbmVzLCBTeW5jVXBkYXRlTGFuZXMpKSB7XG4gICAge1xuICAgICAgbWFya05lc3RlZFVwZGF0ZVNjaGVkdWxlZCgpO1xuICAgIH0gLy8gQ291bnQgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgcm9vdCBzeW5jaHJvbm91c2x5IHJlLXJlbmRlcnMgd2l0aG91dFxuICAgIC8vIGZpbmlzaGluZy4gSWYgdGhlcmUgYXJlIHRvbyBtYW55LCBpdCBpbmRpY2F0ZXMgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AuXG5cblxuICAgIGlmIChyb290ID09PSByb290V2l0aE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICAgIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IHJvb3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgfSAvLyBJZiBsYXlvdXQgd29yayB3YXMgc2NoZWR1bGVkLCBmbHVzaCBpdCBub3cuXG5cblxuICBmbHVzaFN5bmNXb3JrT25BbGxSb290cygpO1xuXG4gIHtcbiAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIG1ha2VFcnJvckluZm8oY29tcG9uZW50U3RhY2spIHtcbiAgdmFyIGVycm9ySW5mbyA9IHtcbiAgICBjb21wb25lbnRTdGFjazogY29tcG9uZW50U3RhY2tcbiAgfTtcblxuICB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9ySW5mbywgJ2RpZ2VzdCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBlcnJvcignWW91IGFyZSBhY2Nlc3NpbmcgXCJkaWdlc3RcIiBmcm9tIHRoZSBlcnJvckluZm8gb2JqZWN0IHBhc3NlZCB0byBvblJlY292ZXJhYmxlRXJyb3IuJyArICcgVGhpcyBwcm9wZXJ0eSBpcyBubyBsb25nZXIgcHJvdmlkZWQgYXMgcGFydCBvZiBlcnJvckluZm8gYnV0IGNhbiBiZSBhY2Nlc3NlZCBhcyBhIHByb3BlcnR5JyArICcgb2YgdGhlIEVycm9yIGluc3RhbmNlIGl0c2VsZi4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlcnJvckluZm87XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpIHtcbiAge1xuICAgIHZhciBwb29sZWRDYWNoZUxhbmVzID0gcm9vdC5wb29sZWRDYWNoZUxhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuXG4gICAgaWYgKHBvb2xlZENhY2hlTGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAgIC8vIE5vbmUgb2YgdGhlIHJlbWFpbmluZyB3b3JrIHJlbGllcyBvbiB0aGUgY2FjaGUgcG9vbC4gQ2xlYXIgaXQgc29cbiAgICAgIC8vIHN1YnNlcXVlbnQgcmVxdWVzdHMgZ2V0IGEgbmV3IGNhY2hlXG4gICAgICB2YXIgcG9vbGVkQ2FjaGUgPSByb290LnBvb2xlZENhY2hlO1xuXG4gICAgICBpZiAocG9vbGVkQ2FjaGUgIT0gbnVsbCkge1xuICAgICAgICByb290LnBvb2xlZENhY2hlID0gbnVsbDtcbiAgICAgICAgcmVsZWFzZUNhY2hlKHBvb2xlZENhY2hlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hQYXNzaXZlRWZmZWN0cygpIHtcbiAgLy8gUmV0dXJucyB3aGV0aGVyIHBhc3NpdmUgZWZmZWN0cyB3ZXJlIGZsdXNoZWQuXG4gIC8vIFRPRE86IENvbWJpbmUgdGhpcyBjaGVjayB3aXRoIHRoZSBvbmUgaW4gZmx1c2hQYXNzaXZlRUZmZWN0c0ltcGwuIFdlIHNob3VsZFxuICAvLyBwcm9iYWJseSBqdXN0IGNvbWJpbmUgdGhlIHR3byBmdW5jdGlvbnMuIEkgYmVsaWV2ZSB0aGV5IHdlcmUgb25seSBzZXBhcmF0ZVxuICAvLyBpbiB0aGUgZmlyc3QgcGxhY2UgYmVjYXVzZSB3ZSB1c2VkIHRvIHdyYXAgaXQgd2l0aFxuICAvLyBgU2NoZWR1bGVyLnJ1bldpdGhQcmlvcml0eWAsIHdoaWNoIGFjY2VwdHMgYSBmdW5jdGlvbi4gQnV0IG5vdyB3ZSB0cmFjayB0aGVcbiAgLy8gcHJpb3JpdHkgd2l0aGluIFJlYWN0IGl0c2VsZiwgc28gd2UgY2FuIG11dGF0ZSB0aGUgdmFyaWFibGUgZGlyZWN0bHkuXG4gIGlmIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyAhPT0gbnVsbCkge1xuICAgIC8vIENhY2hlIHRoZSByb290IHNpbmNlIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzIGlzIGNsZWFyZWQgaW5cbiAgICAvLyBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbFxuICAgIHZhciByb290ID0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHM7IC8vIENhY2hlIGFuZCBjbGVhciB0aGUgcmVtYWluaW5nIGxhbmVzIGZsYWc7IGl0IG11c3QgYmUgcmVzZXQgc2luY2UgdGhpc1xuICAgIC8vIG1ldGhvZCBjYW4gYmUgY2FsbGVkIGZyb20gdmFyaW91cyBwbGFjZXMsIG5vdCBhbHdheXMgZnJvbSBjb21taXRSb290XG4gICAgLy8gd2hlcmUgdGhlIHJlbWFpbmluZyBsYW5lcyBhcmUga25vd25cblxuICAgIHZhciByZW1haW5pbmdMYW5lcyA9IHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzO1xuICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzID0gTm9MYW5lcztcbiAgICB2YXIgcmVuZGVyUHJpb3JpdHkgPSBsYW5lc1RvRXZlbnRQcmlvcml0eShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyk7XG4gICAgdmFyIHByaW9yaXR5ID0gbG93ZXJFdmVudFByaW9yaXR5KERlZmF1bHRFdmVudFByaW9yaXR5LCByZW5kZXJQcmlvcml0eSk7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmlvcml0eSk7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgICAgIHJldHVybiBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247IC8vIE9uY2UgcGFzc2l2ZSBlZmZlY3RzIGhhdmUgcnVuIGZvciB0aGUgdHJlZSAtIGdpdmluZyBjb21wb25lbnRzIGFcbiAgICAgIC8vIGNoYW5jZSB0byByZXRhaW4gY2FjaGUgaW5zdGFuY2VzIHRoZXkgdXNlIC0gcmVsZWFzZSB0aGUgcG9vbGVkXG4gICAgICAvLyBjYWNoZSBhdCB0aGUgcm9vdCAoaWYgdGhlcmUgaXMgb25lKVxuXG4gICAgICByZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QsIHJlbWFpbmluZ0xhbmVzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdChmaWJlcikge1xuICB7XG4gICAgcGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHMucHVzaChmaWJlcik7XG5cbiAgICBpZiAoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCgpIHtcbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIENhY2hlIGFuZCBjbGVhciB0aGUgdHJhbnNpdGlvbnMgZmxhZ1xuXG5cbiAgdmFyIHRyYW5zaXRpb25zID0gcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucztcbiAgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IG51bGw7XG4gIHZhciByb290ID0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHM7XG4gIHZhciBsYW5lcyA9IHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzO1xuICByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGw7IC8vIFRPRE86IFRoaXMgaXMgc29tZXRpbWVzIG91dCBvZiBzeW5jIHdpdGggcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMuXG4gIC8vIEZpZ3VyZSBvdXQgd2h5IGFuZCBmaXggaXQuIEl0J3Mgbm90IGNhdXNpbmcgYW55IGtub3duIGlzc3VlcyAocHJvYmFibHlcbiAgLy8gYmVjYXVzZSBpdCdzIG9ubHkgdXNlZCBmb3IgcHJvZmlsaW5nKSwgYnV0IGl0J3MgYSByZWZhY3RvciBoYXphcmQuXG5cbiAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBOb0xhbmVzO1xuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmbHVzaCBwYXNzaXZlIGVmZmVjdHMgd2hpbGUgYWxyZWFkeSByZW5kZXJpbmcuJyk7XG4gIH1cblxuICB7XG4gICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcbiAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG4gIH1cblxuICB7XG4gICAgbWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcyk7XG4gIH1cblxuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7XG4gIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0cyhyb290LmN1cnJlbnQpO1xuICBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzKHJvb3QsIHJvb3QuY3VycmVudCwgbGFuZXMsIHRyYW5zaXRpb25zKTsgLy8gVE9ETzogTW92ZSB0byBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzXG5cbiAge1xuICAgIHZhciBwcm9maWxlckVmZmVjdHMgPSBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cztcbiAgICBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9maWxlckVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmaWJlciA9IHByb2ZpbGVyRWZmZWN0c1tpXTtcbiAgICAgIGNvbW1pdFBhc3NpdmVFZmZlY3REdXJhdGlvbnMocm9vdCwgZmliZXIpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBtYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkKCk7XG4gIH1cblxuICB7XG4gICAgY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QpO1xuICB9XG5cbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICBmbHVzaFN5bmNXb3JrT25BbGxSb290cygpO1xuXG4gIHtcbiAgICAvLyBJZiBhZGRpdGlvbmFsIHBhc3NpdmUgZWZmZWN0cyB3ZXJlIHNjaGVkdWxlZCwgaW5jcmVtZW50IGEgY291bnRlci4gSWYgdGhpc1xuICAgIC8vIGV4Y2VlZHMgdGhlIGxpbWl0LCB3ZSdsbCBmaXJlIGEgd2FybmluZy5cbiAgICBpZiAoZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cykge1xuICAgICAgaWYgKHJvb3QgPT09IHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwO1xuICAgICAgICByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gcm9vdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcbiAgICB9XG5cbiAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbiAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG4gIH0gLy8gVE9ETzogTW92ZSB0byBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzXG5cblxuICBvblBvc3RDb21taXRSb290KHJvb3QpO1xuXG4gIHtcbiAgICB2YXIgc3RhdGVOb2RlID0gcm9vdC5jdXJyZW50LnN0YXRlTm9kZTtcbiAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkICE9PSBudWxsICYmIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKGluc3RhbmNlKSB7XG4gIGlmIChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9PT0gbnVsbCkge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbmV3IFNldChbaW5zdGFuY2VdKTtcbiAgfSBlbHNlIHtcbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5hZGQoaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHJvb3RGaWJlciwgc291cmNlRmliZXIsIGVycm9yKSB7XG4gIHZhciBlcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciwgc291cmNlRmliZXIpO1xuICB2YXIgdXBkYXRlID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHJvb3RGaWJlci5zdGF0ZU5vZGUsIGVycm9ySW5mbywgU3luY0xhbmUpO1xuICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCB1cGRhdGUsIFN5bmNMYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIG1hcmtSb290VXBkYXRlZChyb290LCBTeW5jTGFuZSk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKHNvdXJjZUZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvciQxKSB7XG4gIHtcbiAgICBzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QoZmFsc2UpO1xuICB9XG5cbiAgaWYgKHNvdXJjZUZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBFcnJvciB3YXMgdGhyb3duIGF0IHRoZSByb290LiBUaGVyZSBpcyBubyBwYXJlbnQsIHNvIHRoZSByb290XG4gICAgLy8gaXRzZWxmIHNob3VsZCBjYXB0dXJlIGl0LlxuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHNvdXJjZUZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IkMSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZpYmVyID0gbmVhcmVzdE1vdW50ZWRBbmNlc3RvcjtcblxuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICBpZiAoZmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QoZmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvciQxKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBjdG9yID0gZmliZXIudHlwZTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSB7XG4gICAgICAgIHZhciBlcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciQxLCBzb3VyY2VGaWJlcik7XG4gICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKFN5bmNMYW5lKTtcbiAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIFN5bmNMYW5lKTtcblxuICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKHVwZGF0ZSwgcm9vdCwgZmliZXIsIGVycm9ySW5mbyk7XG4gICAgICAgICAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIFN5bmNMYW5lKTtcbiAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gIH1cblxuICB7XG4gICAgZXJyb3IoJ0ludGVybmFsIFJlYWN0IGVycm9yOiBBdHRlbXB0ZWQgdG8gY2FwdHVyZSBhIGNvbW1pdCBwaGFzZSBlcnJvciAnICsgJ2luc2lkZSBhIGRldGFjaGVkIHRyZWUuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0LiBQb3RlbnRpYWwgJyArICdjYXVzZXMgaW5jbHVkZSBkZWxldGluZyB0aGUgc2FtZSBmaWJlciBtb3JlIHRoYW4gb25jZSwgY29tbWl0dGluZyBhbiAnICsgJ2FscmVhZHktZmluaXNoZWQgdHJlZSwgb3IgYW4gaW5jb25zaXN0ZW50IHJldHVybiBwb2ludGVyLlxcblxcbicgKyAnRXJyb3IgbWVzc2FnZTpcXG5cXG4lcycsIGVycm9yJDEpO1xuICB9XG59XG5mdW5jdGlvbiBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIGxhbmVzKSB7XG4gIC8vIEF0dGFjaCBhIHBpbmcgbGlzdGVuZXJcbiAgLy9cbiAgLy8gVGhlIGRhdGEgbWlnaHQgcmVzb2x2ZSBiZWZvcmUgd2UgaGF2ZSBhIGNoYW5jZSB0byBjb21taXQgdGhlIGZhbGxiYWNrLiBPcixcbiAgLy8gaW4gdGhlIGNhc2Ugb2YgYSByZWZyZXNoLCB3ZSdsbCBuZXZlciBjb21taXQgYSBmYWxsYmFjay4gU28gd2UgbmVlZCB0b1xuICAvLyBhdHRhY2ggYSBsaXN0ZW5lciBub3cuIFdoZW4gaXQgcmVzb2x2ZXMgKFwicGluZ3NcIiksIHdlIGNhbiBkZWNpZGUgd2hldGhlciB0b1xuICAvLyB0cnkgcmVuZGVyaW5nIHRoZSB0cmVlIGFnYWluLlxuICAvL1xuICAvLyBPbmx5IGF0dGFjaCBhIGxpc3RlbmVyIGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0IGZvciB0aGUgbGFuZXNcbiAgLy8gd2UncmUgY3VycmVudGx5IHJlbmRlcmluZyAod2hpY2ggYWN0cyBsaWtlIGEgXCJ0aHJlYWQgSURcIiBoZXJlKS5cbiAgLy9cbiAgLy8gV2Ugb25seSBuZWVkIHRvIGRvIHRoaXMgaW4gY29uY3VycmVudCBtb2RlLiBMZWdhY3kgU3VzcGVuc2UgYWx3YXlzXG4gIC8vIGNvbW1pdHMgZmFsbGJhY2tzIHN5bmNocm9ub3VzbHksIHNvIHRoZXJlIGFyZSBubyBwaW5ncy5cbiAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuICB2YXIgdGhyZWFkSURzO1xuXG4gIGlmIChwaW5nQ2FjaGUgPT09IG51bGwpIHtcbiAgICBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbiAgICB0aHJlYWRJRHMgPSBuZXcgU2V0KCk7XG4gICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJlYWRJRHMgPSBwaW5nQ2FjaGUuZ2V0KHdha2VhYmxlKTtcblxuICAgIGlmICh0aHJlYWRJRHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRocmVhZElEcy5oYXMobGFuZXMpKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gdHJ1ZTsgLy8gTWVtb2l6ZSB1c2luZyB0aGUgdGhyZWFkIElEIHRvIHByZXZlbnQgcmVkdW5kYW50IGxpc3RlbmVycy5cblxuICAgIHRocmVhZElEcy5hZGQobGFuZXMpO1xuICAgIHZhciBwaW5nID0gcGluZ1N1c3BlbmRlZFJvb3QuYmluZChudWxsLCByb290LCB3YWtlYWJsZSwgbGFuZXMpO1xuXG4gICAge1xuICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgcGVuZGluZyB3b3JrIHN0aWxsLCByZXN0b3JlIHRoZSBvcmlnaW5hbCB1cGRhdGVyc1xuICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIGxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3YWtlYWJsZS50aGVuKHBpbmcsIHBpbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBpbmdTdXNwZW5kZWRSb290KHJvb3QsIHdha2VhYmxlLCBwaW5nZWRMYW5lcykge1xuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG5cbiAgaWYgKHBpbmdDYWNoZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSB3YWtlYWJsZSByZXNvbHZlZCwgc28gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gbWVtb2l6ZSwgYmVjYXVzZSBpdCB3aWxsXG4gICAgLy8gbmV2ZXIgYmUgdGhyb3duIGFnYWluLlxuICAgIHBpbmdDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMpO1xuICB3YXJuSWZTdXNwZW5zZVJlc29sdXRpb25Ob3RXcmFwcGVkV2l0aEFjdERFVigpO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgPT09IHJvb3QgJiYgaXNTdWJzZXRPZkxhbmVzKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLCBwaW5nZWRMYW5lcykpIHtcbiAgICAvLyBSZWNlaXZlZCBhIHBpbmcgYXQgdGhlIHNhbWUgcHJpb3JpdHkgbGV2ZWwgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5XG4gICAgLy8gcmVuZGVyaW5nLiBXZSBtaWdodCB3YW50IHRvIHJlc3RhcnQgdGhpcyByZW5kZXIuIFRoaXMgc2hvdWxkIG1pcnJvclxuICAgIC8vIHRoZSBsb2dpYyBvZiB3aGV0aGVyIG9yIG5vdCBhIHJvb3Qgc3VzcGVuZHMgb25jZSBpdCBjb21wbGV0ZXMuXG4gICAgLy8gVE9ETzogSWYgd2UncmUgcmVuZGVyaW5nIHN5bmMgZWl0aGVyIGR1ZSB0byBTeW5jLCBCYXRjaGVkIG9yIGV4cGlyZWQsXG4gICAgLy8gd2Ugc2hvdWxkIHByb2JhYmx5IG5ldmVyIHJlc3RhcnQuXG4gICAgLy8gSWYgd2UncmUgc3VzcGVuZGVkIHdpdGggZGVsYXksIG9yIGlmIGl0J3MgYSByZXRyeSwgd2UnbGwgYWx3YXlzIHN1c3BlbmRcbiAgICAvLyBzbyB3ZSBjYW4gYWx3YXlzIHJlc3RhcnQuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgfHwgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZCAmJiBpbmNsdWRlc09ubHlSZXRyaWVzKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSAmJiBub3ckMSgpIC0gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA8IEZBTExCQUNLX1RIUk9UVExFX01TKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlc3RhcnQgZnJvbSB0aGUgcm9vdCBieSB1bndpbmRpbmcgdGhlIHN0YWNrLiBVbmxlc3MgdGhpcyBpc1xuICAgICAgLy8gYmVpbmcgY2FsbGVkIGZyb20gdGhlIHJlbmRlciBwaGFzZSwgYmVjYXVzZSB0aGF0IHdvdWxkIGNhdXNlIGEgY3Jhc2guXG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFdmVuIHRob3VnaCB3ZSBjYW4ndCByZXN0YXJ0IHJpZ2h0IG5vdywgd2UgbWlnaHQgZ2V0IGFuXG4gICAgICAvLyBvcHBvcnR1bml0eSBsYXRlci4gU28gd2UgbWFyayB0aGlzIHJlbmRlciBhcyBoYXZpbmcgYSBwaW5nLlxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzLCBwaW5nZWRMYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xufVxuXG5mdW5jdGlvbiByZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKSB7XG4gIC8vIFRoZSBib3VuZGFyeSBmaWJlciAoYSBTdXNwZW5zZSBjb21wb25lbnQgb3IgU3VzcGVuc2VMaXN0IGNvbXBvbmVudClcbiAgLy8gcHJldmlvdXNseSB3YXMgcmVuZGVyZWQgaW4gaXRzIGZhbGxiYWNrIHN0YXRlLiBPbmUgb2YgdGhlIHByb21pc2VzIHRoYXRcbiAgLy8gc3VzcGVuZGVkIGl0IGhhcyByZXNvbHZlZCwgd2hpY2ggbWVhbnMgYXQgbGVhc3QgcGFydCBvZiB0aGUgdHJlZSB3YXNcbiAgLy8gbGlrZWx5IHVuYmxvY2tlZC4gVHJ5IHJlbmRlcmluZyBhZ2FpbiwgYXQgYSBuZXcgbGFuZXMuXG4gIGlmIChyZXRyeUxhbmUgPT09IE5vTGFuZSkge1xuICAgIC8vIFRPRE86IEFzc2lnbiB0aGlzIHRvIGBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZWA/IHRvIGF2b2lkXG4gICAgLy8gdW5uZWNlc3NhcnkgZW50YW5nbGVtZW50P1xuICAgIHJldHJ5TGFuZSA9IHJlcXVlc3RSZXRyeUxhbmUoKTtcbiAgfSAvLyBUT0RPOiBTcGVjaWFsIGNhc2UgaWRsZSBwcmlvcml0eT9cblxuXG4gIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgcmV0cnlMYW5lKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeShib3VuZGFyeUZpYmVyKSB7XG4gIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlO1xuICB2YXIgcmV0cnlMYW5lID0gTm9MYW5lO1xuXG4gIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsKSB7XG4gICAgcmV0cnlMYW5lID0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmU7XG4gIH1cblxuICByZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVSZXRyeVdha2VhYmxlKGJvdW5kYXJ5RmliZXIsIHdha2VhYmxlKSB7XG4gIHZhciByZXRyeUxhbmUgPSBOb0xhbmU7IC8vIERlZmF1bHRcblxuICB2YXIgcmV0cnlDYWNoZTtcblxuICBzd2l0Y2ggKGJvdW5kYXJ5RmliZXIudGFnKSB7XG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICByZXRyeUxhbmUgPSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICByZXRyeUNhY2hlID0gaW5zdGFuY2UuX3JldHJ5Q2FjaGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGluZ2VkIHVua25vd24gc3VzcGVuc2UgYm91bmRhcnkgdHlwZS4gJyArICdUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicpO1xuICB9XG5cbiAgaWYgKHJldHJ5Q2FjaGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgd2FrZWFibGUgcmVzb2x2ZWQsIHNvIHdlIG5vIGxvbmdlciBuZWVkIHRvIG1lbW9pemUsIGJlY2F1c2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGJlIHRocm93biBhZ2Fpbi5cbiAgICByZXRyeUNhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7XG4gIH1cblxuICByZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcbn1cbmZ1bmN0aW9uIHRocm93SWZJbmZpbml0ZVVwZGF0ZUxvb3BEZXRlY3RlZCgpIHtcbiAgaWYgKG5lc3RlZFVwZGF0ZUNvdW50ID4gTkVTVEVEX1VQREFURV9MSU1JVCkge1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwO1xuICAgIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGw7XG4gICAgcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGw7XG5cbiAgICB7XG4gICAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQgJiYgd29ya0luUHJvZ3Jlc3NSb290ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlJ3JlIGluIHRoZSByZW5kZXIgcGhhc2UuIERpc2FibGUgdGhlIGNvbmN1cnJlbnQgZXJyb3IgcmVjb3ZlcnlcbiAgICAgICAgLy8gbWVjaGFuaXNtIHRvIGVuc3VyZSB0aGF0IHRoZSBlcnJvciB3ZSdyZSBhYm91dCB0byB0aHJvdyBnZXRzIGhhbmRsZWQuXG4gICAgICAgIC8vIFdlIG5lZWQgaXQgdG8gdHJpZ2dlciB0aGUgbmVhcmVzdCBlcnJvciBib3VuZGFyeSBzbyB0aGF0IHRoZSBpbmZpbml0ZVxuICAgICAgICAvLyB1cGRhdGUgbG9vcCBpcyBicm9rZW4uXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290LmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgJyArICdyZXBlYXRlZGx5IGNhbGxzIHNldFN0YXRlIGluc2lkZSBjb21wb25lbnRXaWxsVXBkYXRlIG9yICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byAnICsgJ3ByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7XG4gIH1cblxuICB7XG4gICAgaWYgKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA+IE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCkge1xuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcbiAgICAgIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsO1xuXG4gICAgICBlcnJvcignTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50ICcgKyBcImNhbGxzIHNldFN0YXRlIGluc2lkZSB1c2VFZmZlY3QsIGJ1dCB1c2VFZmZlY3QgZWl0aGVyIGRvZXNuJ3QgXCIgKyAnaGF2ZSBhIGRlcGVuZGVuY3kgYXJyYXksIG9yIG9uZSBvZiB0aGUgZGVwZW5kZW5jaWVzIGNoYW5nZXMgb24gJyArICdldmVyeSByZW5kZXIuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoUmVuZGVyUGhhc2VTdHJpY3RNb2RlV2FybmluZ3NJbkRFVigpIHtcbiAge1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcoKTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCwgcGFyZW50RmliZXIsIGlzSW5TdHJpY3RNb2RlKSB7XG4gIGlmICgocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgKFBsYWNlbWVudERFViB8IFZpc2liaWxpdHkpKSA9PT0gTm9GbGFncyQxKSB7XG4gICAgLy8gUGFyZW50J3MgZGVzY2VuZGFudHMgaGF2ZSBhbHJlYWR5IGhhZCBlZmZlY3RzIGRvdWJsZSBpbnZva2VkLlxuICAgIC8vIEVhcmx5IGV4aXQgdG8gYXZvaWQgdW5uZWNlc3NhcnkgdHJlZSB0cmF2ZXJzYWwuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gcGFyZW50RmliZXIuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgZG91YmxlSW52b2tlRWZmZWN0c0luREVWSWZOZWNlc3Nhcnkocm9vdCwgY2hpbGQsIGlzSW5TdHJpY3RNb2RlKTtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn0gLy8gVW5jb25kaXRpb25hbGx5IGRpc2Nvbm5lY3RzIGFuZCBjb25uZWN0cyBwYXNzaXZlIGFuZCBsYXlvdXQgZWZmZWN0cy5cblxuXG5mdW5jdGlvbiBkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlcihyb290LCBmaWJlcikge1xuICB2YXIgc2hvdWxkRG91YmxlSW52b2tlUGFzc2l2ZUVmZmVjdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuICBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpYmVyKTtcblxuICBpZiAoc2hvdWxkRG91YmxlSW52b2tlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChmaWJlcik7XG4gIH1cblxuICByZWFwcGVhckxheW91dEVmZmVjdHMocm9vdCwgZmliZXIuYWx0ZXJuYXRlLCBmaWJlciwgZmFsc2UpO1xuXG4gIGlmIChzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cykge1xuICAgIHJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKHJvb3QsIGZpYmVyLCBOb0xhbmVzLCBudWxsLCBmYWxzZSk7XG4gIH1cblxuICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGRvdWJsZUludm9rZUVmZmVjdHNJbkRFVklmTmVjZXNzYXJ5KHJvb3QsIGZpYmVyLCBwYXJlbnRJc0luU3RyaWN0TW9kZSkge1xuICB2YXIgaXNTdHJpY3RNb2RlRmliZXIgPSBmaWJlci50eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuICB2YXIgaXNJblN0cmljdE1vZGUgPSBwYXJlbnRJc0luU3RyaWN0TW9kZSB8fCBpc1N0cmljdE1vZGVGaWJlcjsgLy8gRmlyc3QgY2FzZTogdGhlIGZpYmVyICoqaXMgbm90Kiogb2YgdHlwZSBPZmZzY3JlZW5Db21wb25lbnQuIE5vXG4gIC8vIHNwZWNpYWwgcnVsZXMgYXBwbHkgdG8gZG91YmxlIGludm9raW5nIGVmZmVjdHMuXG5cbiAgaWYgKGZpYmVyLnRhZyAhPT0gT2Zmc2NyZWVuQ29tcG9uZW50KSB7XG4gICAgaWYgKGZpYmVyLmZsYWdzICYgUGxhY2VtZW50REVWKSB7XG4gICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpYmVyKTtcblxuICAgICAgaWYgKGlzSW5TdHJpY3RNb2RlKSB7XG4gICAgICAgIGRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyKHJvb3QsIGZpYmVyLCAoZmliZXIubW9kZSAmIE5vU3RyaWN0UGFzc2l2ZUVmZmVjdHNNb2RlKSA9PT0gTm9Nb2RlKTtcbiAgICAgIH1cblxuICAgICAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCwgZmliZXIsIGlzSW5TdHJpY3RNb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0gLy8gU2Vjb25kIGNhc2U6IHRoZSBmaWJlciAqKmlzKiogb2YgdHlwZSBPZmZzY3JlZW5Db21wb25lbnQuXG4gIC8vIFRoaXMgYnJhbmNoIGNvbnRhaW5zIGNhc2VzIHNwZWNpZmljIHRvIE9mZnNjcmVlbi5cblxuXG4gIGlmIChmaWJlci5tZW1vaXplZFN0YXRlID09PSBudWxsKSB7XG4gICAgLy8gT25seSBjb25zaWRlciBPZmZzY3JlZW4gdGhhdCBpcyB2aXNpYmxlLlxuICAgIC8vIFRPRE8gKE9mZnNjcmVlbikgSGFuZGxlIG1hbnVhbCBtb2RlLlxuICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmliZXIpO1xuXG4gICAgaWYgKGlzSW5TdHJpY3RNb2RlICYmIGZpYmVyLmZsYWdzICYgVmlzaWJpbGl0eSkge1xuICAgICAgLy8gRG91YmxlIGludm9rZSBlZmZlY3RzIG9uIE9mZnNjcmVlbidzIHN1YnRyZWUgb25seVxuICAgICAgLy8gaWYgaXQgaXMgdmlzaWJsZSBhbmQgaXRzIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQuXG4gICAgICBkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlcihyb290LCBmaWJlcik7XG4gICAgfSBlbHNlIGlmIChmaWJlci5zdWJ0cmVlRmxhZ3MgJiBQbGFjZW1lbnRERVYpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBpbiB0aGUgc3VidHJlZSBjb3VsZCBoYXZlIGJlZW4gc3VzcGVuZGVkLlxuICAgICAgLy8gV2UgbmVlZCB0byBjb250aW51ZSB0cmF2ZXJzYWwgYW5kIGZpbmQgbmV3bHkgaW5zZXJ0ZWQgZmliZXJzLlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290LCBmaWJlciwgaXNJblN0cmljdE1vZGUpO1xuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290LCBoYXNQYXNzaXZlRWZmZWN0cykge1xuICB7XG4gICAge1xuICAgICAgdmFyIGRvdWJsZUludm9rZUVmZmVjdHMgPSB0cnVlO1xuXG4gICAgICBpZiAoIShyb290LmN1cnJlbnQubW9kZSAmIChTdHJpY3RMZWdhY3lNb2RlIHwgU3RyaWN0RWZmZWN0c01vZGUpKSkge1xuICAgICAgICBkb3VibGVJbnZva2VFZmZlY3RzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCwgcm9vdC5jdXJyZW50LCBkb3VibGVJbnZva2VFZmZlY3RzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBudWxsO1xuZnVuY3Rpb24gd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihmaWJlcikge1xuICB7XG4gICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dCkge1xuICAgICAgLy8gV2UgbGV0IHRoZSBvdGhlciB3YXJuaW5nIGFib3V0IHJlbmRlciBwaGFzZSB1cGRhdGVzIGRlYWwgd2l0aCB0aGlzIG9uZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuXG4gICAgaWYgKHRhZyAhPT0gSG9zdFJvb3QgJiYgdGFnICE9PSBDbGFzc0NvbXBvbmVudCAmJiB0YWcgIT09IEZ1bmN0aW9uQ29tcG9uZW50ICYmIHRhZyAhPT0gRm9yd2FyZFJlZiAmJiB0YWcgIT09IE1lbW9Db21wb25lbnQgJiYgdGFnICE9PSBTaW1wbGVNZW1vQ29tcG9uZW50KSB7XG4gICAgICAvLyBPbmx5IHdhcm4gZm9yIHVzZXItZGVmaW5lZCBjb21wb25lbnRzLCBub3QgaW50ZXJuYWwgb25lcyBsaWtlIFN1c3BlbnNlLlxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gV2Ugc2hvdyB0aGUgd2hvbGUgc3RhY2sgYnV0IGRlZHVwZSBvbiB0aGUgdG9wIGNvbXBvbmVudCdzIG5hbWUgYmVjYXVzZVxuICAgIC8vIHRoZSBwcm9ibGVtYXRpYyBjb2RlIGFsbW9zdCBhbHdheXMgbGllcyBpbnNpZGUgdGhhdCBjb21wb25lbnQuXG5cblxuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1JlYWN0Q29tcG9uZW50JztcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG5ldyBTZXQoW2NvbXBvbmVudE5hbWVdKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICB0cnkge1xuICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaWJlcik7XG5cbiAgICAgIGVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gXCIgKyAnVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgJyArICdhc3luY2hyb25vdXNseSBsYXRlciBjYWxscyB0cmllcyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudC4gTW92ZSB0aGlzIHdvcmsgdG8gJyArICd1c2VFZmZlY3QgaW5zdGVhZC4nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaWJlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnZhciBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9IGZhbHNlO1xudmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudDtcblxue1xuICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQgPSBuZXcgU2V0KCk7XG59XG5cbmZ1bmN0aW9uIHdhcm5BYm91dFJlbmRlclBoYXNlVXBkYXRlc0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJpbmdDb21wb25lbnROYW1lID0gd29ya0luUHJvZ3Jlc3MgJiYgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nOyAvLyBEZWR1cGUgYnkgdGhlIHJlbmRlcmluZyBjb21wb25lbnQgYmVjYXVzZSBpdCdzIHRoZSBvbmUgdGhhdCBuZWVkcyB0byBiZSBmaXhlZC5cblxuICAgICAgICAgICAgdmFyIGRlZHVwZUtleSA9IHJlbmRlcmluZ0NvbXBvbmVudE5hbWU7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmhhcyhkZWR1cGVLZXkpKSB7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5hZGQoZGVkdXBlS2V5KTtcbiAgICAgICAgICAgICAgdmFyIHNldFN0YXRlQ29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IHVwZGF0ZSBhIGNvbXBvbmVudCAoYCVzYCkgd2hpbGUgcmVuZGVyaW5nIGEgJyArICdkaWZmZXJlbnQgY29tcG9uZW50IChgJXNgKS4gVG8gbG9jYXRlIHRoZSBiYWQgc2V0U3RhdGUoKSBjYWxsIGluc2lkZSBgJXNgLCAnICsgJ2ZvbGxvdyB0aGUgc3RhY2sgdHJhY2UgYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc2V0c3RhdGUtaW4tcmVuZGVyJywgc2V0U3RhdGVDb21wb25lbnROYW1lLCByZW5kZXJpbmdDb21wb25lbnROYW1lLCByZW5kZXJpbmdDb21wb25lbnROYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlcikge1xuICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyAnICsgJ3dpdGhpbiBgcmVuZGVyYCkuIFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgJyArICdmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuJyk7XG5cbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgbGFuZXMpIHtcbiAge1xuICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICBtZW1vaXplZFVwZGF0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHNjaGVkdWxpbmdGaWJlcikge1xuICAgICAgICBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgc2NoZWR1bGluZ0ZpYmVyLCBsYW5lcyk7XG4gICAgICB9KTsgLy8gVGhpcyBmdW5jdGlvbiBpbnRlbnRpb25hbGx5IGRvZXMgbm90IGNsZWFyIG1lbW9pemVkIHVwZGF0ZXJzLlxuICAgICAgLy8gVGhvc2UgbWF5IHN0aWxsIGJlIHJlbGV2YW50IHRvIHRoZSBjdXJyZW50IGNvbW1pdFxuICAgICAgLy8gYW5kIGEgZnV0dXJlIG9uZSAoZS5nLiBTdXNwZW5zZSkuXG4gICAgfVxuICB9XG59XG52YXIgZmFrZUFjdENhbGxiYWNrTm9kZSA9IHt9OyAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG5cbmZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spIHtcbiAge1xuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYW4gYGFjdGAgc2NvcGUsIGJ5cGFzcyBTY2hlZHVsZXIgYW5kIHB1c2ggdG9cbiAgICAvLyB0aGUgYGFjdGAgcXVldWUgaW5zdGVhZC5cbiAgICB2YXIgYWN0UXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZTtcblxuICAgIGlmIChhY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgYWN0UXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgICByZXR1cm4gZmFrZUFjdENhbGxiYWNrTm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2skMyhwcmlvcml0eUxldmVsLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpIHtcbiAgLy8gTmV2ZXIgZm9yY2UgZmx1c2ggaW4gcHJvZHVjdGlvbi4gVGhpcyBmdW5jdGlvbiBzaG91bGQgZ2V0IHN0cmlwcGVkIG91dC5cbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpIHtcbiAge1xuICAgIHtcbiAgICAgIGlmICghaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSkge1xuICAgICAgICAvLyBOb3QgaW4gYW4gYWN0IGVudmlyb25tZW50LiBObyBuZWVkIHRvIHdhcm4uXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaWJlcik7XG5cbiAgICAgICAgZXJyb3IoJ0FuIHVwZGF0ZSB0byAlcyBpbnNpZGUgYSB0ZXN0IHdhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG4nICsgJ1doZW4gdGVzdGluZywgY29kZSB0aGF0IGNhdXNlcyBSZWFjdCBzdGF0ZSB1cGRhdGVzIHNob3VsZCBiZSAnICsgJ3dyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG4nICsgJ2FjdCgoKSA9PiB7XFxuJyArICcgIC8qIGZpcmUgZXZlbnRzIHRoYXQgdXBkYXRlIHN0YXRlICovXFxuJyArICd9KTtcXG4nICsgJy8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuJyArIFwiVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBcIiArICdpbiB0aGUgYnJvd3Nlci4nICsgJyBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdCcsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChwcmV2aW91c0ZpYmVyKSB7XG4gICAgICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybklmU3VzcGVuc2VSZXNvbHV0aW9uTm90V3JhcHBlZFdpdGhBY3RERVYocm9vdCkge1xuICB7XG4gICAgaWYgKGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkgJiYgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPT09IG51bGwpIHtcbiAgICAgIGVycm9yKCdBIHN1c3BlbmRlZCByZXNvdXJjZSBmaW5pc2hlZCBsb2FkaW5nIGluc2lkZSBhIHRlc3QsIGJ1dCB0aGUgZXZlbnQgJyArICd3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJyArICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCByZXNvbHZlcyBzdXNwZW5kZWQgZGF0YSBzaG91bGQgYmUgd3JhcHBlZCAnICsgJ2ludG8gYWN0KC4uLik6XFxuXFxuJyArICdhY3QoKCkgPT4ge1xcbicgKyAnICAvKiBmaW5pc2ggbG9hZGluZyBzdXNwZW5kZWQgZGF0YSAqL1xcbicgKyAnfSk7XFxuJyArICcvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicgKyBcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIgKyAnaW4gdGhlIGJyb3dzZXIuJyArICcgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0LmRldi9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3QnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGlzUnVubmluZykge1xuICB7XG4gICAgaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gaXNSdW5uaW5nO1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXMgKi9cbi8vIFVzZWQgYnkgUmVhY3QgUmVmcmVzaCBydW50aW1lIHRocm91Z2ggRGV2VG9vbHMgR2xvYmFsIEhvb2suXG5cbnZhciByZXNvbHZlRmFtaWx5ID0gbnVsbDtcbnZhciBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbnZhciBzZXRSZWZyZXNoSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gIHtcbiAgICByZXNvbHZlRmFtaWx5ID0gaGFuZGxlcjtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cbiAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIC8vIE5vIGltcGxlbWVudGF0aW9uIGRpZmZlcmVuY2VzLlxuICByZXR1cm4gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseSh0eXBlKTtcblxuICAgIGlmIChmYW1pbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEgcmVhbCBmb3J3YXJkUmVmLiBEb24ndCB3YW50IHRvIGNyYXNoIGVhcmx5LlxuICAgICAgaWYgKHR5cGUgIT09IG51bGwgJiYgdHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBGb3J3YXJkUmVmIGlzIHNwZWNpYWwgYmVjYXVzZSBpdHMgcmVzb2x2ZWQgLnR5cGUgaXMgYW4gb2JqZWN0LFxuICAgICAgICAvLyBidXQgaXQncyBwb3NzaWJsZSB0aGF0IHdlIG9ubHkgaGF2ZSBpdHMgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGluIHRoZSBtYXAuXG4gICAgICAgIC8vIElmIHRoYXQgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGlzIGRpZmZlcmVudCwgd2UnbGwgYnVpbGQgYSBuZXcgZm9yd2FyZFJlZiB0eXBlLlxuICAgICAgICB2YXIgY3VycmVudFJlbmRlciA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlLnJlbmRlcik7XG5cbiAgICAgICAgaWYgKHR5cGUucmVuZGVyICE9PSBjdXJyZW50UmVuZGVyKSB7XG4gICAgICAgICAgdmFyIHN5bnRoZXRpY1R5cGUgPSB7XG4gICAgICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICAgICAgICAgIHJlbmRlcjogY3VycmVudFJlbmRlclxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzeW50aGV0aWNUeXBlLmRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3ludGhldGljVHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cbiAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhmaWJlciwgZWxlbWVudCkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHByZXZUeXBlID0gZmliZXIuZWxlbWVudFR5cGU7XG4gICAgdmFyIG5leHRUeXBlID0gZWxlbWVudC50eXBlOyAvLyBJZiB3ZSBnb3QgaGVyZSwgd2Uga25vdyB0eXBlcyBhcmVuJ3QgPT09IGVxdWFsLlxuXG4gICAgdmFyIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gZmFsc2U7XG4gICAgdmFyICQkdHlwZW9mTmV4dFR5cGUgPSB0eXBlb2YgbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIG5leHRUeXBlICE9PSBudWxsID8gbmV4dFR5cGUuJCR0eXBlb2YgOiBudWxsO1xuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5leHRUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV4dFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyB0aGUgaW5uZXIgdHlwZSB5ZXQuXG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBhc3N1bWUgdGhhdCB0aGUgbGF6eSBpbm5lciB0eXBlIGlzIHN0YWJsZSxcbiAgICAgICAgICAgIC8vIGFuZCBzbyBpdCBpcyBzdWZmaWNpZW50IHRvIGF2b2lkIHJlY29uY2lsaW5nIGl0IGF3YXkuXG4gICAgICAgICAgICAvLyBXZSdyZSBub3QgZ29pbmcgdG8gdW53cmFwIG9yIGFjdHVhbGx5IHVzZSB0aGUgbmV3IGxhenkgdHlwZS5cbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgICAgICAgLy8gVE9ETzogaWYgaXQgd2FzIGJ1dCBjYW4gbm8gbG9uZ2VyIGJlIHNpbXBsZSxcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZG4ndCBzZXQgdGhpcy5cbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIENoZWNrIGlmIGJvdGggdHlwZXMgaGF2ZSBhIGZhbWlseSBhbmQgaXQncyB0aGUgc2FtZSBvbmUuXG5cblxuICAgIGlmIChuZWVkc0NvbXBhcmVGYW1pbGllcykge1xuICAgICAgLy8gTm90ZTogbWVtbygpIGFuZCBmb3J3YXJkUmVmKCkgd2UnbGwgY29tcGFyZSBvdXRlciByYXRoZXIgdGhhbiBpbm5lciB0eXBlLlxuICAgICAgLy8gVGhpcyBtZWFucyBib3RoIG9mIHRoZW0gbmVlZCB0byBiZSByZWdpc3RlcmVkIHRvIHByZXNlcnZlIHN0YXRlLlxuICAgICAgLy8gSWYgd2UgdW53cmFwcGVkIGFuZCBjb21wYXJlZCB0aGUgaW5uZXIgdHlwZXMgZm9yIHdyYXBwZXJzIGluc3RlYWQsXG4gICAgICAvLyB0aGVuIHdlIHdvdWxkIHJpc2sgZmFsc2VseSBzYXlpbmcgdHdvIHNlcGFyYXRlIG1lbW8oRm9vKVxuICAgICAgLy8gY2FsbHMgYXJlIGVxdWl2YWxlbnQgYmVjYXVzZSB0aGV5IHdyYXAgdGhlIHNhbWUgRm9vIGZ1bmN0aW9uLlxuICAgICAgdmFyIHByZXZGYW1pbHkgPSByZXNvbHZlRmFtaWx5KHByZXZUeXBlKTsgLy8gJEZsb3dGaXhNZVtub3QtYS1mdW5jdGlvbl0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG4gICAgICBpZiAocHJldkZhbWlseSAhPT0gdW5kZWZpbmVkICYmIHByZXZGYW1pbHkgPT09IHJlc29sdmVGYW1pbHkobmV4dFR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgV2Vha1NldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFdlYWtTZXQoKTtcbiAgICB9XG5cbiAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChmaWJlcik7XG4gIH1cbn1cbnZhciBzY2hlZHVsZVJlZnJlc2ggPSBmdW5jdGlvbiAocm9vdCwgdXBkYXRlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhbGVGYW1pbGllcyA9IHVwZGF0ZS5zdGFsZUZhbWlsaWVzLFxuICAgICAgICB1cGRhdGVkRmFtaWxpZXMgPSB1cGRhdGUudXBkYXRlZEZhbWlsaWVzO1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KHJvb3QuY3VycmVudCwgdXBkYXRlZEZhbWlsaWVzLCBzdGFsZUZhbWlsaWVzKTtcbiAgICBmbHVzaFN5bmNXb3JrKCk7XG4gIH1cbn07XG52YXIgc2NoZWR1bGVSb290ID0gZnVuY3Rpb24gKHJvb3QsIGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChyb290LmNvbnRleHQgIT09IGVtcHR5Q29udGV4dE9iamVjdCkge1xuICAgICAgLy8gU3VwZXIgZWRnZSBjYXNlOiByb290IGhhcyBhIGxlZ2FjeSBfcmVuZGVyU3VidHJlZSBjb250ZXh0XG4gICAgICAvLyBidXQgd2UgZG9uJ3Qga25vdyB0aGUgcGFyZW50Q29tcG9uZW50IHNvIHdlIGNhbid0IHBhc3MgaXQuXG4gICAgICAvLyBKdXN0IGlnbm9yZS4gV2UnbGwgZGVsZXRlIHRoaXMgd2l0aCBfcmVuZGVyU3VidHJlZSBjb2RlIHBhdGggbGF0ZXIuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdXBkYXRlQ29udGFpbmVyU3luYyhlbGVtZW50LCByb290LCBudWxsLCBudWxsKTtcbiAgICBmbHVzaFN5bmNXb3JrKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoZmliZXIsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcykge1xuICB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZXNvbHZlRmFtaWx5IHRvIGJlIHNldCBkdXJpbmcgaG90IHJlbG9hZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZHNSZW5kZXIgPSBmYWxzZTtcbiAgICB2YXIgbmVlZHNSZW1vdW50ID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkoY2FuZGlkYXRlVHlwZSk7XG5cbiAgICAgIGlmIChmYW1pbHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3RhbGVGYW1pbGllcy5oYXMoZmFtaWx5KSkge1xuICAgICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodXBkYXRlZEZhbWlsaWVzLmhhcyhmYW1pbHkpKSB7XG4gICAgICAgICAgaWYgKHRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lZWRzUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmFpbGVkQm91bmRhcmllcyAhPT0gbnVsbCkge1xuICAgICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgIGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBmYWlsZWRCb3VuZGFyaWVzLmhhcyhhbHRlcm5hdGUpKSB7XG4gICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzUmVtb3VudCkge1xuICAgICAgZmliZXIuX2RlYnVnTmVlZHNSZW1vdW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobmVlZHNSZW1vdW50IHx8IG5lZWRzUmVuZGVyKSB7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwgJiYgIW5lZWRzUmVtb3VudCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShjaGlsZCwgdXBkYXRlZEZhbWlsaWVzLCBzdGFsZUZhbWlsaWVzKTtcbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShzaWJsaW5nLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoID0gZnVuY3Rpb24gKHJvb3QsIGZhbWlsaWVzKSB7XG4gIHtcbiAgICB2YXIgaG9zdEluc3RhbmNlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgdHlwZXMgPSBuZXcgU2V0KGZhbWlsaWVzLm1hcChmdW5jdGlvbiAoZmFtaWx5KSB7XG4gICAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gICAgfSkpO1xuICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICByZXR1cm4gaG9zdEluc3RhbmNlcztcbiAgfVxufTtcblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KGZpYmVyLCB0eXBlcywgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQsXG4gICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuICAgIHZhciBjYW5kaWRhdGVUeXBlID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGRpZE1hdGNoID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVzLmhhcyhjYW5kaWRhdGVUeXBlKSkge1xuICAgICAgICBkaWRNYXRjaCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpZE1hdGNoKSB7XG4gICAgICAvLyBXZSBoYXZlIGEgbWF0Y2guIFRoaXMgb25seSBkcmlsbHMgZG93biB0byB0aGUgY2xvc2VzdCBob3N0IGNvbXBvbmVudHMuXG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoIGRlZXBlciBiZWNhdXNlIGZvciB0aGUgcHVycG9zZSBvZiBnaXZpbmdcbiAgICAgIC8vIHZpc3VhbCBmZWVkYmFjaywgXCJmbGFzaGluZ1wiIG91dGVybW9zdCBwYXJlbnQgcmVjdGFuZ2xlcyBpcyBzdWZmaWNpZW50LlxuICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbWF0Y2gsIG1heWJlIHRoZXJlIHdpbGwgYmUgb25lIGZ1cnRoZXIgZG93biBpbiB0aGUgY2hpbGQgdHJlZS5cbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoY2hpbGQsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIGZvdW5kSG9zdEluc3RhbmNlcyA9IGZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG5cbiAgICBpZiAoZm91bmRIb3N0SW5zdGFuY2VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnkgaG9zdCBjaGlsZHJlbiwgZmFsbGJhY2sgdG8gY2xvc2VzdCBob3N0IHBhcmVudC5cblxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gcmVhY2ggcm9vdCBmaXJzdC4nKTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ2hpbGRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsIGhvc3RJbnN0YW5jZXMpIHtcbiAge1xuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgdmFyIGZvdW5kSG9zdEluc3RhbmNlcyA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCAoc3VwcG9ydHNTaW5nbGV0b25zID8gbm9kZS50YWcgPT09IEhvc3RTaW5nbGV0b24gOiBmYWxzZSkpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgbWF0Y2guXG4gICAgICAgIGZvdW5kSG9zdEluc3RhbmNlcyA9IHRydWU7XG4gICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTsgLy8gVGhlcmUgbWF5IHN0aWxsIGJlIG1vcmUsIHNvIGtlZXAgc2VhcmNoaW5nLlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBoYXNCYWRNYXBQb2x5ZmlsbDtcblxue1xuICBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbiAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgLy8gSW5zdGFuY2VcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLmVsZW1lbnRUeXBlID0gbnVsbDtcbiAgdGhpcy50eXBlID0gbnVsbDtcbiAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsOyAvLyBGaWJlclxuXG4gIHRoaXMucmV0dXJuID0gbnVsbDtcbiAgdGhpcy5jaGlsZCA9IG51bGw7XG4gIHRoaXMuc2libGluZyA9IG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuICB0aGlzLnJlZiA9IG51bGw7XG4gIHRoaXMucmVmQ2xlYW51cCA9IG51bGw7XG4gIHRoaXMucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgdGhpcy5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICB0aGlzLm1vZGUgPSBtb2RlOyAvLyBFZmZlY3RzXG5cbiAgdGhpcy5mbGFncyA9IE5vRmxhZ3MkMTtcbiAgdGhpcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzJDE7XG4gIHRoaXMuZGVsZXRpb25zID0gbnVsbDtcbiAgdGhpcy5sYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuICB7XG4gICAgLy8gTm90ZTogVGhlIGZvbGxvd2luZyBpcyBkb25lIHRvIGF2b2lkIGEgdjggcGVyZm9ybWFuY2UgY2xpZmYuXG4gICAgLy9cbiAgICAvLyBJbml0aWFsaXppbmcgdGhlIGZpZWxkcyBiZWxvdyB0byBzbWlzIGFuZCBsYXRlciB1cGRhdGluZyB0aGVtIHdpdGhcbiAgICAvLyBkb3VibGUgdmFsdWVzIHdpbGwgY2F1c2UgRmliZXJzIHRvIGVuZCB1cCBoYXZpbmcgc2VwYXJhdGUgc2hhcGVzLlxuICAgIC8vIFRoaXMgYmVoYXZpb3IvYnVnIGhhcyBzb21ldGhpbmcgdG8gZG8gd2l0aCBPYmplY3QucHJldmVudEV4dGVuc2lvbigpLlxuICAgIC8vIEZvcnR1bmF0ZWx5IHRoaXMgb25seSBpbXBhY3RzIERFViBidWlsZHMuXG4gICAgLy8gVW5mb3J0dW5hdGVseSBpdCBtYWtlcyBSZWFjdCB1bnVzYWJseSBzbG93IGZvciBzb21lIGFwcGxpY2F0aW9ucy5cbiAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCBpbml0aWFsaXplIHRoZSBmaWVsZHMgYmVsb3cgd2l0aCBkb3VibGVzLlxuICAgIC8vXG4gICAgLy8gTGVhcm4gbW9yZSBhYm91dCB0aGlzIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDM2NVxuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTg1MzhcbiAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IE51bWJlci5OYU47XG4gICAgdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSBOdW1iZXIuTmFOOyAvLyBJdCdzIG9rYXkgdG8gcmVwbGFjZSB0aGUgaW5pdGlhbCBkb3VibGVzIHdpdGggc21pcyBhZnRlciBpbml0aWFsaXphdGlvbi5cbiAgICAvLyBUaGlzIHdvbid0IHRyaWdnZXIgdGhlIHBlcmZvcm1hbmNlIGNsaWZmIG1lbnRpb25lZCBhYm92ZSxcbiAgICAvLyBhbmQgaXQgc2ltcGxpZmllcyBvdGhlciBwcm9maWxlciBjb2RlIChpbmNsdWRpbmcgRGV2VG9vbHMpLlxuXG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gIH1cblxuICB7XG4gICAgLy8gVGhpcyBpc24ndCBkaXJlY3RseSB1c2VkIGJ1dCBpcyBoYW5keSBmb3IgZGVidWdnaW5nIGludGVybmFsczpcbiAgICB0aGlzLl9kZWJ1Z0luZm8gPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnT3duZXIgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnTmVlZHNSZW1vdW50ID0gZmFsc2U7XG4gICAgdGhpcy5fZGVidWdIb29rVHlwZXMgPSBudWxsO1xuXG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59IC8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbnN0cnVjdG9yXTogdGhlIHNoYXBlcyBhcmUgZXhhY3QgaGVyZSBidXQgRmxvdyBkb2Vzbid0IGxpa2UgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhc2hvdWxkQ29uc3RydWN0KHR5cGUpICYmIHR5cGUuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uQ2xhc3NDb21wb25lbnQodHlwZSkge1xuICByZXR1cm4gc2hvdWxkQ29uc3RydWN0KHR5cGUpO1xufSAvLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGFuIGFsdGVybmF0ZSBmaWJlciB0byBkbyB3b3JrIG9uLlxuXG5mdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBwZW5kaW5nUHJvcHMpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzID09PSBudWxsKSB7XG4gICAgLy8gV2UgdXNlIGEgZG91YmxlIGJ1ZmZlcmluZyBwb29saW5nIHRlY2huaXF1ZSBiZWNhdXNlIHdlIGtub3cgdGhhdCB3ZSdsbFxuICAgIC8vIG9ubHkgZXZlciBuZWVkIGF0IG1vc3QgdHdvIHZlcnNpb25zIG9mIGEgdHJlZS4gV2UgcG9vbCB0aGUgXCJvdGhlclwiIHVudXNlZFxuICAgIC8vIG5vZGUgdGhhdCB3ZSdyZSBmcmVlIHRvIHJldXNlLiBUaGlzIGlzIGxhemlseSBjcmVhdGVkIHRvIGF2b2lkIGFsbG9jYXRpbmdcbiAgICAvLyBleHRyYSBvYmplY3RzIGZvciB0aGluZ3MgdGhhdCBhcmUgbmV2ZXIgdXBkYXRlZC4gSXQgYWxzbyBhbGxvdyB1cyB0b1xuICAgIC8vIHJlY2xhaW0gdGhlIGV4dHJhIG1lbW9yeSBpZiBuZWVkZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVGaWJlcihjdXJyZW50LnRhZywgcGVuZGluZ1Byb3BzLCBjdXJyZW50LmtleSwgY3VycmVudC5tb2RlKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9IGN1cnJlbnQuZWxlbWVudFR5cGU7XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIC8vIERFVi1vbmx5IGZpZWxkc1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gY3VycmVudC5fZGVidWdIb29rVHlwZXM7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wczsgLy8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cblxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7IC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IE5vRmxhZ3MkMTsgLy8gVGhlIGVmZmVjdHMgYXJlIG5vIGxvbmdlciB2YWxpZC5cblxuICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3MkMTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBudWxsO1xuXG4gICAge1xuICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSByZXNldCwgcmF0aGVyIHRoYW4gY29weSwgYWN0dWFsRHVyYXRpb24gJiBhY3R1YWxTdGFydFRpbWUuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHRpbWUgZnJvbSBlbmRsZXNzbHkgYWNjdW11bGF0aW5nIGluIG5ldyBjb21taXRzLlxuICAgICAgLy8gVGhpcyBoYXMgdGhlIGRvd25zaWRlIG9mIHJlc2V0dGluZyB2YWx1ZXMgZm9yIGRpZmZlcmVudCBwcmlvcml0eSByZW5kZXJzLFxuICAgICAgLy8gQnV0IHdvcmtzIGZvciB5aWVsZGluZyAodGhlIGNvbW1vbiBjYXNlKSBhbmQgc2hvdWxkIHN1cHBvcnQgcmVzdW1pbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB9XG4gIH0gLy8gUmVzZXQgYWxsIGVmZmVjdHMgZXhjZXB0IHN0YXRpYyBvbmVzLlxuICAvLyBTdGF0aWMgZWZmZWN0cyBhcmUgbm90IHNwZWNpZmljIHRvIGEgcmVuZGVyLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBjdXJyZW50LmZsYWdzICYgU3RhdGljTWFzaztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcztcbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gQ2xvbmUgdGhlIGRlcGVuZGVuY2llcyBvYmplY3QuIFRoaXMgaXMgbXV0YXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgc29cbiAgLy8gaXQgY2Fubm90IGJlIHNoYXJlZCB3aXRoIHRoZSBjdXJyZW50IGZpYmVyLlxuXG4gIHZhciBjdXJyZW50RGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMgPT09IG51bGwgPyBudWxsIDoge1xuICAgIGxhbmVzOiBjdXJyZW50RGVwZW5kZW5jaWVzLmxhbmVzLFxuICAgIGZpcnN0Q29udGV4dDogY3VycmVudERlcGVuZGVuY2llcy5maXJzdENvbnRleHRcbiAgfTsgLy8gVGhlc2Ugd2lsbCBiZSBvdmVycmlkZGVuIGR1cmluZyB0aGUgcGFyZW50J3MgcmVjb25jaWxpYXRpb25cblxuICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICB3b3JrSW5Qcm9ncmVzcy5pbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuICB3b3JrSW5Qcm9ncmVzcy5yZWZDbGVhbnVwID0gY3VycmVudC5yZWZDbGVhbnVwO1xuXG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudC5zZWxmQmFzZUR1cmF0aW9uO1xuICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gIH1cblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSW5mbyA9IGN1cnJlbnQuX2RlYnVnSW5mbztcbiAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQgPSBjdXJyZW50Ll9kZWJ1Z05lZWRzUmVtb3VudDtcblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59IC8vIFVzZWQgdG8gcmV1c2UgYSBGaWJlciBmb3IgYSBzZWNvbmQgcGFzcy5cblxuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyByZXNldHMgdGhlIEZpYmVyIHRvIHdoYXQgY3JlYXRlRmliZXIgb3IgY3JlYXRlV29ya0luUHJvZ3Jlc3Mgd291bGRcbiAgLy8gaGF2ZSBzZXQgdGhlIHZhbHVlcyB0byBiZWZvcmUgZHVyaW5nIHRoZSBmaXJzdCBwYXNzLiBJZGVhbGx5IHRoaXMgd291bGRuJ3RcbiAgLy8gYmUgbmVjZXNzYXJ5IGJ1dCB1bmZvcnR1bmF0ZWx5IG1hbnkgY29kZSBwYXRocyByZWFkcyBmcm9tIHRoZSB3b3JrSW5Qcm9ncmVzc1xuICAvLyB3aGVuIHRoZXkgc2hvdWxkIGJlIHJlYWRpbmcgZnJvbSBjdXJyZW50IGFuZCB3cml0aW5nIHRvIHdvcmtJblByb2dyZXNzLlxuICAvLyBXZSBhc3N1bWUgcGVuZGluZ1Byb3BzLCBpbmRleCwga2V5LCByZWYsIHJldHVybiBhcmUgc3RpbGwgdW50b3VjaGVkIHRvXG4gIC8vIGF2b2lkIGRvaW5nIGFub3RoZXIgcmVjb25jaWxpYXRpb24uXG4gIC8vIFJlc2V0IHRoZSBlZmZlY3QgZmxhZ3MgYnV0IGtlZXAgYW55IFBsYWNlbWVudCB0YWdzLCBzaW5jZSB0aGF0J3Mgc29tZXRoaW5nXG4gIC8vIHRoYXQgY2hpbGQgZmliZXIgaXMgc2V0dGluZywgbm90IHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gU3RhdGljTWFzayB8IFBsYWNlbWVudDsgLy8gVGhlIGVmZmVjdHMgYXJlIG5vIGxvbmdlciB2YWxpZC5cblxuICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIFJlc2V0IHRvIGNyZWF0ZUZpYmVyJ3MgaW5pdGlhbCB2YWx1ZXMuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gTm9GbGFncyQxO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbiAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVzZXQgdG8gdGhlIGNsb25lZCB2YWx1ZXMgdGhhdCBjcmVhdGVXb3JrSW5Qcm9ncmVzcyB3b3VsZCd2ZS5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gTm9GbGFncyQxO1xuICAgIHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cblxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7IC8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4gICAgLy8gaXQgY2Fubm90IGJlIHNoYXJlZCB3aXRoIHRoZSBjdXJyZW50IGZpYmVyLlxuXG4gICAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzID09PSBudWxsID8gbnVsbCA6IHtcbiAgICAgIGxhbmVzOiBjdXJyZW50RGVwZW5kZW5jaWVzLmxhbmVzLFxuICAgICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuICAgIH07XG5cbiAgICB7XG4gICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbiAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcih0YWcsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSkge1xuICB2YXIgbW9kZTtcblxuICB7XG4gICAgbW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuXG4gICAgaWYgKGlzU3RyaWN0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgbW9kZSB8PSBTdHJpY3RMZWdhY3lNb2RlIHwgU3RyaWN0RWZmZWN0c01vZGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgLy8gQWx3YXlzIGNvbGxlY3QgcHJvZmlsZSB0aW1pbmdzIHdoZW4gRGV2VG9vbHMgYXJlIHByZXNlbnQuXG4gICAgLy8gVGhpcyBlbmFibGVzIERldlRvb2xzIHRvIHN0YXJ0IGNhcHR1cmluZyB0aW1pbmcgYXQgYW55IHBvaW504oCTXG4gICAgLy8gV2l0aG91dCBzb21lIG5vZGVzIGluIHRoZSB0cmVlIGhhdmluZyBlbXB0eSBiYXNlIHRpbWVzLlxuICAgIG1vZGUgfD0gUHJvZmlsZU1vZGU7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlRmliZXIoSG9zdFJvb3QsIG51bGwsIG51bGwsIG1vZGUpO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHR5cGUsIC8vIFJlYWN0JEVsZW1lbnRUeXBlXG5rZXksIHBlbmRpbmdQcm9wcywgb3duZXIsIG1vZGUsIGxhbmVzKSB7XG4gIHZhciBmaWJlclRhZyA9IEZ1bmN0aW9uQ29tcG9uZW50OyAvLyBUaGUgcmVzb2x2ZWQgdHlwZSBpcyBzZXQgaWYgd2Uga25vdyB3aGF0IHRoZSBmaW5hbCB0eXBlIHdpbGwgYmUuIEkuZS4gaXQncyBub3QgbGF6eS5cblxuICB2YXIgcmVzb2x2ZWRUeXBlID0gdHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoc2hvdWxkQ29uc3RydWN0KHR5cGUpKSB7XG4gICAgICBmaWJlclRhZyA9IENsYXNzQ29tcG9uZW50O1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMgJiYgc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICB2YXIgaG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgZmliZXJUYWcgPSBpc0hvc3RIb2lzdGFibGVUeXBlKHR5cGUsIHBlbmRpbmdQcm9wcywgaG9zdENvbnRleHQpID8gSG9zdEhvaXN0YWJsZSA6IGlzSG9zdFNpbmdsZXRvblR5cGUodHlwZSkgPyBIb3N0U2luZ2xldG9uIDogSG9zdENvbXBvbmVudDtcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICB2YXIgX2hvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcblxuICAgICAgZmliZXJUYWcgPSBpc0hvc3RIb2lzdGFibGVUeXBlKHR5cGUsIHBlbmRpbmdQcm9wcywgX2hvc3RDb250ZXh0KSA/IEhvc3RIb2lzdGFibGUgOiBIb3N0Q29tcG9uZW50O1xuICAgIH0gZWxzZSBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICBmaWJlclRhZyA9IGlzSG9zdFNpbmdsZXRvblR5cGUodHlwZSkgPyBIb3N0U2luZ2xldG9uIDogSG9zdENvbXBvbmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmliZXJUYWcgPSBIb3N0Q29tcG9uZW50O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBnZXRUYWc6IHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQocGVuZGluZ1Byb3BzLmNoaWxkcmVuLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICBmaWJlclRhZyA9IE1vZGU7XG4gICAgICAgIG1vZGUgfD0gU3RyaWN0TGVnYWN5TW9kZTtcblxuICAgICAgICB7XG4gICAgICAgICAgLy8gU3RyaWN0IGVmZmVjdHMgc2hvdWxkIG5ldmVyIHJ1biBvbiBsZWdhY3kgcm9vdHNcbiAgICAgICAgICBtb2RlIHw9IFN0cmljdEVmZmVjdHNNb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2VMaXN0KHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU6XG5cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICBjYXNlIFJFQUNUX1NDT1BFX1RZUEU6XG5cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICBjYXNlIFJFQUNUX1RSQUNJTkdfTUFSS0VSX1RZUEU6XG5cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICBjYXNlIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFOlxuXG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcblxuICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IENvbnRleHRQcm92aWRlcjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dENvbnN1bWVyO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBGb3J3YXJkUmVmO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBNZW1vQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IExhenlDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvd25lck5hbWUgPSBvd25lciA/IGdldENvbXBvbmVudE5hbWVGcm9tT3duZXIob3duZXIpIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiAnICsgJ2NvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgJyArIChcImJ1dCBnb3Q6IFwiICsgdHlwZVN0cmluZyArIFwiLlwiICsgaW5mbykpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoZmliZXJUYWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSB0eXBlO1xuICBmaWJlci50eXBlID0gcmVzb2x2ZWRUeXBlO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IG93bmVyO1xuICB9XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBtb2RlLCBsYW5lcykge1xuICB2YXIgb3duZXIgPSBudWxsO1xuXG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCBrZXksIHBlbmRpbmdQcm9wcywgb3duZXIsIG1vZGUsIGxhbmVzKTtcblxuICB7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEZyYWdtZW50LCBlbGVtZW50cywga2V5LCBtb2RlKTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qcm9maWxlcihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgcGVuZGluZ1Byb3BzLmlkICE9PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3IoJ1Byb2ZpbGVyIG11c3Qgc3BlY2lmeSBhbiBcImlkXCIgb2YgdHlwZSBgc3RyaW5nYCBhcyBhIHByb3AuIFJlY2VpdmVkIHRoZSB0eXBlIGAlc2AgaW5zdGVhZC4nLCB0eXBlb2YgcGVuZGluZ1Byb3BzLmlkKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihQcm9maWxlciwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUgfCBQcm9maWxlTW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcblxuICB7XG4gICAgZmliZXIuc3RhdGVOb2RlID0ge1xuICAgICAgZWZmZWN0RHVyYXRpb246IDAsXG4gICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZShwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoU3VzcGVuc2VDb21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFN1c3BlbnNlTGlzdENvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihPZmZzY3JlZW5Db21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgdmFyIHByaW1hcnlDaGlsZEluc3RhbmNlID0ge1xuICAgIF92aXNpYmlsaXR5OiBPZmZzY3JlZW5WaXNpYmxlLFxuICAgIF9wZW5kaW5nVmlzaWJpbGl0eTogT2Zmc2NyZWVuVmlzaWJsZSxcbiAgICBfcGVuZGluZ01hcmtlcnM6IG51bGwsXG4gICAgX3JldHJ5Q2FjaGU6IG51bGwsXG4gICAgX3RyYW5zaXRpb25zOiBudWxsLFxuICAgIF9jdXJyZW50OiBudWxsLFxuICAgIGRldGFjaDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRldGFjaE9mZnNjcmVlbkluc3RhbmNlKHByaW1hcnlDaGlsZEluc3RhbmNlKTtcbiAgICB9LFxuICAgIGF0dGFjaDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGF0dGFjaE9mZnNjcmVlbkluc3RhbmNlKHByaW1hcnlDaGlsZEluc3RhbmNlKTtcbiAgICB9XG4gIH07XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHByaW1hcnlDaGlsZEluc3RhbmNlO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsIG1vZGUsIGxhbmVzKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RUZXh0LCBjb250ZW50LCBudWxsLCBtb2RlKTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRGVoeWRyYXRlZEZyYWdtZW50KGRlaHlkcmF0ZWROb2RlKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKERlaHlkcmF0ZWRGcmFnbWVudCwgbnVsbCwgbnVsbCwgTm9Nb2RlKTtcbiAgZmliZXIuc3RhdGVOb2RlID0gZGVoeWRyYXRlZE5vZGU7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIG1vZGUsIGxhbmVzKSB7XG4gIHZhciBwZW5kaW5nUHJvcHMgPSBwb3J0YWwuY2hpbGRyZW4gIT09IG51bGwgPyBwb3J0YWwuY2hpbGRyZW4gOiBbXTtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFBvcnRhbCwgcGVuZGluZ1Byb3BzLCBwb3J0YWwua2V5LCBtb2RlKTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgZmliZXIuc3RhdGVOb2RlID0ge1xuICAgIGNvbnRhaW5lckluZm86IHBvcnRhbC5jb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcbiAgICAvLyBVc2VkIGJ5IHBlcnNpc3RlbnQgdXBkYXRlc1xuICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgfTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBGaWJlclJvb3ROb2RlKGNvbnRhaW5lckluZm8sIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbnRhZywgaHlkcmF0ZSwgaWRlbnRpZmllclByZWZpeCwgb25VbmNhdWdodEVycm9yLCBvbkNhdWdodEVycm9yLCBvblJlY292ZXJhYmxlRXJyb3IsIGZvcm1TdGF0ZSkge1xuICB0aGlzLnRhZyA9IENvbmN1cnJlbnRSb290IDtcbiAgdGhpcy5jb250YWluZXJJbmZvID0gY29udGFpbmVySW5mbztcbiAgdGhpcy5wZW5kaW5nQ2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB0aGlzLnBpbmdDYWNoZSA9IG51bGw7XG4gIHRoaXMuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICB0aGlzLmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja05vZGUgPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmU7XG4gIHRoaXMuZXhwaXJhdGlvblRpbWVzID0gY3JlYXRlTGFuZU1hcChOb1RpbWVzdGFtcCk7XG4gIHRoaXMucGVuZGluZ0xhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5zdXNwZW5kZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMucGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmV4cGlyZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLnNoZWxsU3VzcGVuZENvdW50ZXIgPSAwO1xuICB0aGlzLmVudGFuZ2xlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5lbnRhbmdsZW1lbnRzID0gY3JlYXRlTGFuZU1hcChOb0xhbmVzKTtcbiAgdGhpcy5oaWRkZW5VcGRhdGVzID0gY3JlYXRlTGFuZU1hcChudWxsKTtcbiAgdGhpcy5pZGVudGlmaWVyUHJlZml4ID0gaWRlbnRpZmllclByZWZpeDtcbiAgdGhpcy5vblVuY2F1Z2h0RXJyb3IgPSBvblVuY2F1Z2h0RXJyb3I7XG4gIHRoaXMub25DYXVnaHRFcnJvciA9IG9uQ2F1Z2h0RXJyb3I7XG4gIHRoaXMub25SZWNvdmVyYWJsZUVycm9yID0gb25SZWNvdmVyYWJsZUVycm9yO1xuXG4gIHtcbiAgICB0aGlzLnBvb2xlZENhY2hlID0gbnVsbDtcbiAgICB0aGlzLnBvb2xlZENhY2hlTGFuZXMgPSBOb0xhbmVzO1xuICB9XG5cbiAgdGhpcy5mb3JtU3RhdGUgPSBmb3JtU3RhdGU7XG4gIHRoaXMuaW5jb21wbGV0ZVRyYW5zaXRpb25zID0gbmV3IE1hcCgpO1xuXG4gIHtcbiAgICB0aGlzLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICB0aGlzLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gIH1cblxuICB7XG4gICAgdGhpcy5tZW1vaXplZFVwZGF0ZXJzID0gbmV3IFNldCgpO1xuICAgIHZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gdGhpcy5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gW107XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgVG90YWxMYW5lczsgX2krKykge1xuICAgICAgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcC5wdXNoKG5ldyBTZXQoKSk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIC8vIFRPRE86IFRoaXMgdmFyaWVzIGJ5IGVhY2ggcmVuZGVyZXIuXG4gICAgICB0aGlzLl9kZWJ1Z1Jvb3RUeXBlID0gaHlkcmF0ZSA/ICdoeWRyYXRlUm9vdCgpJyA6ICdjcmVhdGVSb290KCknO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBpbml0aWFsQ2hpbGRyZW4sIGh5ZHJhdGlvbkNhbGxiYWNrcywgaXNTdHJpY3RNb2RlLCBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLCAvLyBUT0RPOiBXZSBoYXZlIHNldmVyYWwgb2YgdGhlc2UgYXJndW1lbnRzIHRoYXQgYXJlIGNvbmNlcHR1YWxseSBwYXJ0IG9mIHRoZVxuLy8gaG9zdCBjb25maWcsIGJ1dCBiZWNhdXNlIHRoZXkgYXJlIHBhc3NlZCBpbiBhdCBydW50aW1lLCB3ZSBoYXZlIHRvIHRocmVhZFxuLy8gdGhlbSB0aHJvdWdoIHRoZSByb290IGNvbnN0cnVjdG9yLiBQZXJoYXBzIHdlIHNob3VsZCBwdXQgdGhlbSBhbGwgaW50byBhXG4vLyBzaW5nbGUgdHlwZSwgbGlrZSBhIER5bmFtaWNIb3N0Q29uZmlnIHRoYXQgaXMgZGVmaW5lZCBieSB0aGUgcmVuZGVyZXIuXG5pZGVudGlmaWVyUHJlZml4LCBvblVuY2F1Z2h0RXJyb3IsIG9uQ2F1Z2h0RXJyb3IsIG9uUmVjb3ZlcmFibGVFcnJvciwgdHJhbnNpdGlvbkNhbGxiYWNrcywgZm9ybVN0YXRlKSB7XG4gIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb25zdHJ1Y3Rvcl0gRmxvdyBubyBsb25nZXIgc3VwcG9ydHMgY2FsbGluZyBuZXcgb24gZnVuY3Rpb25zXG4gIHZhciByb290ID0gbmV3IEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBpZGVudGlmaWVyUHJlZml4LCBvblVuY2F1Z2h0RXJyb3IsIG9uQ2F1Z2h0RXJyb3IsIG9uUmVjb3ZlcmFibGVFcnJvciwgZm9ybVN0YXRlKTtcbiAgLy8gc3RhdGVOb2RlIGlzIGFueS5cblxuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKHRhZywgaXNTdHJpY3RNb2RlKTtcbiAgcm9vdC5jdXJyZW50ID0gdW5pbml0aWFsaXplZEZpYmVyO1xuICB1bmluaXRpYWxpemVkRmliZXIuc3RhdGVOb2RlID0gcm9vdDtcblxuICB7XG4gICAgdmFyIGluaXRpYWxDYWNoZSA9IGNyZWF0ZUNhY2hlKCk7XG4gICAgcmV0YWluQ2FjaGUoaW5pdGlhbENhY2hlKTsgLy8gVGhlIHBvb2xlZENhY2hlIGlzIGEgZnJlc2ggY2FjaGUgaW5zdGFuY2UgdGhhdCBpcyB1c2VkIHRlbXBvcmFyaWx5XG4gICAgLy8gZm9yIG5ld2x5IG1vdW50ZWQgYm91bmRhcmllcyBkdXJpbmcgYSByZW5kZXIuIEluIGdlbmVyYWwsIHRoZVxuICAgIC8vIHBvb2xlZENhY2hlIGlzIGFsd2F5cyBjbGVhcmVkIGZyb20gdGhlIHJvb3QgYXQgdGhlIGVuZCBvZiBhIHJlbmRlcjpcbiAgICAvLyBpdCBpcyBlaXRoZXIgcmVsZWFzZWQgd2hlbiByZW5kZXIgY29tbWl0cywgb3IgbW92ZWQgdG8gYW4gT2Zmc2NyZWVuXG4gICAgLy8gY29tcG9uZW50IGlmIHJlbmRlcmluZyBzdXNwZW5kcy4gQmVjYXVzZSB0aGUgbGlmZXRpbWUgb2YgdGhlIHBvb2xlZFxuICAgIC8vIGNhY2hlIGlzIGRpc3RpbmN0IGZyb20gdGhlIG1haW4gbWVtb2l6ZWRTdGF0ZS5jYWNoZSwgaXQgbXVzdCBiZVxuICAgIC8vIHJldGFpbmVkIHNlcGFyYXRlbHkuXG5cbiAgICByb290LnBvb2xlZENhY2hlID0gaW5pdGlhbENhY2hlO1xuICAgIHJldGFpbkNhY2hlKGluaXRpYWxDYWNoZSk7XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHtcbiAgICAgIGVsZW1lbnQ6IGluaXRpYWxDaGlsZHJlbixcbiAgICAgIGlzRGVoeWRyYXRlZDogaHlkcmF0ZSxcbiAgICAgIGNhY2hlOiBpbml0aWFsQ2FjaGVcbiAgICB9O1xuICAgIHVuaW5pdGlhbGl6ZWRGaWJlci5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB9XG5cbiAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHVuaW5pdGlhbGl6ZWRGaWJlcik7XG4gIHJldHVybiByb290O1xufVxuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE5LjAuMC1yYy05MzUxODBjN2UwLTIwMjQwNTI0JztcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sIC8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHtcbiAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGtleSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxuLy8gTWlnaHQgYWRkIFBST0ZJTEUgbGF0ZXIuXG5cbnZhciBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzO1xudmFyIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlO1xuXG57XG4gIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUgPSB7fTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KSB7XG4gIGlmICghcGFyZW50Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChwYXJlbnRDb21wb25lbnQpO1xuICB2YXIgcGFyZW50Q29udGV4dCA9IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KCk7XG5cbiAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gZmliZXIudHlwZTtcblxuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcigpKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgQ29tcG9uZW50LCBwYXJlbnRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyZW50Q29udGV4dDtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShjb21wb25lbnQpIHtcbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cbiAgaWYgKGZpYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbXBvbmVudCkuam9pbignLCcpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBrZXlzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShob3N0RmliZXIuc3RhdGVOb2RlKTtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudCwgbWV0aG9kTmFtZSkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cbiAgICBpZiAoZmliZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb21wb25lbnQpLmpvaW4oJywnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBrZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGhvc3RGaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoaG9zdEZpYmVyKTtcblxuICAgICAgICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICAgICAgZXJyb3IoJyVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4gJyArICclcyB3YXMgcGFzc2VkIGFuIGluc3RhbmNlIG9mICVzIHdoaWNoIGlzIGluc2lkZSBTdHJpY3RNb2RlLiAnICsgJ0luc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlJywgbWV0aG9kTmFtZSwgbWV0aG9kTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCclcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICcgKyAnJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCByZW5kZXJzIFN0cmljdE1vZGUgY2hpbGRyZW4uICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGUnLCBtZXRob2ROYW1lLCBtZXRob2ROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gSWRlYWxseSB0aGlzIHNob3VsZCByZXNldCB0byBwcmV2aW91cyBidXQgdGhpcyBzaG91bGRuJ3QgYmUgY2FsbGVkIGluXG4gICAgICAgICAgLy8gcmVuZGVyIGFuZCB0aGVyZSdzIGFub3RoZXIgd2FybmluZyBmb3IgdGhhdCBhbnl3YXkuXG4gICAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYocHJldmlvdXNGaWJlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShob3N0RmliZXIuc3RhdGVOb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25VbmNhdWdodEVycm9yLCBvbkNhdWdodEVycm9yLCBvblJlY292ZXJhYmxlRXJyb3IsIHRyYW5zaXRpb25DYWxsYmFja3MpIHtcbiAgdmFyIGh5ZHJhdGUgPSBmYWxzZTtcbiAgdmFyIGluaXRpYWxDaGlsZHJlbiA9IG51bGw7XG4gIHJldHVybiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBpbml0aWFsQ2hpbGRyZW4sIGh5ZHJhdGlvbkNhbGxiYWNrcywgaXNTdHJpY3RNb2RlLCBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLCBpZGVudGlmaWVyUHJlZml4LCBvblVuY2F1Z2h0RXJyb3IsIG9uQ2F1Z2h0RXJyb3IsIG9uUmVjb3ZlcmFibGVFcnJvciwgdHJhbnNpdGlvbkNhbGxiYWNrcywgbnVsbCk7XG59XG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25Db250YWluZXIoaW5pdGlhbENoaWxkcmVuLCAvLyBUT0RPOiBSZW1vdmUgYGNhbGxiYWNrYCB3aGVuIHdlIGRlbGV0ZSBsZWdhY3kgbW9kZS5cbmNhbGxiYWNrLCBjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGlvbkNhbGxiYWNrcywgaXNTdHJpY3RNb2RlLCBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLCBpZGVudGlmaWVyUHJlZml4LCBvblVuY2F1Z2h0RXJyb3IsIG9uQ2F1Z2h0RXJyb3IsIG9uUmVjb3ZlcmFibGVFcnJvciwgdHJhbnNpdGlvbkNhbGxiYWNrcywgZm9ybVN0YXRlKSB7XG4gIHZhciBoeWRyYXRlID0gdHJ1ZTtcbiAgdmFyIHJvb3QgPSBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBpbml0aWFsQ2hpbGRyZW4sIGh5ZHJhdGlvbkNhbGxiYWNrcywgaXNTdHJpY3RNb2RlLCBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLCBpZGVudGlmaWVyUHJlZml4LCBvblVuY2F1Z2h0RXJyb3IsIG9uQ2F1Z2h0RXJyb3IsIG9uUmVjb3ZlcmFibGVFcnJvciwgdHJhbnNpdGlvbkNhbGxiYWNrcywgZm9ybVN0YXRlKTsgLy8gVE9ETzogTW92ZSB0aGlzIHRvIEZpYmVyUm9vdCBjb25zdHJ1Y3RvclxuXG4gIHJvb3QuY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpOyAvLyBTY2hlZHVsZSB0aGUgaW5pdGlhbCByZW5kZXIuIEluIGEgaHlkcmF0aW9uIHJvb3QsIHRoaXMgaXMgZGlmZmVyZW50IGZyb21cbiAgLy8gYSByZWd1bGFyIHVwZGF0ZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBtdXN0IG1hdGNoIHdhcyB3YXMgcmVuZGVyZWRcbiAgLy8gb24gdGhlIHNlcnZlci5cbiAgLy8gTk9URTogVGhpcyB1cGRhdGUgaW50ZW50aW9uYWxseSBkb2Vzbid0IGhhdmUgYSBwYXlsb2FkLiBXZSdyZSBvbmx5IHVzaW5nXG4gIC8vIHRoZSB1cGRhdGUgdG8gc2NoZWR1bGUgd29yayBvbiB0aGUgcm9vdCBmaWJlciAoYW5kLCBmb3IgbGVnYWN5IHJvb3RzLCB0b1xuICAvLyBlbnF1ZXVlIHRoZSBjYWxsYmFjayBpZiBvbmUgaXMgcHJvdmlkZWQpLlxuXG4gIHZhciBjdXJyZW50ID0gcm9vdC5jdXJyZW50O1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQpO1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsID8gY2FsbGJhY2sgOiBudWxsO1xuICBlbnF1ZXVlVXBkYXRlKGN1cnJlbnQsIHVwZGF0ZSwgbGFuZSk7XG4gIHNjaGVkdWxlSW5pdGlhbEh5ZHJhdGlvbk9uUm9vdChyb290LCBsYW5lKTtcbiAgcmV0dXJuIHJvb3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDb250YWluZXIoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQ7XG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoY3VycmVudCk7XG4gIHVwZGF0ZUNvbnRhaW5lckltcGwoY3VycmVudCwgbGFuZSwgZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiB1cGRhdGVDb250YWluZXJTeW5jKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICBpZiAoY29udGFpbmVyLnRhZyA9PT0gTGVnYWN5Um9vdCkge1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQ7XG4gIHVwZGF0ZUNvbnRhaW5lckltcGwoY3VycmVudCwgU3luY0xhbmUsIGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gIHJldHVybiBTeW5jTGFuZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVySW1wbChyb290RmliZXIsIGxhbmUsIGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB7XG4gICAgb25TY2hlZHVsZVJvb3QoY29udGFpbmVyLCBlbGVtZW50KTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpO1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuXG4gIGlmIChjb250YWluZXIuY29udGV4dCA9PT0gbnVsbCkge1xuICAgIGNvbnRhaW5lci5jb250ZXh0ID0gY29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiBjdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpIHx8ICdVbmtub3duJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTsgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG5cbiAgdXBkYXRlLnBheWxvYWQgPSB7XG4gICAgZWxlbWVudDogZWxlbWVudFxuICB9O1xuICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG5cbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHZhciByb290ID0gZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIHVwZGF0ZSwgbGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgcm9vdEZpYmVyLCBsYW5lKTtcbiAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIHJvb3RGaWJlciwgbGFuZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFB1YmxpY1Jvb3RJbnN0YW5jZShjb250YWluZXIpIHtcbiAgdmFyIGNvbnRhaW5lckZpYmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHJvb3QgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKGlzUm9vdERlaHlkcmF0ZWQocm9vdCkpIHtcbiAgICAgICAgICAvLyBGbHVzaCB0aGUgZmlyc3Qgc2NoZWR1bGVkIFwidXBkYXRlXCIuXG4gICAgICAgICAgdmFyIGxhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5UGVuZGluZ0xhbmVzKHJvb3QpO1xuICAgICAgICAgIGZsdXNoUm9vdChyb290LCBsYW5lcyk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgICAgIGlmIChfcm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihfcm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsdXNoU3luY1dvcmsoKTsgLy8gSWYgd2UncmUgc3RpbGwgYmxvY2tlZCBhZnRlciB0aGlzLCB3ZSBuZWVkIHRvIGluY3JlYXNlXG4gICAgICAgIC8vIHRoZSBwcmlvcml0eSBvZiBhbnkgcHJvbWlzZXMgcmVzb2x2aW5nIHdpdGhpbiB0aGlzXG4gICAgICAgIC8vIGJvdW5kYXJ5IHNvIHRoYXQgdGhleSBuZXh0IGF0dGVtcHQgYWxzbyBoYXMgaGlnaGVyIHByaS5cblxuICAgICAgICB2YXIgcmV0cnlMYW5lID0gU3luY0xhbmU7XG4gICAgICAgIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCByZXRyeUxhbmUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKSB7XG4gIHZhciBzdXNwZW5zZVN0YXRlID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCAmJiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSA9IGhpZ2hlclByaW9yaXR5TGFuZShzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSwgcmV0cnlMYW5lKTtcbiAgfVxufSAvLyBJbmNyZWFzZXMgdGhlIHByaW9yaXR5IG9mIHRoZW5hYmxlcyB3aGVuIHRoZXkgcmVzb2x2ZSB3aXRoaW4gdGhpcyBib3VuZGFyeS5cblxuXG5mdW5jdGlvbiBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgcmV0cnlMYW5lKSB7XG4gIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpO1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChhbHRlcm5hdGUpIHtcbiAgICBtYXJrUmV0cnlMYW5lSW1wbChhbHRlcm5hdGUsIHJldHJ5TGFuZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IGFuZCB0aGV5IHNob3VsZCBub3Qgc3VzcGVuZCBvbiBJL08sXG4gICAgLy8gc2luY2UgeW91IGhhdmUgdG8gd3JhcCBhbnl0aGluZyB0aGF0IG1pZ2h0IHN1c3BlbmQgaW5cbiAgICAvLyBTdXNwZW5zZS5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbGFuZSA9IFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU7XG4gIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBsYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSk7XG4gIH1cblxuICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IG90aGVyIHRoYW4gc3luY2hyb25vdXNseSBmbHVzaCBpdC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIGxhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgfVxuXG4gIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcbn1cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGZpYmVyKSB7XG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMoZmliZXIpO1xuXG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShob3N0RmliZXIuc3RhdGVOb2RlKTtcbn1cblxudmFyIHNob3VsZEVycm9ySW1wbCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZEVycm9yKGZpYmVyKSB7XG4gIHJldHVybiBzaG91bGRFcnJvckltcGwoZmliZXIpO1xufVxuXG52YXIgc2hvdWxkU3VzcGVuZEltcGwgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkU3VzcGVuZChmaWJlcikge1xuICByZXR1cm4gc2hvdWxkU3VzcGVuZEltcGwoZmliZXIpO1xufVxudmFyIG92ZXJyaWRlSG9va1N0YXRlID0gbnVsbDtcbnZhciBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wcyA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gbnVsbDtcbnZhciBzY2hlZHVsZVVwZGF0ZSA9IG51bGw7XG52YXIgc2V0RXJyb3JIYW5kbGVyID0gbnVsbDtcbnZhciBzZXRTdXNwZW5zZUhhbmRsZXIgPSBudWxsO1xuXG57XG4gIHZhciBjb3B5V2l0aERlbGV0ZUltcGwgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCBpbmRleCkge1xuICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuXG4gICAgaWYgKGluZGV4ICsgMSA9PT0gcGF0aC5sZW5ndGgpIHtcbiAgICAgIGlmIChpc0FycmF5KHVwZGF0ZWQpKSB7XG4gICAgICAgIHVwZGF0ZWQuc3BsaWNlKGtleSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdXBkYXRlZFtrZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblxuXG4gICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhEZWxldGVJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEpO1xuICAgIHJldHVybiB1cGRhdGVkO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aERlbGV0ZSA9IGZ1bmN0aW9uIChvYmosIHBhdGgpIHtcbiAgICByZXR1cm4gY29weVdpdGhEZWxldGVJbXBsKG9iaiwgcGF0aCwgMCk7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoUmVuYW1lSW1wbCA9IGZ1bmN0aW9uIChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4KSB7XG4gICAgdmFyIG9sZEtleSA9IG9sZFBhdGhbaW5kZXhdO1xuICAgIHZhciB1cGRhdGVkID0gaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBvbGRQYXRoLmxlbmd0aCkge1xuICAgICAgdmFyIG5ld0tleSA9IG5ld1BhdGhbaW5kZXhdOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICAgIHVwZGF0ZWRbbmV3S2V5XSA9IHVwZGF0ZWRbb2xkS2V5XTtcblxuICAgICAgaWYgKGlzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgICAgdXBkYXRlZC5zcGxpY2Uob2xkS2V5LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkW29sZEtleV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICAgIHVwZGF0ZWRbb2xkS2V5XSA9IGNvcHlXaXRoUmVuYW1lSW1wbCggLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuICAgICAgb2JqW29sZEtleV0sIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4ICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoUmVuYW1lID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIGlmIChvbGRQYXRoLmxlbmd0aCAhPT0gbmV3UGF0aC5sZW5ndGgpIHtcbiAgICAgIHdhcm4oJ2NvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyBvZiB0aGUgc2FtZSBsZW5ndGgnKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1BhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChvbGRQYXRoW2ldICE9PSBuZXdQYXRoW2ldKSB7XG4gICAgICAgICAgd2FybignY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGRlZXBlc3Qga2V5Jyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29weVdpdGhSZW5hbWVJbXBsKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgMCk7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoU2V0SW1wbCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIGluZGV4LCB2YWx1ZSkge1xuICAgIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aFNldEltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSwgdmFsdWUpO1xuICAgIHJldHVybiB1cGRhdGVkO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFNldCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGNvcHlXaXRoU2V0SW1wbChvYmosIHBhdGgsIDAsIHZhbHVlKTtcbiAgfTtcblxuICB2YXIgZmluZEhvb2sgPSBmdW5jdGlvbiAoZmliZXIsIGlkKSB7XG4gICAgLy8gRm9yIG5vdywgdGhlIFwiaWRcIiBvZiBzdGF0ZWZ1bCBob29rcyBpcyBqdXN0IHRoZSBzdGF0ZWZ1bCBob29rIGluZGV4LlxuICAgIC8vIFRoaXMgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlIHdpdGggZS5nLiBuZXN0ZWQgaG9va3MuXG4gICAgdmFyIGN1cnJlbnRIb29rID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICAgIHdoaWxlIChjdXJyZW50SG9vayAhPT0gbnVsbCAmJiBpZCA+IDApIHtcbiAgICAgIGN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcbiAgICAgIGlkLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRIb29rO1xuICB9OyAvLyBTdXBwb3J0IERldlRvb2xzIGVkaXRhYmxlIHZhbHVlcyBmb3IgdXNlU3RhdGUgYW5kIHVzZVJlZHVjZXIuXG5cblxuICBvdmVycmlkZUhvb2tTdGF0ZSA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgsIHZhbHVlKSB7XG4gICAgdmFyIGhvb2sgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuXG4gICAgaWYgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoU2V0KGhvb2subWVtb2l6ZWRTdGF0ZSwgcGF0aCwgdmFsdWUpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoKSB7XG4gICAgdmFyIGhvb2sgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuXG4gICAgaWYgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoRGVsZXRlKGhvb2subWVtb2l6ZWRTdGF0ZSwgcGF0aCk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7IC8vIFdlIGFyZW4ndCBhY3R1YWxseSBhZGRpbmcgYW4gdXBkYXRlIHRvIHRoZSBxdWV1ZSxcbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXBkYXRlIHdlIGNhbiBhZGQgZm9yIHVzZVJlZHVjZXIgaG9va3MgdGhhdCB3b24ndCB0cmlnZ2VyIGFuIGVycm9yLlxuICAgICAgLy8gKFRoZXJlJ3Mgbm8gYXBwcm9wcmlhdGUgYWN0aW9uIHR5cGUgZm9yIERldlRvb2xzIG92ZXJyaWRlcy4pXG4gICAgICAvLyBBcyBhIHJlc3VsdCB0aG91Z2gsIFJlYWN0IHdpbGwgc2VlIHRoZSBzY2hlZHVsZWQgdXBkYXRlIGFzIGEgbm9vcCBhbmQgYmFpbG91dC5cbiAgICAgIC8vIFNoYWxsb3cgY2xvbmluZyBwcm9wcyB3b3JrcyBhcyBhIHdvcmthcm91bmQgZm9yIG5vdyB0byBieXBhc3MgdGhlIGJhaWxvdXQgY2hlY2suXG5cbiAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBhc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpO1xuICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICB2YXIgaG9vayA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG5cbiAgICBpZiAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5ld1N0YXRlID0gY29weVdpdGhSZW5hbWUoaG9vay5tZW1vaXplZFN0YXRlLCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIFN1cHBvcnQgRGV2VG9vbHMgcHJvcHMgZm9yIGZ1bmN0aW9uIGNvbXBvbmVudHMsIGZvcndhcmRSZWYsIG1lbW8sIGhvc3QgY29tcG9uZW50cywgZXRjLlxuXG5cbiAgb3ZlcnJpZGVQcm9wcyA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCwgdmFsdWUpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFNldChmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoLCB2YWx1ZSk7XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgIH1cblxuICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSk7XG4gICAgfVxuICB9O1xuXG4gIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBwYXRoKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhEZWxldGUoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCk7XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgIH1cblxuICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSk7XG4gICAgfVxuICB9O1xuXG4gIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhSZW5hbWUoZmliZXIubWVtb2l6ZWRQcm9wcywgb2xkUGF0aCwgbmV3UGF0aCk7XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgIH1cblxuICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSk7XG4gICAgfVxuICB9O1xuXG4gIHNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgICB9XG4gIH07XG5cbiAgc2V0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKG5ld1Nob3VsZEVycm9ySW1wbCkge1xuICAgIHNob3VsZEVycm9ySW1wbCA9IG5ld1Nob3VsZEVycm9ySW1wbDtcbiAgfTtcblxuICBzZXRTdXNwZW5zZUhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkU3VzcGVuZEltcGwpIHtcbiAgICBzaG91bGRTdXNwZW5kSW1wbCA9IG5ld1Nob3VsZFN1c3BlbmRJbXBsO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcihmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xufVxuXG5mdW5jdGlvbiBlbXB0eUZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scygpIHtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGluamVjdEludG9EZXZUb29scyhkZXZUb29sc0NvbmZpZykge1xuICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcbiAgcmV0dXJuIGluamVjdEludGVybmFscyh7XG4gICAgYnVuZGxlVHlwZTogZGV2VG9vbHNDb25maWcuYnVuZGxlVHlwZSxcbiAgICB2ZXJzaW9uOiBkZXZUb29sc0NvbmZpZy52ZXJzaW9uLFxuICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6IGRldlRvb2xzQ29uZmlnLnJlbmRlcmVyUGFja2FnZU5hbWUsXG4gICAgcmVuZGVyZXJDb25maWc6IGRldlRvb2xzQ29uZmlnLnJlbmRlcmVyQ29uZmlnLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlOiBvdmVycmlkZUhvb2tTdGF0ZSxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGg6IG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGg6IG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCxcbiAgICBvdmVycmlkZVByb3BzOiBvdmVycmlkZVByb3BzLFxuICAgIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoOiBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCxcbiAgICBvdmVycmlkZVByb3BzUmVuYW1lUGF0aDogb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGgsXG4gICAgc2V0RXJyb3JIYW5kbGVyOiBzZXRFcnJvckhhbmRsZXIsXG4gICAgc2V0U3VzcGVuc2VIYW5kbGVyOiBzZXRTdXNwZW5zZUhhbmRsZXIsXG4gICAgc2NoZWR1bGVVcGRhdGU6IHNjaGVkdWxlVXBkYXRlLFxuICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBSZWFjdFNoYXJlZEludGVybmFscyxcbiAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIsXG4gICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlIHx8IGVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UsXG4gICAgLy8gUmVhY3QgUmVmcmVzaFxuICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaDogZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoICxcbiAgICBzY2hlZHVsZVJlZnJlc2g6IHNjaGVkdWxlUmVmcmVzaCAsXG4gICAgc2NoZWR1bGVSb290OiBzY2hlZHVsZVJvb3QgLFxuICAgIHNldFJlZnJlc2hIYW5kbGVyOiBzZXRSZWZyZXNoSGFuZGxlciAsXG4gICAgLy8gRW5hYmxlcyBEZXZUb29scyB0byBhcHBlbmQgb3duZXIgc3RhY2tzIHRvIGVycm9yIG1lc3NhZ2VzIGluIERFViBtb2RlLlxuICAgIGdldEN1cnJlbnRGaWJlcjogZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMgLFxuICAgIC8vIEVuYWJsZXMgRGV2VG9vbHMgdG8gZGV0ZWN0IHJlY29uY2lsZXIgdmVyc2lvbiByYXRoZXIgdGhhbiByZW5kZXJlciB2ZXJzaW9uXG4gICAgLy8gd2hpY2ggbWF5IG5vdCBtYXRjaCBmb3IgdGhpcmQgcGFydHkgcmVuZGVyZXJzLlxuICAgIHJlY29uY2lsZXJWZXJzaW9uOiBSZWFjdFZlcnNpb25cbiAgfSk7XG59XG5cbmV4cG9ydHMuYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24gPSBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbjtcbmV4cG9ydHMuYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5ID0gYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5O1xuZXhwb3J0cy5hdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24gPSBhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb247XG5leHBvcnRzLmJhdGNoZWRVcGRhdGVzID0gYmF0Y2hlZFVwZGF0ZXM7XG5leHBvcnRzLmNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yID0gY3JlYXRlQ29tcG9uZW50U2VsZWN0b3I7XG5leHBvcnRzLmNyZWF0ZUNvbnRhaW5lciA9IGNyZWF0ZUNvbnRhaW5lcjtcbmV4cG9ydHMuY3JlYXRlSGFzUHNldWRvQ2xhc3NTZWxlY3RvciA9IGNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3I7XG5leHBvcnRzLmNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lciA9IGNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lcjtcbmV4cG9ydHMuY3JlYXRlUG9ydGFsID0gY3JlYXRlUG9ydGFsO1xuZXhwb3J0cy5jcmVhdGVSb2xlU2VsZWN0b3IgPSBjcmVhdGVSb2xlU2VsZWN0b3I7XG5leHBvcnRzLmNyZWF0ZVRlc3ROYW1lU2VsZWN0b3IgPSBjcmVhdGVUZXN0TmFtZVNlbGVjdG9yO1xuZXhwb3J0cy5jcmVhdGVUZXh0U2VsZWN0b3IgPSBjcmVhdGVUZXh0U2VsZWN0b3I7XG5leHBvcnRzLmRlZmF1bHRPbkNhdWdodEVycm9yID0gZGVmYXVsdE9uQ2F1Z2h0RXJyb3I7XG5leHBvcnRzLmRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IgPSBkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yO1xuZXhwb3J0cy5kZWZhdWx0T25VbmNhdWdodEVycm9yID0gZGVmYXVsdE9uVW5jYXVnaHRFcnJvcjtcbmV4cG9ydHMuZGVmZXJyZWRVcGRhdGVzID0gZGVmZXJyZWRVcGRhdGVzO1xuZXhwb3J0cy5kaXNjcmV0ZVVwZGF0ZXMgPSBkaXNjcmV0ZVVwZGF0ZXM7XG5leHBvcnRzLmZpbmRBbGxOb2RlcyA9IGZpbmRBbGxOb2RlcztcbmV4cG9ydHMuZmluZEJvdW5kaW5nUmVjdHMgPSBmaW5kQm91bmRpbmdSZWN0cztcbmV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZSA9IGZpbmRIb3N0SW5zdGFuY2U7XG5leHBvcnRzLmZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzID0gZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHM7XG5leHBvcnRzLmZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyA9IGZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZztcbmV4cG9ydHMuZmx1c2hQYXNzaXZlRWZmZWN0cyA9IGZsdXNoUGFzc2l2ZUVmZmVjdHM7XG5leHBvcnRzLmZsdXNoU3luY0Zyb21SZWNvbmNpbGVyID0gZmx1c2hTeW5jRnJvbVJlY29uY2lsZXI7XG5leHBvcnRzLmZsdXNoU3luY1dvcmsgPSBmbHVzaFN5bmNXb3JrO1xuZXhwb3J0cy5mb2N1c1dpdGhpbiA9IGZvY3VzV2l0aGluO1xuZXhwb3J0cy5nZXRGaW5kQWxsTm9kZXNGYWlsdXJlRGVzY3JpcHRpb24gPSBnZXRGaW5kQWxsTm9kZXNGYWlsdXJlRGVzY3JpcHRpb247XG5leHBvcnRzLmdldFB1YmxpY1Jvb3RJbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZTtcbmV4cG9ydHMuaW5qZWN0SW50b0RldlRvb2xzID0gaW5qZWN0SW50b0RldlRvb2xzO1xuZXhwb3J0cy5pc0FscmVhZHlSZW5kZXJpbmcgPSBpc0FscmVhZHlSZW5kZXJpbmc7XG5leHBvcnRzLm9ic2VydmVWaXNpYmxlUmVjdHMgPSBvYnNlcnZlVmlzaWJsZVJlY3RzO1xuZXhwb3J0cy5zaG91bGRFcnJvciA9IHNob3VsZEVycm9yO1xuZXhwb3J0cy5zaG91bGRTdXNwZW5kID0gc2hvdWxkU3VzcGVuZDtcbmV4cG9ydHMuc3RhcnRIb3N0VHJhbnNpdGlvbiA9IHN0YXJ0SG9zdFRyYW5zaXRpb247XG5leHBvcnRzLnVwZGF0ZUNvbnRhaW5lciA9IHVwZGF0ZUNvbnRhaW5lcjtcbmV4cG9ydHMudXBkYXRlQ29udGFpbmVyU3luYyA9IHVwZGF0ZUNvbnRhaW5lclN5bmM7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH07XG4gIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsIiQkJHJlY29uY2lsZXIiLCIkJCRjb25maWciLCJSZWFjdCIsInJlcXVpcmUiLCJTY2hlZHVsZXIiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSIsInN1cHByZXNzV2FybmluZyIsInNldFN1cHByZXNzV2FybmluZyIsIm5ld1N1cHByZXNzV2FybmluZyIsIndhcm4iLCJmb3JtYXQiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleSIsInByaW50V2FybmluZyIsImVycm9yIiwiX2xlbjIiLCJfa2V5MiIsImxldmVsIiwiaXNFcnJvckxvZ2dlciIsImdldEN1cnJlbnRTdGFjayIsInN0YWNrIiwiY29uY2F0IiwidW5zaGlmdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImFwcGx5IiwiY2FsbCIsImNvbnNvbGUiLCJhc3NpZ24iLCJPYmplY3QiLCJMZWdhY3lSb290IiwiQ29uY3VycmVudFJvb3QiLCJnZXQiLCJrZXkiLCJfcmVhY3RJbnRlcm5hbHMiLCJzZXQiLCJ2YWx1ZSIsImZhdm9yU2FmZXR5T3Zlckh5ZHJhdGlvblBlcmYiLCJlbmFibGVBc3luY0FjdGlvbnMiLCJkaXNhYmxlRGVmYXVsdFByb3BzRXhjZXB0Rm9yQ2xhc3NlcyIsImVuYWJsZVN1c3BlbnNlQ2FsbGJhY2siLCJlbmFibGVBc3luY0l0ZXJhYmxlQ2hpbGRyZW4iLCJlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uIiwiZW5hYmxlTGVnYWN5SGlkZGVuIiwiYWx3YXlzVGhyb3R0bGVSZXRyaWVzIiwicGFzc0NoaWxkcmVuV2hlbkNsb25pbmdQZXJzaXN0ZWROb2RlcyIsInN5bmNMYW5lRXhwaXJhdGlvbk1zIiwidHJhbnNpdGlvbkxhbmVFeHBpcmF0aW9uTXMiLCJkaXNhYmxlTGVnYWN5TW9kZSIsImVuYWJsZVNjaGVkdWxpbmdQcm9maWxlciIsImVuYWJsZVByb2ZpbGVyVGltZXIiLCJlbmFibGVQcm9maWxlckNvbW1pdEhvb2tzIiwiZW5hYmxlUHJvZmlsZXJOZXN0ZWRVcGRhdGVQaGFzZSIsIkZ1bmN0aW9uQ29tcG9uZW50IiwiQ2xhc3NDb21wb25lbnQiLCJIb3N0Um9vdCIsIkhvc3RQb3J0YWwiLCJIb3N0Q29tcG9uZW50IiwiSG9zdFRleHQiLCJGcmFnbWVudCIsIk1vZGUiLCJDb250ZXh0Q29uc3VtZXIiLCJDb250ZXh0UHJvdmlkZXIiLCJGb3J3YXJkUmVmIiwiUHJvZmlsZXIiLCJTdXNwZW5zZUNvbXBvbmVudCIsIk1lbW9Db21wb25lbnQiLCJTaW1wbGVNZW1vQ29tcG9uZW50IiwiTGF6eUNvbXBvbmVudCIsIkluY29tcGxldGVDbGFzc0NvbXBvbmVudCIsIkRlaHlkcmF0ZWRGcmFnbWVudCIsIlN1c3BlbnNlTGlzdENvbXBvbmVudCIsIlNjb3BlQ29tcG9uZW50IiwiT2Zmc2NyZWVuQ29tcG9uZW50IiwiTGVnYWN5SGlkZGVuQ29tcG9uZW50IiwiQ2FjaGVDb21wb25lbnQiLCJUcmFjaW5nTWFya2VyQ29tcG9uZW50IiwiSG9zdEhvaXN0YWJsZSIsIkhvc3RTaW5nbGV0b24iLCJJbmNvbXBsZXRlRnVuY3Rpb25Db21wb25lbnQiLCJSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OU1VNRVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfU0NPUEVfVFlQRSIsIlJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUiLCJSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFIiwiUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJnZXRXcmFwcGVkTmFtZSQxIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSQxIiwidHlwZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCIkJHR5cGVvZiIsInRhZyIsImNvbnRleHQiLCJjb25zdW1lciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJnZXRXcmFwcGVkTmFtZSIsImdldENvbnRleHROYW1lIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21Pd25lciIsIm93bmVyIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlciIsImZpYmVyIiwiTm9GbGFncyQxIiwiUGVyZm9ybWVkV29yayIsIlBsYWNlbWVudCIsIkRpZENhcHR1cmUiLCJIeWRyYXRpbmciLCJVcGRhdGUiLCJDaGlsZERlbGV0aW9uIiwiQ29udGVudFJlc2V0IiwiQ2FsbGJhY2siLCJGb3JjZUNsaWVudFJlbmRlciIsIlJlZiIsIlNuYXBzaG90IiwiUGFzc2l2ZSQxIiwiVmlzaWJpbGl0eSIsIlN0b3JlQ29uc2lzdGVuY3kiLCJTY2hlZHVsZVJldHJ5IiwiU2hvdWxkU3VzcGVuZENvbW1pdCIsIkRpZERlZmVyIiwiRm9ybVJlc2V0IiwiSG9zdEVmZmVjdE1hc2siLCJJbmNvbXBsZXRlIiwiU2hvdWxkQ2FwdHVyZSIsIkZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UiLCJGb3JrZWQiLCJSZWZTdGF0aWMiLCJMYXlvdXRTdGF0aWMiLCJQYXNzaXZlU3RhdGljIiwiTWF5U3VzcGVuZENvbW1pdCIsIlBsYWNlbWVudERFViIsIk1vdW50TGF5b3V0RGV2IiwiTW91bnRQYXNzaXZlRGV2IiwiQmVmb3JlTXV0YXRpb25NYXNrIiwiTXV0YXRpb25NYXNrIiwiTGF5b3V0TWFzayIsIlBhc3NpdmVNYXNrIiwiU3RhdGljTWFzayIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiX19yZWFjdERpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJsb2ciLCJpbmZvIiwiZ3JvdXAiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwicHJvcHMiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwicHJlZml4IiwiZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUiLCJ1bmRlZmluZWQiLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsImRlc2NyaWJlRGVidWdJbmZvRnJhbWUiLCJlbnYiLCJyZWVudHJ5IiwiY29tcG9uZW50RnJhbWVDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCQxIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiSCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUiLCJjdG9yIiwiZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lIiwiZGVzY3JpYmVGaWJlciIsImdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCIsIndvcmtJblByb2dyZXNzIiwibm9kZSIsImRlYnVnSW5mbyIsIl9kZWJ1Z0luZm8iLCJpIiwiZW50cnkiLCJyZXR1cm4iLCJtZXNzYWdlIiwiY3VycmVudCIsImlzUmVuZGVyaW5nIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldiIsInJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFViIsInJlc2V0Q3VycmVudEZpYmVyIiwic2V0Q3VycmVudERlYnVnRmliZXJJbkRFViIsInNldEN1cnJlbnRGaWJlciIsImdldEN1cnJlbnRGaWJlciIsInNldElzUmVuZGVyaW5nIiwicmVuZGVyaW5nIiwiZ2V0TmVhcmVzdE1vdW50ZWRGaWJlciIsIm5lYXJlc3RNb3VudGVkIiwiYWx0ZXJuYXRlIiwibmV4dE5vZGUiLCJmbGFncyIsImlzTW91bnRlZCIsImNvbXBvbmVudCIsIm93bmVyRmliZXIiLCJpbnN0YW5jZSIsInN0YXRlTm9kZSIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImFzc2VydElzTW91bnRlZCIsImZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoIiwiYSIsImIiLCJwYXJlbnRBIiwicGFyZW50QiIsIm5leHRQYXJlbnQiLCJjaGlsZCIsInNpYmxpbmciLCJkaWRGaW5kQ2hpbGQiLCJfY2hpbGQiLCJmaW5kQ3VycmVudEhvc3RGaWJlciIsInBhcmVudCIsImN1cnJlbnRQYXJlbnQiLCJmaW5kQ3VycmVudEhvc3RGaWJlckltcGwiLCJmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMiLCJmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsIiwiaXNBcnJheUltcGwiLCJpc0FycmF5IiwiZ2V0UHVibGljSW5zdGFuY2UiLCJnZXRSb290SG9zdENvbnRleHQiLCJnZXRDaGlsZEhvc3RDb250ZXh0IiwicHJlcGFyZUZvckNvbW1pdCIsInJlc2V0QWZ0ZXJDb21taXQiLCJjcmVhdGVJbnN0YW5jZSIsImFwcGVuZEluaXRpYWxDaGlsZCIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwic2hvdWxkU2V0VGV4dENvbnRlbnQiLCJjcmVhdGVUZXh0SW5zdGFuY2UiLCJzY2hlZHVsZVRpbWVvdXQiLCJjYW5jZWxUaW1lb3V0Iiwibm9UaW1lb3V0IiwiaXNQcmltYXJ5UmVuZGVyZXIiLCJ3YXJuc0lmTm90QWN0aW5nIiwic3VwcG9ydHNNdXRhdGlvbiIsInN1cHBvcnRzUGVyc2lzdGVuY2UiLCJzdXBwb3J0c0h5ZHJhdGlvbiIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIiLCJhZnRlckFjdGl2ZUluc3RhbmNlQmx1ciIsInByZXBhcmVQb3J0YWxNb3VudCIsInByZXBhcmVTY29wZVVwZGF0ZSIsImdldEluc3RhbmNlRnJvbVNjb3BlIiwic2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5IiwiZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5IiwicmVzb2x2ZVVwZGF0ZVByaW9yaXR5Iiwic2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbiIsImRldGFjaERlbGV0ZWRJbnN0YW5jZSIsInJlcXVlc3RQb3N0UGFpbnRDYWxsYmFjayIsIm1heVN1c3BlbmRDb21taXQiLCJwcmVsb2FkSW5zdGFuY2UiLCJzdGFydFN1c3BlbmRpbmdDb21taXQiLCJzdXNwZW5kSW5zdGFuY2UiLCJ3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5IiwiTm90UGVuZGluZ1RyYW5zaXRpb24iLCJyZXNldEZvcm1JbnN0YW5jZSIsInN1cHBvcnRzTWljcm90YXNrcyIsInNjaGVkdWxlTWljcm90YXNrIiwic3VwcG9ydHNUZXN0U2VsZWN0b3JzIiwiZmluZEZpYmVyUm9vdCIsImdldEJvdW5kaW5nUmVjdCIsImdldFRleHRDb250ZW50IiwiaXNIaWRkZW5TdWJ0cmVlIiwibWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSIsInNldEZvY3VzSWZGb2N1c2FibGUiLCJzZXR1cEludGVyc2VjdGlvbk9ic2VydmVyIiwiYXBwZW5kQ2hpbGQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiY29tbWl0VGV4dFVwZGF0ZSIsImNvbW1pdE1vdW50IiwiY29tbWl0VXBkYXRlIiwiaW5zZXJ0QmVmb3JlIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJyZW1vdmVDaGlsZCIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsInJlc2V0VGV4dENvbnRlbnQiLCJoaWRlSW5zdGFuY2UiLCJoaWRlVGV4dEluc3RhbmNlIiwidW5oaWRlSW5zdGFuY2UiLCJ1bmhpZGVUZXh0SW5zdGFuY2UiLCJjbGVhckNvbnRhaW5lciIsImNsb25lSW5zdGFuY2UiLCJjcmVhdGVDb250YWluZXJDaGlsZFNldCIsImFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCIsImZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4iLCJyZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4iLCJjbG9uZUhpZGRlbkluc3RhbmNlIiwiY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UiLCJpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nIiwiaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2siLCJnZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMiLCJyZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeSIsImNhbkh5ZHJhdGVGb3JtU3RhdGVNYXJrZXIiLCJpc0Zvcm1TdGF0ZU1hcmtlck1hdGNoaW5nIiwiZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lciIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZSIsImNhbkh5ZHJhdGVJbnN0YW5jZSIsImNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSIsImh5ZHJhdGVJbnN0YW5jZSIsImh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSIsImdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UiLCJjb21taXRIeWRyYXRlZENvbnRhaW5lciIsImNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSIsImNsZWFyU3VzcGVuc2VCb3VuZGFyeSIsImNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIiLCJzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyIsImRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MiLCJkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3MiLCJkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzIiwidmFsaWRhdGVIeWRyYXRhYmxlSW5zdGFuY2UiLCJ2YWxpZGF0ZUh5ZHJhdGFibGVUZXh0SW5zdGFuY2UiLCJzdXBwb3J0c1Jlc291cmNlcyIsImlzSG9zdEhvaXN0YWJsZVR5cGUiLCJnZXRIb2lzdGFibGVSb290IiwiZ2V0UmVzb3VyY2UiLCJhY3F1aXJlUmVzb3VyY2UiLCJyZWxlYXNlUmVzb3VyY2UiLCJoeWRyYXRlSG9pc3RhYmxlIiwibW91bnRIb2lzdGFibGUiLCJ1bm1vdW50SG9pc3RhYmxlIiwiY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2UiLCJwcmVwYXJlVG9Db21taXRIb2lzdGFibGVzIiwibWF5UmVzb3VyY2VTdXNwZW5kQ29tbWl0IiwicHJlbG9hZFJlc291cmNlIiwic3VzcGVuZFJlc291cmNlIiwic3VwcG9ydHNTaW5nbGV0b25zIiwicmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlIiwiY2xlYXJTaW5nbGV0b24iLCJhY3F1aXJlU2luZ2xldG9uSW5zdGFuY2UiLCJyZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UiLCJpc0hvc3RTaW5nbGV0b25UeXBlIiwidmFsdWVTdGFjayIsImZpYmVyU3RhY2siLCJpbmRleCIsImNyZWF0ZUN1cnNvciIsImRlZmF1bHRWYWx1ZSIsInBvcCIsImN1cnNvciIsInB1c2giLCJlbXB0eUNvbnRleHRPYmplY3QiLCJmcmVlemUiLCJoYXNDb250ZXh0Q2hhbmdlZCIsImlzQ29udGV4dFByb3ZpZGVyIiwicHJvY2Vzc0NoaWxkQ29udGV4dCIsInBhcmVudENvbnRleHQiLCJmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dCIsIk9mZnNjcmVlblZpc2libGUiLCJPZmZzY3JlZW5EZXRhY2hlZCIsIk9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkIiwiaXNPZmZzY3JlZW5NYW51YWwiLCJvZmZzY3JlZW5GaWJlciIsIm1lbW9pemVkUHJvcHMiLCJtb2RlIiwiTm9Nb2RlIiwiQ29uY3VycmVudE1vZGUiLCJQcm9maWxlTW9kZSIsIlN0cmljdExlZ2FjeU1vZGUiLCJTdHJpY3RFZmZlY3RzTW9kZSIsIk5vU3RyaWN0UGFzc2l2ZUVmZmVjdHNNb2RlIiwiY2x6MzIiLCJNYXRoIiwiY2x6MzJGYWxsYmFjayIsImxvZyQxIiwiTE4yIiwiYXNVaW50IiwiVG90YWxMYW5lcyIsIk5vTGFuZXMiLCJOb0xhbmUiLCJTeW5jSHlkcmF0aW9uTGFuZSIsIlN5bmNMYW5lIiwiU3luY0xhbmVJbmRleCIsIklucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmUiLCJJbnB1dENvbnRpbnVvdXNMYW5lIiwiRGVmYXVsdEh5ZHJhdGlvbkxhbmUiLCJEZWZhdWx0TGFuZSIsIlN5bmNVcGRhdGVMYW5lcyIsIlRyYW5zaXRpb25IeWRyYXRpb25MYW5lIiwiVHJhbnNpdGlvbkxhbmVzIiwiVHJhbnNpdGlvbkxhbmUxIiwiVHJhbnNpdGlvbkxhbmUyIiwiVHJhbnNpdGlvbkxhbmUzIiwiVHJhbnNpdGlvbkxhbmU0IiwiVHJhbnNpdGlvbkxhbmU1IiwiVHJhbnNpdGlvbkxhbmU2IiwiVHJhbnNpdGlvbkxhbmU3IiwiVHJhbnNpdGlvbkxhbmU4IiwiVHJhbnNpdGlvbkxhbmU5IiwiVHJhbnNpdGlvbkxhbmUxMCIsIlRyYW5zaXRpb25MYW5lMTEiLCJUcmFuc2l0aW9uTGFuZTEyIiwiVHJhbnNpdGlvbkxhbmUxMyIsIlRyYW5zaXRpb25MYW5lMTQiLCJUcmFuc2l0aW9uTGFuZTE1IiwiUmV0cnlMYW5lcyIsIlJldHJ5TGFuZTEiLCJSZXRyeUxhbmUyIiwiUmV0cnlMYW5lMyIsIlJldHJ5TGFuZTQiLCJTb21lUmV0cnlMYW5lIiwiU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSIsIk5vbklkbGVMYW5lcyIsIklkbGVIeWRyYXRpb25MYW5lIiwiSWRsZUxhbmUiLCJPZmZzY3JlZW5MYW5lIiwiRGVmZXJyZWRMYW5lIiwiVXBkYXRlTGFuZXMiLCJnZXRMYWJlbEZvckxhbmUiLCJsYW5lIiwiTm9UaW1lc3RhbXAiLCJuZXh0VHJhbnNpdGlvbkxhbmUiLCJuZXh0UmV0cnlMYW5lIiwiZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMiLCJsYW5lcyIsInBlbmRpbmdTeW5jTGFuZXMiLCJnZXRIaWdoZXN0UHJpb3JpdHlMYW5lIiwiZ2V0TmV4dExhbmVzIiwicm9vdCIsIndpcExhbmVzIiwicGVuZGluZ0xhbmVzIiwibmV4dExhbmVzIiwic3VzcGVuZGVkTGFuZXMiLCJwaW5nZWRMYW5lcyIsIm5vbklkbGVQZW5kaW5nTGFuZXMiLCJub25JZGxlVW5ibG9ja2VkTGFuZXMiLCJub25JZGxlUGluZ2VkTGFuZXMiLCJ1bmJsb2NrZWRMYW5lcyIsIm5leHRMYW5lIiwid2lwTGFuZSIsImdldEVudGFuZ2xlZExhbmVzIiwicmVuZGVyTGFuZXMiLCJlbnRhbmdsZWRMYW5lcyIsImFsbEVudGFuZ2xlZExhbmVzIiwiZW50YW5nbGVtZW50cyIsInBpY2tBcmJpdHJhcnlMYW5lSW5kZXgiLCJjb21wdXRlRXhwaXJhdGlvblRpbWUiLCJjdXJyZW50VGltZSIsIm1hcmtTdGFydmVkTGFuZXNBc0V4cGlyZWQiLCJleHBpcmF0aW9uVGltZXMiLCJleHBpcmF0aW9uVGltZSIsImV4cGlyZWRMYW5lcyIsImdldEhpZ2hlc3RQcmlvcml0eVBlbmRpbmdMYW5lcyIsImdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yIiwib3JpZ2luYWxseUF0dGVtcHRlZExhbmVzIiwiZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMiLCJldmVyeXRoaW5nQnV0T2Zmc2NyZWVuIiwiaW5jbHVkZXNTeW5jTGFuZSIsImluY2x1ZGVzTm9uSWRsZVdvcmsiLCJpbmNsdWRlc09ubHlSZXRyaWVzIiwiaW5jbHVkZXNPbmx5Tm9uVXJnZW50TGFuZXMiLCJVcmdlbnRMYW5lcyIsImluY2x1ZGVzT25seVRyYW5zaXRpb25zIiwiaW5jbHVkZXNCbG9ja2luZ0xhbmUiLCJTeW5jRGVmYXVsdExhbmVzIiwiaW5jbHVkZXNFeHBpcmVkTGFuZSIsImlzVHJhbnNpdGlvbkxhbmUiLCJjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSIsImNsYWltTmV4dFJldHJ5TGFuZSIsInBpY2tBcmJpdHJhcnlMYW5lIiwibGFuZVRvSW5kZXgiLCJpbmNsdWRlc1NvbWVMYW5lIiwiaXNTdWJzZXRPZkxhbmVzIiwic3Vic2V0IiwibWVyZ2VMYW5lcyIsInJlbW92ZUxhbmVzIiwiaW50ZXJzZWN0TGFuZXMiLCJsYW5lVG9MYW5lcyIsImhpZ2hlclByaW9yaXR5TGFuZSIsImNyZWF0ZUxhbmVNYXAiLCJpbml0aWFsIiwibGFuZU1hcCIsIm1hcmtSb290VXBkYXRlZCQxIiwidXBkYXRlTGFuZSIsIm1hcmtSb290U3VzcGVuZGVkJDEiLCJzcGF3bmVkTGFuZSIsIm1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lIiwibWFya1Jvb3RQaW5nZWQkMSIsIm1hcmtSb290RmluaXNoZWQiLCJyZW1haW5pbmdMYW5lcyIsIm5vTG9uZ2VyUGVuZGluZ0xhbmVzIiwic2hlbGxTdXNwZW5kQ291bnRlciIsImhpZGRlblVwZGF0ZXMiLCJoaWRkZW5VcGRhdGVzRm9yTGFuZSIsInVwZGF0ZSIsInNwYXduZWRMYW5lSW5kZXgiLCJtYXJrUm9vdEVudGFuZ2xlZCIsInJvb3RFbnRhbmdsZWRMYW5lcyIsInVwZ3JhZGVQZW5kaW5nTGFuZVRvU3luYyIsInVwZ3JhZGVQZW5kaW5nTGFuZXNUb1N5bmMiLCJsYW5lc1RvVXBncmFkZSIsIm1hcmtIaWRkZW5VcGRhdGUiLCJnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uIiwicmVuZGVyTGFuZSIsImFkZEZpYmVyVG9MYW5lc01hcCIsImlzRGV2VG9vbHNQcmVzZW50IiwicGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCIsInVwZGF0ZXJzIiwiYWRkIiwibW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkIiwibWVtb2l6ZWRVcGRhdGVycyIsInNpemUiLCJmb3JFYWNoIiwiaGFzIiwiY2xlYXIiLCJnZXRUcmFuc2l0aW9uc0ZvckxhbmVzIiwiRGlzY3JldGVFdmVudFByaW9yaXR5IiwiQ29udGludW91c0V2ZW50UHJpb3JpdHkiLCJEZWZhdWx0RXZlbnRQcmlvcml0eSIsIklkbGVFdmVudFByaW9yaXR5IiwiaGlnaGVyRXZlbnRQcmlvcml0eSIsImxvd2VyRXZlbnRQcmlvcml0eSIsImlzSGlnaGVyRXZlbnRQcmlvcml0eSIsImV2ZW50UHJpb3JpdHlUb0xhbmUiLCJ1cGRhdGVQcmlvcml0eSIsImxhbmVzVG9FdmVudFByaW9yaXR5Iiwic2NoZWR1bGVDYWxsYmFjayQzIiwidW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayIsImNhbmNlbENhbGxiYWNrJDEiLCJ1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayIsInNob3VsZFlpZWxkIiwidW5zdGFibGVfc2hvdWxkWWllbGQiLCJyZXF1ZXN0UGFpbnQiLCJ1bnN0YWJsZV9yZXF1ZXN0UGFpbnQiLCJub3ckMSIsInVuc3RhYmxlX25vdyIsIkltbWVkaWF0ZVByaW9yaXR5IiwidW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkiLCJVc2VyQmxvY2tpbmdQcmlvcml0eSIsInVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5IiwiTm9ybWFsUHJpb3JpdHkkMSIsInVuc3RhYmxlX05vcm1hbFByaW9yaXR5IiwiSWRsZVByaW9yaXR5IiwidW5zdGFibGVfSWRsZVByaW9yaXR5IiwidW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUiLCJyZW5kZXJlcklEIiwiaW5qZWN0ZWRIb29rIiwiaW5qZWN0ZWRQcm9maWxpbmdIb29rcyIsImhhc0xvZ2dlZEVycm9yIiwiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaW5qZWN0SW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiaG9vayIsImlzRGlzYWJsZWQiLCJzdXBwb3J0c0ZpYmVyIiwiZ2V0TGFuZUxhYmVsTWFwIiwiaW5qZWN0UHJvZmlsaW5nSG9va3MiLCJpbmplY3QiLCJlcnIiLCJjaGVja0RDRSIsIm9uU2NoZWR1bGVSb290IiwiY2hpbGRyZW4iLCJvblNjaGVkdWxlRmliZXJSb290Iiwib25Db21taXRSb290JDEiLCJldmVudFByaW9yaXR5Iiwib25Db21taXRGaWJlclJvb3QiLCJkaWRFcnJvciIsInNjaGVkdWxlclByaW9yaXR5Iiwib25Qb3N0Q29tbWl0Um9vdCIsIm9uUG9zdENvbW1pdEZpYmVyUm9vdCIsIm9uQ29tbWl0VW5tb3VudCIsIm9uQ29tbWl0RmliZXJVbm1vdW50Iiwic2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMiLCJuZXdJc1N0cmljdE1vZGUiLCJzZXRTdHJpY3RNb2RlIiwicHJvZmlsaW5nSG9va3MiLCJsYWJlbCIsIm1hcmtDb21taXRTdGFydGVkIiwibWFya0NvbW1pdFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCIsIm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50RXJyb3JlZCIsInRocm93blZhbHVlIiwibWFya0NvbXBvbmVudFN1c3BlbmRlZCIsIndha2VhYmxlIiwibWFya0xheW91dEVmZmVjdHNTdGFydGVkIiwibWFya0xheW91dEVmZmVjdHNTdG9wcGVkIiwibWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCIsIm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQiLCJtYXJrUmVuZGVyU3RhcnRlZCIsIm1hcmtSZW5kZXJZaWVsZGVkIiwibWFya1JlbmRlclN0b3BwZWQiLCJtYXJrUmVuZGVyU2NoZWR1bGVkIiwibWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkIiwibWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkIiwiaXMiLCJ5Iiwib2JqZWN0SXMiLCJpc1Jvb3REZWh5ZHJhdGVkIiwiY3VycmVudFN0YXRlIiwibWVtb2l6ZWRTdGF0ZSIsImlzRGVoeWRyYXRlZCIsIkNhcHR1cmVkU3RhY2tzIiwiY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIiLCJzb3VyY2UiLCJjYXB0dXJlZFN0YWNrIiwiY3JlYXRlQ2FwdHVyZWRWYWx1ZUZyb21FcnJvciIsImZvcmtTdGFjayIsImZvcmtTdGFja0luZGV4IiwidHJlZUZvcmtQcm92aWRlciIsInRyZWVGb3JrQ291bnQiLCJpZFN0YWNrIiwiaWRTdGFja0luZGV4IiwidHJlZUNvbnRleHRQcm92aWRlciIsInRyZWVDb250ZXh0SWQiLCJ0cmVlQ29udGV4dE92ZXJmbG93IiwiaXNGb3JrZWRDaGlsZCIsIndhcm5JZk5vdEh5ZHJhdGluZyIsImdldEZvcmtzQXRMZXZlbCIsImdldFRyZWVJZCIsIm92ZXJmbG93IiwiaWRXaXRoTGVhZGluZ0JpdCIsImlkIiwiZ2V0TGVhZGluZ0JpdCIsInRvU3RyaW5nIiwicHVzaFRyZWVGb3JrIiwidG90YWxDaGlsZHJlbiIsInB1c2hUcmVlSWQiLCJiYXNlSWRXaXRoTGVhZGluZ0JpdCIsImJhc2VPdmVyZmxvdyIsImJhc2VMZW5ndGgiLCJnZXRCaXRMZW5ndGgiLCJiYXNlSWQiLCJzbG90IiwibnVtYmVyT2ZPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvdyIsInJlc3RPZkJhc2VJZCIsInJlc3RPZkJhc2VMZW5ndGgiLCJyZXN0T2ZMZW5ndGgiLCJyZXN0T2ZOZXdCaXRzIiwibmV3Qml0cyIsIl9pZCIsIl9vdmVyZmxvdyIsInB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQiLCJyZXR1cm5GaWJlciIsIm51bWJlck9mRm9ya3MiLCJzbG90SW5kZXgiLCJudW1iZXIiLCJwb3BUcmVlQ29udGV4dCIsImdldFN1c3BlbmRlZFRyZWVDb250ZXh0IiwicmVzdG9yZVN1c3BlbmRlZFRyZWVDb250ZXh0Iiwic3VzcGVuZGVkQ29udGV4dCIsImdldElzSHlkcmF0aW5nIiwiY29udGV4dFN0YWNrQ3Vyc29yIiwiY29udGV4dEZpYmVyU3RhY2tDdXJzb3IiLCJyb290SW5zdGFuY2VTdGFja0N1cnNvciIsImhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IiLCJIb3N0VHJhbnNpdGlvbkNvbnRleHQiLCJQcm92aWRlciIsIkNvbnN1bWVyIiwiX2N1cnJlbnRWYWx1ZSIsIl9jdXJyZW50VmFsdWUyIiwiX3RocmVhZENvdW50IiwicmVxdWlyZWRDb250ZXh0IiwiZ2V0Um9vdEhvc3RDb250YWluZXIiLCJyb290SW5zdGFuY2UiLCJwdXNoSG9zdENvbnRhaW5lciIsIm5leHRSb290SW5zdGFuY2UiLCJuZXh0Um9vdENvbnRleHQiLCJwb3BIb3N0Q29udGFpbmVyIiwiZ2V0SG9zdENvbnRleHQiLCJwdXNoSG9zdENvbnRleHQiLCJzdGF0ZUhvb2siLCJuZXh0Q29udGV4dCIsInBvcEhvc3RDb250ZXh0IiwibWF4Um93TGVuZ3RoIiwiaWRlYWxEZXB0aCIsImZpbmROb3RhYmxlTm9kZSIsImluZGVudCIsInNlcnZlclByb3BzIiwic2VydmVyVGFpbCIsImRpc3RhbmNlRnJvbUxlYWYiLCJpbmRlbnRhdGlvbiIsInJlcGVhdCIsImFkZGVkIiwicmVtb3ZlZCIsImRlc2NyaWJlRmliZXJUeXBlIiwiY3RyIiwibmVlZHNFc2NhcGluZyIsImRlc2NyaWJlVGV4dE5vZGUiLCJjb250ZW50IiwibWF4TGVuZ3RoIiwidGVzdCIsImVuY29kZWQiLCJKU09OIiwic3RyaW5naWZ5Iiwic2xpY2UiLCJkZXNjcmliZVRleHREaWZmIiwiY2xpZW50VGV4dCIsInNlcnZlclRleHQiLCJmaXJzdERpZmYiLCJjaGFyQ29kZUF0Iiwib2JqZWN0TmFtZSIsIm9iamVjdCIsIm0iLCJwMCIsImRlc2NyaWJlVmFsdWUiLCJwcm9wZXJ0aWVzIiwicHJvcE5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsImpzb25Qcm9wTmFtZSIsInByb3BWYWx1ZSIsIl9uYW1lIiwiZGVzY3JpYmVQcm9wVmFsdWUiLCJkZXNjcmliZUNvbGxhcHNlZEVsZW1lbnQiLCJkZXNjcmliZUV4cGFuZGVkRWxlbWVudCIsInJvd1ByZWZpeCIsInJlbWFpbmluZ1Jvd0xlbmd0aCIsImpvaW4iLCJkZXNjcmliZVByb3BlcnRpZXNEaWZmIiwiY2xpZW50T2JqZWN0Iiwic2VydmVyT2JqZWN0IiwicmVtYWluaW5nU2VydmVyUHJvcGVydGllcyIsImNsaWVudFZhbHVlIiwiY2xpZW50UHJvcFZhbHVlIiwic2VydmVyVmFsdWUiLCJzZXJ2ZXJQcm9wVmFsdWUiLCJfcHJvcE5hbWUiLCJfbWF4TGVuZ3RoIiwiX3NlcnZlclZhbHVlIiwiX3NlcnZlclByb3BWYWx1ZSIsImRlc2NyaWJlRWxlbWVudERpZmYiLCJjbGllbnRQcm9wcyIsInNlcnZlclByb3BOYW1lcyIsInRvTG93ZXJDYXNlIiwiX3Byb3BOYW1lMiIsInNlcnZlclByb3BOYW1lIiwiZGVsZXRlIiwia2V5cyIsImluZGV4T2YiLCJzZXJ2ZXJDaGlsZHJlbiIsImNsaWVudENoaWxkcmVuIiwiZGVzY3JpYmVTaWJsaW5nRmliZXIiLCJmbGF0Q29udGVudCIsImNoaWxkRmliZXIiLCJkZXNjcmliZU5vZGUiLCJza2lwVG9Ob2RlIiwicGFyZW50Q29udGVudCIsInNlcnZlckNvbXBvbmVudE5hbWUiLCJzZWxmQ29udGVudCIsInBlbmRpbmdQcm9wcyIsImNoaWxkQ29udGVudCIsImRpZmZJZHgiLCJjaGlsZE5vZGUiLCJfaSIsInRhaWxOb2RlIiwiZGVzY3JpYmVEaWZmIiwicm9vdE5vZGUiLCJoeWRyYXRpb25QYXJlbnRGaWJlciIsIm5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJpc0h5ZHJhdGluZyIsImRpZFN1c3BlbmRPckVycm9yREVWIiwiaHlkcmF0aW9uRGlmZlJvb3RERVYiLCJoeWRyYXRpb25FcnJvcnMiLCJyb290T3JTaW5nbGV0b25Db250ZXh0IiwiYnVpbGRIeWRyYXRpb25EaWZmTm9kZSIsInNpYmxpbmdzIiwiZXhpc3RpbmciLCJuZXdOb2RlIiwid2FybklmSHlkcmF0aW5nIiwibWFya0RpZFRocm93V2hpbGVIeWRyYXRpbmdERVYiLCJlbnRlckh5ZHJhdGlvblN0YXRlIiwicGFyZW50SW5zdGFuY2UiLCJjb250YWluZXJJbmZvIiwicmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlIiwic3VzcGVuc2VJbnN0YW5jZSIsInRyZWVDb250ZXh0Iiwid2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2UiLCJyZWplY3RlZENhbmRpZGF0ZSIsImRpZmZOb2RlIiwiZGVzY3JpcHRpb24iLCJ0cnlIeWRyYXRlSW5zdGFuY2UiLCJuZXh0SW5zdGFuY2UiLCJob3N0Q29udGV4dCIsImRpZmZlcmVuY2VzIiwidHJ5SHlkcmF0ZVRleHQiLCJ0ZXh0IiwidGV4dEluc3RhbmNlIiwidHJ5SHlkcmF0ZVN1c3BlbnNlIiwic3VzcGVuc2VTdGF0ZSIsImRlaHlkcmF0ZWQiLCJyZXRyeUxhbmUiLCJkZWh5ZHJhdGVkRnJhZ21lbnQiLCJjcmVhdGVGaWJlckZyb21EZWh5ZHJhdGVkRnJhZ21lbnQiLCJIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiIsInRocm93T25IeWRyYXRpb25NaXNtYXRjaCIsImRpZmYiLCJkaWZmUm9vdCIsInF1ZXVlSHlkcmF0aW9uRXJyb3IiLCJjbGFpbUh5ZHJhdGFibGVTaW5nbGV0b24iLCJjdXJyZW50Um9vdENvbnRhaW5lciIsImN1cnJlbnRIb3N0Q29udGV4dCIsInRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwic2hvdWxkS2VlcFdhcm5pbmciLCJ0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UiLCJ0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlIiwidHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlRm9ybU1hcmtlckluc3RhbmNlIiwibWFya2VySW5zdGFuY2UiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlIiwiZGlkSHlkcmF0ZSIsInByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIiwidGV4dENvbnRlbnQiLCJzaG91bGRXYXJuSWZNaXNtYXRjaERldiIsInBhcmVudFByb3BzIiwiZGlmZmVyZW5jZSIsIl9kaWZmZXJlbmNlIiwiX2RpZmZOb2RlIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlIiwic2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSIsInBvcFRvTmV4dEhvc3RQYXJlbnQiLCJwb3BIeWRyYXRpb25TdGF0ZSIsInNob3VsZENsZWFyIiwid2FybklmVW5oeWRyYXRlZFRhaWxOb2RlcyIsInJlc2V0SHlkcmF0aW9uU3RhdGUiLCJ1cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSIsInF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMiLCJlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzIiwiY29uY3VycmVudFF1ZXVlcyIsImNvbmN1cnJlbnRRdWV1ZXNJbmRleCIsImNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyIsImZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMiLCJlbmRJbmRleCIsInF1ZXVlIiwicGVuZGluZyIsIm5leHQiLCJtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdCIsImdldENvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyIsImVucXVldWVVcGRhdGUkMSIsImVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZSIsImNvbmN1cnJlbnRRdWV1ZSIsImNvbmN1cnJlbnRVcGRhdGUiLCJnZXRSb290Rm9yVXBkYXRlZEZpYmVyIiwiZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlQW5kRWFnZXJseUJhaWxvdXQiLCJpc0NvbmN1cnJlbnRseVJlbmRlcmluZyIsImdldFdvcmtJblByb2dyZXNzUm9vdCIsImVucXVldWVDb25jdXJyZW50Q2xhc3NVcGRhdGUiLCJlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUiLCJ1bnNhZmVfbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QiLCJzb3VyY2VGaWJlciIsImlzSGlkZGVuIiwiY2hpbGRMYW5lcyIsIm9mZnNjcmVlbkluc3RhbmNlIiwiX3Zpc2liaWxpdHkiLCJ0aHJvd0lmSW5maW5pdGVVcGRhdGVMb29wRGV0ZWN0ZWQiLCJkZXRlY3RVcGRhdGVPblVubW91bnRlZEZpYmVyIiwid2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFViIsImZpcnN0U2NoZWR1bGVkUm9vdCIsImxhc3RTY2hlZHVsZWRSb290IiwiZGlkU2NoZWR1bGVNaWNyb3Rhc2siLCJkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QiLCJtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsiLCJpc0ZsdXNoaW5nV29yayIsImN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lIiwiZW5zdXJlUm9vdElzU2NoZWR1bGVkIiwiYWN0UXVldWUiLCJzY2hlZHVsZUltbWVkaWF0ZVRhc2siLCJwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2siLCJmbHVzaFN5bmNXb3JrT25BbGxSb290cyIsImZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsIiwib25seUxlZ2FjeSIsImRpZFBlcmZvcm1Tb21lV29yayIsIndvcmtJblByb2dyZXNzUm9vdCIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIiwiZ2V0V29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMiLCJwZXJmb3JtU3luY1dvcmtPblJvb3QiLCJwcmV2Iiwic2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayIsImV4aXN0aW5nQ2FsbGJhY2tOb2RlIiwiY2FsbGJhY2tOb2RlIiwiaXNXb3JrTG9vcFN1c3BlbmRlZE9uRGF0YSIsImNhbmNlbFBlbmRpbmdDb21taXQiLCJjYW5jZWxDYWxsYmFjayIsImNhbGxiYWNrUHJpb3JpdHkiLCJleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkiLCJuZXdDYWxsYmFja1ByaW9yaXR5IiwiZmFrZUFjdENhbGxiYWNrTm9kZSQxIiwic2NoZWR1bGVyUHJpb3JpdHlMZXZlbCIsIm5ld0NhbGxiYWNrTm9kZSIsInNjaGVkdWxlQ2FsbGJhY2skMiIsInBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdCIsImJpbmQiLCJnZXRDb250aW51YXRpb25Gb3JSb290Iiwib3JpZ2luYWxDYWxsYmFja05vZGUiLCJwcmlvcml0eUxldmVsIiwiY2FsbGJhY2siLCJjYiIsImV4ZWN1dGlvbkNvbnRleHQiLCJnZXRFeGVjdXRpb25Db250ZXh0IiwiUmVuZGVyQ29udGV4dCIsIkNvbW1pdENvbnRleHQiLCJOb0NvbnRleHQiLCJyZXF1ZXN0VHJhbnNpdGlvbkxhbmUiLCJ0cmFuc2l0aW9uIiwiY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyIsImN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQiLCJjdXJyZW50RW50YW5nbGVkTGFuZSIsImN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSIsImVudGFuZ2xlQXN5bmNBY3Rpb24iLCJ0aGVuYWJsZSIsImVudGFuZ2xlZExpc3RlbmVycyIsImVudGFuZ2xlZFRoZW5hYmxlIiwic3RhdHVzIiwidGhlbiIsInJlc29sdmUiLCJwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlIiwiZnVsZmlsbGVkVGhlbmFibGUiLCJsaXN0ZW5lcnMiLCJsaXN0ZW5lciIsImNoYWluVGhlbmFibGVWYWx1ZSIsInJlc3VsdCIsInRoZW5hYmxlV2l0aE92ZXJyaWRlIiwicmVhc29uIiwicmVqZWN0ZWRUaGVuYWJsZSIsInBlZWtFbnRhbmdsZWRBY3Rpb25MYW5lIiwicGVla0VudGFuZ2xlZEFjdGlvblRoZW5hYmxlIiwiVXBkYXRlU3RhdGUiLCJSZXBsYWNlU3RhdGUiLCJGb3JjZVVwZGF0ZSIsIkNhcHR1cmVVcGRhdGUiLCJoYXNGb3JjZVVwZGF0ZSIsImRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUiLCJjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUiLCJpbml0aWFsaXplVXBkYXRlUXVldWUiLCJiYXNlU3RhdGUiLCJmaXJzdEJhc2VVcGRhdGUiLCJsYXN0QmFzZVVwZGF0ZSIsInNoYXJlZCIsImhpZGRlbkNhbGxiYWNrcyIsImNhbGxiYWNrcyIsInVwZGF0ZVF1ZXVlIiwiY2xvbmVVcGRhdGVRdWV1ZSIsImN1cnJlbnRRdWV1ZSIsImNsb25lIiwiY3JlYXRlVXBkYXRlIiwiZW5xdWV1ZVVwZGF0ZSIsInNoYXJlZFF1ZXVlIiwiY29tcG9uZW50TmFtZSIsImlzVW5zYWZlQ2xhc3NSZW5kZXJQaGFzZVVwZGF0ZSIsImVudGFuZ2xlVHJhbnNpdGlvbnMiLCJxdWV1ZUxhbmVzIiwibmV3UXVldWVMYW5lcyIsImVucXVldWVDYXB0dXJlZFVwZGF0ZSIsImNhcHR1cmVkVXBkYXRlIiwibmV3Rmlyc3QiLCJuZXdMYXN0IiwiZ2V0U3RhdGVGcm9tVXBkYXRlIiwicHJldlN0YXRlIiwibmV4dFByb3BzIiwiZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsIm5leHRTdGF0ZSIsImV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsInBhcnRpYWxTdGF0ZSIsImRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24iLCJzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uIiwiZW50YW5nbGVkQWN0aW9uVGhlbmFibGUiLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJwZW5kaW5nUXVldWUiLCJsYXN0UGVuZGluZ1VwZGF0ZSIsImZpcnN0UGVuZGluZ1VwZGF0ZSIsImN1cnJlbnRMYXN0QmFzZVVwZGF0ZSIsIm5ld1N0YXRlIiwibmV3TGFuZXMiLCJuZXdCYXNlU3RhdGUiLCJuZXdGaXJzdEJhc2VVcGRhdGUiLCJuZXdMYXN0QmFzZVVwZGF0ZSIsImlzSGlkZGVuVXBkYXRlIiwic2hvdWxkU2tpcFVwZGF0ZSIsIl9jbG9uZSIsIl9sYXN0UGVuZGluZ1VwZGF0ZSIsIl9maXJzdFBlbmRpbmdVcGRhdGUiLCJtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzIiwiY2FsbENhbGxiYWNrIiwicmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmciLCJjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nIiwiZGVmZXJIaWRkZW5DYWxsYmFja3MiLCJuZXdIaWRkZW5DYWxsYmFja3MiLCJleGlzdGluZ0hpZGRlbkNhbGxiYWNrcyIsImNvbW1pdEhpZGRlbkNhbGxiYWNrcyIsImNvbW1pdENhbGxiYWNrcyIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzQiIsImN1cnJlbnRLZXkiLCJSZWFjdFN0cmljdE1vZGVXYXJuaW5ncyIsInJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwiZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJyZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyIsImZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmciLCJkaXNjYXJkUGVuZGluZ1dhcm5pbmdzIiwiZmluZFN0cmljdFJvb3QiLCJtYXliZVN0cmljdFJvb3QiLCJzZXRUb1NvcnRlZFN0cmluZyIsImFycmF5Iiwic29ydCIsInBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MiLCJwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzIiwicGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MiLCJwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzIiwicGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MiLCJkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzIiwiU2V0IiwiY29tcG9uZW50V2lsbE1vdW50IiwiX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUiLCJjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMiLCJjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzIiwic29ydGVkTmFtZXMiLCJfc29ydGVkTmFtZXMiLCJfc29ydGVkTmFtZXMyIiwiX3NvcnRlZE5hbWVzMyIsIl9zb3J0ZWROYW1lczQiLCJfc29ydGVkTmFtZXM1IiwicGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCIsInN0cmljdFJvb3QiLCJ3YXJuaW5nc0ZvclJvb3QiLCJjb250ZXh0VHlwZXMiLCJjaGlsZENvbnRleHRUeXBlcyIsImdldENoaWxkQ29udGV4dCIsImZpYmVyQXJyYXkiLCJmaXJzdEZpYmVyIiwidW5pcXVlTmFtZXMiLCJnZXRUaGVuYWJsZXNGcm9tU3RhdGUiLCJzdGF0ZSIsImRldlN0YXRlIiwidGhlbmFibGVzIiwiU3VzcGVuc2VFeGNlcHRpb24iLCJTdXNwZW5zZXlDb21taXRFeGNlcHRpb24iLCJub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUiLCJjcmVhdGVUaGVuYWJsZVN0YXRlIiwiZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlIiwiaXNUaGVuYWJsZVJlc29sdmVkIiwibm9vcCQxIiwidHJhY2tVc2VkVGhlbmFibGUiLCJ0aGVuYWJsZVN0YXRlIiwiZGlkVXNlUHJvbWlzZSIsInRyYWNrZWRUaGVuYWJsZXMiLCJwcmV2aW91cyIsInRoZW5hYmxlU3RhdGVEZXYiLCJmdWxmaWxsZWRWYWx1ZSIsInJlamVjdGVkRXJyb3IiLCJjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaCIsInBlbmRpbmdUaGVuYWJsZSIsIl9yZWplY3RlZEVycm9yIiwic3VzcGVuZGVkVGhlbmFibGUiLCJuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViIsInN1c3BlbmRDb21taXQiLCJnZXRTdXNwZW5kZWRUaGVuYWJsZSIsImNoZWNrSWZVc2VXcmFwcGVkSW5UcnlDYXRjaCIsInJlamVjdGVkUmVhc29uIiwidGhlbmFibGVTdGF0ZSQxIiwidGhlbmFibGVJbmRleENvdW50ZXIkMSIsIm1lcmdlRGVidWdJbmZvIiwib3V0ZXIiLCJpbm5lciIsImRpZFdhcm5BYm91dE1hcHMiLCJkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwib3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nIiwib3duZXJIYXNTeW1ib2xUeXBlV2FybmluZyIsIndhcm5Gb3JNaXNzaW5nS2V5IiwiX3N0b3JlIiwidmFsaWRhdGVkIiwiY29tcG9uZW50S2V5IiwiY2hpbGRPd25lciIsIl9vd25lciIsInBhcmVudE93bmVyIiwiX2RlYnVnT3duZXIiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lckFwcGVuZGl4Iiwib3duZXJOYW1lIiwiY3JlYXRlRmliZXJGcm9tRWxlbWVudCIsInByZXZEZWJ1Z0ZpYmVyIiwidmFsaWRhdGVGcmFnbWVudFByb3BzIiwiZWxlbWVudCIsInVud3JhcFRoZW5hYmxlIiwiY29lcmNlUmVmIiwicmVmIiwicmVmUHJvcCIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsIm5ld0NoaWxkIiwiY2hpbGRTdHJpbmciLCJ3YXJuT25GdW5jdGlvblR5cGUiLCJpbnZhbGlkQ2hpbGQiLCJwYXJlbnROYW1lIiwid2Fybk9uU3ltYm9sVHlwZSIsInJlc29sdmVMYXp5IiwibGF6eVR5cGUiLCJjcmVhdGVDaGlsZFJlY29uY2lsZXIiLCJzaG91bGRUcmFja1NpZGVFZmZlY3RzIiwiZGVsZXRlQ2hpbGQiLCJjaGlsZFRvRGVsZXRlIiwiZGVsZXRpb25zIiwiZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4iLCJjdXJyZW50Rmlyc3RDaGlsZCIsIm1hcFJlbWFpbmluZ0NoaWxkcmVuIiwiZXhpc3RpbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGQiLCJ1c2VGaWJlciIsImNyZWF0ZVdvcmtJblByb2dyZXNzIiwicGxhY2VDaGlsZCIsIm5ld0ZpYmVyIiwibGFzdFBsYWNlZEluZGV4IiwibmV3SW5kZXgiLCJvbGRJbmRleCIsInBsYWNlU2luZ2xlQ2hpbGQiLCJ1cGRhdGVUZXh0Tm9kZSIsImNyZWF0ZWQiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwidXBkYXRlRWxlbWVudCIsImVsZW1lbnRUeXBlIiwidXBkYXRlZCIsInVwZGF0ZUZyYWdtZW50IiwiaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nIiwidXBkYXRlUG9ydGFsIiwicG9ydGFsIiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJmcmFnbWVudCIsImNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfY3JlYXRlZCIsIl9jcmVhdGVkMiIsIl9jcmVhdGVkMyIsInJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24iLCJ1cGRhdGVTbG90Iiwib2xkRmliZXIiLCJ1cGRhdGVGcm9tTWFwIiwibmV3SWR4IiwibWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlciIsIl9tYXRjaGVkRmliZXIyIiwiX21hdGNoZWRGaWJlcjMiLCJ3YXJuT25JbnZhbGlkS2V5Iiwia25vd25LZXlzIiwicmVjb25jaWxlQ2hpbGRyZW5BcnJheSIsIm5ld0NoaWxkcmVuIiwicmVzdWx0aW5nRmlyc3RDaGlsZCIsInByZXZpb3VzTmV3RmliZXIiLCJuZXh0T2xkRmliZXIiLCJfbmV3RmliZXIiLCJfbnVtYmVyT2ZGb3JrcyIsIl9uZXdGaWJlcjIiLCJfbnVtYmVyT2ZGb3JrczIiLCJyZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdGFibGUiLCJuZXdDaGlsZHJlbkl0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsImlzR2VuZXJhdG9yQ29tcG9uZW50IiwiZW50cmllcyIsInJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IiLCJzdGVwIiwiZG9uZSIsIl9uZXdGaWJlcjMiLCJfbnVtYmVyT2ZGb3JrczMiLCJfbmV3RmliZXI0IiwiX251bWJlck9mRm9ya3M0IiwicmVjb25jaWxlU2luZ2xlVGV4dE5vZGUiLCJyZWNvbmNpbGVTaW5nbGVFbGVtZW50IiwiX2V4aXN0aW5nIiwiX2NyZWF0ZWQ0IiwicmVjb25jaWxlU2luZ2xlUG9ydGFsIiwicmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsIiwiaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCIsInJlY29uY2lsZUNoaWxkRmliZXJzIiwiZmlyc3RDaGlsZEZpYmVyIiwibW91bnRDaGlsZEZpYmVycyIsInJlc2V0Q2hpbGRSZWNvbmNpbGVyT25VbndpbmQiLCJjbG9uZUNoaWxkRmliZXJzIiwiY3VycmVudENoaWxkIiwicmVzZXRDaGlsZEZpYmVycyIsInJlc2V0V29ya0luUHJvZ3Jlc3MiLCJjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yIiwicHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yIiwicHVzaEhpZGRlbkNvbnRleHQiLCJwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMiLCJnZXRFbnRhbmdsZWRSZW5kZXJMYW5lcyIsInNldEVudGFuZ2xlZFJlbmRlckxhbmVzIiwiYmFzZUxhbmVzIiwicmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayIsInBvcEhpZGRlbkNvbnRleHQiLCJpc0N1cnJlbnRUcmVlSGlkZGVuIiwic3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IiLCJzaGVsbEJvdW5kYXJ5IiwiZ2V0U2hlbGxCb3VuZGFyeSIsInB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlciIsImhhbmRsZXIiLCJwdXNoU3VzcGVuc2VMaXN0Q29udGV4dCIsInNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VMaXN0Q29udGV4dCIsInN1c3BlbnNlU3RhY2tDdXJzb3IiLCJwdXNoRmFsbGJhY2tUcmVlU3VzcGVuc2VIYW5kbGVyIiwicmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrIiwicHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlciIsImdldFN1c3BlbnNlSGFuZGxlciIsInBvcFN1c3BlbnNlSGFuZGxlciIsInBvcFN1c3BlbnNlTGlzdENvbnRleHQiLCJEZWZhdWx0U3VzcGVuc2VDb250ZXh0IiwiU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2siLCJGb3JjZVN1c3BlbnNlRmFsbGJhY2siLCJoYXNTdXNwZW5zZUxpc3RDb250ZXh0IiwiZmxhZyIsInNldFNoYWxsb3dTdXNwZW5zZUxpc3RDb250ZXh0Iiwic2hhbGxvd0NvbnRleHQiLCJuZXdDb250ZXh0IiwiZmluZEZpcnN0U3VzcGVuZGVkIiwicm93IiwicmV2ZWFsT3JkZXIiLCJkaWRTdXNwZW5kIiwiTm9GbGFncyIsIkhhc0VmZmVjdCIsIkluc2VydGlvbiIsIkxheW91dCIsIlBhc3NpdmUiLCJkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQiLCJkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCIsImRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoIiwiZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQiLCJkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGUiLCJjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxIiwiY3VycmVudEhvb2siLCJ3b3JrSW5Qcm9ncmVzc0hvb2siLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlIiwiZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzIiwic2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYiLCJsb2NhbElkQ291bnRlciIsInRoZW5hYmxlSW5kZXhDb3VudGVyIiwiZ2xvYmFsQ2xpZW50SWRDb3VudGVyIiwiUkVfUkVOREVSX0xJTUlUIiwiY3VycmVudEhvb2tOYW1lSW5EZXYiLCJob29rVHlwZXNEZXYiLCJob29rVHlwZXNVcGRhdGVJbmRleERldiIsImlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzIiwibW91bnRIb29rVHlwZXNEZXYiLCJob29rTmFtZSIsInVwZGF0ZUhvb2tUeXBlc0RldiIsIndhcm5Pbkhvb2tNaXNtYXRjaEluRGV2IiwiY2hlY2tEZXBzQXJlQXJyYXlEZXYiLCJkZXBzIiwiY3VycmVudEhvb2tOYW1lIiwidGFibGUiLCJzZWNvbmRDb2x1bW5TdGFydCIsIm9sZEhvb2tOYW1lIiwibmV3SG9va05hbWUiLCJ3YXJuT25Vc2VGb3JtU3RhdGVJbkRldiIsIndhcm5JZkFzeW5jQ2xpZW50Q29tcG9uZW50IiwiQ29tcG9uZW50IiwiaXNBc3luY0Z1bmN0aW9uIiwidGhyb3dJbnZhbGlkSG9va0Vycm9yIiwiYXJlSG9va0lucHV0c0VxdWFsIiwibmV4dERlcHMiLCJwcmV2RGVwcyIsInJlbmRlcldpdGhIb29rcyIsInNlY29uZEFyZyIsIm5leHRSZW5kZXJMYW5lcyIsIl9kZWJ1Z0hvb2tUeXBlcyIsIkhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWIiwiSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWIiwic2hvdWxkRG91YmxlUmVuZGVyREVWIiwicmVuZGVyV2l0aEhvb2tzQWdhaW4iLCJmaW5pc2hSZW5kZXJpbmdIb29rcyIsIkNvbnRleHRPbmx5RGlzcGF0Y2hlciIsImRpZFJlbmRlclRvb0Zld0hvb2tzIiwicmVwbGF5U3VzcGVuZGVkQ29tcG9uZW50V2l0aEhvb2tzIiwibnVtYmVyT2ZSZVJlbmRlcnMiLCJIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYiLCJyZW5kZXJUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50V2l0aEhvb2tzIiwiVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudCIsImRpc3BhdGNoZXIiLCJfZGlzcGF0Y2hlciR1c2VTdGF0ZSIsInVzZVN0YXRlIiwibWF5YmVUaGVuYWJsZSIsInVzZVRoZW5hYmxlIiwiX2Rpc3BhdGNoZXIkdXNlU3RhdGUyIiwibmV4dFJlc2V0U3RhdGUiLCJwcmV2UmVzZXRTdGF0ZSIsImNoZWNrRGlkUmVuZGVySWRIb29rIiwiZGlkUmVuZGVySWRIb29rIiwiYmFpbG91dEhvb2tzIiwicmVzZXRIb29rc0FmdGVyVGhyb3ciLCJyZXNldEhvb2tzT25VbndpbmQiLCJtb3VudFdvcmtJblByb2dyZXNzSG9vayIsImJhc2VRdWV1ZSIsInVwZGF0ZVdvcmtJblByb2dyZXNzSG9vayIsIm5leHRDdXJyZW50SG9vayIsIm5leHRXb3JrSW5Qcm9ncmVzc0hvb2siLCJjdXJyZW50RmliZXIiLCJuZXdIb29rIiwiY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSIsImxhc3RFZmZlY3QiLCJldmVudHMiLCJzdG9yZXMiLCJtZW1vQ2FjaGUiLCJ1c2UiLCJ1c2FibGUiLCJyZWFkQ29udGV4dCIsInVzZU1lbW9DYWNoZSIsImN1cnJlbnRVcGRhdGVRdWV1ZSIsImN1cnJlbnRNZW1vQ2FjaGUiLCJkYXRhIiwiYmFzaWNTdGF0ZVJlZHVjZXIiLCJhY3Rpb24iLCJtb3VudFJlZHVjZXIiLCJyZWR1Y2VyIiwiaW5pdGlhbEFyZyIsImluaXRpYWxTdGF0ZSIsImRpc3BhdGNoIiwibGFzdFJlbmRlcmVkUmVkdWNlciIsImxhc3RSZW5kZXJlZFN0YXRlIiwiZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uIiwidXBkYXRlUmVkdWNlciIsInVwZGF0ZVJlZHVjZXJJbXBsIiwiYmFzZUZpcnN0IiwicGVuZGluZ0ZpcnN0IiwiZmlyc3QiLCJuZXdCYXNlUXVldWVGaXJzdCIsIm5ld0Jhc2VRdWV1ZUxhc3QiLCJyZXZlcnRMYW5lIiwiaGFzRWFnZXJTdGF0ZSIsImVhZ2VyU3RhdGUiLCJfY2xvbmUyIiwibWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUiLCJyZXJlbmRlclJlZHVjZXIiLCJsYXN0UmVuZGVyUGhhc2VVcGRhdGUiLCJmaXJzdFJlbmRlclBoYXNlVXBkYXRlIiwibW91bnRTeW5jRXh0ZXJuYWxTdG9yZSIsInN1YnNjcmliZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJuZXh0U25hcHNob3QiLCJjYWNoZWRTbmFwc2hvdCIsInJvb3RSZW5kZXJMYW5lcyIsInB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2siLCJpbnN0IiwibW91bnRFZmZlY3QiLCJzdWJzY3JpYmVUb1N0b3JlIiwicHVzaEVmZmVjdCIsInVwZGF0ZVN0b3JlSW5zdGFuY2UiLCJjcmVhdGVFZmZlY3RJbnN0YW5jZSIsInVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlIiwicHJldlNuYXBzaG90Iiwic25hcHNob3RDaGFuZ2VkIiwidXBkYXRlRWZmZWN0IiwicmVuZGVyZWRTbmFwc2hvdCIsImNoZWNrIiwiY29tcG9uZW50VXBkYXRlUXVldWUiLCJjaGVja0lmU25hcHNob3RDaGFuZ2VkIiwiZm9yY2VTdG9yZVJlcmVuZGVyIiwiaGFuZGxlU3RvcmVDaGFuZ2UiLCJsYXRlc3RHZXRTbmFwc2hvdCIsInByZXZWYWx1ZSIsIm5leHRWYWx1ZSIsInNjaGVkdWxlVXBkYXRlT25GaWJlciIsIm1vdW50U3RhdGVJbXBsIiwiaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIiLCJtb3VudFN0YXRlIiwiZGlzcGF0Y2hTZXRTdGF0ZSIsInVwZGF0ZVN0YXRlIiwicmVyZW5kZXJTdGF0ZSIsIm1vdW50T3B0aW1pc3RpYyIsInBhc3N0aHJvdWdoIiwiZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUiLCJ1cGRhdGVPcHRpbWlzdGljIiwidXBkYXRlT3B0aW1pc3RpY0ltcGwiLCJyZXNvbHZlZFJlZHVjZXIiLCJyZXJlbmRlck9wdGltaXN0aWMiLCJkaXNwYXRjaEFjdGlvblN0YXRlIiwiYWN0aW9uUXVldWUiLCJzZXRQZW5kaW5nU3RhdGUiLCJzZXRTdGF0ZSIsImlzUmVuZGVyUGhhc2VVcGRhdGUiLCJsYXN0IiwicnVuQWN0aW9uU3RhdGVBY3Rpb24iLCJfbmV3TGFzdCIsInByZXZUcmFuc2l0aW9uIiwiVCIsImN1cnJlbnRUcmFuc2l0aW9uIiwiX3VwZGF0ZWRGaWJlcnMiLCJyZXR1cm5WYWx1ZSIsIm9uU3RhcnRUcmFuc2l0aW9uRmluaXNoIiwiUyIsImZpbmlzaFJ1bm5pbmdBY3Rpb25TdGF0ZUFjdGlvbiIsInVwZGF0ZWRGaWJlcnNDb3VudCIsImFjdGlvblN0YXRlUmVkdWNlciIsIm9sZFN0YXRlIiwibW91bnRBY3Rpb25TdGF0ZSIsImluaXRpYWxTdGF0ZVByb3AiLCJwZXJtYWxpbmsiLCJzc3JGb3JtU3RhdGUiLCJmb3JtU3RhdGUiLCJpc01hdGNoaW5nIiwic3RhdGVRdWV1ZSIsInBlbmRpbmdTdGF0ZUhvb2siLCJhY3Rpb25RdWV1ZUhvb2siLCJ1cGRhdGVBY3Rpb25TdGF0ZSIsImN1cnJlbnRTdGF0ZUhvb2siLCJ1cGRhdGVBY3Rpb25TdGF0ZUltcGwiLCJfdXBkYXRlUmVkdWNlckltcGwiLCJhY3Rpb25SZXN1bHQiLCJfdXBkYXRlU3RhdGUiLCJpc1BlbmRpbmciLCJwcmV2QWN0aW9uIiwiYWN0aW9uU3RhdGVBY3Rpb25FZmZlY3QiLCJyZXJlbmRlckFjdGlvblN0YXRlIiwiY3JlYXRlIiwiZWZmZWN0IiwiZmlyc3RFZmZlY3QiLCJkZXN0cm95IiwibW91bnRSZWYiLCJpbml0aWFsVmFsdWUiLCJ1cGRhdGVSZWYiLCJtb3VudEVmZmVjdEltcGwiLCJmaWJlckZsYWdzIiwiaG9va0ZsYWdzIiwidXBkYXRlRWZmZWN0SW1wbCIsInByZXZFZmZlY3QiLCJtb3VudEluc2VydGlvbkVmZmVjdCIsInVwZGF0ZUluc2VydGlvbkVmZmVjdCIsIm1vdW50TGF5b3V0RWZmZWN0IiwidXBkYXRlTGF5b3V0RWZmZWN0IiwiaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdCIsInJlZkNhbGxiYWNrIiwicmVmQ2xlYW51cCIsInJlZk9iamVjdCIsIl9pbnN0IiwibW91bnRJbXBlcmF0aXZlSGFuZGxlIiwiZWZmZWN0RGVwcyIsInVwZGF0ZUltcGVyYXRpdmVIYW5kbGUiLCJtb3VudERlYnVnVmFsdWUiLCJmb3JtYXR0ZXJGbiIsInVwZGF0ZURlYnVnVmFsdWUiLCJtb3VudENhbGxiYWNrIiwidXBkYXRlQ2FsbGJhY2siLCJtb3VudE1lbW8iLCJuZXh0Q3JlYXRlIiwidXBkYXRlTWVtbyIsIm1vdW50RGVmZXJyZWRWYWx1ZSIsIm1vdW50RGVmZXJyZWRWYWx1ZUltcGwiLCJ1cGRhdGVEZWZlcnJlZFZhbHVlIiwicmVzb2x2ZWRDdXJyZW50SG9vayIsInVwZGF0ZURlZmVycmVkVmFsdWVJbXBsIiwicmVyZW5kZXJEZWZlcnJlZFZhbHVlIiwiZGVmZXJyZWRMYW5lIiwicmVxdWVzdERlZmVycmVkTGFuZSIsInJlc3VsdFZhbHVlIiwic2hvdWxkRGVmZXJWYWx1ZSIsInN0YXJ0VHJhbnNpdGlvbiIsInBlbmRpbmdTdGF0ZSIsImZpbmlzaGVkU3RhdGUiLCJvcHRpb25zIiwicHJldmlvdXNQcmlvcml0eSIsInRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSIsIm5vb3AiLCJzdGFydEhvc3RUcmFuc2l0aW9uIiwiZm9ybUZpYmVyIiwiZm9ybURhdGEiLCJlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bCIsInJlcXVlc3RGb3JtUmVzZXQiLCJleGlzdGluZ1N0YXRlSG9vayIsIm5ld1F1ZXVlIiwiaW5pdGlhbFJlc2V0U3RhdGUiLCJuZXdSZXNldFN0YXRlUXVldWUiLCJyZXNldFN0YXRlSG9vayIsInJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbiIsIm5ld1Jlc2V0U3RhdGUiLCJyZXNldFN0YXRlUXVldWUiLCJtb3VudFRyYW5zaXRpb24iLCJzdGFydCIsInVwZGF0ZVRyYW5zaXRpb24iLCJfdXBkYXRlU3RhdGUyIiwiYm9vbGVhbk9yVGhlbmFibGUiLCJyZXJlbmRlclRyYW5zaXRpb24iLCJfcmVyZW5kZXJTdGF0ZSIsInVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzIiwibW91bnRJZCIsImlkZW50aWZpZXJQcmVmaXgiLCJ0cmVlSWQiLCJsb2NhbElkIiwiZ2xvYmFsQ2xpZW50SWQiLCJ1cGRhdGVJZCIsIm1vdW50UmVmcmVzaCIsInJlZnJlc2giLCJyZWZyZXNoQ2FjaGUiLCJ1cGRhdGVSZWZyZXNoIiwic2VlZEtleSIsInNlZWRWYWx1ZSIsInByb3ZpZGVyIiwicmVxdWVzdFVwZGF0ZUxhbmUiLCJyZWZyZXNoVXBkYXRlIiwic2VlZGVkQ2FjaGUiLCJjcmVhdGVDYWNoZSIsImNhY2hlIiwiZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlIiwiZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlIiwibWFya1VwZGF0ZUluRGV2VG9vbHMiLCJwcmV2RGlzcGF0Y2hlciIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWIiwidGhyb3dJZkR1cmluZ1JlbmRlciIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVkdWNlciIsInVzZVJlZiIsInVzZURlYnVnVmFsdWUiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidXNlVHJhbnNpdGlvbiIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidXNlSWQiLCJ1c2VDYWNoZVJlZnJlc2giLCJ1c2VGb3JtU3RhdGUiLCJ1c2VBY3Rpb25TdGF0ZSIsInVzZU9wdGltaXN0aWMiLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViIsIndhcm5JbnZhbGlkQ29udGV4dEFjY2VzcyIsIndhcm5JbnZhbGlkSG9va0FjY2VzcyIsIm5vdyIsImNvbW1pdFRpbWUiLCJsYXlvdXRFZmZlY3RTdGFydFRpbWUiLCJwcm9maWxlclN0YXJ0VGltZSIsInBhc3NpdmVFZmZlY3RTdGFydFRpbWUiLCJjdXJyZW50VXBkYXRlSXNOZXN0ZWQiLCJuZXN0ZWRVcGRhdGVTY2hlZHVsZWQiLCJpc0N1cnJlbnRVcGRhdGVOZXN0ZWQiLCJtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkIiwicmVzZXROZXN0ZWRVcGRhdGVGbGFnIiwic3luY05lc3RlZFVwZGF0ZUZsYWciLCJnZXRDb21taXRUaW1lIiwicmVjb3JkQ29tbWl0VGltZSIsInN0YXJ0UHJvZmlsZXJUaW1lciIsImFjdHVhbFN0YXJ0VGltZSIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSIsIm92ZXJyaWRlQmFzZVRpbWUiLCJlbGFwc2VkVGltZSIsImFjdHVhbER1cmF0aW9uIiwic2VsZkJhc2VEdXJhdGlvbiIsInJlY29yZExheW91dEVmZmVjdER1cmF0aW9uIiwicGFyZW50RmliZXIiLCJlZmZlY3REdXJhdGlvbiIsInBhcmVudFN0YXRlTm9kZSIsInJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbiIsInBhc3NpdmVFZmZlY3REdXJhdGlvbiIsInN0YXJ0TGF5b3V0RWZmZWN0VGltZXIiLCJzdGFydFBhc3NpdmVFZmZlY3RUaW1lciIsInRyYW5zZmVyQWN0dWFsRHVyYXRpb24iLCJmYWtlSW50ZXJuYWxJbnN0YW5jZSIsImRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCIsImRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSIsImRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSIsImRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUiLCJkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSIsImRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSIsImRpZFdhcm5PbkludmFsaWRDYWxsYmFjayIsIndhcm5PbkludmFsaWRDYWxsYmFjayIsIndhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsImFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY2xhc3NDb21wb25lbnRVcGRhdGVyIiwiZW5xdWV1ZVNldFN0YXRlIiwiZW5xdWV1ZVJlcGxhY2VTdGF0ZSIsImVucXVldWVGb3JjZVVwZGF0ZSIsImNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlIiwib2xkUHJvcHMiLCJuZXdQcm9wcyIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsInNob3VsZFVwZGF0ZSIsImlzUHVyZVJlYWN0Q29tcG9uZW50IiwiY2hlY2tDbGFzc0luc3RhbmNlIiwicmVuZGVyUHJlc2VudCIsImdldEluaXRpYWxTdGF0ZSIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwiZ2V0RGVmYXVsdFByb3BzIiwicHJvcFR5cGVzIiwiY29udGV4dFR5cGUiLCJjb21wb25lbnRTaG91bGRVcGRhdGUiLCJjb21wb25lbnREaWRVbm1vdW50IiwiY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiaGFzTXV0YXRlZFByb3BzIiwiZGVmYXVsdFByb3BzIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJjb25zdHJ1Y3RDbGFzc0luc3RhbmNlIiwiaXNWYWxpZCIsImFkZGVuZHVtIiwidXBkYXRlciIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJmb3VuZFdpbGxNb3VudE5hbWUiLCJmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsIl9jb21wb25lbnROYW1lIiwibmV3QXBpTmFtZSIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm1vdW50Q2xhc3NJbnN0YW5jZSIsInJlZnMiLCJjb21wb25lbnREaWRNb3VudCIsInJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSIsInVucmVzb2x2ZWRPbGRQcm9wcyIsInJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzIiwib2xkQ29udGV4dCIsImhhc05ld0xpZmVjeWNsZXMiLCJ1bnJlc29sdmVkTmV3UHJvcHMiLCJkaWRSZWNlaXZlTmV3UHJvcHMiLCJ1cGRhdGVDbGFzc0luc3RhbmNlIiwiYmFzZVByb3BzIiwiYWxyZWFkeVJlc29sdmVkRGVmYXVsdFByb3BzIiwicmVwb3J0R2xvYmFsRXJyb3IiLCJyZXBvcnRFcnJvciIsIndpbmRvdyIsIkVycm9yRXZlbnQiLCJldmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwic2hvdWxkTG9nIiwiZGlzcGF0Y2hFdmVudCIsImVtaXQiLCJlcnJvckJvdW5kYXJ5TmFtZSIsImRlZmF1bHRPblVuY2F1Z2h0RXJyb3IiLCJlcnJvckluZm8iLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiY29tcG9uZW50U3RhY2siLCJkZWZhdWx0T25DYXVnaHRFcnJvciIsImVycm9yJDEiLCJyZWNyZWF0ZU1lc3NhZ2UiLCJkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yIiwibG9nVW5jYXVnaHRFcnJvciIsInRocm93bkVycm9ycyIsIm9uVW5jYXVnaHRFcnJvciIsImUiLCJzZXRUaW1lb3V0IiwibG9nQ2F1Z2h0RXJyb3IiLCJib3VuZGFyeSIsIm9uQ2F1Z2h0RXJyb3IiLCJlcnJvckJvdW5kYXJ5IiwiY3JlYXRlUm9vdEVycm9yVXBkYXRlIiwicHJldkZpYmVyIiwiY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSIsImluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlIiwibWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmciLCJjb21wb25lbnREaWRDYXRjaCIsIm1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQiLCJtYXJrU3VzcGVuc2VCb3VuZGFyeVNob3VsZENhcHR1cmUiLCJzdXNwZW5zZUJvdW5kYXJ5IiwidGhyb3dFeGNlcHRpb24iLCJyZXN0b3JlUGVuZGluZ1VwZGF0ZXJzIiwicmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSIsInJlbmRlckRpZFN1c3BlbmQiLCJpc1N1c3BlbnNleVJlc291cmNlIiwicmV0cnlRdWV1ZSIsImF0dGFjaFBpbmdMaXN0ZW5lciIsIl9pc1N1c3BlbnNleVJlc291cmNlIiwib2Zmc2NyZWVuUXVldWUiLCJuZXdPZmZzY3JlZW5RdWV1ZSIsInRyYW5zaXRpb25zIiwibWFya2VySW5zdGFuY2VzIiwiX3JldHJ5UXVldWUiLCJfc3VzcGVuc2VCb3VuZGFyeSIsIl93cmFwcGVyRXJyb3IiLCJjYXVzZSIsIl93cmFwcGVyRXJyb3IyIiwiX3dvcmtJblByb2dyZXNzIiwicm9vdEVycm9ySW5mbyIsInJlbmRlckRpZEVycm9yIiwid3JhcHBlckVycm9yIiwicXVldWVDb25jdXJyZW50RXJyb3IiLCJfbGFuZSIsIl91cGRhdGUiLCJpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5IiwiX2xhbmUyIiwiX3VwZGF0ZTIiLCJTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24iLCJkaWRSZWNlaXZlVXBkYXRlIiwiZGlkV2FybkFib3V0QmFkQ2xhc3MiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyIsImRpZFdhcm5BYm91dFJldmVhbE9yZGVyIiwiZGlkV2FybkFib3V0VGFpbE9wdGlvbnMiLCJyZWNvbmNpbGVDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsImZvcmNlVW5tb3VudEN1cnJlbnRBbmRSZWNvbmNpbGUiLCJ1cGRhdGVGb3J3YXJkUmVmIiwicHJvcHNXaXRob3V0UmVmIiwiaGFzSWQiLCJwcmVwYXJlVG9SZWFkQ29udGV4dCIsImJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsiLCJ1cGRhdGVNZW1vQ29tcG9uZW50IiwiaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCIsImNvbXBhcmUiLCJyZXNvbHZlZFR5cGUiLCJyZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmciLCJ2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYiLCJ1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50IiwiY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzIiwiaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0IiwiY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQiLCJwcmV2UHJvcHMiLCJ1cGRhdGVGdW5jdGlvbkNvbXBvbmVudCIsInVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudCIsIm5leHRJc0RldGFjaGVkIiwiX3BlbmRpbmdWaXNpYmlsaXR5IiwibWFya1JlZiIsIm5leHRCYXNlTGFuZXMiLCJjdXJyZW50Q2hpbGRMYW5lcyIsImxhbmVzV2VKdXN0QXR0ZW1wdGVkIiwicmVtYWluaW5nQ2hpbGRMYW5lcyIsImRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50IiwiX25leHRCYXNlTGFuZXMiLCJfbmV4dFN0YXRlIiwiY2FjaGVQb29sIiwicHJldkNhY2hlUG9vbCIsInB1c2hUcmFuc2l0aW9uIiwiX3ByZXZDYWNoZVBvb2wiLCJnZXRPZmZzY3JlZW5EZWZlcnJlZENhY2hlIiwidXBkYXRlQ2FjaGVDb21wb25lbnQiLCJwYXJlbnRDYWNoZSIsIkNhY2hlQ29udGV4dCIsImZyZXNoQ2FjaGUiLCJyZXF1ZXN0Q2FjaGVGcm9tUG9vbCIsInB1c2hDYWNoZVByb3ZpZGVyIiwiZGVyaXZlZFN0YXRlIiwibmV4dENhY2hlIiwicHJvcGFnYXRlQ29udGV4dENoYW5nZSIsInVwZGF0ZU1vZGUiLCJ1cGRhdGVQcm9maWxlciIsInJlcGxheUZ1bmN0aW9uQ29tcG9uZW50IiwidXBkYXRlQ2xhc3NDb21wb25lbnQiLCJzaG91bGRFcnJvciIsIl9pbnN0YW5jZSIsInRlbXBJbnN0YW5jZSIsImhhc0NvbnRleHQiLCJuZXh0VW5pdE9mV29yayIsImZpbmlzaENsYXNzQ29tcG9uZW50IiwiZGlkQ2FwdHVyZUVycm9yIiwicHVzaEhvc3RSb290Q29udGV4dCIsInVwZGF0ZUhvc3RSb290IiwicHJldkNoaWxkcmVuIiwib3ZlcnJpZGVTdGF0ZSIsIm1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nIiwicmVjb3ZlcmFibGVFcnJvciIsInVwZGF0ZUhvc3RDb21wb25lbnQkMSIsImlzRGlyZWN0VGV4dENoaWxkIiwib2xkU3RhdGVIb29rIiwidXBkYXRlSG9zdEhvaXN0YWJsZSIsImN1cnJlbnRQcm9wcyIsInJlc291cmNlIiwidXBkYXRlSG9zdFNpbmdsZXRvbiIsInVwZGF0ZUhvc3RUZXh0JDEiLCJtb3VudExhenlDb21wb25lbnQiLCJfY3VycmVudCIsImlzRnVuY3Rpb25DbGFzc0NvbXBvbmVudCIsInJlc29sdmVkUHJvcHMiLCJyZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmciLCJfcmVzb2x2ZWRQcm9wcyIsIl9yZXNvbHZlZFByb3BzMiIsInJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nIiwiX3Jlc29sdmVkUHJvcHMzIiwiaGludCIsIl9jb21wb25lbnROYW1lMiIsIl9jb21wb25lbnROYW1lMyIsIlNVU1BFTkRFRF9NQVJLRVIiLCJtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUiLCJnZXRTdXNwZW5kZWRDYWNoZSIsInVwZGF0ZVN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUiLCJwcmV2T2Zmc2NyZWVuU3RhdGUiLCJwb29sIiwic2hvdWxkUmVtYWluT25GYWxsYmFjayIsInN1c3BlbnNlQ29udGV4dCIsImdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlIiwicHJpbWFyeVRyZWVEaWREZWZlciIsInBlZWtEZWZlcnJlZExhbmUiLCJ1cGRhdGVTdXNwZW5zZUNvbXBvbmVudCIsInNob3VsZFN1c3BlbmQiLCJzaG93RmFsbGJhY2siLCJkaWRQcmltYXJ5Q2hpbGRyZW5EZWZlciIsIm1vdW50RGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50IiwibmV4dFByaW1hcnlDaGlsZHJlbiIsIm5leHRGYWxsYmFja0NoaWxkcmVuIiwiZmFsbGJhY2siLCJmYWxsYmFja0ZyYWdtZW50IiwibW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4iLCJwcmltYXJ5Q2hpbGRGcmFnbWVudCIsIm1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4iLCJfZGVoeWRyYXRlZCIsInVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCIsIl9uZXh0RmFsbGJhY2tDaGlsZHJlbiIsIl9uZXh0UHJpbWFyeUNoaWxkcmVuIiwiZmFsbGJhY2tDaGlsZEZyYWdtZW50IiwidXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuIiwiX3ByaW1hcnlDaGlsZEZyYWdtZW50MiIsIl9uZXh0UHJpbWFyeUNoaWxkcmVuMiIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDMiLCJ1cGRhdGVTdXNwZW5zZVByaW1hcnlDaGlsZHJlbiIsInByaW1hcnlDaGlsZHJlbiIsInByaW1hcnlDaGlsZFByb3BzIiwibW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyIiwiZmFsbGJhY2tDaGlsZHJlbiIsIm9mZnNjcmVlblByb3BzIiwiY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuIiwidXBkYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlciIsImN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCIsImN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQiLCJzdWJ0cmVlRmxhZ3MiLCJyZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyIsIm1vdW50U3VzcGVuc2VGYWxsYmFja0FmdGVyUmV0cnlXaXRob3V0SHlkcmF0aW5nIiwiZmliZXJNb2RlIiwiZGlnZXN0IiwiX2dldFN1c3BlbnNlSW5zdGFuY2VGIiwiY2FwdHVyZWRWYWx1ZSIsImF0dGVtcHRIeWRyYXRpb25BdExhbmUiLCJyZXRyeSIsInJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0Iiwic2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyIiwicHJvcGFnYXRpb25Sb290Iiwic2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aCIsInByb3BhZ2F0ZVN1c3BlbnNlQ29udGV4dENoYW5nZSIsImZpcnN0Q2hpbGQiLCJmaW5kTGFzdENvbnRlbnRSb3ciLCJsYXN0Q29udGVudFJvdyIsImN1cnJlbnRSb3ciLCJ2YWxpZGF0ZVJldmVhbE9yZGVyIiwidmFsaWRhdGVUYWlsT3B0aW9ucyIsInRhaWxNb2RlIiwidmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZCIsImNoaWxkU2xvdCIsImlzQW5BcnJheSIsImlzSXRlcmFibGUiLCJ2YWxpZGF0ZVN1c3BlbnNlTGlzdENoaWxkcmVuIiwiY2hpbGRyZW5JdGVyYXRvciIsImluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSIsImlzQmFja3dhcmRzIiwidGFpbCIsInJlbmRlclN0YXRlIiwicmVuZGVyaW5nU3RhcnRUaW1lIiwidXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50Iiwic2hvdWxkRm9yY2VGYWxsYmFjayIsImRpZFN1c3BlbmRCZWZvcmUiLCJfdGFpbCIsIm5leHRSb3ciLCJ1cGRhdGVQb3J0YWxDb21wb25lbnQiLCJoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciIsInVwZGF0ZUNvbnRleHRQcm92aWRlciIsIm5ld1ZhbHVlIiwicHVzaFByb3ZpZGVyIiwib2xkVmFsdWUiLCJ1cGRhdGVDb250ZXh0Q29uc3VtZXIiLCJjb25zdW1lclR5cGUiLCJkZXBlbmRlbmNpZXMiLCJyZW1vdW50RmliZXIiLCJvbGRXb3JrSW5Qcm9ncmVzcyIsIm5ld1dvcmtJblByb2dyZXNzIiwicHJldlNpYmxpbmciLCJ1cGRhdGVMYW5lcyIsImF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlIiwiaGFzQ2hpbGRXb3JrIiwicHJpbWFyeUNoaWxkTGFuZXMiLCJfaGFzQ2hpbGRXb3JrIiwiX2NhY2hlIiwiYmVnaW5Xb3JrIiwiX2RlYnVnTmVlZHNSZW1vdW50IiwidW5yZXNvbHZlZFByb3BzIiwiX0NvbXBvbmVudCIsIl91bnJlc29sdmVkUHJvcHMiLCJfcmVzb2x2ZWRQcm9wczQiLCJfdW5yZXNvbHZlZFByb3BzMiIsIl9yZXNvbHZlZFByb3BzNSIsIl90eXBlIiwiX3VucmVzb2x2ZWRQcm9wczMiLCJfcmVzb2x2ZWRQcm9wczYiLCJ2YWx1ZUN1cnNvciIsInJlbmRlcmVyQ3Vyc29yREVWIiwicmVuZGVyZXIyQ3Vyc29yREVWIiwicmVuZGVyZXJTaWdpbCIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyIiwibGFzdENvbnRleHREZXBlbmRlbmN5IiwibGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0IiwiaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsInJlc2V0Q29udGV4dERlcGVuZGVuY2llcyIsInByb3ZpZGVyRmliZXIiLCJfY3VycmVudFJlbmRlcmVyIiwiX2N1cnJlbnRSZW5kZXJlcjIiLCJwb3BQcm92aWRlciIsImN1cnJlbnRWYWx1ZSIsImN1cnJlbnRSZW5kZXJlciIsImN1cnJlbnRSZW5kZXJlcjIiLCJwcm9wYWdhdGVDb250ZXh0Q2hhbmdlX2VhZ2VyIiwibmV4dEZpYmVyIiwibGlzdCIsImRlcGVuZGVuY3kiLCJmaXJzdENvbnRleHQiLCJwYXJlbnRTdXNwZW5zZSIsIl9hbHRlcm5hdGUiLCJyZWFkQ29udGV4dEZvckNvbnN1bWVyIiwiY29udGV4dEl0ZW0iLCJtZW1vaXplZFZhbHVlIiwiQWJvcnRDb250cm9sbGVyTG9jYWwiLCJBYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXJTaGltIiwic2lnbmFsIiwiYWJvcnRlZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJhYm9ydCIsInNjaGVkdWxlQ2FsbGJhY2skMSIsIk5vcm1hbFByaW9yaXR5IiwiY29udHJvbGxlciIsInJlZkNvdW50IiwicmV0YWluQ2FjaGUiLCJyZWxlYXNlQ2FjaGUiLCJwb3BDYWNoZVByb3ZpZGVyIiwicHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoIiwib25TdGFydFRyYW5zaXRpb25GaW5pc2hGb3JSZWNvbmNpbGVyIiwicmVzdW1lZENhY2hlIiwicGVla0NhY2hlRnJvbVBvb2wiLCJjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXIiLCJjYWNoZUZyb21Sb290Q2FjaGVQb29sIiwicG9vbGVkQ2FjaGUiLCJjYWNoZUZyb21Qb29sIiwicG9vbGVkQ2FjaGVMYW5lcyIsIm9mZnNjcmVlbldvcmtJblByb2dyZXNzIiwibmV3VHJhbnNpdGlvbnMiLCJwb3BUcmFuc2l0aW9uIiwibWFya1VwZGF0ZSIsImRvZXNSZXF1aXJlQ2xvbmUiLCJjb21wbGV0ZWRXb3JrIiwiZGlkQmFpbG91dCIsImFwcGVuZEFsbENoaWxkcmVuIiwibmVlZHNWaXNpYmlsaXR5VG9nZ2xlIiwiX25vZGUiLCJhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyIiwiY29udGFpbmVyQ2hpbGRTZXQiLCJfaW5zdGFuY2UyIiwiX25lZWRzVmlzaWJpbGl0eVRvZ2dsZSIsInVwZGF0ZUhvc3RDb250YWluZXIiLCJwb3J0YWxPclJvb3QiLCJjb250YWluZXIiLCJuZXdDaGlsZFNldCIsInBlbmRpbmdDaGlsZHJlbiIsInVwZGF0ZUhvc3RDb21wb25lbnQiLCJjdXJyZW50SW5zdGFuY2UiLCJfb2xkUHJvcHMiLCJyZXF1aXJlc0Nsb25lIiwibmV3SW5zdGFuY2UiLCJwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQiLCJpc1JlYWR5Iiwic2hvdWxkUmVtYWluT25QcmV2aW91c1NjcmVlbiIsInByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZCIsInNjaGVkdWxlUmV0cnlFZmZlY3QiLCJ3YWtlYWJsZXMiLCJ1cGRhdGVIb3N0VGV4dCIsIm9sZFRleHQiLCJuZXdUZXh0Iiwicm9vdENvbnRhaW5lckluc3RhbmNlIiwiY3V0T2ZmVGFpbElmTmVlZGVkIiwiaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrIiwibGFzdFRhaWxOb2RlIiwiX3RhaWxOb2RlIiwiX2xhc3RUYWlsTm9kZSIsImJ1YmJsZVByb3BlcnRpZXMiLCJuZXdDaGlsZExhbmVzIiwidHJlZUJhc2VEdXJhdGlvbiIsIl90cmVlQmFzZUR1cmF0aW9uIiwiX2NoaWxkMiIsIl9jaGlsZDMiLCJjb21wbGV0ZURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5Iiwid2FzSHlkcmF0ZWQiLCJpc1RpbWVkT3V0U3VzcGVuc2UiLCJfaXNUaW1lZE91dFN1c3BlbnNlIiwiX3ByaW1hcnlDaGlsZEZyYWdtZW50IiwiY29tcGxldGVXb3JrIiwiZmliZXJSb290IiwicHJldmlvdXNDYWNoZSIsInBlbmRpbmdDb250ZXh0IiwibmV4dFJlc291cmNlIiwiY3VycmVudFJlc291cmNlIiwiX29sZFByb3BzMiIsIl93YXNIeWRyYXRlZCIsIl90eXBlMiIsIl9jdXJyZW50SG9zdENvbnRleHQiLCJfd2FzSHlkcmF0ZWQyIiwiX3Jvb3RDb250YWluZXJJbnN0YW5jZSIsIl9pbnN0YW5jZTMiLCJfcm9vdENvbnRhaW5lckluc3RhbmNlMiIsIl9jdXJyZW50SG9zdENvbnRleHQyIiwiX3dhc0h5ZHJhdGVkMyIsImZhbGx0aHJvdWdoVG9Ob3JtYWxTdXNwZW5zZVBhdGgiLCJuZXh0RGlkVGltZW91dCIsInByZXZEaWRUaW1lb3V0IiwiX3ByZXZpb3VzQ2FjaGUiLCJfb2Zmc2NyZWVuRmliZXIyIiwiZGlkU3VzcGVuZEFscmVhZHkiLCJyZW5kZXJlZFRhaWwiLCJjYW5ub3RCZVN1c3BlbmRlZCIsInJlbmRlckhhc05vdFN1c3BlbmRlZFlldCIsInN1c3BlbmRlZCIsImdldFJlbmRlclRhcmdldFRpbWUiLCJfc3VzcGVuZGVkIiwiX3JldHJ5UXVldWUyIiwicHJldmlvdXNTaWJsaW5nIiwibmV4dElzSGlkZGVuIiwiX3ByZXZTdGF0ZSIsInByZXZJc0hpZGRlbiIsIl9yZXRyeVF1ZXVlMyIsIl9wcmV2aW91c0NhY2hlMiIsIl9jYWNoZTIiLCJfcHJldmlvdXNDYWNoZTMiLCJfY2FjaGUzIiwidW53aW5kV29yayIsIl9mbGFncyIsIl9mbGFnczIiLCJfZmxhZ3MzIiwidW53aW5kSW50ZXJydXB0ZWRXb3JrIiwiaW50ZXJydXB0ZWRXb3JrIiwiZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUiLCJvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4iLCJvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIiwibmVlZHNGb3JtUmVzZXQiLCJQb3NzaWJseVdlYWtTZXQiLCJXZWFrU2V0IiwibmV4dEVmZmVjdCIsImluUHJvZ3Jlc3NMYW5lcyIsImluUHJvZ3Jlc3NSb290Iiwic2hvdWxkUHJvZmlsZSIsImNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciIsImNvbXBvbmVudFdpbGxVbm1vdW50Iiwic2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50IiwibmVhcmVzdE1vdW50ZWRBbmNlc3RvciIsImNhcHR1cmVDb21taXRQaGFzZUVycm9yIiwic2FmZWx5QXR0YWNoUmVmIiwiY29tbWl0QXR0YWNoUmVmIiwic2FmZWx5RGV0YWNoUmVmIiwiZmluaXNoZWRXb3JrIiwic2FmZWx5Q2FsbERlc3Ryb3kiLCJzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIiLCJjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMiLCJjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfYmVnaW4iLCJzaG91bGRGaXJlIiwiY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2NvbXBsZXRlIiwiY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlciIsInNuYXBzaG90IiwiZGlkV2FyblNldCIsIl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50Iiwic2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0IiwiY29tbWl0SG9va0VmZmVjdExpc3RNb3VudCIsImNvbW1pdFBhc3NpdmVFZmZlY3REdXJhdGlvbnMiLCJmaW5pc2hlZFJvb3QiLCJfZmluaXNoZWRXb3JrJG1lbW9pemUiLCJvblBvc3RDb21taXQiLCJwaGFzZSIsImNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzIiwiY29tbWl0Q2xhc3NMYXlvdXRMaWZlY3ljbGVzIiwiY29tbWl0Q2xhc3NDYWxsYmFja3MiLCJjb21taXRIb3N0Q29tcG9uZW50TW91bnQiLCJjb21taXRQcm9maWxlclVwZGF0ZSIsIl9maW5pc2hlZFdvcmskbWVtb2l6ZTIiLCJvbkNvbW1pdCIsIm9uUmVuZGVyIiwiZW5xdWV1ZVBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3QiLCJjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyIiwiY29tbWl0dGVkTGFuZXMiLCJyZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyIsImNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzIiwiaXNNb2Rlcm5Sb290IiwibmV3T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIiwid2FzSGlkZGVuIiwibmV3T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsInByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4iLCJwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsImluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMiLCJyZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzIiwiaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4iLCJob3N0U3VidHJlZVJvb3QiLCJpbnN0YW5jZVRvVXNlIiwiZGV0YWNoRmliZXJNdXRhdGlvbiIsImRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzIiwiaG9zdEluc3RhbmNlIiwiZW1wdHlQb3J0YWxDb250YWluZXIiLCJlbXB0eUNoaWxkU2V0IiwiZ2V0SG9zdFBhcmVudEZpYmVyIiwiaXNIb3N0UGFyZW50IiwiZ2V0SG9zdFNpYmxpbmciLCJjb21taXRQbGFjZW1lbnQiLCJiZWZvcmUiLCJpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUiLCJfcGFyZW50IiwiX2JlZm9yZSIsIl9wYXJlbnQyIiwiX2JlZm9yZTIiLCJpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyIiwiaXNIb3N0IiwiaG9zdFBhcmVudCIsImhvc3RQYXJlbnRJc0NvbnRhaW5lciIsImNvbW1pdERlbGV0aW9uRWZmZWN0cyIsImRlbGV0ZWRGaWJlciIsImZpbmRQYXJlbnQiLCJjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyIsInByZXZIb3N0UGFyZW50IiwicHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciIsIl9wcmV2SG9zdFBhcmVudCIsIl9wcmV2SG9zdFBhcmVudElzQ29udGFpbmVyIiwiX3ByZXZIb3N0UGFyZW50MiIsIl9wcmV2SG9zdFBhcmVudElzQ29udGFpbmVyMiIsImNvbW1pdFN1c3BlbnNlQ2FsbGJhY2siLCJoeWRyYXRpb25DYWxsYmFja3MiLCJvbkh5ZHJhdGVkIiwiZ2V0UmV0cnlDYWNoZSIsInJldHJ5Q2FjaGUiLCJfcmV0cnlDYWNoZSIsImRldGFjaE9mZnNjcmVlbkluc3RhbmNlIiwiYXR0YWNoT2Zmc2NyZWVuSW5zdGFuY2UiLCJhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzIiwicmVzb2x2ZVJldHJ5V2FrZWFibGUiLCJjb21taXRNdXRhdGlvbkVmZmVjdHMiLCJjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyIsImN1cnJlbnRIb2lzdGFibGVSb290IiwiY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzIiwiaG9pc3RhYmxlUm9vdCIsIm5ld1Jlc291cmNlIiwicHJldmlvdXNXb3JrIiwic2luZ2xldG9uIiwicHJldmlvdXNIb2lzdGFibGVSb290IiwicHJldlJvb3RTdGF0ZSIsInJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyIsIl9wcmV2aW91c0hvaXN0YWJsZVJvb3QiLCJfY29udGFpbmVySW5mbyIsIl9wZW5kaW5nQ2hpbGRyZW4iLCJpc1Nob3dpbmdGYWxsYmFjayIsIndhc1Nob3dpbmdGYWxsYmFjayIsIm1hcmtDb21taXRUaW1lT2ZGYWxsYmFjayIsImlzVXBkYXRlIiwid2FzSGlkZGVuQnlBbmNlc3Rvck9mZnNjcmVlbiIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzIiwicmVzZXRGb3JtT25GaWJlciIsImZvcm1JbnN0YW5jZSIsImNvbW1pdExheW91dEVmZmVjdHMiLCJkaXNhcHBlYXJMYXlvdXRFZmZlY3RzIiwicmVhcHBlYXJMYXlvdXRFZmZlY3RzIiwib2Zmc2NyZWVuU3RhdGUiLCJjaGlsZFNob3VsZEluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMiLCJjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyIsImNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMiLCJjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdCIsImNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMiLCJjb21taXR0ZWRUcmFuc2l0aW9ucyIsImNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIiLCJyZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyIsIl9jdXJyZW50MiIsInJlY29ubmVjdFBhc3NpdmVFZmZlY3RzIiwiX2luc3RhbmNlNCIsIl9jdXJyZW50MyIsIl9jdXJyZW50NCIsImNvbW1pdEF0b21pY1Bhc3NpdmVFZmZlY3RzIiwiX2N1cnJlbnQ1IiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzIiwiY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyIiwic3VzcGVuc2V5Q29tbWl0RmxhZyIsImFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQiLCJhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlciIsInJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdCIsIl9wcm9wcyIsInByZXZGbGFncyIsImRldGFjaEFsdGVybmF0ZVNpYmxpbmdzIiwicHJldmlvdXNGaWJlciIsImRldGFjaGVkQ2hpbGQiLCJkZXRhY2hlZFNpYmxpbmciLCJjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzIiwicmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4iLCJyZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzIiwiZGlzY29ubmVjdFBhc3NpdmVFZmZlY3QiLCJkZWxldGVkU3VidHJlZVJvb3QiLCJjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlciIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfY29tcGxldGUiLCJnZXRDYWNoZUZvclR5cGUiLCJyZXNvdXJjZVR5cGUiLCJjYWNoZUZvclR5cGUiLCJEZWZhdWx0QXN5bmNEaXNwYXRjaGVyIiwiZ2V0T3duZXIiLCJDT01QT05FTlRfVFlQRSIsIkhBU19QU0VVRE9fQ0xBU1NfVFlQRSIsIlJPTEVfVFlQRSIsIlRFU1RfTkFNRV9UWVBFIiwiVEVYVF9UWVBFIiwic3ltYm9sRm9yIiwiY3JlYXRlQ29tcG9uZW50U2VsZWN0b3IiLCJjcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yIiwic2VsZWN0b3JzIiwiY3JlYXRlUm9sZVNlbGVjdG9yIiwicm9sZSIsImNyZWF0ZVRleHRTZWxlY3RvciIsImNyZWF0ZVRlc3ROYW1lU2VsZWN0b3IiLCJmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QiLCJob3N0Um9vdCIsIm1heWJlRmliZXIiLCJtYXRjaFNlbGVjdG9yIiwic2VsZWN0b3IiLCJoYXNNYXRjaGluZ1BhdGhzIiwiZGF0YVRlc3RJRCIsInNlbGVjdG9yVG9TdHJpbmciLCJmaW5kUGF0aHMiLCJtYXRjaGluZ0ZpYmVycyIsInNlbGVjdG9ySW5kZXgiLCJmaW5kQWxsTm9kZXMiLCJpbnN0YW5jZVJvb3RzIiwiZnJvbSIsImdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbiIsIm1heFNlbGVjdG9ySW5kZXgiLCJtYXRjaGVkTmFtZXMiLCJ1bm1hdGNoZWROYW1lcyIsImZpbmRCb3VuZGluZ1JlY3RzIiwiYm91bmRpbmdSZWN0cyIsInRhcmdldFJlY3QiLCJ0YXJnZXRMZWZ0IiwidGFyZ2V0UmlnaHQiLCJ3aWR0aCIsInRhcmdldFRvcCIsInRhcmdldEJvdHRvbSIsImhlaWdodCIsImoiLCJvdGhlclJlY3QiLCJvdGhlckxlZnQiLCJvdGhlclJpZ2h0Iiwib3RoZXJUb3AiLCJvdGhlckJvdHRvbSIsInNwbGljZSIsImZvY3VzV2l0aGluIiwiY29tbWl0SG9va3MiLCJvbkNvbW1pdFJvb3QiLCJjb21taXRIb29rIiwib2JzZXJ2ZVZpc2libGVSZWN0cyIsIl9zZXR1cEludGVyc2VjdGlvbk9icyIsImRpc2Nvbm5lY3QiLCJvYnNlcnZlIiwidW5vYnNlcnZlIiwibmV4dEluc3RhbmNlUm9vdHMiLCJ0YXJnZXQiLCJpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCIsImlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCIsIklTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCIsIlBvc3NpYmx5V2Vha01hcCIsIkJhdGNoZWRDb250ZXh0IiwiUm9vdEluUHJvZ3Jlc3MiLCJSb290RmF0YWxFcnJvcmVkIiwiUm9vdEVycm9yZWQiLCJSb290U3VzcGVuZGVkIiwiUm9vdFN1c3BlbmRlZFdpdGhEZWxheSIsIlJvb3RDb21wbGV0ZWQiLCJSb290RGlkTm90Q29tcGxldGUiLCJOb3RTdXNwZW5kZWQiLCJTdXNwZW5kZWRPbkVycm9yIiwiU3VzcGVuZGVkT25EYXRhIiwiU3VzcGVuZGVkT25JbW1lZGlhdGUiLCJTdXNwZW5kZWRPbkluc3RhbmNlIiwiU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZSIsIlN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSIsIlN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZSIsIlN1c3BlbmRlZE9uSHlkcmF0aW9uIiwid29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24iLCJ3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlIiwid29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyIiwiZW50YW5nbGVkUmVuZGVyTGFuZXMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzIiwid29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyIsIndvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lIiwid29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyIsIndvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzIiwid29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSIsImRpZEluY2x1ZGVDb21taXRQaGFzZVVwZGF0ZSIsImdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUiLCJGQUxMQkFDS19USFJPVFRMRV9NUyIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUiLCJJbmZpbml0eSIsIlJFTkRFUl9USU1FT1VUX01TIiwid29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyIsInJlc2V0UmVuZGVyVGltZXIiLCJsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCIsInJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzIiwicm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMiLCJwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyIsInBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzIiwicGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMiLCJwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zIiwiTkVTVEVEX1VQREFURV9MSU1JVCIsIm5lc3RlZFVwZGF0ZUNvdW50Iiwicm9vdFdpdGhOZXN0ZWRVcGRhdGVzIiwiaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzIiwiZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyIsIk5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCIsIm5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCIsInJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMiLCJpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QiLCJhY3Rpb25TY29wZUxhbmUiLCJyZXF1ZXN0UmV0cnlMYW5lIiwiaXNQcmVyZW5kZXJpbmciLCJzdXNwZW5zZUhhbmRsZXIiLCJwcmVwYXJlRnJlc2hTdGFjayIsIm1hcmtSb290U3VzcGVuZGVkIiwibWFya1Jvb3RVcGRhdGVkIiwid2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYiLCJ3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYiLCJpc0JhdGNoaW5nTGVnYWN5Iiwic2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290IiwiZGlkVGltZW91dCIsImRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMiLCJmbHVzaFBhc3NpdmVFZmZlY3RzIiwic2hvdWxkVGltZVNsaWNlIiwiZXhpdFN0YXR1cyIsInJlbmRlclJvb3RDb25jdXJyZW50IiwicmVuZGVyUm9vdFN5bmMiLCJyZW5kZXJXYXNDb25jdXJyZW50IiwiaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzIiwibGFuZXNUaGF0SnVzdEVycm9yZWQiLCJlcnJvclJldHJ5TGFuZXMiLCJyZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvciIsImZpbmlzaGVkTGFuZXMiLCJmaW5pc2hDb25jdXJyZW50UmVuZGVyIiwiZXJyb3JzRnJvbUZpcnN0QXR0ZW1wdCIsIndhc1Jvb3REZWh5ZHJhdGVkIiwicm9vdFdvcmtJblByb2dyZXNzIiwiZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQiLCJlcnJvcnMiLCJzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYiLCJjb21taXRSb290IiwibXNVbnRpbFRpbWVvdXQiLCJ0aW1lb3V0SGFuZGxlIiwiY29tbWl0Um9vdFdoZW5SZWFkeSIsInJlY292ZXJhYmxlRXJyb3JzIiwiZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlIiwiQm90aFZpc2liaWxpdHlBbmRNYXlTdXNwZW5kQ29tbWl0Iiwic2NoZWR1bGVQZW5kaW5nQ29tbWl0IiwiY2hlY2tzIiwicmVuZGVyZWRWYWx1ZSIsInVwZGF0ZWRMYW5lcyIsIm1hcmtSb290UGluZ2VkIiwiZmx1c2hSb290IiwiZGVmZXJyZWRVcGRhdGVzIiwiYmF0Y2hlZFVwZGF0ZXMiLCJkaXNjcmV0ZVVwZGF0ZXMiLCJkIiwiZmx1c2hTeW5jRnJvbVJlY29uY2lsZXIiLCJwcmV2RXhlY3V0aW9uQ29udGV4dCIsImZsdXNoU3luY1dvcmsiLCJpc0FscmVhZHlSZW5kZXJpbmciLCJuZXdFbnRhbmdsZWRSZW5kZXJMYW5lcyIsInJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjayIsInJlc2V0U3VzcGVuZGVkV29ya0xvb3BPblVud2luZCIsImhhbmRsZVRocm93IiwiaXNXYWtlYWJsZSIsImVycm9yZWRXb3JrIiwicHVzaERpc3BhdGNoZXIiLCJwb3BEaXNwYXRjaGVyIiwicHVzaEFzeW5jRGlzcGF0Y2hlciIsInByZXZBc3luY0Rpc3BhdGNoZXIiLCJBIiwicG9wQXN5bmNEaXNwYXRjaGVyIiwiZGlkU3VzcGVuZEluU2hlbGwiLCJ1bml0T2ZXb3JrIiwidGhyb3dBbmRVbndpbmRXb3JrTG9vcCIsIndvcmtMb29wU3luYyIsInBlcmZvcm1Vbml0T2ZXb3JrIiwicmVzdW1lT3JVbndpbmQiLCJyZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrIiwib25SZXNvbHV0aW9uIiwiX3RoZW5hYmxlIiwiaG9zdEZpYmVyIiwiY29tcGxldGVVbml0T2ZXb3JrIiwid29ya0xvb3BDb25jdXJyZW50IiwiaXNQcm9maWxpbmdNb2RlIiwiZGlkRmF0YWwiLCJwYW5pY09uUm9vdEVycm9yIiwidW53aW5kVW5pdE9mV29yayIsInNpYmxpbmdGaWJlciIsImluY29tcGxldGVXb3JrIiwicHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkiLCJjb21taXRSb290SW1wbCIsInJlbmRlclByaW9yaXR5TGV2ZWwiLCJmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYiLCJzY2hlZHVsZUNhbGxiYWNrIiwic3VidHJlZUhhc0VmZmVjdHMiLCJyb290SGFzRWZmZWN0Iiwicm9vdERpZEhhdmVQYXNzaXZlRWZmZWN0cyIsInJlbGVhc2VSb290UG9vbGVkQ2FjaGUiLCJjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYiLCJvblJlY292ZXJhYmxlRXJyb3IiLCJtYWtlRXJyb3JJbmZvIiwicmVuZGVyUHJpb3JpdHkiLCJwcmlvcml0eSIsImZsdXNoUGFzc2l2ZUVmZmVjdHNJbXBsIiwicHJvZmlsZXJFZmZlY3RzIiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QiLCJyb290RmliZXIiLCJwaW5nQ2FjaGUiLCJ0aHJlYWRJRHMiLCJwaW5nIiwicGluZ1N1c3BlbmRlZFJvb3QiLCJ3YXJuSWZTdXNwZW5zZVJlc29sdXRpb25Ob3RXcmFwcGVkV2l0aEFjdERFViIsInJldHJ5VGltZWRPdXRCb3VuZGFyeSIsImJvdW5kYXJ5RmliZXIiLCJyZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWIiwiaXNJblN0cmljdE1vZGUiLCJkb3VibGVJbnZva2VFZmZlY3RzSW5ERVZJZk5lY2Vzc2FyeSIsImRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyIiwic2hvdWxkRG91YmxlSW52b2tlUGFzc2l2ZUVmZmVjdHMiLCJwYXJlbnRJc0luU3RyaWN0TW9kZSIsImlzU3RyaWN0TW9kZUZpYmVyIiwiaGFzUGFzc2l2ZUVmZmVjdHMiLCJkb3VibGVJbnZva2VFZmZlY3RzIiwiZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCIsImRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyIiwiZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50IiwicmVuZGVyaW5nQ29tcG9uZW50TmFtZSIsImRlZHVwZUtleSIsInNldFN0YXRlQ29tcG9uZW50TmFtZSIsInNjaGVkdWxpbmdGaWJlciIsImZha2VBY3RDYWxsYmFja05vZGUiLCJpc1J1bm5pbmciLCJyZXNvbHZlRmFtaWx5IiwiZmFpbGVkQm91bmRhcmllcyIsInNldFJlZnJlc2hIYW5kbGVyIiwiZmFtaWx5IiwiY3VycmVudFJlbmRlciIsInN5bnRoZXRpY1R5cGUiLCJwcmV2VHlwZSIsIm5leHRUeXBlIiwibmVlZHNDb21wYXJlRmFtaWxpZXMiLCIkJHR5cGVvZk5leHRUeXBlIiwicHJldkZhbWlseSIsInNjaGVkdWxlUmVmcmVzaCIsInN0YWxlRmFtaWxpZXMiLCJ1cGRhdGVkRmFtaWxpZXMiLCJzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5Iiwic2NoZWR1bGVSb290IiwidXBkYXRlQ29udGFpbmVyU3luYyIsImNhbmRpZGF0ZVR5cGUiLCJuZWVkc1JlbmRlciIsIm5lZWRzUmVtb3VudCIsImZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaCIsImZhbWlsaWVzIiwiaG9zdEluc3RhbmNlcyIsInR5cGVzIiwiZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5IiwiZGlkTWF0Y2giLCJmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5IiwiZm91bmRIb3N0SW5zdGFuY2VzIiwiZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5IiwiaGFzQmFkTWFwUG9seWZpbGwiLCJub25FeHRlbnNpYmxlT2JqZWN0IiwicHJldmVudEV4dGVuc2lvbnMiLCJGaWJlck5vZGUiLCJOdW1iZXIiLCJOYU4iLCJjcmVhdGVGaWJlciIsInNob3VsZENvbnN0cnVjdCIsImlzUmVhY3RDb21wb25lbnQiLCJjdXJyZW50RGVwZW5kZW5jaWVzIiwiY3JlYXRlSG9zdFJvb3RGaWJlciIsImlzU3RyaWN0TW9kZSIsImNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUiLCJmaWJlclRhZyIsIl9ob3N0Q29udGV4dCIsImdldFRhZyIsImNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyIiwiY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UiLCJjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QiLCJ0eXBlU3RyaW5nIiwiZWxlbWVudHMiLCJwcmltYXJ5Q2hpbGRJbnN0YW5jZSIsIl9wZW5kaW5nTWFya2VycyIsIl90cmFuc2l0aW9ucyIsImRldGFjaCIsImF0dGFjaCIsImRlaHlkcmF0ZWROb2RlIiwiRmliZXJSb290Tm9kZSIsImh5ZHJhdGUiLCJpbmNvbXBsZXRlVHJhbnNpdGlvbnMiLCJfZGVidWdSb290VHlwZSIsImNyZWF0ZUZpYmVyUm9vdCIsImluaXRpYWxDaGlsZHJlbiIsInRyYW5zaXRpb25DYWxsYmFja3MiLCJ1bmluaXRpYWxpemVkRmliZXIiLCJpbml0aWFsQ2FjaGUiLCJSZWFjdFZlcnNpb24iLCJ0eXBlTmFtZSIsImhhc1RvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJjb25zdHJ1Y3RvciIsIndpbGxDb2VyY2lvblRocm93IiwidGVzdFN0cmluZ0NvZXJjaW9uIiwiY2hlY2tLZXlTdHJpbmdDb2VyY2lvbiIsImNyZWF0ZVBvcnRhbCIsImRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMiLCJkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZSIsImdldENvbnRleHRGb3JTdWJ0cmVlIiwicGFyZW50Q29tcG9uZW50IiwiZmluZEhvc3RJbnN0YW5jZSIsImZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyIsIm1ldGhvZE5hbWUiLCJjcmVhdGVDb250YWluZXIiLCJjcmVhdGVIeWRyYXRpb25Db250YWluZXIiLCJ1cGRhdGVDb250YWluZXIiLCJ1cGRhdGVDb250YWluZXJJbXBsIiwiZ2V0UHVibGljUm9vdEluc3RhbmNlIiwiY29udGFpbmVyRmliZXIiLCJhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24iLCJfcm9vdCIsIm1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkIiwibWFya1JldHJ5TGFuZUltcGwiLCJhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiIsImF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSIsImZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzIiwic2hvdWxkRXJyb3JJbXBsIiwic2hvdWxkU3VzcGVuZEltcGwiLCJvdmVycmlkZUhvb2tTdGF0ZSIsIm92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCIsIm92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCIsIm92ZXJyaWRlUHJvcHMiLCJvdmVycmlkZVByb3BzRGVsZXRlUGF0aCIsIm92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoIiwic2NoZWR1bGVVcGRhdGUiLCJzZXRFcnJvckhhbmRsZXIiLCJzZXRTdXNwZW5zZUhhbmRsZXIiLCJjb3B5V2l0aERlbGV0ZUltcGwiLCJvYmoiLCJwYXRoIiwiY29weVdpdGhEZWxldGUiLCJjb3B5V2l0aFJlbmFtZUltcGwiLCJvbGRQYXRoIiwibmV3UGF0aCIsIm9sZEtleSIsIm5ld0tleSIsImNvcHlXaXRoUmVuYW1lIiwiY29weVdpdGhTZXRJbXBsIiwiY29weVdpdGhTZXQiLCJmaW5kSG9vayIsIm5ld1Nob3VsZEVycm9ySW1wbCIsIm5ld1Nob3VsZFN1c3BlbmRJbXBsIiwiZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIiLCJlbXB0eUZpbmRGaWJlckJ5SG9zdEluc3RhbmNlIiwiZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMiLCJpbmplY3RJbnRvRGV2VG9vbHMiLCJkZXZUb29sc0NvbmZpZyIsImZpbmRGaWJlckJ5SG9zdEluc3RhbmNlIiwiYnVuZGxlVHlwZSIsInZlcnNpb24iLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwicmVuZGVyZXJDb25maWciLCJjdXJyZW50RGlzcGF0Y2hlclJlZiIsInJlY29uY2lsZXJWZXJzaW9uIiwiZGVmYXVsdCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/react-reconciler/constants.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler-constants.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGtMQUEyRTtBQUM3RSIsInNvdXJjZXMiOlsiL1VzZXJzL3NpZGRoYW50Z3VwdGEvRG9jdW1lbnRzL3Byb2plY3RzL2ZvcmdldGFpL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-reconciler/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsOEpBQWlFO0FBQ25FIiwic291cmNlcyI6WyIvVXNlcnMvc2lkZGhhbnRndXB0YS9Eb2N1bWVudHMvcHJvamVjdHMvZm9yZ2V0YWkvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlY29uY2lsZXIucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\nvar enableSchedulerDebugging = false;\nvar enableProfiling = false;\nvar frameYieldMs = 5;\nvar userBlockingPriorityTimeout = 250;\nvar normalPriorityTimeout = 5000;\nvar lowPriorityTimeout = 10000;\n\nfunction push(heap, node) {\n  var index = heap.length;\n  heap.push(node);\n  siftUp(heap, node, index);\n}\nfunction peek(heap) {\n  return heap.length === 0 ? null : heap[0];\n}\nfunction pop(heap) {\n  if (heap.length === 0) {\n    return null;\n  }\n\n  var first = heap[0];\n  var last = heap.pop();\n\n  if (last !== first) {\n    heap[0] = last;\n    siftDown(heap, last, 0);\n  }\n\n  return first;\n}\n\nfunction siftUp(heap, node, i) {\n  var index = i;\n\n  while (index > 0) {\n    var parentIndex = index - 1 >>> 1;\n    var parent = heap[parentIndex];\n\n    if (compare(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node;\n      heap[index] = parent;\n      index = parentIndex;\n    } else {\n      // The parent is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction siftDown(heap, node, i) {\n  var index = i;\n  var length = heap.length;\n  var halfLength = length >>> 1;\n\n  while (index < halfLength) {\n    var leftIndex = (index + 1) * 2 - 1;\n    var left = heap[leftIndex];\n    var rightIndex = leftIndex + 1;\n    var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n    if (compare(left, node) < 0) {\n      if (rightIndex < length && compare(right, left) < 0) {\n        heap[index] = right;\n        heap[rightIndex] = node;\n        index = rightIndex;\n      } else {\n        heap[index] = left;\n        heap[leftIndex] = node;\n        index = leftIndex;\n      }\n    } else if (rightIndex < length && compare(right, node) < 0) {\n      heap[index] = right;\n      heap[rightIndex] = node;\n      index = rightIndex;\n    } else {\n      // Neither child is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction compare(a, b) {\n  // Compare sort index first, then task id.\n  var diff = a.sortIndex - b.sortIndex;\n  return diff !== 0 ? diff : a.id - b.id;\n}\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n\nfunction markTaskErrored(task, ms) {\n}\n\n/* eslint-disable no-var */\nexports.unstable_now = void 0;\nvar hasPerformanceNow = // $FlowFixMe[method-unbinding]\ntypeof performance === 'object' && typeof performance.now === 'function';\n\nif (hasPerformanceNow) {\n  var localPerformance = performance;\n\n  exports.unstable_now = function () {\n    return localPerformance.now();\n  };\n} else {\n  var localDate = Date;\n  var initialTime = localDate.now();\n\n  exports.unstable_now = function () {\n    return localDate.now() - initialTime;\n  };\n} // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\n\n\nvar maxSigned31BitInt = 1073741823; // Tasks are stored on a min heap\n\nvar taskQueue = [];\nvar timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\nvar taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\nvar currentTask = null;\nvar currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n\nvar isPerformingWork = false;\nvar isHostCallbackScheduled = false;\nvar isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;\nvar localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom\n\nfunction advanceTimers(currentTime) {\n  // Check for tasks that are no longer delayed and add them to the queue.\n  var timer = peek(timerQueue);\n\n  while (timer !== null) {\n    if (timer.callback === null) {\n      // Timer was cancelled.\n      pop(timerQueue);\n    } else if (timer.startTime <= currentTime) {\n      // Timer fired. Transfer to the task queue.\n      pop(timerQueue);\n      timer.sortIndex = timer.expirationTime;\n      push(taskQueue, timer);\n    } else {\n      // Remaining timers are pending.\n      return;\n    }\n\n    timer = peek(timerQueue);\n  }\n}\n\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = false;\n  advanceTimers(currentTime);\n\n  if (!isHostCallbackScheduled) {\n    if (peek(taskQueue) !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback();\n    } else {\n      var firstTimer = peek(timerQueue);\n\n      if (firstTimer !== null) {\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n      }\n    }\n  }\n}\n\nfunction flushWork(initialTime) {\n\n\n  isHostCallbackScheduled = false;\n\n  if (isHostTimeoutScheduled) {\n    // We scheduled a timeout but it's no longer needed. Cancel it.\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  isPerformingWork = true;\n  var previousPriorityLevel = currentPriorityLevel;\n\n  try {\n    var currentTime; if (enableProfiling) ; else {\n      // No catch in prod code path.\n      return workLoop(initialTime);\n    }\n  } finally {\n    currentTask = null;\n    currentPriorityLevel = previousPriorityLevel;\n    isPerformingWork = false;\n  }\n}\n\nfunction workLoop(initialTime) {\n  var currentTime = initialTime;\n  advanceTimers(currentTime);\n  currentTask = peek(taskQueue);\n\n  while (currentTask !== null && !(enableSchedulerDebugging )) {\n    if (currentTask.expirationTime > currentTime && shouldYieldToHost()) {\n      // This currentTask hasn't expired, and we've reached the deadline.\n      break;\n    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n    var callback = currentTask.callback;\n\n    if (typeof callback === 'function') {\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      currentTask.callback = null; // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n      currentPriorityLevel = currentTask.priorityLevel; // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n      var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n\n      var continuationCallback = callback(didUserCallbackTimeout);\n      currentTime = exports.unstable_now();\n\n      if (typeof continuationCallback === 'function') {\n        // If a continuation is returned, immediately yield to the main thread\n        // regardless of how much time is left in the current time slice.\n        // $FlowFixMe[incompatible-use] found when upgrading Flow\n        currentTask.callback = continuationCallback;\n\n        advanceTimers(currentTime);\n        return true;\n      } else {\n\n        if (currentTask === peek(taskQueue)) {\n          pop(taskQueue);\n        }\n\n        advanceTimers(currentTime);\n      }\n    } else {\n      pop(taskQueue);\n    }\n\n    currentTask = peek(taskQueue);\n  } // Return whether there's additional work\n\n\n  if (currentTask !== null) {\n    return true;\n  } else {\n    var firstTimer = peek(timerQueue);\n\n    if (firstTimer !== null) {\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n\n    return false;\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_next(eventHandler) {\n  var priorityLevel;\n\n  switch (currentPriorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n      // Shift down to normal priority\n      priorityLevel = NormalPriority;\n      break;\n\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel; // $FlowFixMe[incompatible-return]\n  // $FlowFixMe[missing-this-annot]\n\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n}\n\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\n  var currentTime = exports.unstable_now();\n  var startTime;\n\n  if (typeof options === 'object' && options !== null) {\n    var delay = options.delay;\n\n    if (typeof delay === 'number' && delay > 0) {\n      startTime = currentTime + delay;\n    } else {\n      startTime = currentTime;\n    }\n  } else {\n    startTime = currentTime;\n  }\n\n  var timeout;\n\n  switch (priorityLevel) {\n    case ImmediatePriority:\n      // Times out immediately\n      timeout = -1;\n      break;\n\n    case UserBlockingPriority:\n      // Eventually times out\n      timeout = userBlockingPriorityTimeout;\n      break;\n\n    case IdlePriority:\n      // Never times out\n      timeout = maxSigned31BitInt;\n      break;\n\n    case LowPriority:\n      // Eventually times out\n      timeout = lowPriorityTimeout;\n      break;\n\n    case NormalPriority:\n    default:\n      // Eventually times out\n      timeout = normalPriorityTimeout;\n      break;\n  }\n\n  var expirationTime = startTime + timeout;\n  var newTask = {\n    id: taskIdCounter++,\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: startTime,\n    expirationTime: expirationTime,\n    sortIndex: -1\n  };\n\n  if (startTime > currentTime) {\n    // This is a delayed task.\n    newTask.sortIndex = startTime;\n    push(timerQueue, newTask);\n\n    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n      // All tasks are delayed, and this is the task with the earliest delay.\n      if (isHostTimeoutScheduled) {\n        // Cancel an existing timeout.\n        cancelHostTimeout();\n      } else {\n        isHostTimeoutScheduled = true;\n      } // Schedule a timeout.\n\n\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } else {\n    newTask.sortIndex = expirationTime;\n    push(taskQueue, newTask);\n    // wait until the next time we yield.\n\n\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n      isHostCallbackScheduled = true;\n      requestHostCallback();\n    }\n  }\n\n  return newTask;\n}\n\nfunction unstable_pauseExecution() {\n}\n\nfunction unstable_continueExecution() {\n\n  if (!isHostCallbackScheduled && !isPerformingWork) {\n    isHostCallbackScheduled = true;\n    requestHostCallback();\n  }\n}\n\nfunction unstable_getFirstCallbackNode() {\n  return peek(taskQueue);\n}\n\nfunction unstable_cancelCallback(task) {\n  // remove from the queue because you can't remove arbitrary nodes from an\n  // array based heap, only the first one.)\n\n\n  task.callback = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nvar isMessageLoopRunning = false;\nvar taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n// thread, like user events. By default, it yields multiple times per frame.\n// It does not attempt to align with frame boundaries, since most tasks don't\n// need to be frame aligned; for those that do, use requestAnimationFrame.\n\nvar frameInterval = frameYieldMs;\nvar startTime = -1;\n\nfunction shouldYieldToHost() {\n  var timeElapsed = exports.unstable_now() - startTime;\n\n  if (timeElapsed < frameInterval) {\n    // The main thread has only been blocked for a really short amount of time;\n    // smaller than a single frame. Don't yield yet.\n    return false;\n  } // Yield now.\n\n\n  return true;\n}\n\nfunction requestPaint() {}\n\nfunction forceFrameRate(fps) {\n  if (fps < 0 || fps > 125) {\n    // Using console['error'] to evade Babel and ESLint\n    console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n    return;\n  }\n\n  if (fps > 0) {\n    frameInterval = Math.floor(1000 / fps);\n  } else {\n    // reset the framerate\n    frameInterval = frameYieldMs;\n  }\n}\n\nvar performWorkUntilDeadline = function () {\n  if (isMessageLoopRunning) {\n    var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n    // has been blocked.\n\n    startTime = currentTime; // If a scheduler task throws, exit the current browser task so the\n    // error can be observed.\n    //\n    // Intentionally not using a try-catch, since that makes some debugging\n    // techniques harder. Instead, if `flushWork` errors, then `hasMoreWork` will\n    // remain true, and we'll continue the work loop.\n\n    var hasMoreWork = true;\n\n    try {\n      hasMoreWork = flushWork(currentTime);\n    } finally {\n      if (hasMoreWork) {\n        // If there's more work, schedule the next message event at the end\n        // of the preceding one.\n        schedulePerformWorkUntilDeadline();\n      } else {\n        isMessageLoopRunning = false;\n      }\n    }\n  }\n};\n\nvar schedulePerformWorkUntilDeadline;\n\nif (typeof localSetImmediate === 'function') {\n  // Node.js and old IE.\n  // There's a few reasons for why we prefer setImmediate.\n  //\n  // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n  // (Even though this is a DOM fork of the Scheduler, you could get here\n  // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n  // https://github.com/facebook/react/issues/20756\n  //\n  // But also, it runs earlier which is the semantic we want.\n  // If other browsers ever implement it, it's better to use it.\n  // Although both of these would be inferior to native scheduling.\n  schedulePerformWorkUntilDeadline = function () {\n    localSetImmediate(performWorkUntilDeadline);\n  };\n} else if (typeof MessageChannel !== 'undefined') {\n  // DOM and Worker environments.\n  // We prefer MessageChannel because of the 4ms setTimeout clamping.\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n\n  schedulePerformWorkUntilDeadline = function () {\n    port.postMessage(null);\n  };\n} else {\n  // We should only fallback here in non-browser environments.\n  schedulePerformWorkUntilDeadline = function () {\n    // $FlowFixMe[not-a-function] nullable value\n    localSetTimeout(performWorkUntilDeadline, 0);\n  };\n}\n\nfunction requestHostCallback() {\n  if (!isMessageLoopRunning) {\n    isMessageLoopRunning = true;\n    schedulePerformWorkUntilDeadline();\n  }\n}\n\nfunction requestHostTimeout(callback, ms) {\n  // $FlowFixMe[not-a-function] nullable value\n  taskTimeoutID = localSetTimeout(function () {\n    callback(exports.unstable_now());\n  }, ms);\n}\n\nfunction cancelHostTimeout() {\n  // $FlowFixMe[not-a-function] nullable value\n  localClearTimeout(taskTimeoutID);\n  taskTimeoutID = -1;\n}\nvar unstable_Profiling = null;\n\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_LowPriority = LowPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_Profiling = unstable_Profiling;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_continueExecution = unstable_continueExecution;\nexports.unstable_forceFrameRate = forceFrameRate;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\nexports.unstable_next = unstable_next;\nexports.unstable_pauseExecution = unstable_pauseExecution;\nexports.unstable_requestPaint = requestPaint;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_shouldYield = shouldYieldToHost;\nexports.unstable_wrapCallback = unstable_wrapCallback;\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUUsb0JBQW9CO0FBQ3RCO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQSxFQUFFLG9CQUFvQjtBQUN0QjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7OztBQUdBLG9DQUFvQzs7QUFFcEM7QUFDQSxxQkFBcUI7O0FBRXJCLHVCQUF1QjtBQUN2QjtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBLG1GQUFtRjs7QUFFbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DLHdEQUF3RDs7QUFFeEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCLGtDQUFrQztBQUNsQyw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLDBCQUEwQjtBQUMxQixxQ0FBcUM7QUFDckMsK0JBQStCO0FBQy9CLGtDQUFrQztBQUNsQywrQkFBK0I7QUFDL0Isd0NBQXdDO0FBQ3hDLHFDQUFxQztBQUNyQyxxQkFBcUI7QUFDckIsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3QixnQ0FBZ0M7QUFDaEMsaUNBQWlDO0FBQ2pDLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIIiwic291cmNlcyI6WyIvVXNlcnMvc2lkZGhhbnRndXB0YS9Eb2N1bWVudHMvcHJvamVjdHMvZm9yZ2V0YWkvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHNjaGVkdWxlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxudmFyIGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyA9IGZhbHNlO1xudmFyIGVuYWJsZVByb2ZpbGluZyA9IGZhbHNlO1xudmFyIGZyYW1lWWllbGRNcyA9IDU7XG52YXIgdXNlckJsb2NraW5nUHJpb3JpdHlUaW1lb3V0ID0gMjUwO1xudmFyIG5vcm1hbFByaW9yaXR5VGltZW91dCA9IDUwMDA7XG52YXIgbG93UHJpb3JpdHlUaW1lb3V0ID0gMTAwMDA7XG5cbmZ1bmN0aW9uIHB1c2goaGVhcCwgbm9kZSkge1xuICB2YXIgaW5kZXggPSBoZWFwLmxlbmd0aDtcbiAgaGVhcC5wdXNoKG5vZGUpO1xuICBzaWZ0VXAoaGVhcCwgbm9kZSwgaW5kZXgpO1xufVxuZnVuY3Rpb24gcGVlayhoZWFwKSB7XG4gIHJldHVybiBoZWFwLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBoZWFwWzBdO1xufVxuZnVuY3Rpb24gcG9wKGhlYXApIHtcbiAgaWYgKGhlYXAubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmlyc3QgPSBoZWFwWzBdO1xuICB2YXIgbGFzdCA9IGhlYXAucG9wKCk7XG5cbiAgaWYgKGxhc3QgIT09IGZpcnN0KSB7XG4gICAgaGVhcFswXSA9IGxhc3Q7XG4gICAgc2lmdERvd24oaGVhcCwgbGFzdCwgMCk7XG4gIH1cblxuICByZXR1cm4gZmlyc3Q7XG59XG5cbmZ1bmN0aW9uIHNpZnRVcChoZWFwLCBub2RlLCBpKSB7XG4gIHZhciBpbmRleCA9IGk7XG5cbiAgd2hpbGUgKGluZGV4ID4gMCkge1xuICAgIHZhciBwYXJlbnRJbmRleCA9IGluZGV4IC0gMSA+Pj4gMTtcbiAgICB2YXIgcGFyZW50ID0gaGVhcFtwYXJlbnRJbmRleF07XG5cbiAgICBpZiAoY29tcGFyZShwYXJlbnQsIG5vZGUpID4gMCkge1xuICAgICAgLy8gVGhlIHBhcmVudCBpcyBsYXJnZXIuIFN3YXAgcG9zaXRpb25zLlxuICAgICAgaGVhcFtwYXJlbnRJbmRleF0gPSBub2RlO1xuICAgICAgaGVhcFtpbmRleF0gPSBwYXJlbnQ7XG4gICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcGFyZW50IGlzIHNtYWxsZXIuIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNpZnREb3duKGhlYXAsIG5vZGUsIGkpIHtcbiAgdmFyIGluZGV4ID0gaTtcbiAgdmFyIGxlbmd0aCA9IGhlYXAubGVuZ3RoO1xuICB2YXIgaGFsZkxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcblxuICB3aGlsZSAoaW5kZXggPCBoYWxmTGVuZ3RoKSB7XG4gICAgdmFyIGxlZnRJbmRleCA9IChpbmRleCArIDEpICogMiAtIDE7XG4gICAgdmFyIGxlZnQgPSBoZWFwW2xlZnRJbmRleF07XG4gICAgdmFyIHJpZ2h0SW5kZXggPSBsZWZ0SW5kZXggKyAxO1xuICAgIHZhciByaWdodCA9IGhlYXBbcmlnaHRJbmRleF07IC8vIElmIHRoZSBsZWZ0IG9yIHJpZ2h0IG5vZGUgaXMgc21hbGxlciwgc3dhcCB3aXRoIHRoZSBzbWFsbGVyIG9mIHRob3NlLlxuXG4gICAgaWYgKGNvbXBhcmUobGVmdCwgbm9kZSkgPCAwKSB7XG4gICAgICBpZiAocmlnaHRJbmRleCA8IGxlbmd0aCAmJiBjb21wYXJlKHJpZ2h0LCBsZWZ0KSA8IDApIHtcbiAgICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcbiAgICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gbGVmdDtcbiAgICAgICAgaGVhcFtsZWZ0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgaW5kZXggPSBsZWZ0SW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIGNvbXBhcmUocmlnaHQsIG5vZGUpIDwgMCkge1xuICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcbiAgICAgIGhlYXBbcmlnaHRJbmRleF0gPSBub2RlO1xuICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZWl0aGVyIGNoaWxkIGlzIHNtYWxsZXIuIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAvLyBDb21wYXJlIHNvcnQgaW5kZXggZmlyc3QsIHRoZW4gdGFzayBpZC5cbiAgdmFyIGRpZmYgPSBhLnNvcnRJbmRleCAtIGIuc29ydEluZGV4O1xuICByZXR1cm4gZGlmZiAhPT0gMCA/IGRpZmYgOiBhLmlkIC0gYi5pZDtcbn1cblxuLy8gVE9ETzogVXNlIHN5bWJvbHM/XG52YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbnZhciBOb3JtYWxQcmlvcml0eSA9IDM7XG52YXIgTG93UHJpb3JpdHkgPSA0O1xudmFyIElkbGVQcmlvcml0eSA9IDU7XG5cbmZ1bmN0aW9uIG1hcmtUYXNrRXJyb3JlZCh0YXNrLCBtcykge1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIgKi9cbmV4cG9ydHMudW5zdGFibGVfbm93ID0gdm9pZCAwO1xudmFyIGhhc1BlcmZvcm1hbmNlTm93ID0gLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nO1xuXG5pZiAoaGFzUGVyZm9ybWFuY2VOb3cpIHtcbiAgdmFyIGxvY2FsUGVyZm9ybWFuY2UgPSBwZXJmb3JtYW5jZTtcblxuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxQZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBsb2NhbERhdGUgPSBEYXRlO1xuICB2YXIgaW5pdGlhbFRpbWUgPSBsb2NhbERhdGUubm93KCk7XG5cbiAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxvY2FsRGF0ZS5ub3coKSAtIGluaXRpYWxUaW1lO1xuICB9O1xufSAvLyBNYXggMzEgYml0IGludGVnZXIuIFRoZSBtYXggaW50ZWdlciBzaXplIGluIFY4IGZvciAzMi1iaXQgc3lzdGVtcy5cbi8vIE1hdGgucG93KDIsIDMwKSAtIDFcbi8vIDBiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG5cblxudmFyIG1heFNpZ25lZDMxQml0SW50ID0gMTA3Mzc0MTgyMzsgLy8gVGFza3MgYXJlIHN0b3JlZCBvbiBhIG1pbiBoZWFwXG5cbnZhciB0YXNrUXVldWUgPSBbXTtcbnZhciB0aW1lclF1ZXVlID0gW107IC8vIEluY3JlbWVudGluZyBpZCBjb3VudGVyLiBVc2VkIHRvIG1haW50YWluIGluc2VydGlvbiBvcmRlci5cblxudmFyIHRhc2tJZENvdW50ZXIgPSAxOyAvLyBQYXVzaW5nIHRoZSBzY2hlZHVsZXIgaXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG52YXIgY3VycmVudFRhc2sgPSBudWxsO1xudmFyIGN1cnJlbnRQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7IC8vIFRoaXMgaXMgc2V0IHdoaWxlIHBlcmZvcm1pbmcgd29yaywgdG8gcHJldmVudCByZS1lbnRyYW5jZS5cblxudmFyIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbnZhciBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xudmFyIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTsgLy8gQ2FwdHVyZSBsb2NhbCByZWZlcmVuY2VzIHRvIG5hdGl2ZSBBUElzLCBpbiBjYXNlIGEgcG9seWZpbGwgb3ZlcnJpZGVzIHRoZW0uXG5cbnZhciBsb2NhbFNldFRpbWVvdXQgPSB0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IHNldFRpbWVvdXQgOiBudWxsO1xudmFyIGxvY2FsQ2xlYXJUaW1lb3V0ID0gdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6IG51bGw7XG52YXIgbG9jYWxTZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyA/IHNldEltbWVkaWF0ZSA6IG51bGw7IC8vIElFIGFuZCBOb2RlLmpzICsganNkb21cblxuZnVuY3Rpb24gYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSkge1xuICAvLyBDaGVjayBmb3IgdGFza3MgdGhhdCBhcmUgbm8gbG9uZ2VyIGRlbGF5ZWQgYW5kIGFkZCB0aGVtIHRvIHRoZSBxdWV1ZS5cbiAgdmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICB3aGlsZSAodGltZXIgIT09IG51bGwpIHtcbiAgICBpZiAodGltZXIuY2FsbGJhY2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRpbWVyIHdhcyBjYW5jZWxsZWQuXG4gICAgICBwb3AodGltZXJRdWV1ZSk7XG4gICAgfSBlbHNlIGlmICh0aW1lci5zdGFydFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgIC8vIFRpbWVyIGZpcmVkLiBUcmFuc2ZlciB0byB0aGUgdGFzayBxdWV1ZS5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICAgIHRpbWVyLnNvcnRJbmRleCA9IHRpbWVyLmV4cGlyYXRpb25UaW1lO1xuICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtYWluaW5nIHRpbWVycyBhcmUgcGVuZGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlVGltZW91dChjdXJyZW50VGltZSkge1xuICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpIHtcbiAgICBpZiAocGVlayh0YXNrUXVldWUpICE9PSBudWxsKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICAgICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFdvcmsoaW5pdGlhbFRpbWUpIHtcblxuXG4gIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAvLyBXZSBzY2hlZHVsZWQgYSB0aW1lb3V0IGJ1dCBpdCdzIG5vIGxvbmdlciBuZWVkZWQuIENhbmNlbCBpdC5cbiAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgfVxuXG4gIGlzUGVyZm9ybWluZ1dvcmsgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICB2YXIgY3VycmVudFRpbWU7IGlmIChlbmFibGVQcm9maWxpbmcpIDsgZWxzZSB7XG4gICAgICAvLyBObyBjYXRjaCBpbiBwcm9kIGNvZGUgcGF0aC5cbiAgICAgIHJldHVybiB3b3JrTG9vcChpbml0aWFsVGltZSk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRUYXNrID0gbnVsbDtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICBpc1BlcmZvcm1pbmdXb3JrID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gd29ya0xvb3AoaW5pdGlhbFRpbWUpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gaW5pdGlhbFRpbWU7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcblxuICB3aGlsZSAoY3VycmVudFRhc2sgIT09IG51bGwgJiYgIShlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgKSkge1xuICAgIGlmIChjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA+IGN1cnJlbnRUaW1lICYmIHNob3VsZFlpZWxkVG9Ib3N0KCkpIHtcbiAgICAgIC8vIFRoaXMgY3VycmVudFRhc2sgaGFzbid0IGV4cGlyZWQsIGFuZCB3ZSd2ZSByZWFjaGVkIHRoZSBkZWFkbGluZS5cbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgIHZhciBjYWxsYmFjayA9IGN1cnJlbnRUYXNrLmNhbGxiYWNrO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IG51bGw7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRUYXNrLnByaW9yaXR5TGV2ZWw7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG4gICAgICB2YXIgZGlkVXNlckNhbGxiYWNrVGltZW91dCA9IGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lO1xuXG4gICAgICB2YXIgY29udGludWF0aW9uQ2FsbGJhY2sgPSBjYWxsYmFjayhkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0KTtcbiAgICAgIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcblxuICAgICAgaWYgKHR5cGVvZiBjb250aW51YXRpb25DYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBJZiBhIGNvbnRpbnVhdGlvbiBpcyByZXR1cm5lZCwgaW1tZWRpYXRlbHkgeWllbGQgdG8gdGhlIG1haW4gdGhyZWFkXG4gICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2YgaG93IG11Y2ggdGltZSBpcyBsZWZ0IGluIHRoZSBjdXJyZW50IHRpbWUgc2xpY2UuXG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IGNvbnRpbnVhdGlvbkNhbGxiYWNrO1xuXG4gICAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrID09PSBwZWVrKHRhc2tRdWV1ZSkpIHtcbiAgICAgICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICB9XG5cbiAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgfSAvLyBSZXR1cm4gd2hldGhlciB0aGVyZSdzIGFkZGl0aW9uYWwgd29ya1xuXG5cbiAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcnVuV2l0aFByaW9yaXR5KHByaW9yaXR5TGV2ZWwsIGV2ZW50SGFuZGxlcikge1xuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICB9XG5cbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfbmV4dChldmVudEhhbmRsZXIpIHtcbiAgdmFyIHByaW9yaXR5TGV2ZWw7XG5cbiAgc3dpdGNoIChjdXJyZW50UHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgICAgLy8gU2hpZnQgZG93biB0byBub3JtYWwgcHJpb3JpdHlcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEFueXRoaW5nIGxvd2VyIHRoYW4gbm9ybWFsIHByaW9yaXR5IHNob3VsZCByZW1haW4gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgICBwcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3dyYXBDYWxsYmFjayhjYWxsYmFjaykge1xuICB2YXIgcGFyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gIC8vICRGbG93Rml4TWVbbWlzc2luZy10aGlzLWFubm90XVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgcnVuV2l0aFByaW9yaXR5LCBpbmxpbmVkIGZvciBwZXJmb3JtYW5jZS5cbiAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgdmFyIHN0YXJ0VGltZTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICB2YXIgZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuXG4gICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgJiYgZGVsYXkgPiAwKSB7XG4gICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZSArIGRlbGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICB2YXIgdGltZW91dDtcblxuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgLy8gVGltZXMgb3V0IGltbWVkaWF0ZWx5XG4gICAgICB0aW1lb3V0ID0gLTE7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICAvLyBFdmVudHVhbGx5IHRpbWVzIG91dFxuICAgICAgdGltZW91dCA9IHVzZXJCbG9ja2luZ1ByaW9yaXR5VGltZW91dDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICAvLyBOZXZlciB0aW1lcyBvdXRcbiAgICAgIHRpbWVvdXQgPSBtYXhTaWduZWQzMUJpdEludDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgIC8vIEV2ZW50dWFsbHkgdGltZXMgb3V0XG4gICAgICB0aW1lb3V0ID0gbG93UHJpb3JpdHlUaW1lb3V0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBFdmVudHVhbGx5IHRpbWVzIG91dFxuICAgICAgdGltZW91dCA9IG5vcm1hbFByaW9yaXR5VGltZW91dDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gc3RhcnRUaW1lICsgdGltZW91dDtcbiAgdmFyIG5ld1Rhc2sgPSB7XG4gICAgaWQ6IHRhc2tJZENvdW50ZXIrKyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgcHJpb3JpdHlMZXZlbDogcHJpb3JpdHlMZXZlbCxcbiAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgc29ydEluZGV4OiAtMVxuICB9O1xuXG4gIGlmIChzdGFydFRpbWUgPiBjdXJyZW50VGltZSkge1xuICAgIC8vIFRoaXMgaXMgYSBkZWxheWVkIHRhc2suXG4gICAgbmV3VGFzay5zb3J0SW5kZXggPSBzdGFydFRpbWU7XG4gICAgcHVzaCh0aW1lclF1ZXVlLCBuZXdUYXNrKTtcblxuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgPT09IG51bGwgJiYgbmV3VGFzayA9PT0gcGVlayh0aW1lclF1ZXVlKSkge1xuICAgICAgLy8gQWxsIHRhc2tzIGFyZSBkZWxheWVkLCBhbmQgdGhpcyBpcyB0aGUgdGFzayB3aXRoIHRoZSBlYXJsaWVzdCBkZWxheS5cbiAgICAgIGlmIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkKSB7XG4gICAgICAgIC8vIENhbmNlbCBhbiBleGlzdGluZyB0aW1lb3V0LlxuICAgICAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IHRydWU7XG4gICAgICB9IC8vIFNjaGVkdWxlIGEgdGltZW91dC5cblxuXG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IGV4cGlyYXRpb25UaW1lO1xuICAgIHB1c2godGFza1F1ZXVlLCBuZXdUYXNrKTtcbiAgICAvLyB3YWl0IHVudGlsIHRoZSBuZXh0IHRpbWUgd2UgeWllbGQuXG5cblxuICAgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VGFzaztcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcGF1c2VFeGVjdXRpb24oKSB7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uKCkge1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgcmVxdWVzdEhvc3RDYWxsYmFjaygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlKCkge1xuICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayh0YXNrKSB7XG4gIC8vIHJlbW92ZSBmcm9tIHRoZSBxdWV1ZSBiZWNhdXNlIHlvdSBjYW4ndCByZW1vdmUgYXJiaXRyYXJ5IG5vZGVzIGZyb20gYW5cbiAgLy8gYXJyYXkgYmFzZWQgaGVhcCwgb25seSB0aGUgZmlyc3Qgb25lLilcblxuXG4gIHRhc2suY2FsbGJhY2sgPSBudWxsO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpIHtcbiAgcmV0dXJuIGN1cnJlbnRQcmlvcml0eUxldmVsO1xufVxuXG52YXIgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbnZhciB0YXNrVGltZW91dElEID0gLTE7IC8vIFNjaGVkdWxlciBwZXJpb2RpY2FsbHkgeWllbGRzIGluIGNhc2UgdGhlcmUgaXMgb3RoZXIgd29yayBvbiB0aGUgbWFpblxuLy8gdGhyZWFkLCBsaWtlIHVzZXIgZXZlbnRzLiBCeSBkZWZhdWx0LCBpdCB5aWVsZHMgbXVsdGlwbGUgdGltZXMgcGVyIGZyYW1lLlxuLy8gSXQgZG9lcyBub3QgYXR0ZW1wdCB0byBhbGlnbiB3aXRoIGZyYW1lIGJvdW5kYXJpZXMsIHNpbmNlIG1vc3QgdGFza3MgZG9uJ3Rcbi8vIG5lZWQgdG8gYmUgZnJhbWUgYWxpZ25lZDsgZm9yIHRob3NlIHRoYXQgZG8sIHVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG5cbnZhciBmcmFtZUludGVydmFsID0gZnJhbWVZaWVsZE1zO1xudmFyIHN0YXJ0VGltZSA9IC0xO1xuXG5mdW5jdGlvbiBzaG91bGRZaWVsZFRvSG9zdCgpIHtcbiAgdmFyIHRpbWVFbGFwc2VkID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKSAtIHN0YXJ0VGltZTtcblxuICBpZiAodGltZUVsYXBzZWQgPCBmcmFtZUludGVydmFsKSB7XG4gICAgLy8gVGhlIG1haW4gdGhyZWFkIGhhcyBvbmx5IGJlZW4gYmxvY2tlZCBmb3IgYSByZWFsbHkgc2hvcnQgYW1vdW50IG9mIHRpbWU7XG4gICAgLy8gc21hbGxlciB0aGFuIGEgc2luZ2xlIGZyYW1lLiBEb24ndCB5aWVsZCB5ZXQuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFlpZWxkIG5vdy5cblxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0UGFpbnQoKSB7fVxuXG5mdW5jdGlvbiBmb3JjZUZyYW1lUmF0ZShmcHMpIHtcbiAgaWYgKGZwcyA8IDAgfHwgZnBzID4gMTI1KSB7XG4gICAgLy8gVXNpbmcgY29uc29sZVsnZXJyb3InXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG4gICAgY29uc29sZVsnZXJyb3InXSgnZm9yY2VGcmFtZVJhdGUgdGFrZXMgYSBwb3NpdGl2ZSBpbnQgYmV0d2VlbiAwIGFuZCAxMjUsICcgKyAnZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZnBzID4gMCkge1xuICAgIGZyYW1lSW50ZXJ2YWwgPSBNYXRoLmZsb29yKDEwMDAgLyBmcHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc2V0IHRoZSBmcmFtZXJhdGVcbiAgICBmcmFtZUludGVydmFsID0gZnJhbWVZaWVsZE1zO1xuICB9XG59XG5cbnZhciBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChpc01lc3NhZ2VMb29wUnVubmluZykge1xuICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7IC8vIEtlZXAgdHJhY2sgb2YgdGhlIHN0YXJ0IHRpbWUgc28gd2UgY2FuIG1lYXN1cmUgaG93IGxvbmcgdGhlIG1haW4gdGhyZWFkXG4gICAgLy8gaGFzIGJlZW4gYmxvY2tlZC5cblxuICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lOyAvLyBJZiBhIHNjaGVkdWxlciB0YXNrIHRocm93cywgZXhpdCB0aGUgY3VycmVudCBicm93c2VyIHRhc2sgc28gdGhlXG4gICAgLy8gZXJyb3IgY2FuIGJlIG9ic2VydmVkLlxuICAgIC8vXG4gICAgLy8gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgYSB0cnktY2F0Y2gsIHNpbmNlIHRoYXQgbWFrZXMgc29tZSBkZWJ1Z2dpbmdcbiAgICAvLyB0ZWNobmlxdWVzIGhhcmRlci4gSW5zdGVhZCwgaWYgYGZsdXNoV29ya2AgZXJyb3JzLCB0aGVuIGBoYXNNb3JlV29ya2Agd2lsbFxuICAgIC8vIHJlbWFpbiB0cnVlLCBhbmQgd2UnbGwgY29udGludWUgdGhlIHdvcmsgbG9vcC5cblxuICAgIHZhciBoYXNNb3JlV29yayA9IHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgaGFzTW9yZVdvcmsgPSBmbHVzaFdvcmsoY3VycmVudFRpbWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoaGFzTW9yZVdvcmspIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHdvcmssIHNjaGVkdWxlIHRoZSBuZXh0IG1lc3NhZ2UgZXZlbnQgYXQgdGhlIGVuZFxuICAgICAgICAvLyBvZiB0aGUgcHJlY2VkaW5nIG9uZS5cbiAgICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG5cbmlmICh0eXBlb2YgbG9jYWxTZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gTm9kZS5qcyBhbmQgb2xkIElFLlxuICAvLyBUaGVyZSdzIGEgZmV3IHJlYXNvbnMgZm9yIHdoeSB3ZSBwcmVmZXIgc2V0SW1tZWRpYXRlLlxuICAvL1xuICAvLyBVbmxpa2UgTWVzc2FnZUNoYW5uZWwsIGl0IGRvZXNuJ3QgcHJldmVudCBhIE5vZGUuanMgcHJvY2VzcyBmcm9tIGV4aXRpbmcuXG4gIC8vIChFdmVuIHRob3VnaCB0aGlzIGlzIGEgRE9NIGZvcmsgb2YgdGhlIFNjaGVkdWxlciwgeW91IGNvdWxkIGdldCBoZXJlXG4gIC8vIHdpdGggYSBtaXggb2YgTm9kZS5qcyAxNSssIHdoaWNoIGhhcyBhIE1lc3NhZ2VDaGFubmVsLCBhbmQganNkb20uKVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwNzU2XG4gIC8vXG4gIC8vIEJ1dCBhbHNvLCBpdCBydW5zIGVhcmxpZXIgd2hpY2ggaXMgdGhlIHNlbWFudGljIHdlIHdhbnQuXG4gIC8vIElmIG90aGVyIGJyb3dzZXJzIGV2ZXIgaW1wbGVtZW50IGl0LCBpdCdzIGJldHRlciB0byB1c2UgaXQuXG4gIC8vIEFsdGhvdWdoIGJvdGggb2YgdGhlc2Ugd291bGQgYmUgaW5mZXJpb3IgdG8gbmF0aXZlIHNjaGVkdWxpbmcuXG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIGxvY2FsU2V0SW1tZWRpYXRlKHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gRE9NIGFuZCBXb3JrZXIgZW52aXJvbm1lbnRzLlxuICAvLyBXZSBwcmVmZXIgTWVzc2FnZUNoYW5uZWwgYmVjYXVzZSBvZiB0aGUgNG1zIHNldFRpbWVvdXQgY2xhbXBpbmcuXG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG5cbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIFdlIHNob3VsZCBvbmx5IGZhbGxiYWNrIGhlcmUgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW25vdC1hLWZ1bmN0aW9uXSBudWxsYWJsZSB2YWx1ZVxuICAgIGxvY2FsU2V0VGltZW91dChwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUsIDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0SG9zdENhbGxiYWNrKCkge1xuICBpZiAoIWlzTWVzc2FnZUxvb3BSdW5uaW5nKSB7XG4gICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSB0cnVlO1xuICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdEhvc3RUaW1lb3V0KGNhbGxiYWNrLCBtcykge1xuICAvLyAkRmxvd0ZpeE1lW25vdC1hLWZ1bmN0aW9uXSBudWxsYWJsZSB2YWx1ZVxuICB0YXNrVGltZW91dElEID0gbG9jYWxTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLnVuc3RhYmxlX25vdygpKTtcbiAgfSwgbXMpO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxIb3N0VGltZW91dCgpIHtcbiAgLy8gJEZsb3dGaXhNZVtub3QtYS1mdW5jdGlvbl0gbnVsbGFibGUgdmFsdWVcbiAgbG9jYWxDbGVhclRpbWVvdXQodGFza1RpbWVvdXRJRCk7XG4gIHRhc2tUaW1lb3V0SUQgPSAtMTtcbn1cbnZhciB1bnN0YWJsZV9Qcm9maWxpbmcgPSBudWxsO1xuXG5leHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eSA9IElkbGVQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHkgPSBMb3dQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfUHJvZmlsaW5nID0gdW5zdGFibGVfUHJvZmlsaW5nO1xuZXhwb3J0cy51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSA9IFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayA9IHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrO1xuZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9mb3JjZUZyYW1lUmF0ZSA9IGZvcmNlRnJhbWVSYXRlO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IHVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSA9IHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlO1xuZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gdW5zdGFibGVfbmV4dDtcbmV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbjtcbmV4cG9ydHMudW5zdGFibGVfcmVxdWVzdFBhaW50ID0gcmVxdWVzdFBhaW50O1xuZXhwb3J0cy51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkgPSB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrO1xuZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZCA9IHNob3VsZFlpZWxkVG9Ib3N0O1xuZXhwb3J0cy51bnN0YWJsZV93cmFwQ2FsbGJhY2sgPSB1bnN0YWJsZV93cmFwQ2FsbGJhY2s7XG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG5cbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/node_modules/scheduler/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-reconciler/node_modules/scheduler/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(ssr)/./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1S0FBMEQ7QUFDNUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zaWRkaGFudGd1cHRhL0RvY3VtZW50cy9wcm9qZWN0cy9mb3JnZXRhaS9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/node_modules/scheduler/index.js\n");

/***/ })

};
;